!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("mobx"),require("inferno"),require("hoist-non-inferno-statics")):"function"==typeof define&&define.amd?define(["exports","mobx","inferno","hoist-non-inferno-statics"],t):t((e.Inferno=e.Inferno||{},e.Inferno.Mobx=e.Inferno.Mobx||{}),e.mobx,e.Inferno,e.hoistNonReactStatics)}(this,function(e,u,a,n){"use strict";function t(){this.listeners=[]}function r(e){console.error(e)}n=n&&n.hasOwnProperty("default")?n.default:n,t.prototype.on=function(t){var n=this;return this.listeners.push(t),function(){var e=n.listeners.indexOf(t);-1!==e&&n.listeners.splice(e,1)}};var f=!(t.prototype.emit=function(e){for(var t=this.listeners,n=0,o=t.length;n<o;n++)t[n](e)}),d=!1,i=!1,o=new t;function s(e){var t=e.$LI.dom;o.emit({component:e,event:"render",node:t,renderTime:e.__$mobRenderEnd-e.__$mobRenderStart,totalTime:Date.now()-e.__$mobRenderStart})}var l=new t;function c(e,t,n){var o=e[t],r=p[t],n=o?!0===n?function(){r.apply(this,arguments),o.apply(this,arguments)}:function(){o.apply(this,arguments),r.apply(this,arguments)}:r;e[t]=n}function m(e,t){if(null==e||null==t||"object"!=typeof e||"object"!=typeof t)return e!==t;var n,o=Object.keys(e);if(o.length!==Object.keys(t).length)return!0;for(var r=o.length-1;0<=r;r--)if(t[n=o[r]]!==e[n])return!0;return!1}var p={componentWillMount:function(){var e,o,t,n,r,i,s,c,a=this;function p(e){var t=this[e],n=u.createAtom("reactive "+e);Object.defineProperty(this,e,{configurable:!0,enumerable:!0,get:function(){return n.reportObserved(),t},set:function(e){m(t,e)?(t=e,o=!0,n.reportChanged(),o=!1):t=e}})}!0!==d&&(e=this.displayName||this.name||this.constructor&&(this.constructor.displayName||this.constructor.name)||"<component>",o=!1,p.call(this,"props"),p.call(this,"state"),n=(t=this).render.bind(this),i=null,s=!(r=function(){return n(t.props,t.state,t.context)}),c=function(){var t;s=!1;var e=null;if(i.track(function(){f&&(a.__$mobRenderStart=Date.now());try{e=u._allowStateChanges(!1,r)}catch(e){t=e}f&&(a.__$mobRenderEnd=Date.now())}),t)throw l.emit(t),t;return e},this.render=function(){return(i=new u.Reaction(e+".render()",function(){s||(s=!0,"function"==typeof a.componentWillReact&&a.componentWillReact(),o||a.forceUpdate())})).reactComponent=a,c.$mobx=i,(a.render=c)()})},componentWillUnmount:function(){var e;!0!==d&&(this.render.$mobx&&this.render.$mobx.dispose(),f&&(e=this.$LI.dom,o.emit({component:this,event:"destroy",node:e})))},componentDidMount:function(){f&&s(this)},componentDidUpdate:function(){f&&s(this)},shouldComponentUpdate:function(e,t){return d&&r("[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side."),this.state!==t||m(this.props,e)}};function h(t,e){if("string"==typeof t)throw new Error("Store names should be provided as array");if(Array.isArray(t))return i||(i=!0,r('Mobx observer: Using observer to inject stores is deprecated since 4.0. Use `@inject("store1", "store2") @observer ComponentClass` or `inject("store1", "store2")(observer(componentClass))` instead of `@observer(["store1", "store2"]) ComponentClass`')),e?x.apply(null,t)(h(e)):function(e){return h(t,e)};var o=t;if(!0===o.isMobxInjector&&r("Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'"),!("function"!=typeof o||o.prototype&&o.prototype.render))return h(((n=function(e){function t(){e.apply(this,arguments)}return e&&(t.__proto__=e),((t.prototype=Object.create(e&&e.prototype)).constructor=t).prototype.render=function(e,t,n){return o(e,n)},t}(a.Component)).displayName=o.displayName||o.name,n.defaultProps=o.defaultProps,n));if(!o)throw new Error("Please pass a valid component to 'observer'");var n=o.prototype||o;return c(n,"componentWillMount",!0),c(n,"componentDidMount",!1),c(n,"componentWillUnmount",!1),c(n,"componentDidUpdate",!1),n.shouldComponentUpdate||(n.shouldComponentUpdate=p.shouldComponentUpdate),o.isMobXReactObserver=!0,o}var b=h(function(e){return(0,e.children)()});b.displayName="Observer";var y={isMobxInjector:{configurable:!0,enumerable:!0,value:!0,writable:!0}};function v(s,c,e){var t="inject-"+(c.displayName||c.name||c.constructor&&c.constructor.name||"Unknown");return e&&(t+="-with-"+e),(e=function(n){function e(e,t){n.call(this,e,t),this.storeRef=this.storeRef.bind(this)}return n&&(e.__proto__=n),((e.prototype=Object.create(n&&n.prototype)).constructor=e).prototype.storeRef=function(e){this.wrappedInstance=e},e.prototype.render=function(e,t,n){var o,r={};for(o in e)r[o]=e[o];var i=s(n.mobxStores||{},r,n)||{};for(o in i)r[o]=i[o];return a.createComponentVNode(2,c,r,null,(n=c).prototype&&n.prototype.render?this.storeRef:null)},e}(a.Component)).displayName=t,e.isMobxInjector=!1,n(e,c),e.wrappedComponent=c,Object.defineProperties(e,y),e}function x(){var t,e=arguments;if("function"==typeof arguments[0])return t=arguments[0],function(e){return(e=v(t,e)).isMobxInjector=!1,(e=h(e)).isMobxInjector=!0,e};for(var i,n=[],o=0;o<arguments.length;o++)n.push(e[o]);return i=n,t=function(e,t){for(var n=0,o=i.length;n<o;n++){var r=i[n];r in t||(t[r]=e[r])}return t},function(e){return v(t,e,n.join("-"))}}var _={children:!0,key:!0,ref:!0},g=function(e){function t(){e.apply(this,arguments)}return e&&(t.__proto__=e),((t.prototype=Object.create(e&&e.prototype)).constructor=t).prototype.render=function(e){return e.children},t.prototype.getChildContext=function(){var e,t={},n=this.props,o=this.context.mobxStores;if(o)for(var r in o)t[r]=o[r];for(e in n)void 0===_[e]&&"suppressChangedStoreWarning"!==e&&(t[e]=n[e]);return{mobxStores:t}},t}(a.Component);e.errorsReporter=l,e.inject=x,e.observer=h,e.onError=function(e){return l.on(e)},e.EventEmitter=t,e.Observer=b,e.Provider=g,e.renderReporter=o,e.trackComponents=function(){f?(f=!1,o.listeners.length=0):(f=!0,r("Do not turn trackComponents on in production, its expensive. For tracking dom nodes you need inferno-compat."))},e.useStaticRendering=function(e){d=e},Object.defineProperty(e,"__esModule",{value:!0})});
