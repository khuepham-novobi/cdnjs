window["AlloyEditor"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/adapter/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.8.5
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' ||
  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;
    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;
          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;
              default:
                return $$typeof;
            }
        }
      case REACT_LAZY_TYPE:
      case REACT_MEMO_TYPE:
      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
}

// AsyncMode is deprecated along with isAsyncMode
var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;

var hasWarnedAboutDeprecatedIsAsyncMode = false;

// AsyncMode should be deprecated
function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true;
      lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }
  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.typeOf = typeOf;
exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isValidElementType = isValidElementType;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./src/adapter/core.js":
/*!*****************************!*\
  !*** ./src/adapter/core.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

__webpack_require__(/*! ../core */ "./src/core/index.js");

__webpack_require__(/*! ../plugins */ "./src/plugins/index.js");

__webpack_require__(/*! ../components/uibridge */ "./src/components/uibridge/index.js");

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _commands = __webpack_require__(/*! ../commands */ "./src/commands/index.js");

var _main = __webpack_require__(/*! ../components/main.jsx */ "./src/components/main.jsx");

var _main2 = _interopRequireDefault(_main);

var _base = __webpack_require__(/*! ../oop/base */ "./src/oop/base.js");

var _base2 = _interopRequireDefault(_base);

var _lang = __webpack_require__(/*! ../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _oop = __webpack_require__(/*! ../oop/oop */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

var _selections = __webpack_require__(/*! ../selections/selections */ "./src/selections/selections.js");

var _selections2 = _interopRequireDefault(_selections);

var _editorContext = __webpack_require__(/*! ./editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var EMBED_VIDEO_WIDTH = 560;
var EMBED_VIDEO_HEIGHT = 315;

/**
 * AlloyEditor main class. Creates instance of the editor and provides the user configuration
 * to the UI.
 *
 * @class Core
 * @constructor
 * @param {Object} config The configuration to be used.
 */
function Core(config) {
	Core.superclass.constructor.call(this, config);
}

(0, _oop2.default)(Core, _base2.default, {
	/**
  * Initializer lifecycle implementation for the AlloyEditor class. Creates a CKEditor
  * instance, passing it the provided configuration attributes.
  *
  * @memberof Core
  * @instance
  * @protected
  * @method initializer
  * @param {Object} config Configuration object literal for the editor.
  */
	initializer: function initializer(config) {
		var _this = this;

		var node = this.get('srcNode');

		if (this.get('enableContentEditable')) {
			node.setAttribute('contenteditable', 'true');
		}

		var editor = CKEDITOR.inline(node);

		editor.config.allowedContent = this.get('allowedContent');

		editor.config.toolbars = this.get('toolbars');

		editor.config.removePlugins = this.get('removePlugins');

		editor.config.extraPlugins = this.get('extraPlugins');

		editor.config.embedProviders = this.get('embedProviders');

		editor.config.placeholderClass = this.get('placeholderClass');

		editor.config.pasteFromWordRemoveStyles = false;
		editor.config.pasteFromWordRemoveFontStyles = false;

		editor.config.selectionKeystrokes = this.get('selectionKeystrokes');

		editor.config.spritemap = this.get('spritemap');

		_lang2.default.mix(editor.config, config);

		if (CKEDITOR.env.ie && !CKEDITOR.env.edge) {
			var plugin = CKEDITOR.env.version === 11 ? 'ae_dragresize_ie11' : 'ae_dragresize_ie';

			editor.config.extraPlugins = editor.config.extraPlugins.replace('ae_dragresize', plugin);
			editor.config.removePlugins = editor.config.removePlugins.replace('ae_dragresize', plugin);
		}

		editor.once('contentDom', function () {
			_this._addReadOnlyLinkClickListener(editor);

			var editable = editor.editable();

			var extraCommands = _this.get('extraCommands');

			var extraCommandKeys = Object.keys(extraCommands);
			for (var i = 0; i < extraCommandKeys.length; i++) {
				var commandName = extraCommandKeys[i];

				if (editor.commands[commandName]) {
					continue;
				}

				editor.addCommand(commandName, extraCommands[commandName]);
			}

			editable.addClass('ae-editable');
		});

		this._editor = editor;

		AlloyEditor.loadLanguageResources(this._renderUI.bind(this));
	},


	/**
  * Destructor lifecycle implementation for the AlloyEdtor class. Destroys the CKEditor
  * instance and destroys all created toolbars.
  *
  * @memberof Core
  * @instance
  * @protected
  * @method destructor
  */
	destructor: function destructor() {
		this._destroyed = true;

		if (this._editorUIElement) {
			_reactDom2.default.unmountComponentAtNode(this._editorUIElement);
			this._editorUIElement.parentNode.removeChild(this._editorUIElement);
		}

		var nativeEditor = this.get('nativeEditor');

		if (nativeEditor) {
			var editable = nativeEditor.editable();

			if (editable) {
				editable.removeClass('ae-editable');

				if (this.get('enableContentEditable')) {
					this.get('srcNode').setAttribute('contenteditable', 'false');
				}
			}

			this._clearSelections();

			nativeEditor.destroy();
		}
	},


	/**
  * Clear selections from window object
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _clearSelections
  */
	_clearSelections: function _clearSelections() {
		var nativeEditor = this.get('nativeEditor');
		var isMSSelection = typeof window.getSelection != 'function';

		if (isMSSelection) {
			nativeEditor.document.$.selection.empty();
		} else {
			nativeEditor.document.getWindow().$.getSelection().removeAllRanges();
		}
	},


	/**
  * Method to set default link behavior
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _addReadOnlyLinkClickListener
  * @param {Object} editor
  */
	_addReadOnlyLinkClickListener: function _addReadOnlyLinkClickListener(editor) {
		editor.editable().on('click', this._defaultReadOnlyClickFn, this, {
			editor: editor
		});
	},


	/**
  * Called on `click` event when the editor is in read only mode. Navigates to link's URL or opens
  * the link in a new window.
  *
  * @memberof Core
  * @instance
  * @event readOnlyClick
  * @protected
  * @method _defaultReadOnlyClickFn
  * @param {Object} event The fired `click` event payload
  */
	_defaultReadOnlyClickFn: function _defaultReadOnlyClickFn(event) {
		var mouseEvent = event.data.$;
		var hasCtrlKey = mouseEvent.ctrlKey || mouseEvent.metaKey;
		var shouldOpen = this._editor.config.readOnly || hasCtrlKey;

		mouseEvent.preventDefault();

		if (!shouldOpen) {
			return;
		}

		if (event.listenerData.editor.editable().editor.fire('readOnlyClick', event.data) !== false) {
			var ckElement = new CKEDITOR.dom.elementPath(event.data.getTarget(), this);
			var link = ckElement.lastElement;

			if (link) {
				var href = link.$.attributes.href ? link.$.attributes.href.value : null;
				var target = hasCtrlKey ? '_blank' : link.$.attributes.target ? link.$.attributes.target.value : null;
				this._redirectLink(href, target);
			}
		}
	},


	/**
  * Retrieves the native CKEditor instance. Having this, the developer may use the API of CKEditor OOTB.
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _getNativeEditor
  * @return {Object} The current instance of CKEditor.
  */
	_getNativeEditor: function _getNativeEditor() {
		return this._editor;
	},


	/**
  * Redirects the browser to a given link
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _redirectLink
  * @param {string} href The href to take the browser to
  * @param {string=} target Specifies where to display the link
  */
	_redirectLink: function _redirectLink(href, target) {
		if (target && href) {
			window.open(href, target);
		} else if (href) {
			window.location.href = href;
		}
	},


	/**
  * Renders the specified from the user toolbars.
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _renderUI
  */
	_renderUI: function _renderUI() {
		var _this2 = this;

		if (!this._destroyed) {
			var editorUIElement = document.createElement('div');
			editorUIElement.className = 'ae-ui';

			var uiNode = this.get('uiNode') || document.body;

			uiNode.appendChild(editorUIElement);

			var callbackRef = function callbackRef(element) {
				if (!_this2._mainUI && element) {
					_this2._mainUI = element;
					_this2.get('nativeEditor').fire('uiReady');
				}
			};

			_reactDom2.default.render(_react2.default.createElement(
				_editorContext2.default.Provider,
				{ value: { editor: this } },
				_react2.default.createElement(_main2.default, {
					eventsDelay: this.get('eventsDelay'),
					ref: callbackRef,
					toolbars: this.get('toolbars')
				})
			), editorUIElement);

			this._editorUIElement = editorUIElement;
		}
	},


	/**
  * The function returns an HTML element from the passed value. If the passed value is a string, it should be
  * the Id of the element which have to be retrieved from the DOM.
  * If an HTML Element is passed, the element itself will be returned.
  *
  * @memberof Core
  * @instance
  * @method _toElement
  * @protected
  * @param {!(String|HTMLElement)} value String, which have to correspond to an HTML element from the DOM,
  * or the HTML element itself. If Id is passed, the HTML element will be retrieved from the DOM.
  * @return {HTMLElement} An HTML element.
  */
	_toElement: function _toElement(value) {
		if (_lang2.default.isString(value)) {
			value = document.getElementById(value);
		}

		return value;
	},


	/**
  * Validates the allowed content attribute. Look
  * [here](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-allowedContent) for more information about the
  * supported values.
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _validateAllowedContent
  * @param {Any} value The value to be checked
  * @return {Boolean} True if the current value is valid configuration, false otherwise
  */
	_validateAllowedContent: function _validateAllowedContent(value) {
		return _lang2.default.isString(value) || _lang2.default.isObject(value) || _lang2.default.isBoolean(value);
	},


	/**
  * Validates the value of toolbars attribute
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _validateToolbars
  * @param {Any} value The value to be checked
  * @return {Boolean} True if the current value is valid toolbars configuration, false otherwise
  */
	_validateToolbars: function _validateToolbars(value) {
		return _lang2.default.isObject(value) || _lang2.default.isNull(value);
	}
}, {
	ATTRS: {
		/**
   * Configures the allowed content for the current instance of AlloyEditor.
   * Look on the [official CKEditor API](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-allowedContent)
   * for more information about the valid values.
   *
   * @memberof Core
   * @instance
   * @property allowedContent
   * @default true
   * @writeOnce
   * @type {Boolean, String, Object}
   */
		allowedContent: {
			validator: '_validateAllowedContent',
			value: true,
			writeOnce: true
		},

		/**
   * Callback to be invoked when clicking on the
   * <code>src/components/buttons/button-link-edit-browse.jsx</code>
   * component.
   *
   * @memberof Core
   * @instance
   * @propety documentBrowseLinkCallback
   * @default undefined
   * @type {Function|undefined}
   */
		documentBrowseLinkCallback: {
			validator: _lang2.default.isFunction,
			value: undefined
		},

		/**
   * Configuration for the
   * <code>src/components/buttons/button-link-edit-browse.jsx</code>
   * component.
   *
   * @memberof Core
   * @instance
   * @propety documentBrowseLinkUrl
   * @default undefined
   * @type {String|undefined}
   */
		documentBrowseLinkUrl: {
			validator: _lang2.default.isString,
			value: undefined
		},

		/**
   * List of embed providers for videos
   *
   * @memberof Core
   * @instance
   * @property embedProviders
   * @default []
   * @type Array}
   */
		embedProviders: {
			validator: _lang2.default.isArray,
			value: [{
				id: 'facebook',
				tpl: '<iframe allowFullScreen="true" allowTransparency="true"\n\t\t\t\t\t\t\t\t\t\t\t\t frameborder="0" height="' + EMBED_VIDEO_HEIGHT + '"\n\t\t\t\t\t\t\t\t\t\t\t\t src="https://www.facebook.com/plugins/video.php?href={embedId}\'\n\t\t\t\t\t\t\t\t\t\t\t\t &show_text=0&width=' + EMBED_VIDEO_WIDTH + '&height=' + EMBED_VIDEO_HEIGHT + '" scrolling="no"\n\t\t\t\t\t\t\t\t\t\t\t\t style="border:none;overflow:hidden" width="' + EMBED_VIDEO_WIDTH + '}"></iframe>',
				type: 'video',
				urlSchemes: ['(https?:\\/\\/(?:www\\.)?facebook.com\\/\\S*\\/videos\\/\\S*)']
			}, {
				id: 'twitch',
				tpl: '<iframe allowfullscreen="true" frameborder="0"\n\t\t\t\t\t\t\t\t\t\t\t\t height="' + EMBED_VIDEO_HEIGHT + '"\n\t\t\t\t\t\t\t\t\t\t\t\t src="https://player.twitch.tv/?autoplay=false&video={embedId}"\n\t\t\t\t\t\t\t\t\t\t\t\t scrolling="no" width="' + EMBED_VIDEO_WIDTH + '"></iframe>',
				type: 'video',
				urlSchemes: ['https?:\\/\\/(?:www\\.)?twitch.tv\\/videos\\/(\\S*)$']
			}, {
				id: 'vimeo',
				tpl: '<iframe allowfullscreen frameborder="0" height="' + EMBED_VIDEO_HEIGHT + '"\n\t\t\t\t\t\t\t\t\t\t\t\t mozallowfullscreen src="https://player.vimeo.com/video/{embedId}"\n\t\t\t\t\t\t\t\t\t\t\t\t webkitallowfullscreen width="' + EMBED_VIDEO_WIDTH + '"></iframe>',
				type: 'video',
				urlSchemes: ['https?:\\/\\/(?:www\\.)?vimeo\\.com\\/album\\/.*\\/video\\/(\\S*)', 'https?:\\/\\/(?:www\\.)?vimeo\\.com\\/channels\\/.*\\/(\\S*)', 'https?:\\/\\/(?:www\\.)?vimeo\\.com\\/groups\\/.*\\/videos\\/(\\S*)', 'https?:\\/\\/(?:www\\.)?vimeo\\.com\\/(\\S*)$']
			}, {
				id: 'youtube',
				tpl: '<iframe allow="autoplay; encrypted-media" allowfullscreen\n\t\t\t\t\t\t\t\t\t\t\t\t height="' + EMBED_VIDEO_HEIGHT + '" frameborder="0"\n\t\t\t\t\t\t\t\t\t\t\t\t src="https://www.youtube.com/embed/{embedId}?rel=0"\n\t\t\t\t\t\t\t\t\t\t\t\t width="' + EMBED_VIDEO_WIDTH + '"></iframe>',
				type: 'video',
				urlSchemes: ['https?:\\/\\/(?:www\\.)?youtube.com\\/watch\\?v=(\\S*)$']
			}]
		},

		/**
   * Specifies whether AlloyEditor set the contenteditable attribute
   * to "true" on its srcNode.
   *
   * @memberof Core
   * @instance
   * @property enableContentEditable
   * @type Boolean
   * @default true
   * @writeOnce
   */
		enableContentEditable: {
			validator: _lang2.default.isBoolean,
			value: true,
			writeOnce: true
		},

		/**
   * The delay (timeout), in ms, after which events such like key or mouse events will be processed.
   *
   * @memberof Core
   * @instance
   * @property eventsDelay
   * @type {Number}
   */
		eventsDelay: {
			validator: _lang2.default.isNumber,
			value: 100
		},

		/**
   * The list of extra commands to be added to the editor.
   *
   * @memberof Core
   * @instance
   * @property extraCommands
   * @type {Object}
   */
		extraCommands: {
			validator: _lang2.default.isObject,
			value: {
				removeImage: _commands.removeImageCommand
			},
			writeOnce: true
		},

		/**
   * Specifies the extra plugins which have to be loaded to the current CKEditor instance in order to
   * make AlloyEditor to work properly.
   *
   * @memberof Core
   * @instance
   * @property extraPlugins
   * @default 'uicore,selectionregion,dragresize,addimages,placeholder,tabletools,tableresize,autolink'
   * @writeOnce
   * @type {String}
   */
		extraPlugins: {
			validator: _lang2.default.isString,
			value: 'ae_uicore,ae_selectionregion,ae_selectionkeystrokes,ae_imagealignment,ae_addimages,ae_placeholder,' + 'ae_tabletools,ae_tableresize,ae_autolink,ae_embed,ae_autolist,ae_dragresize,' + 'ae_uibridge,ae_richcombobridge,ae_panelmenubuttonbridge,ae_menubridge,ae_menubuttonbridge,ae_buttonbridge,font,colorbutton',
			writeOnce: true
		},

		/**
   * Specifies the "mode" for alloy editor
   * @memberof Core
   * @instance
   * @property mode
   * @default 'simple'
   * @writeOnce
   * @type {String}
   */
		mode: {
			validator: _lang2.default.isString,
			value: 'simple'
		},

		/**
   * Retrieves the native CKEditor instance. Having this, the developer may use the full API of CKEditor.
   *
   * @memberof Core
   * @instance
   * @property nativeEditor
   * @readOnly
   * @type {Object}
   */
		nativeEditor: {
			getter: '_getNativeEditor',
			readOnly: true
		},

		/**
   * Specifies the class, which should be added by Placeholder plugin
   * {{#crossLink "CKEDITOR.plugins.ae_placeholder}}{{/crossLink}}
   * when editor is not focused.
   *
   * @memberof Core
   * @instance
   * @property placeholderClass
   * @default 'ae-placeholder'
   * @writeOnce
   * @type {String}
   */
		placeholderClass: {
			validator: _lang2.default.isString,
			value: 'ae-placeholder',
			writeOnce: true
		},

		/**
   * Specifies the plugins, which come by default with CKEditor, but which are not needed by AlloyEditor.
   * These plugins add the default UI for CKeditor, which is no more needed. Please note that AlloyEdtor
   * comes with its own highly optimized copy of CKEditor (just customized via their official download page).
   * This version does not come with the unneeded plugins, so the value of this property won't be needed.
   * However, if you decide to go with the OOTB version of CKEditor, you will have to remove some of the
   * plugins if you decide to use AlloyEditor. Keep in mind that removing these plugins doesn't remove them
   * entirely from CKEditor. It just removes them from its current instance, in which you will use different
   * UI - those of AlloyEditor. You will be fully able to use both OOTB CKEditor and AlloyEditor on the same
   * page!
   *
   * @memberof Core
   * @instance
   * @property removePlugins
   * @default 'contextmenu,toolbar,elementspath,resize,liststyle,link'
   * @writeOnce
   * @type {String}
   */
		removePlugins: {
			validator: _lang2.default.isString,
			value: 'contextmenu,toolbar,elementspath,resize,liststyle,link',
			writeOnce: true
		},

		/**
   * Array of manual selection triggers. They can be configured to manually show a specific selection toolbar
   * by forcing the selection type. A selectionKeystroke item consists of a keys property with a [CKEditor keystroke
   * definition](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-keystrokes) and a selection property with
   * the selection name to trigger.
   *
   * @memberof Core
   * @instance
   * @property selectionKeystrokes
   * @type {Array}
   */
		selectionKeystrokes: {
			validator: _lang2.default.isArray,
			value: [{
				keys: CKEDITOR.CTRL + 76 /* L*/
				, selection: 'link'
			}, {
				keys: CKEDITOR.CTRL + CKEDITOR.SHIFT + 76 /* L*/
				, selection: 'embed'
			}]
		},

		/**
   * The path to the spritemap SVG used for icons
   *
   * @memberof Core
   * @instance
   * @property spritemap
   * @type String
   * @writeOnce
   */
		spritemap: {
			validator: _lang2.default.isString,
			value: 'alloy-editor/assets/icons/icons.svg',
			writeOnce: true
		},

		/**
   * The Node ID or HTMl node, which AlloyEditor should use as an editable area.
   *
   * @memberof Core
   * @instance
   * @property srcNode
   * @type String | Node
   * @writeOnce
   */
		srcNode: {
			setter: '_toElement',
			writeOnce: true
		},

		/**
   * The toolbars configuration for this editor instance
   *
   * @memberof Core
   * @instance
   * @property {Object} toolbars
   */
		toolbars: {
			validator: '_validateToolbars',
			value: {
				add: {
					buttons: ['imageFromFile', 'embed', 'camera', 'hline', 'table'],
					tabIndex: 2
				},
				styles: {
					selections: _selections2.default,
					tabIndex: 1
				}
			}
		},

		/**
   * The Node ID or HTMl node, where AlloyEditor's UI should be rendered.
   *
   * @memberof Core
   * @instance
   * @property uiNode
   * @type String | Node
   * @writeOnce
   */
		uiNode: {
			setter: '_toElement',
			writeOnce: true
		}
	}
});

CKEDITOR.event.implementOn(Core);

exports.default = Core;

/***/ }),

/***/ "./src/adapter/editor-context.js":
/*!***************************************!*\
  !*** ./src/adapter/editor-context.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**
                                                                                                                                                                                                                                                                   * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                   * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                   */

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * React context to avoid explicitly passing the editor instance all
 * through the component hierarchy via props.
 */
var EditorContext = _react2.default.createContext({});

/**
 * Helper that passes the editor context in via a prop.
 *
 * Context can only be accessed in `render()` and in lifecycle methods
 * (`componentDidMount()` etc). If a component needs to access context
 * elsewhere, such as in a constructor, the context needs to be passed
 * in via a prop.
 */
EditorContext.toProps = function (Component) {
  var forwardingComponent = _react2.default.forwardRef(function (props, ref) {
    return _react2.default.createElement(
      EditorContext.Consumer,
      null,
      function (context) {
        return _react2.default.createElement(Component, _extends({}, props, { context: context, ref: ref }));
      }
    );
  });
  forwardingComponent.key = Component.key;
  return forwardingComponent;
};

exports.default = EditorContext;

/***/ }),

/***/ "./src/adapter/main.js":
/*!*****************************!*\
  !*** ./src/adapter/main.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.registerBridgeButton = exports.regexBasePath = exports.loadLanguageResources = exports.implementEventTarget = exports.getUrl = exports.getButtons = exports.getBasePath = exports.editable = exports.Toolbars = exports.Selections = exports.SelectionTest = exports.SelectionSetPosition = exports.SelectionGetArrowBoxClasses = exports.OOP = exports.Lang = exports.Core = exports.Compat = exports.Buttons = exports.Base = exports.Attribute = undefined;

var _base = __webpack_require__(/*! ../components/base */ "./src/components/base/index.js");

var Base = _interopRequireWildcard(_base);

var _buttons = __webpack_require__(/*! ../components/buttons */ "./src/components/buttons/index.js");

var _buttons2 = _interopRequireDefault(_buttons);

var _compat = __webpack_require__(/*! ../components/compat */ "./src/components/compat/index.js");

var Compat = _interopRequireWildcard(_compat);

var _toolbars = __webpack_require__(/*! ../components/toolbars */ "./src/components/toolbars/index.js");

var _toolbars2 = _interopRequireDefault(_toolbars);

var _attribute = __webpack_require__(/*! ../oop/attribute */ "./src/oop/attribute.js");

var _attribute2 = _interopRequireDefault(_attribute);

var _lang = __webpack_require__(/*! ../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _oop = __webpack_require__(/*! ../oop/oop */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

var _selectionArrowbox = __webpack_require__(/*! ../selections/selection-arrowbox */ "./src/selections/selection-arrowbox.js");

var _selectionArrowbox2 = _interopRequireDefault(_selectionArrowbox);

var _selectionPosition = __webpack_require__(/*! ../selections/selection-position */ "./src/selections/selection-position.js");

var _selectionPosition2 = _interopRequireDefault(_selectionPosition);

var _selectionTest = __webpack_require__(/*! ../selections/selection-test */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

var _selections = __webpack_require__(/*! ../selections/selections */ "./src/selections/selections.js");

var _selections2 = _interopRequireDefault(_selections);

var _core = __webpack_require__(/*! ./core */ "./src/adapter/core.js");

var _core2 = _interopRequireDefault(_core);

__webpack_require__(/*! ../plugins */ "./src/plugins/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// An object containing all currently registered plugins in AlloyEditor.
var BRIDGE_BUTTONS = {};

/**
 * Creates an instance of AlloyEditor.
 *
 * @memberof AlloyEditor
 * @method editable
 * @static
 * @param {String|Node} node The Node ID or HTMl node, which AlloyEditor should use as an editable area.
 * @param {Object} config Configuration attributes for the current instance of AlloyEditor.
 * @return {Object} An instance of {{#crossLink "Core"}}{{/crossLink}}
 */
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var editable = function editable(node, config) {
	config = config || {};
	config.srcNode = node;

	AlloyEditor.implementEventTarget();

	return new _core2.default(config);
};

/**
 * The full URL for the AlloyEditor installation directory.
 * It is possible to manually provide the base path by setting a
 * global variable named `ALLOYEDITOR_BASEPATH`. This global variable
 * must be set **before** the editor script loading.
 *
 * @memberof AlloyEditor
 * @method getBasePath
 * @static
 * @return {String} The found base path
 */
var getBasePath = function getBasePath() {
	// Find out the editor directory path, based on its <script> tag.
	var path = window.ALLOYEDITOR_BASEPATH || '';

	if (!path) {
		var scripts = document.getElementsByTagName('script');

		for (var i = 0; i < scripts.length; i++) {
			var match = scripts[i].src.match(AlloyEditor.regexBasePath);

			if (match) {
				path = match[1];
				break;
			}
		}
	}

	// In IE (only) the script.src string is the raw value entered in the
	// HTML source. Other browsers return the full resolved URL instead.
	if (path.indexOf(':/') === -1 && path.slice(0, 2) !== '//') {
		// Absolute path.
		if (path.indexOf('/') === 0) {
			path = location.href.match(/^.*?:\/\/[^/]*/)[0] + path;
		}
		// Relative path.
		else {
				path = location.href.match(/^[^?]*\/(?:)/)[0] + path;
			}
	}

	if (!path) {
		throw new Error('The AlloyEditor installation path could not be automatically detected. Please set the global variable "ALLOYEDITOR_BASEPATH" before creating editor instances.');
	}

	return path;
};

/**
 * Detects and load the corresponding language file if AlloyEditor language strings are not already present.
 * The function fires a {{#crossLink "AlloyEditor/languageResourcesLoaded:event"}}{{/crossLink}} event
 *
 * @memberof AlloyEditor
 * @method loadLanguageResources
 * @static
 * @param {Function} callback Optional callback to be called when AlloyEditor loads the language resource.
 */
var loadLanguageResources = function loadLanguageResources(callback) {
	AlloyEditor.implementEventTarget();

	if (_lang2.default.isFunction(callback)) {
		if (AlloyEditor.Strings) {
			setTimeout(callback, 0);
		} else {
			AlloyEditor.once('languageResourcesLoaded', function () {
				setTimeout(callback, 0);
			});
		}
	}

	if (!AlloyEditor._langResourceRequested) {
		AlloyEditor._langResourceRequested = true;

		var languages = ['af', 'ar', 'bg', 'bn', 'bs', 'ca', 'cs', 'cy', 'da', 'de', 'el', 'en-au', 'en-ca', 'en-gb', 'en', 'eo', 'es', 'et', 'eu', 'fa', 'fi', 'fo', 'fr-ca', 'fr', 'gl', 'gu', 'he', 'hi', 'hr', 'hu', 'id', 'is', 'it', 'ja', 'ka', 'km', 'ko', 'ku', 'lt', 'lv', 'mk', 'mn', 'ms', 'nb', 'nl', 'no', 'pl', 'pt-br', 'pt', 'ro', 'ru', 'si', 'sk', 'sl', 'sq', 'sr-latn', 'sr', 'sv', 'th', 'tr', 'tt', 'ug', 'uk', 'vi', 'zh-cn', 'zh'];

		var userLanguage = navigator.language || navigator.userLanguage || 'en';

		var parts = userLanguage.toLowerCase().match(/([a-z]+)(?:-([a-z]+))?/);
		var lang = parts[1];
		var locale = parts[2];

		if (languages.indexOf(lang + '-' + locale) >= 0) {
			lang = lang + '-' + locale;
		} else if (languages.indexOf(lang) === -1) {
			lang = 'en';
		}

		CKEDITOR.scriptLoader.load(AlloyEditor.getUrl('lang/alloy-editor/' + lang + '.js'), function (loaded) {
			if (loaded) {
				AlloyEditor.fire('languageResourcesLoaded');
			}
		},
		/* eslint-disable no-invalid-this */
		this // Always `AlloyEditor`.
		/* eslint-enable no-invalid-this */
		);
	}
};

/**
 * Gets the full URL for AlloyEditor resources. By default, URLs
 * returned by this function contain a querystring parameter ("t")
 * set to the {@link CKEDITOR#timestamp} value.
 *
 * @memberof AlloyEditor
 * @method getUrl
 * @static
 * @param {String} resource The resource whose full URL we want to get.
 * It may be a full, absolute, or relative URL.
 * @return {String} The full URL.
 */
var getUrl = function getUrl(resource) {
	var basePath = AlloyEditor.getBasePath();

	// If this is not a full or absolute path.
	if (resource.indexOf(':/') === -1 && resource.indexOf('/') !== 0) {
		resource = basePath + resource;
	}

	// Add the timestamp, except for directories.
	if (CKEDITOR.timestamp && resource.charAt(resource.length - 1) !== '/' && !/[&?]t=/.test(resource)) {
		resource += (resource.indexOf('?') >= 0 ? '&' : '?') + 't=' + CKEDITOR.timestamp;
	}

	return resource;
};

/**
 * Implements event firing and subscribing via CKEDITOR.event.
 *
 * @memberof AlloyEditor
 * @method implementEventTarget
 * @static
 */
var implementEventTarget = function implementEventTarget() {
	if (!AlloyEditor.fire && !AlloyEditor.on) {
		CKEDITOR.event.implementOn(AlloyEditor);
	}
};

/**
 * Regular expression which should match the script which have been used to load AlloyEditor.
 *
 * @memberof AlloyEditor
 * @property regexBasePath
 * @type {RegExp}
 * @static
 */
var regexBasePath = /(^|.*[\\/])(?:alloy-editor[^/]+|alloy-editor)\.js(?:\?.*|;.*)?$/i;

/**
 * Fired when AlloyEditor detects the browser language and loads the corresponding language file. Once this event
 * is fired, AlloyEditor.Strings will be populated with data.
 *
 * @event languageResourcesLoaded
 */

/**
 * Returns the required plugin names needed for a given plugin
 * if it is already registered or an empty array.
 *
 * @memberof AlloyEditor
 * @method getButtons
 * @param {Array} buttons An array of buttons or plugin names.
 * @return {Function} A function that can be invoked to resolve the requested button names.
 * @static
 */
var getButtons = function getButtons(buttons) {
	return function () {
		return buttons.reduce(function (acc, val) {
			val = BRIDGE_BUTTONS[val] || [val];
			return acc.concat(val);
		}, []);
	};
};

/**
 * Register a button and try to get its required plugins.
 *
 * @memberof AlloyEditor
 * @method registerBridgeButton
 * @param {String} buttonName The name of the button.
 * @param {String} pluginName The name of the plugin that registers the button.
 * @static
 */
var registerBridgeButton = function registerBridgeButton(buttonName, pluginName) {
	if (!BRIDGE_BUTTONS[pluginName]) {
		BRIDGE_BUTTONS[pluginName] = [];
	}

	BRIDGE_BUTTONS[pluginName].push(buttonName);
};

/**
 * @method OOP
 * @memberof AlloyEditor
 */
var OOP = {
	extend: _oop2.default
};

exports.Attribute = _attribute2.default;
exports.Base = Base;
exports.Buttons = _buttons2.default;
exports.Compat = Compat;
exports.Core = _core2.default;
exports.Lang = _lang2.default;
exports.OOP = OOP;
exports.SelectionGetArrowBoxClasses = _selectionArrowbox2.default;
exports.SelectionSetPosition = _selectionPosition2.default;
exports.SelectionTest = _selectionTest2.default;
exports.Selections = _selections2.default;
exports.Toolbars = _toolbars2.default;
exports.editable = editable;
exports.getBasePath = getBasePath;
exports.getButtons = getButtons;
exports.getUrl = getUrl;
exports.implementEventTarget = implementEventTarget;
exports.loadLanguageResources = loadLanguageResources;
exports.regexBasePath = regexBasePath;
exports.registerBridgeButton = registerBridgeButton;

/***/ }),

/***/ "./src/commands/index.js":
/*!*******************************!*\
  !*** ./src/commands/index.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeImageCommand = undefined;

var _removeImage = __webpack_require__(/*! ./remove-image */ "./src/commands/remove-image.js");

var _removeImage2 = _interopRequireDefault(_removeImage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.removeImageCommand = _removeImage2.default; /**
                                                     * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                     * SPDX-License-Identifier: LGPL-3.0-or-later
                                                     */

/***/ }),

/***/ "./src/commands/remove-image.js":
/*!**************************************!*\
  !*** ./src/commands/remove-image.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var removeImageCommand = {
	exec: function exec(editor) {
		var selection = editor.getSelection();

		if (selection) {
			var ranges = selection.getRanges();
			var startContainer = ranges[0].startContainer;

			var nextRange = new CKEDITOR.dom.range(startContainer);
			nextRange.setStart(startContainer, 0);
			nextRange.setEnd(startContainer, 0);

			var selectedElement = selection.getSelectedElement();

			if (selectedElement && selectedElement.getName() === 'img') {
				var native = selection.getNative();
				if (native) {
					native.removeAllRanges();
				}

				selection.selectRanges([nextRange]);

				selectedElement.remove();
			}
		}
	}
};

exports.default = removeImageCommand;

/***/ }),

/***/ "./src/components/base/button-action-style.js":
/*!****************************************************!*\
  !*** ./src/components/base/button-action-style.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * ButtonActionStyle is a mixin that provides applying style implementation for a
 * button based on the `applyStyle` and `removeStyle` API of CKEDITOR.
 *
 * To execute properly, the component has to expose the following methods which can be obtained
 * out of the box using the {{#crossLink "ButtonStyle"}}{{/crossLink}} mixin:
 * - `Function` {{#crossLink "ButtonStyle/isActive"}}{{/crossLink}} to check the active state
 * - `Function` {{#crossLink "ButtonStyle/getStyle"}}{{/crossLink}} to return the style that should be applied
 *
 * @class ButtonActionStyle
 */
exports.default = function (WrappedComponent) {
	var _class, _temp2;

	return _temp2 = _class = function (_WrappedComponent) {
		_inherits(ButtonActionStyle, _WrappedComponent);

		function ButtonActionStyle() {
			var _ref;

			var _temp, _this, _ret;

			_classCallCheck(this, ButtonActionStyle);

			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonActionStyle.__proto__ || Object.getPrototypeOf(ButtonActionStyle)).call.apply(_ref, [this].concat(args))), _this), _this.applyStyle = function () {
				if (_lang2.default.isFunction(_this.isActive) && _lang2.default.isFunction(_this.getStyle)) {
					var editor = _this.context.editor.get('nativeEditor');

					editor.getSelection().lock();

					if (_this.isActive()) {
						editor.removeStyle(_this.getStyle());
					} else {
						editor.applyStyle(_this.getStyle());
					}

					editor.getSelection().unlock();

					editor.fire('actionPerformed', _this);
				}
			}, _temp), _possibleConstructorReturn(_this, _ret);
		}

		/**
   * Removes or applies the component style to the current selection.
   *
   * @instance
   * @memberof ButtonActionStyle
   * @method applyStyle
   */


		return ButtonActionStyle;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp2;
};

/***/ }),

/***/ "./src/components/base/button-command-active.js":
/*!******************************************************!*\
  !*** ./src/components/base/button-command-active.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * ButtonCommandActive is a mixin that provides an `isActive` method to determine if
 * a context-aware command is currently in an active state.
 *
 * @class ButtonCommandActive
 */
exports.default = function (WrappedComponent) {
	var _class, _temp;

	return _temp = _class = function (_WrappedComponent) {
		_inherits(ButtonCommandActive, _WrappedComponent);

		function ButtonCommandActive() {
			_classCallCheck(this, ButtonCommandActive);

			return _possibleConstructorReturn(this, (ButtonCommandActive.__proto__ || Object.getPrototypeOf(ButtonCommandActive)).apply(this, arguments));
		}

		_createClass(ButtonCommandActive, [{
			key: 'isActive',


			/**
    * Checks if the command is active in the current selection.
    *
    * @instance
    * @memberof ButtonCommandActive
    * @method isActive
    * @return {Boolean} True if the command is active, false otherwise.
    */
			value: function isActive() {
				var editor = this.context.editor.get('nativeEditor');

				var command = editor.getCommand(this.props.command);

				return command ? command.state === CKEDITOR.TRISTATE_ON : false;
			}
		}]);

		return ButtonCommandActive;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp;
};

/***/ }),

/***/ "./src/components/base/button-command.js":
/*!***********************************************!*\
  !*** ./src/components/base/button-command.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * ButtonCommand is a mixin that executes a command via CKEDITOR's API.
 *
 * @class ButtonCommand
 */
exports.default = function (WrappedComponent) {
	var _class, _temp2;

	return _temp2 = _class = function (_WrappedComponent) {
		_inherits(ButtonCommand, _WrappedComponent);

		function ButtonCommand() {
			var _ref;

			var _temp, _this, _ret;

			_classCallCheck(this, ButtonCommand);

			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonCommand.__proto__ || Object.getPrototypeOf(ButtonCommand)).call.apply(_ref, [this].concat(args))), _this), _this.execCommand = function (data) {
				var editor = _this.context.editor.get('nativeEditor');

				editor.execCommand(_this.props.command, data);

				editor.fire('actionPerformed', _this);
			}, _temp), _possibleConstructorReturn(_this, _ret);
		}

		/**
   * Executes a CKEditor command and fires `actionPerformed` event.
   *
   * @instance
   * @memberof ButtonCommand
   * @param {Object=} data Optional data to be passed to CKEDITOR's `execCommand` method.
   * @method execCommand
   */


		return ButtonCommand;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp2;
};

/***/ }),

/***/ "./src/components/base/button-keystroke.js":
/*!*************************************************!*\
  !*** ./src/components/base/button-keystroke.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * ButtonKeystroke is a mixin that provides a `keystroke` prop that allows configuring
 * a function of the instance to be invoked upon the keystroke activation.
 *
 * @class ButtonKeystroke
 */
exports.default = function (WrappedComponent) {
	var _class, _temp;

	return _temp = _class = function (_WrappedComponent) {
		_inherits(ButtonKeystroke, _WrappedComponent);

		function ButtonKeystroke() {
			_classCallCheck(this, ButtonKeystroke);

			return _possibleConstructorReturn(this, (ButtonKeystroke.__proto__ || Object.getPrototypeOf(ButtonKeystroke)).apply(this, arguments));
		}

		_createClass(ButtonKeystroke, [{
			key: 'componentWillMount',


			/**
    * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
    *
    * @instance
    * @memberof ButtonKeystroke
    * @method componentWillMount
    */
			value: function componentWillMount() {
				if (_lang2.default.isFunction(_get(ButtonKeystroke.prototype.__proto__ || Object.getPrototypeOf(ButtonKeystroke.prototype), 'componentWillMount', this))) {
					_get(ButtonKeystroke.prototype.__proto__ || Object.getPrototypeOf(ButtonKeystroke.prototype), 'componentWillMount', this).call(this);
				}

				var nativeEditor = this.context.editor.get('nativeEditor');
				var keystroke = this.props.keystroke;

				var commandName = 'keystroke:' + keystroke.name;

				var command = nativeEditor.getCommand(commandName);

				if (!command) {
					command = new CKEDITOR.command(nativeEditor, {
						exec: function (editor) {
							var keystrokeFn = keystroke.fn;

							if (_lang2.default.isString(keystrokeFn)) {
								this[keystrokeFn].call(this, editor);
							} else if (_lang2.default.isFunction(keystrokeFn)) {
								keystrokeFn.call(this, editor);
							}
						}.bind(this)
					});

					nativeEditor.addCommand(commandName, command);
				}

				this._defaultKeystrokeCommand = nativeEditor.keystrokeHandler.keystrokes[keystroke.keys];

				nativeEditor.setKeystroke(keystroke.keys, commandName);
			}

			/**
    * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
    *
    * @instance
    * @memberof ButtonKeystroke
    * @method componentWillUnmount
    */

		}, {
			key: 'componentWillUnmount',
			value: function componentWillUnmount() {
				if (_lang2.default.isFunction(_get(ButtonKeystroke.prototype.__proto__ || Object.getPrototypeOf(ButtonKeystroke.prototype), 'componentWillUnmount', this))) {
					_get(ButtonKeystroke.prototype.__proto__ || Object.getPrototypeOf(ButtonKeystroke.prototype), 'componentWillUnmount', this).call(this);
				}

				this.context.editor.get('nativeEditor').setKeystroke(this.props.keystroke.keys, this._defaultKeystrokeCommand);
			}
		}]);

		return ButtonKeystroke;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp;
};

/***/ }),

/***/ "./src/components/base/button-props.js":
/*!*********************************************!*\
  !*** ./src/components/base/button-props.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * ButtonCfgProps is a class that provides a mergeButtonCfgProps method for
 * merging React props and the native CKEDITOR's buttonCfg.
 *
 * @class ButtonProps
 */
exports.default = function (WrappedComponent) {
	var _class, _temp;

	return _temp = _class = function (_WrappedComponent) {
		_inherits(ButtonProps, _WrappedComponent);

		function ButtonProps() {
			_classCallCheck(this, ButtonProps);

			return _possibleConstructorReturn(this, (ButtonProps.__proto__ || Object.getPrototypeOf(ButtonProps)).apply(this, arguments));
		}

		_createClass(ButtonProps, [{
			key: 'mergeButtonCfgProps',


			/**
    * Merges the properties, passed to the current component with user's configuration
    * via `buttonCfg` property.
    *
    * @instance
    * @memberof ButtonProps
    * @method mergeButtonCfgProps
    * @param {Object} props The properties to be merged with the provided configuration for this
    * button. If not passed, the user configuration will be merged with `this.props`
    * @return {Object} The merged properties
    */
			value: function mergeButtonCfgProps() {
				var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;

				var nativeEditor = this.context.editor.get('nativeEditor');
				var buttonCfg = nativeEditor.config.buttonCfg || {};
				return CKEDITOR.tools.merge(props, buttonCfg['linkEdit']);
			}
		}]);

		return ButtonProps;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp;
};

/***/ }),

/***/ "./src/components/base/button-state-classes.js":
/*!*****************************************************!*\
  !*** ./src/components/base/button-state-classes.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * ButtonStateClasses is a mixin that decorates the domElement of a component
 * with different CSS classes based on the current state of the element.
 *
 * To check for state, the component can expose the following methods:
 * - `Function` **isActive** to check the active state
 *
 * @class ButtonStateClasses
 */
exports.default = function (WrappedComponent) {
	return function (_WrappedComponent) {
		_inherits(ButtonStateClasses, _WrappedComponent);

		function ButtonStateClasses() {
			_classCallCheck(this, ButtonStateClasses);

			return _possibleConstructorReturn(this, (ButtonStateClasses.__proto__ || Object.getPrototypeOf(ButtonStateClasses)).apply(this, arguments));
		}

		_createClass(ButtonStateClasses, [{
			key: 'getStateClasses',

			/**
    * Returns the list of state classes associated to the current element's state, according
    * to the results of the isActive method.
    *
    * @instance
    * @memberof ButtonStateClasses
    * @method getStateClasses
    * @return {String} A string with the state CSS classes.
    */
			value: function getStateClasses() {
				var stateClasses = '';

				// Check for active state
				if (_lang2.default.isFunction(this.isActive) && this.isActive()) {
					stateClasses += 'ae-button-pressed';
				}

				return stateClasses;
			}
		}]);

		return ButtonStateClasses;
	}(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-style.js":
/*!*********************************************!*\
  !*** ./src/components/base/button-style.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * ButtonStyle is a mixin that provides a style prop and some methods to apply the resulting
 * style and checking if it is present in a given path or selection.
 *
 * @class ButtonStyle
 */
exports.default = function (WrappedComponent) {
	var _class, _temp;

	return _temp = _class = function (_WrappedComponent) {
		_inherits(ButtonStyle, _WrappedComponent);

		function ButtonStyle() {
			_classCallCheck(this, ButtonStyle);

			return _possibleConstructorReturn(this, (ButtonStyle.__proto__ || Object.getPrototypeOf(ButtonStyle)).apply(this, arguments));
		}

		_createClass(ButtonStyle, [{
			key: 'componentWillMount',


			/**
    * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
    *
    * @instance
    * @memberof ButtonStyle
    * @method componentWillMount
    */
			value: function componentWillMount() {
				if (_lang2.default.isFunction(_get(ButtonStyle.prototype.__proto__ || Object.getPrototypeOf(ButtonStyle.prototype), 'componentWillMount', this))) {
					_get(ButtonStyle.prototype.__proto__ || Object.getPrototypeOf(ButtonStyle.prototype), 'componentWillMount', this).call(this);
				}

				var style = this.props.style;

				if (_lang2.default.isString(style)) {
					var parts = style.split('.');
					var currentMember = this.context.editor.get('nativeEditor').config;
					var property = parts.shift();

					while (property && _lang2.default.isObject(currentMember) && _lang2.default.isObject(currentMember[property])) {
						currentMember = currentMember[property];
						property = parts.shift();
					}

					if (_lang2.default.isObject(currentMember)) {
						style = currentMember;
					}
				}

				this._style = new CKEDITOR.style(style);
			}

			/**
    * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
    *
    * @instance
    * @memberof ButtonStyle
    * @method componentWillUnmount
    */

		}, {
			key: 'componentWillUnmount',
			value: function componentWillUnmount() {
				if (_lang2.default.isFunction(_get(ButtonStyle.prototype.__proto__ || Object.getPrototypeOf(ButtonStyle.prototype), 'componentWillUnmount', this))) {
					_get(ButtonStyle.prototype.__proto__ || Object.getPrototypeOf(ButtonStyle.prototype), 'componentWillUnmount', this).call(this);
				}

				this._style = null;
			}

			/**
    * Returns instance of CKEDITOR.style which represents the current button style.
    *
    * @instance
    * @memberof ButtonStyle
    * @method getStyle
    * @return {CKEDITOR.style} The current style representation.
    */

		}, {
			key: 'getStyle',
			value: function getStyle() {
				return this._style;
			}

			/**
    * Checks if style is active in the current selection.
    *
    * @instance
    * @memberof ButtonStyle
    * @method isActive
    * @return {Boolean} True if style is active, false otherwise.
    */

		}, {
			key: 'isActive',
			value: function isActive() {
				var editor = this.context.editor.get('nativeEditor');
				var elementPath = editor.elementPath();
				return this.getStyle().checkActive(elementPath, editor);
			}
		}]);

		return ButtonStyle;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp;
};

/***/ }),

/***/ "./src/components/base/index.js":
/*!**************************************!*\
  !*** ./src/components/base/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _buttonActionStyle = __webpack_require__(/*! ./button-action-style */ "./src/components/base/button-action-style.js");

Object.defineProperty(exports, 'ButtonActionStyle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonActionStyle).default;
  }
});

var _buttonCommandActive = __webpack_require__(/*! ./button-command-active */ "./src/components/base/button-command-active.js");

Object.defineProperty(exports, 'ButtonCommandActive', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonCommandActive).default;
  }
});

var _buttonCommand = __webpack_require__(/*! ./button-command */ "./src/components/base/button-command.js");

Object.defineProperty(exports, 'ButtonCommand', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonCommand).default;
  }
});

var _buttonKeystroke = __webpack_require__(/*! ./button-keystroke */ "./src/components/base/button-keystroke.js");

Object.defineProperty(exports, 'ButtonKeystroke', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonKeystroke).default;
  }
});

var _buttonProps = __webpack_require__(/*! ./button-props */ "./src/components/base/button-props.js");

Object.defineProperty(exports, 'ButtonProps', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonProps).default;
  }
});

var _buttonStateClasses = __webpack_require__(/*! ./button-state-classes */ "./src/components/base/button-state-classes.js");

Object.defineProperty(exports, 'ButtonStateClasses', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonStateClasses).default;
  }
});

var _buttonStyle = __webpack_require__(/*! ./button-style */ "./src/components/base/button-style.js");

Object.defineProperty(exports, 'ButtonStyle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonStyle).default;
  }
});

var _toolbarButtons = __webpack_require__(/*! ./toolbar-buttons */ "./src/components/base/toolbar-buttons.js");

Object.defineProperty(exports, 'ToolbarButtons', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_toolbarButtons).default;
  }
});

var _widgetDropdown = __webpack_require__(/*! ./widget-dropdown */ "./src/components/base/widget-dropdown.js");

Object.defineProperty(exports, 'WidgetDropdown', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetDropdown).default;
  }
});

var _widgetExclusive = __webpack_require__(/*! ./widget-exclusive */ "./src/components/base/widget-exclusive.js");

Object.defineProperty(exports, 'WidgetExclusive', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetExclusive).default;
  }
});

var _widgetFocusManager = __webpack_require__(/*! ./widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

Object.defineProperty(exports, 'WidgetFocusManager', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetFocusManager).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "./src/components/base/toolbar-buttons.js":
/*!************************************************!*\
  !*** ./src/components/base/toolbar-buttons.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * ToolbarButtons provides a list of buttons which have to be displayed
 * on the current toolbar depending on user preferences and given state.
 *
 * @class ToolbarButtons
 */
exports.default = function (WrappedComponent) {
	var _class, _temp;

	return _temp = _class = function (_WrappedComponent) {
		_inherits(ToolbarButtons, _WrappedComponent);

		function ToolbarButtons() {
			_classCallCheck(this, ToolbarButtons);

			return _possibleConstructorReturn(this, (ToolbarButtons.__proto__ || Object.getPrototypeOf(ToolbarButtons)).apply(this, arguments));
		}

		_createClass(ToolbarButtons, [{
			key: 'cancelAnimation',


			/**
    * Cancels an scheduled animation frame.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method cancelAnimation
    */
			value: function cancelAnimation() {
				if (this._animationFrameId) {
					window.cancelAnimationFrame(this._animationFrameId);
				}
			}

			/**
    * Provides functionality for displaying toolbar Arrow box on top or on bottom of the toolbar
    * depending on the point of user interaction with the editor.
    * Returns the list of arrow box classes associated to the current element's state. It relies
    * on the getInteractionPoint method to calculate the selection direction.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method getArrowBoxClasses
    * @return {String} A string with the arrow box CSS classes.
    */


			/**
    * Lifecycle. Returns the default values of the properties used in the
    * toolbar.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method getDefaultProps
    */

		}, {
			key: 'getArrowBoxClasses',
			value: function getArrowBoxClasses() {
				var arrowBoxClasses = 'ae-arrow-box';

				if (this.getInteractionPoint().direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
					arrowBoxClasses += ' ae-arrow-box-top';
				} else {
					arrowBoxClasses += ' ae-arrow-box-bottom';
				}

				return arrowBoxClasses;
			}

			/**
    * Returns an object which contains the position of the element in page coordinates,
    * restricted to fit to given viewport.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method getConstrainedPosition
    * @param {Object} attrs The following properties, provided as numbers:
    * - height
    * - left
    * - top
    * - width
    * @param {Object} viewPaneSize Optional. If not provided, the current viewport will be used. Should contain at least these properties:
    * - width
    * @return {Object} An object with `x` and `y` properties, which represent the constrained position of the
    * element.
    */

		}, {
			key: 'getConstrainedPosition',
			value: function getConstrainedPosition(attrs, viewPaneSize) {
				viewPaneSize = viewPaneSize || new CKEDITOR.dom.window(window).getViewPaneSize();

				var x = attrs.left;
				var y = attrs.top;

				if (attrs.left + attrs.width > viewPaneSize.width) {
					x -= attrs.left + attrs.width - viewPaneSize.width;
				}

				if (y < 0) {
					y = 0;
				}

				return {
					x: x,
					y: y
				};
			}

			/**
    * Returns the position, in page coordinates, according to which a toolbar should appear.
    * Depending on the direction of the selection, the wdiget may appear above of or on bottom of the selection.
    *
    * It depends on the props editorEvent to analyze the following user-interaction parameters:
    * - {Object} selectionData The data about the selection in the editor as returned from
    * {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
    * - {Number} pos Contains the coordinates of the position, considered as most appropriate.
    * This may be the point where the user released the mouse, or just the beginning or the end of
    * the selection.
    *
    * @instance
    * @method getInteractionPoint
    * @return {Object} An Object which contains the following properties:
    * direction, x, y, where x and y are in page coordinates and direction can be one of these:
    * CKEDITOR.SELECTION_BOTTOM_TO_TOP or CKEDITOR.SELECTION_TOP_TO_BOTTOM
    */

		}, {
			key: 'getInteractionPoint',
			value: function getInteractionPoint() {
				var eventPayload = this.props.editorEvent ? this.props.editorEvent.data : null;

				if (!eventPayload) {
					return;
				}

				var selectionData = eventPayload.selectionData;

				var nativeEvent = eventPayload.nativeEvent;

				var pos = {
					x: eventPayload.nativeEvent.pageX,
					y: selectionData.region.top
				};

				var direction = selectionData.region.direction;

				var endRect = selectionData.region.endRect;

				var startRect = selectionData.region.startRect;

				if (endRect && startRect && startRect.top === endRect.top) {
					direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
				}

				var x = void 0;
				var y = void 0;

				// If we have the point where user released the mouse, show Toolbar at this point
				// otherwise show it on the middle of the selection.

				if (pos.x && pos.y) {
					x = this._getXPoint(selectionData, pos.x);

					if (direction === CKEDITOR.SELECTION_BOTTOM_TO_TOP) {
						y = Math.min(pos.y, selectionData.region.top);
					} else {
						y = Math.max(pos.y, this._getYPoint(selectionData, nativeEvent));
					}
				} else {
					x = selectionData.region.left + selectionData.region.width / 2;

					if (direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
						y = this._getYPoint(selectionData, nativeEvent);
					} else {
						y = selectionData.region.top;
					}
				}

				return {
					direction: direction,
					x: x,
					y: y
				};
			}

			/**
    * Returns the position of the toolbar.
    *
    * @instance
    * @method _getXPoint
    * @param {Object} eventX The X coordinate received from the native event (mouseup).
    * @param {Object} selectionData The data about the selection in the editor as returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
    * @protected
    * @return {Number} The calculated X point in page coordinates.
    */

		}, {
			key: '_getXPoint',
			value: function _getXPoint(selectionData, eventX) {
				var region = selectionData.region;

				var left = region.startRect ? region.startRect.left : region.left;
				var right = region.endRect ? region.endRect.right : region.right;

				var x = void 0;

				if (left < eventX && right > eventX) {
					x = eventX;
				} else {
					var leftDist = Math.abs(left - eventX);
					var rightDist = Math.abs(right - eventX);

					if (leftDist < rightDist) {
						// user raised the mouse on left on the selection
						x = left;
					} else {
						x = right;
					}
				}

				return x;
			}

			/**
    * Returns the position of the toolbar.
    *
    * @instance
    * @method _getYPoint
    * @param {Object} nativeEvent The data about event is fired
    * @param {Object} selectionData The data about the selection in the editor as returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
    * @protected
    * @return {Number} The calculated Y point in page coordinates.
    */

		}, {
			key: '_getYPoint',
			value: function _getYPoint(selectionData, nativeEvent) {
				var y = 0;

				if (selectionData && nativeEvent) {
					var elementTarget = new CKEDITOR.dom.element(nativeEvent.target);

					if (elementTarget.$ && elementTarget.getStyle('overflow') === 'auto') {
						y = nativeEvent.target.offsetTop + nativeEvent.target.offsetHeight;
					} else {
						y = selectionData.region.bottom;
					}
				}

				return y;
			}

			/**
    * Returns the position of the toolbar taking in consideration the
    * {{#crossLink "ToolbarButtons/gutter:attribute"}}{{/crossLink}} attribute.
    *
    * @instance
    * @memberof ToolbarButtons
    * @protected
    * @method  getWidgetXYPoint
    * @param {Number} left The left offset in page coordinates where Toolbar should be shown.
    * @param {Number} top The top offset in page coordinates where Toolbar should be shown.
    * @param {Number} direction The direction of the selection. May be one of the following:
    * CKEDITOR.SELECTION_BOTTOM_TO_TOP or CKEDITOR.SELECTION_TOP_TO_BOTTOM
    * @return {Array} An Array with left and top offsets in page coordinates.
    */

		}, {
			key: 'getWidgetXYPoint',
			value: function getWidgetXYPoint(left, top, direction) {
				var domNode = _reactDom2.default.findDOMNode(this);

				var gutter = this.props.gutter;

				if (direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM || direction === CKEDITOR.SELECTION_BOTTOM_TO_TOP) {
					left = left - gutter.left - domNode.offsetWidth / 2;

					top = direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM ? top + gutter.top : top - domNode.offsetHeight - gutter.top;
				} else if (direction === CKEDITOR.SELECTION_LEFT_TO_RIGHT || direction === CKEDITOR.SELECTION_RIGHT_TO_LEFT) {
					left = direction === CKEDITOR.SELECTION_LEFT_TO_RIGHT ? left + gutter.left + domNode.offsetHeight / 2 : left - 3 * domNode.offsetHeight / 2 - gutter.left;

					top = top - gutter.top - domNode.offsetHeight / 2;
				}

				if (left < 0) {
					left = 0;
				}

				if (top < 0) {
					top = 0;
				}

				return [left, top];
			}

			/**
    * Returns true if the toolbar is visible, false otherwise
    *
    * @instance
    * @memberof ToolbarButtons
    * @method isVisible
    * @return {Boolean} True if the toolbar is visible, false otherwise
    */

		}, {
			key: 'isVisible',
			value: function isVisible() {
				var domNode = _reactDom2.default.findDOMNode(this);

				if (domNode) {
					var domElement = new CKEDITOR.dom.element(domNode);

					return domElement.hasClass('alloy-editor-visible');
				}

				return false;
			}

			/**
    * Moves a toolbar from a starting point to a destination point.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method moveToPoint
    * @param  {Object} startPoint The starting point for the movement.
    * @param  {Object} endPoint The destination point for the movement.
    */

		}, {
			key: 'moveToPoint',
			value: function moveToPoint(startPoint, endPoint) {
				var domElement = new CKEDITOR.dom.element(_reactDom2.default.findDOMNode(this));

				domElement.setStyles({
					left: startPoint[0] + 'px',
					top: startPoint[1] + 'px',
					opacity: 0,
					pointerEvents: 'none'
				});

				domElement.removeClass('alloy-editor-invisible');

				this._animationFrameId = window.requestAnimationFrame(function () {
					domElement.addClass('ae-toolbar-transition');
					domElement.addClass('alloy-editor-visible');
					domElement.setStyles({
						left: endPoint[0] + 'px',
						top: endPoint[1] + 'px',
						opacity: 1
					});

					// 150ms to match transition-duration for .ae-toolbar-transition:
					setTimeout(function () {
						domElement.setStyles({
							pointerEvents: ''
						});
					}, 150);
				});
			}

			/**
    * Shows the toolbar with the default animation transition.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method show
    */

		}, {
			key: 'show',
			value: function show() {
				var domNode = _reactDom2.default.findDOMNode(this);
				var uiNode = this.context.editor.get('uiNode');

				var scrollTop = uiNode ? uiNode.scrollTop : 0;

				if (!this.isVisible() && domNode) {
					var interactionPoint = this.getInteractionPoint();

					if (interactionPoint) {
						var domElement = new CKEDITOR.dom.element(domNode);

						var finalX = void 0;
						var finalY = void 0;
						var initialX = void 0;
						var initialY = void 0;

						finalX = initialX = parseFloat(domElement.getStyle('left'));
						finalY = initialY = parseFloat(domElement.getStyle('top'));

						if (this.props.constrainToViewport) {
							var res = this.getConstrainedPosition({
								height: parseFloat(domNode.offsetHeight),
								left: finalX,
								top: finalY,
								width: parseFloat(domNode.offsetWidth)
							});

							finalX = res.x;
							finalY = res.y;
						}

						if (interactionPoint.direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
							initialY = this.props.selectionData.region.bottom + scrollTop;
						} else {
							initialY = this.props.selectionData.region.top + scrollTop;
						}

						this.moveToPoint([initialX, initialY], [finalX, finalY]);
					}
				}
			}

			/**
    * Updates the toolbar position based on the current interaction point.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method updatePosition
    */

		}, {
			key: 'updatePosition',
			value: function updatePosition() {
				var interactionPoint = this.getInteractionPoint();

				var domNode = _reactDom2.default.findDOMNode(this);

				if (interactionPoint && domNode) {
					var uiNode = this.context.editor.get('uiNode') || document.body;
					var uiNodeStyle = getComputedStyle(uiNode);
					var uiNodeMarginLeft = parseInt(uiNodeStyle.getPropertyValue('margin-left'), 10);
					var uiNodeMarginRight = parseInt(uiNodeStyle.getPropertyValue('margin-right'), 10);
					var totalWidth = uiNodeMarginLeft + uiNode.clientWidth + uiNodeMarginRight;

					var scrollTop = uiNode.tagName !== 'BODY' ? uiNode.scrollTop : 0;

					var xy = this.getWidgetXYPoint(interactionPoint.x, interactionPoint.y, interactionPoint.direction);
					xy[1] += scrollTop;

					if (xy[0] < 0) {
						xy[0] = 0;
					}
					if (xy[0] > totalWidth - domNode.offsetWidth) {
						xy[0] = totalWidth - domNode.offsetWidth;
					}

					new CKEDITOR.dom.element(domNode).setStyles({
						left: xy[0] + 'px',
						top: xy[1] + 'px'
					});
				}
			}

			/**
    * Analyses the current selection and returns the buttons or button groups to be rendered.
    *
    * @instance
    * @method getToolbarButtonGroups
    * @param {Array} buttons The buttons could be shown, prior to the state filtering.
    * @param {Object} additionalProps Additional props that should be passed down to the buttons.
    * @return {Array} An Array which contains the buttons or button groups that should be rendered.
    */

		}, {
			key: 'getToolbarButtonGroups',
			value: function getToolbarButtonGroups(buttons, additionalProps) {
				var _this2 = this;

				if (_lang2.default.isFunction(buttons)) {
					buttons = buttons.call(this) || [];
				}

				return buttons.reduce(function (list, button) {
					if (Array.isArray(button)) {
						list.push(_this2.getToolbarButtons(button, additionalProps));
						return list;
					} else {
						return _this2.getToolbarButtons(buttons, additionalProps);
					}
				}, []);
			}

			/**
    * Analyzes the current selection and the buttons exclusive mode value to figure out which
    * buttons should be present in a given state.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method getToolbarButtons
    * @param {Array} buttons The buttons could be shown, prior to the state filtering.
    * @param {Object} additionalProps Additional props that should be passed down to the buttons.
    * @return {Array} An Array which contains the buttons that should be rendered.
    */

		}, {
			key: 'getToolbarButtons',
			value: function getToolbarButtons(buttons, additionalProps) {
				var buttonProps = {};

				var nativeEditor = this.context.editor.get('nativeEditor');
				var buttonCfg = nativeEditor.config.buttonCfg || {};

				if (_lang2.default.isFunction(buttons)) {
					buttons = buttons.call(this) || [];
				}

				var toolbarButtons = this.filterExclusive(buttons.filter(function (button) {
					return button && (AlloyEditor.Buttons[button] || AlloyEditor.Buttons[button.name]);
				}).map(function (button) {
					if (_lang2.default.isString(button)) {
						buttonProps[button] = buttonCfg[button];
						button = AlloyEditor.Buttons[button];
					} else if (_lang2.default.isString(button.name)) {
						buttonProps[AlloyEditor.Buttons[button.name].key] = CKEDITOR.tools.merge(buttonCfg[button], button.cfg);
						button = AlloyEditor.Buttons[button.name];
					}

					return button;
				})).map(function (button, index) {
					var props = this.mergeExclusiveProps({
						editor: this.context.editor,
						key: button.key !== 'separator' ? button.key : button.key + '-' + index,
						tabKey: button.key,
						tabIndex: this.props.trigger && this.props.trigger.props.tabKey === button.key ? 0 : -1,
						trigger: this.props.trigger
					}, button.key);

					props = this.mergeDropdownProps(props, button.key);

					if (additionalProps) {
						props = CKEDITOR.tools.merge(props, additionalProps);
					}

					props = CKEDITOR.tools.merge(props, buttonProps[button.key]);

					return _react2.default.createElement(button, props);
				}, this);

				return toolbarButtons;
			}
		}]);

		return ToolbarButtons;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _class.defaultProps = _extends({}, WrappedComponent.defaultProps, {
		gutter: {
			left: 0,
			top: 10
		},
		constrainToViewport: true
	}), _temp;
};

/***/ }),

/***/ "./src/components/base/widget-dropdown.js":
/*!************************************************!*\
  !*** ./src/components/base/widget-dropdown.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * Provides functionality for managing different dropdowns inside a widget.
 *
 * @class WidgetDropdown
 */
exports.default = function (WrappedComponent) {
	return function (_WrappedComponent) {
		_inherits(WidgetDropdown, _WrappedComponent);

		function WidgetDropdown(props) {
			_classCallCheck(this, WidgetDropdown);

			var _this = _possibleConstructorReturn(this, (WidgetDropdown.__proto__ || Object.getPrototypeOf(WidgetDropdown)).call(this, props));

			_this.mergeDropdownProps = function (obj, itemKey) {
				return CKEDITOR.tools.merge(obj, {
					expanded: _this.state.itemDropdown === itemKey ? true : false,
					tabIndex: _this.state.dropdownTrigger === itemKey ? 0 : -1,
					toggleDropdown: _this.toggleDropdown.bind(_this, itemKey)
				});
			};

			_this.toggleDropdown = function (itemDropdown, toggleDirection) {
				_this.setState({
					dropdownTrigger: itemDropdown,
					itemDropdown: itemDropdown !== _this.state.itemDropdown ? itemDropdown : null
				}, function () {
					if (!_this.state.itemDropdown) {
						if (_this.moveFocus) {
							_this.moveFocus(toggleDirection);
						} else {
							_reactDom2.default.findDOMNode(_this).focus();
						}
					}
				});
			};

			_this.state = _extends({}, _this.state, {
				dropdownTrigger: null,
				itemDropdown: null
			});
			return _this;
		}

		/**
   * Lifecycle. Invoked when a component is receiving new props.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof WidgetDropdown
   * @method componentWillReceiveProps
   */


		_createClass(WidgetDropdown, [{
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(nextProps) {
				if (_lang2.default.isFunction(_get(WidgetDropdown.prototype.__proto__ || Object.getPrototypeOf(WidgetDropdown.prototype), 'componentWillReceiveProps', this))) {
					_get(WidgetDropdown.prototype.__proto__ || Object.getPrototypeOf(WidgetDropdown.prototype), 'componentWillReceiveProps', this).call(this, nextProps);
				}

				this.setState({
					dropdownTrigger: null,
					itemDropdown: null
				});
			}

			/**
    * Merges the provided object with two more properties:
    * - expanded - boolean flag which indicates if an widget should be rendered exclusively.
    * - toggleDropdown - function, which can be used by an widget in order to obtain exclusive state.
    *
    * @instance
    * @memberof WidgetDropdown
    * @method mergeDropdownProps
    * @param {Object} obj The properties container which should be merged with the properties, related
    *    to dropdown state.
    * @param {Object} itemKey They key of an React Widget which contains the dropdown.
    * @return {Object} The merged object.
    */


			/**
    * Sets the active dropdown of the widget or discards the toggled item from the state.
    *
    * @instance
    * @memberof WidgetDropdown
    * @method toggleDropdown
    * @param {Object} itemDropdown The widget which requests to toggle its dropdown.
    * @param {Number} toggleDirection User movement direction when toggled via keyboard.
    */

		}]);

		return WidgetDropdown;
	}(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-exclusive.js":
/*!*************************************************!*\
  !*** ./src/components/base/widget-exclusive.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * Provides functionality for managing exclusive state of an widget.
 * The exclusive state means that a button may request to be the only rendered
 * widget in its parent container. WidgetExclusive will manage this state by
 * filtering and suppressing the other sibling widgets from displaying.
 *
 * @class WidgetExclusive
 */
exports.default = function (WrappedComponent) {
	return function (_WrappedComponent) {
		_inherits(WidgetExclusive, _WrappedComponent);

		function WidgetExclusive() {
			var _ref;

			var _temp, _this, _ret;

			_classCallCheck(this, WidgetExclusive);

			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = WidgetExclusive.__proto__ || Object.getPrototypeOf(WidgetExclusive)).call.apply(_ref, [this].concat(args))), _this), _this.requestExclusive = function (itemExclusive) {
				_this.setState({
					itemExclusive: itemExclusive
				});
			}, _temp), _possibleConstructorReturn(_this, _ret);
		}

		_createClass(WidgetExclusive, [{
			key: 'cancelExclusive',

			/**
    * Cancels the exclusive state of an widget.
    *
    * @instance
    * @memberof WidgetExclusive
    * @method cancelExclusive
    * @param {Object} itemExclusive The widget which exclusive state should be canceled.
    */
			value: function cancelExclusive(itemExclusive) {
				if (this.state.itemExclusive === itemExclusive) {
					this.setState({
						itemExclusive: null
					});
				}
			}

			/**
    * Lifecycle. Invoked when a component is receiving new props.
    * This method is not called for the initial render.
    * Calling this.setState() within this function will not trigger an additional render.
    *
    * @instance
    * @memberof WidgetExclusive
    * @method componentWillReceiveProps
    * @param {Object} nextProps Object containing the current set of properties.
    */

		}, {
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(nextProps) {
				if (_lang2.default.isFunction(_get(WidgetExclusive.prototype.__proto__ || Object.getPrototypeOf(WidgetExclusive.prototype), 'componentWillReceiveProps', this))) {
					_get(WidgetExclusive.prototype.__proto__ || Object.getPrototypeOf(WidgetExclusive.prototype), 'componentWillReceiveProps', this).call(this, nextProps);
				}

				// Receiving properties means that the component is being re-rendered.
				// Re-rendering is triggered by editorInteraction, so we have to
				// reset the exclusive state and render the UI according to the new selection.
				this.setState({
					itemExclusive: null
				});
			}

			/**
    * Filters the items and returns only those with exclusive state.
    *
    * @instance
    * @memberof WidgetExclusive
    * @method filterExclusive
    * @param {Array} items The widgets to be filtered.
    * @return {Array|Object} The item with executive state.
    */

		}, {
			key: 'filterExclusive',
			value: function filterExclusive(items) {
				var _this2 = this;

				return items.filter(function (item) {
					if (_this2.state.itemExclusive) {
						if (_this2.state.itemExclusive === item.key) {
							return item;
						}
					} else {
						return item;
					}
				});
			}

			/**
    * Merges the provided object with three more properties:
    * - cancelExclusive - function, which can be used by a widget in order to cancel executive state.
    * - renderExclusive - boolean flag which indicates if an widget should be rendered exclusively.
    * - requestExclusive - function, which can be used by a widget in order to obtain exclusive state.
    *
    * @instance
    * @memberof WidgetExclusive
    * @method mergeExclusiveProps
    * @param {Object} obj The properties container which should be merged with the properties, related
    *    to exclusive state.
    * @param {Object} itemKey They key of an React Widget which should be rendered exclusively.
    * @return {Object} The merged object.
    */

		}, {
			key: 'mergeExclusiveProps',
			value: function mergeExclusiveProps(obj, itemKey) {
				return CKEDITOR.tools.merge(obj, {
					cancelExclusive: this.cancelExclusive.bind(this, itemKey),
					renderExclusive: this.state.itemExclusive === itemKey,
					requestExclusive: this.requestExclusive.bind(this, itemKey)
				});
			}

			/**
    * Requests and sets exclusive state of an widget.
    *
    * @instance
    * @memberof WidgetExclusive
    * @method requestExclusive
    * @param {Object} itemExclusive The widget which requests exclusive state.
    */

		}]);

		return WidgetExclusive;
	}(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-focus-manager.js":
/*!*****************************************************!*\
  !*** ./src/components/base/widget-focus-manager.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var DIRECTION_NONE = 0;
var DIRECTION_NEXT = 1;
var DIRECTION_PREV = -1;

var ACTION_NONE = 0;
var ACTION_MOVE_FOCUS = 1;
var ACTION_DISMISS_FOCUS = 2;

/**
 * WidgetFocusManager is a mixin that provides keyboard navigation inside a widget. To do this,
 * it exposes the following props and methods:
 *
 * @class WidgetFocusManager
 */

exports.default = function (WrappedComponent) {
	return function (_WrappedComponent) {
		_inherits(WidgetFocusManager, _WrappedComponent);

		function WidgetFocusManager() {
			var _ref;

			var _temp, _this, _ret;

			_classCallCheck(this, WidgetFocusManager);

			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = WidgetFocusManager.__proto__ || Object.getPrototypeOf(WidgetFocusManager)).call.apply(_ref, [this].concat(args))), _this), _this.focus = function (event) {
				if (!event || _this._isValidTarget(event.target)) {
					if (_this._descendants && _this._descendants.length) {
						var activeDescendantEl = _this._descendants[_this._activeDescendant];
						// When user clicks with the mouse, the activeElement is already set and there
						// is no need to focus it. Focusing of the active descendant (usually some button) is required
						// in case of keyboard navigation, because the focused element might be not the first button,
						// but the div element, which contains the button.
						if (document.activeElement !== activeDescendantEl && !_this.props.focusFirstChild) {
							if (_this._descendants.indexOf(document.activeElement) === -1) {
								activeDescendantEl.focus();
							}
						}

						if (event) {
							event.stopPropagation();
							event.preventDefault();
						}
					}
				}
			}, _this.handleKey = function (event) {
				if (_this._isValidTarget(event.target) && _this._descendants) {
					var action = _this._getFocusAction(event);

					if (action.type) {
						event.stopPropagation();
						event.preventDefault();

						if (action.type === ACTION_MOVE_FOCUS) {
							_this._moveFocus(action.direction);
						}

						if (action.type === ACTION_DISMISS_FOCUS) {
							_this.props.onDismiss(action.direction);
						}
					}
				}
			}, _temp), _possibleConstructorReturn(_this, _ret);
		}

		_createClass(WidgetFocusManager, [{
			key: 'componentDidMount',

			/**
    * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method componentDidMount
    */
			value: function componentDidMount() {
				if (_lang2.default.isFunction(_get(WidgetFocusManager.prototype.__proto__ || Object.getPrototypeOf(WidgetFocusManager.prototype), 'componentDidMount', this))) {
					_get(WidgetFocusManager.prototype.__proto__ || Object.getPrototypeOf(WidgetFocusManager.prototype), 'componentDidMount', this).call(this);
				}

				this._refresh();
			}

			/**
    * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
    * Refreshes the descendants list.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method componentDidUpdate
    */

		}, {
			key: 'componentDidUpdate',
			value: function componentDidUpdate() {
				if (_lang2.default.isFunction(_get(WidgetFocusManager.prototype.__proto__ || Object.getPrototypeOf(WidgetFocusManager.prototype), 'componentDidUpdate', this))) {
					_get(WidgetFocusManager.prototype.__proto__ || Object.getPrototypeOf(WidgetFocusManager.prototype), 'componentDidUpdate', this).call(this);
				}

				this._refresh();
			}

			/**
    * Focuses the current active descendant.
    *
    * Several Widgets can be nested in a component hierarchy by attaching this focus method to
    * the widget DOM node, transferring the DOM focus control to the inner FocusManager.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method focus
    */


			/**
    * Handles the key events on a DOM node to execute the appropriate navigation when needed.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @param {Object} event The Keyboard event that was detected on the widget DOM node.
    * @method handleKey
    */

		}, {
			key: 'moveFocus',


			/**
    * Moves the focus among descendants in the especified direction.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method moveFocus
    * @param {number} direction The direction (1 or -1) of the focus movement among descendants.
    */
			value: function moveFocus(direction) {
				direction = _lang2.default.isNumber(direction) ? direction : 0;

				this._moveFocus(direction);
			}

			/**
    * Returns the action, if any, that a keyboard event in the current focus manager state
    * should produce.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _getFocusAction
    * @param {object} event The Keyboard event.
    * @protected
    * @return {Object} An action object with type and direction properties.
    */

		}, {
			key: '_getFocusAction',
			value: function _getFocusAction(event) {
				var action = {
					type: ACTION_NONE
				};

				if (this.props.keys) {
					var direction = this._getFocusMoveDirection(event);

					if (direction) {
						action.direction = direction;
						action.type = ACTION_MOVE_FOCUS;
					}

					var dismissAction = this._getFocusDismissAction(event, direction);

					if (dismissAction.dismiss) {
						action.direction = dismissAction.direction;
						action.type = ACTION_DISMISS_FOCUS;
					}
				}

				return action;
			}

			/**
    * Returns the dismiss action, if any, the focus manager should execute to yield the focus. This
    * will happen in any of these scenarios if a dismiss callback has been specified:
    * - A dismiss key has been pressed
    * - In a non-circular focus manager, when:
    *     - The active descendant is the first one and a prev key has been pressed.
    *     - The active descendant is the last one and a next key has been pressed.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _getFocusDismissAction
    * @param {Number} focusMoveDirection The focus movement direction (if any).
    * @param {Object} event The Keyboard event.
    * @protected
    * @return {Object} A dismiss action with dismiss and direction properties.
    */

		}, {
			key: '_getFocusDismissAction',
			value: function _getFocusDismissAction(event, focusMoveDirection) {
				var dismissAction = {
					direction: focusMoveDirection,
					dismiss: false
				};

				if (this.props.onDismiss) {
					if (this._isValidKey(event.keyCode, this.props.keys.dismiss)) {
						dismissAction.dismiss = true;
					}
					if (this._isValidKey(event.keyCode, this.props.keys.dismissNext)) {
						dismissAction.dismiss = true;
						dismissAction.direction = DIRECTION_NEXT;
					}
					if (this._isValidKey(event.keyCode, this.props.keys.dismissPrev)) {
						dismissAction.dismiss = true;
						dismissAction.direction = DIRECTION_PREV;
					}

					if (!dismissAction.dismiss && !this.props.circular && focusMoveDirection) {
						dismissAction.dismiss = focusMoveDirection === DIRECTION_PREV && this._activeDescendant === 0 || focusMoveDirection === DIRECTION_NEXT && this._activeDescendant === this._descendants.length - 1;
					}
				}

				return dismissAction;
			}

			/**
    * Returns the direction, if any, in which the focus should be moved. In presence of the
    * shift key modifier, the direction of the movement is inverted.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _getFocusMoveDirection
    * @param {Object} event The Keyboard event.
    * @protected
    * @return {Number} The computed direction of the expected focus movement.
    */

		}, {
			key: '_getFocusMoveDirection',
			value: function _getFocusMoveDirection(event) {
				var direction = DIRECTION_NONE;

				if (this._isValidKey(event.keyCode, this.props.keys.next)) {
					direction = DIRECTION_NEXT;
				}
				if (this._isValidKey(event.keyCode, this.props.keys.prev)) {
					direction = DIRECTION_PREV;
				}

				if (event.shifKey) {
					direction *= -1;
				}

				return direction;
			}

			/**
    * Indicates if a given keyCode is valid for the given set of keys.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _isValidKey
    * @param {Array|Number} keys A key set. Can be a number an array of numbers representing the allowed keyCodes.
    * @param {Number} keyCode An event keyCode.
    * @protected
    * @return {Boolean} A boolean value indicating if the key is valid.
    */

		}, {
			key: '_isValidKey',
			value: function _isValidKey(keyCode, keys) {
				return _lang2.default.isArray(keys) ? keys.indexOf(keyCode) !== -1 : keyCode === keys;
			}

			/**
    * Indicates if a given element is valid for focus management. User input elements such as
    * input, select or textarea are excluded.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _isValidKey
    * @param {DOMNode} element A DOM element.
    * @protected
    * @return {Boolean} A boolean value indicating if the element is valid.
    */

		}, {
			key: '_isValidTarget',
			value: function _isValidTarget(element) {
				var tagName = element.tagName.toLowerCase();

				return tagName !== 'input' && tagName !== 'select' && tagName !== 'textarea';
			}

			/**
    * Moves the focus among descendants in the especified direction.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _moveFocus
    * @param {number} direction The direction (1 or -1) of the focus movement among descendants.
    * @protected
    */

		}, {
			key: '_moveFocus',
			value: function _moveFocus(direction) {
				var numDescendants = this._descendants.length;

				var descendant = this._descendants[this._activeDescendant];

				descendant.setAttribute('tabIndex', -1);

				this._activeDescendant += direction;

				if (this.props.circular) {
					// Calculate proper modulo result since remainder operator doesn't behave in the
					// same way for negative numbers
					this._activeDescendant = (this._activeDescendant % numDescendants + numDescendants) % numDescendants;
				} else {
					this._activeDescendant = Math.max(Math.min(this._activeDescendant, numDescendants - 1), 0);
				}

				descendant = this._descendants[this._activeDescendant];

				descendant.setAttribute('tabIndex', 0);
				descendant.focus();
			}

			/**
    * Refreshes the descendants list by executing the CSS selector again and resets the descendants tabIndex.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _refresh
    * @protected
    */

		}, {
			key: '_refresh',
			value: function _refresh() {
				var _this2 = this;

				var domNode = _reactDom2.default.findDOMNode(this);

				if (domNode) {
					var descendants = domNode.querySelectorAll(this.props.descendants);

					var priorityDescendants = [];

					this._descendants = [];

					Array.prototype.slice.call(descendants).forEach(function (item) {
						var dataTabIndex = item.getAttribute('data-tabindex');

						if (dataTabIndex) {
							priorityDescendants.push(item);
						} else {
							_this2._descendants.push(item);
						}
					});

					priorityDescendants = priorityDescendants.sort(function (a, b) {
						return _lang2.default.toInt(a.getAttribute('data-tabindex')) > _lang2.default.toInt(b.getAttribute('data-tabindex'));
					});

					this._descendants = priorityDescendants.concat(this._descendants);

					this._activeDescendant = 0;

					this._descendants.some(function (item, index) {
						if (item.getAttribute('tabindex') === '0') {
							_this2._activeDescendant = index;
							_this2.focus();

							return true;
						}
					});
				}
			}
		}]);

		return WidgetFocusManager;
	}(WrappedComponent);
};

/***/ }),

/***/ "./src/components/buttons/button-accessibility-image-alt.jsx":
/*!*******************************************************************!*\
  !*** ./src/components/buttons/button-accessibility-image-alt.jsx ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonAccessibilityImageAlt class provides functionality for changing text color in a document.
 *
 * @class ButtonAccessibilityImageAlt
 *
 */
var ButtonAccessibilityImageAlt = function (_React$Component) {
	_inherits(ButtonAccessibilityImageAlt, _React$Component);

	function ButtonAccessibilityImageAlt(props) {
		_classCallCheck(this, ButtonAccessibilityImageAlt);

		var _this = _possibleConstructorReturn(this, (ButtonAccessibilityImageAlt.__proto__ || Object.getPrototypeOf(ButtonAccessibilityImageAlt)).call(this, props));

		_initialiseProps.call(_this);

		var selection = props.context.editor.get('nativeEditor').getSelection();

		var element = selection.getSelectedElement() || selection.getStartElement();

		_this._element = element;

		var imageElement = _this._element.findOne('img');

		var imageAlt = imageElement ? imageElement.getAttribute('alt') : _this._element.getAttribute('alt');

		_this.state = {
			imageAlt: imageAlt
		};
		return _this;
	}

	/**
  * Lifecycle. Renders the UI of the button.
  *
  * @method render
  * @return {Object} The content which should be rendered.
  */


	_createClass(ButtonAccessibilityImageAlt, [{
		key: 'render',
		value: function render() {
			if (this.props.renderExclusive) {
				return _react2.default.createElement(
					'div',
					{ className: 'ae-container-edit-link' },
					_react2.default.createElement(
						'div',
						{ className: 'ae-container-input xxl' },
						_react2.default.createElement('input', {
							'aria-label': 'alt',
							className: 'ae-input',
							onChange: this._handleAltChange,
							onKeyDown: this._handleKeyDown,
							placeholder: 'alt',
							ref: 'refAltInput',
							title: 'alt',
							type: 'text',
							value: this.state.imageAlt
						})
					),
					_react2.default.createElement(
						'button',
						{
							'aria-label': AlloyEditor.Strings.confirm,
							className: 'ae-button',
							onClick: this._updateImageAlt,
							title: AlloyEditor.Strings.confirm },
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'check' })
					)
				);
			} else {
				return _react2.default.createElement(
					'button',
					{
						className: 'ae-button',
						onClick: this._requestExclusive,
						tabIndex: this.props.tabIndex },
					_react2.default.createElement(
						'small',
						{ className: 'ae-icon small' },
						'Alt'
					)
				);
			}
		}

		/**
   * Focuses the user cursor on the widget's input.
   *
   * @protected
   * @method _focusAltInput
   */

	}, {
		key: '_focusAltInput',
		value: function _focusAltInput() {
			var instance = this;

			var focusAltEl = function focusAltEl() {
				_reactDom2.default.findDOMNode(instance.refs.refAltInput).focus();
			};

			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(focusAltEl);
			} else {
				setTimeout(focusAltEl, 0);
			}
		}

		/**
   * Event attached to alt input that fires when its value is changed
   *
   * @protected
   * @method  _handleAltChange
   * @param {MouseEvent} event
   */


		/**
   * Event attached to al tinput that fires when key is down
   * This method check that enter key is pushed to update the componentÂ´s state
   *
   * @protected
   * @method  _handleKeyDown
   * @param {MouseEvent} event
   */


		/**
   * Requests the link button to be rendered in exclusive mode to allow the creation of a link.
   *
   * @protected
   * @method _requestExclusive
   */


		/**
   * Method called by clicking ok button or pushing key enter to update imageAlt state and to update alt property from the image that is selected
   * This method calls cancelExclusive to show the previous toolbar before enter to edit alt property
   *
   * @protected
   * @method  _updateImageAlt
   */

	}]);

	return ButtonAccessibilityImageAlt;
}(_react2.default.Component);

ButtonAccessibilityImageAlt.contextType = _editorContext2.default;
ButtonAccessibilityImageAlt.key = 'imageAlt';

var _initialiseProps = function _initialiseProps() {
	var _this2 = this;

	this._handleAltChange = function (event) {
		_this2.setState({
			imageAlt: event.target.value
		});

		_this2._focusAltInput();
	};

	this._handleKeyDown = function (event) {
		if (event.keyCode === 13) {
			event.preventDefault();

			_this2._updateImageAlt();
		}
	};

	this._requestExclusive = function () {
		_this2.props.requestExclusive(ButtonAccessibilityImageAlt.key);
	};

	this._updateImageAlt = function () {
		var editor = _this2.context.editor.get('nativeEditor');

		var imageAlt = _this2.refs.refAltInput.value;

		_this2.setState({
			imageAlt: imageAlt
		});

		var imageElement = _this2._element.findOne('img');
		var image = imageElement ? imageElement : _this2._element;

		image.setAttribute('alt', imageAlt);

		editor.fire('actionPerformed', _this2);

		// We need to cancelExclusive with the bound parameters in case the button is used
		// inside another in exclusive mode (such is the case of the alt button)
		_this2.props.cancelExclusive();
	};
};

exports.default = _editorContext2.default.toProps(ButtonAccessibilityImageAlt);

/***/ }),

/***/ "./src/components/buttons/button-background-color.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-background-color.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ButtonBackgroundColor = function (_React$Component) {
	_inherits(ButtonBackgroundColor, _React$Component);

	function ButtonBackgroundColor() {
		_classCallCheck(this, ButtonBackgroundColor);

		return _possibleConstructorReturn(this, (ButtonBackgroundColor.__proto__ || Object.getPrototypeOf(ButtonBackgroundColor)).apply(this, arguments));
	}

	_createClass(ButtonBackgroundColor, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var _this2 = this;

			var activeColor = AlloyEditor.Strings.normal;

			var activeColorClass = '';

			var colors = this._getColors();

			var itemStyle = {
				element: 'span',
				attributes: {
					class: ''
				}
			};

			colors.forEach(function (item) {
				itemStyle.attributes.class = item.styleClass;

				if (_this2._checkActive(itemStyle)) {
					activeColor = item.name;

					activeColorClass = item.style.attributes.class;
				}
			});

			var _props = this.props,
			    expanded = _props.expanded,
			    tabIndex = _props.tabIndex,
			    toggleDropdown = _props.toggleDropdown;


			var buttonStylesProps = {
				activeStyle: activeColor,
				onDismiss: toggleDropdown,
				showRemoveStylesItem: false,
				styles: colors
			};

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': expanded,
						className: 'ae-toolbar-element',
						onClick: toggleDropdown,
						role: 'combobox',
						tabIndex: tabIndex },
					_react2.default.createElement(
						'span',
						{ className: activeColorClass },
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'textbox' })
					)
				),
				expanded && _react2.default.createElement(_buttonStylesList2.default, buttonStylesProps)
			);
		}
	}, {
		key: '_applyStyle',
		value: function _applyStyle(className) {
			var _this3 = this;

			var editor = this.context.editor.get('nativeEditor');

			var styleConfig = {
				element: 'span',
				attributes: {
					class: className
				}
			};

			editor.getSelection().lock();

			this._getColors().forEach(function (item) {
				styleConfig.attributes.class = item.styleClass;

				if (_this3._checkActive(styleConfig)) {
					editor.removeStyle(new CKEDITOR.style(styleConfig));
				}
			});

			styleConfig.attributes.class = className;

			var style = new CKEDITOR.style(styleConfig);

			editor.applyStyle(style);

			editor.getSelection().unlock();

			editor.fire('actionPerformed', this);
		}

		/**
   * Checks if the given color definition is applied to the current selection in the editor.
   *
   * @instance
   * @memberof ButtonBackgroundColor
   * @method _checkActive
   * @param {Object} styleConfig color definition as per http://docs.ckeditor.com/#!/api/CKEDITOR.style.
   * @protected
   * @return {Boolean} Returns true if the color is applied to the selection, false otherwise.
   */

	}, {
		key: '_checkActive',
		value: function _checkActive(styleConfig) {
			var nativeEditor = this.context.editor.get('nativeEditor');

			// Styles with wildcard element (*) won't be considered active by CKEditor. Defaulting
			// to a 'span' element works for most of those cases with no defined element.
			styleConfig = CKEDITOR.tools.merge({ element: 'span' }, styleConfig);

			var style = new CKEDITOR.style(styleConfig);

			return style.checkActive(nativeEditor.elementPath(), nativeEditor);
		}

		/**
   * Returns an array of colors. Each color consists of two properties:
   * - name - the style name, for example "default"
   * - style - an object with one property, called `element` which value
   * represents the style which have to be applied to the element.
   *
   * @instance
   * @memberof ButtonBackgroundColor
   * @method _getColor
   * @protected
   * @return {Array<object>} An array of objects containing the colors.
   */

	}, {
		key: '_getColors',
		value: function _getColors() {
			return this.props.styles || [{
				name: AlloyEditor.Strings.normal,
				style: {
					element: 'span',
					attributes: {
						class: 'text-body'
					}
				},
				styleClass: '',
				styleFn: this._applyStyle.bind(this, '')
			}, {
				name: AlloyEditor.Strings.primary,
				style: {
					element: 'span',
					attributes: {
						class: 'text-primary'
					}
				},
				styleClass: 'bg-primary',
				styleFn: this._applyStyle.bind(this, 'bg-primary')
			}, {
				name: AlloyEditor.Strings.disabled,
				style: {
					element: 'span',
					attributes: {
						class: 'text-secondary'
					}
				},
				styleClass: 'bg-secondary',
				styleFn: this._applyStyle.bind(this, 'bg-secondary')
			}, {
				name: AlloyEditor.Strings.success,
				style: {
					element: 'span',
					attributes: {
						class: 'text-success'
					}
				},
				styleClass: 'bg-success',
				styleFn: this._applyStyle.bind(this, 'bg-success')
			}, {
				name: AlloyEditor.Strings.danger,
				style: {
					element: 'span',
					attributes: {
						class: 'text-danger'
					}
				},
				styleClass: 'bg-danger',
				styleFn: this._applyStyle.bind(this, 'bg-danger')
			}, {
				name: AlloyEditor.Strings.warning,
				style: {
					element: 'span',
					attributes: {
						class: 'text-warning'
					}
				},
				styleClass: 'bg-warning',
				styleFn: this._applyStyle.bind(this, 'bg-warning')
			}, {
				name: AlloyEditor.Strings.info,
				style: {
					element: 'span',
					attributes: {
						class: 'text-info'
					}
				},
				styleClass: 'bg-info',
				styleFn: this._applyStyle.bind(this, 'bg-info')
			}];
		}
	}]);

	return ButtonBackgroundColor;
}(_react2.default.Component);

ButtonBackgroundColor.contextType = _editorContext2.default;
ButtonBackgroundColor.key = 'backgroundColor';
ButtonBackgroundColor.propTypes = {
	/**
  * Indicates whether the styles list is expanded or not.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {Boolean} expanded
  */
	expanded: _propTypes2.default.bool,

	/**
  * The label that should be used for accessibility purposes.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {String} label
  */
	label: _propTypes2.default.string,

	/**
  * Indicates whether the remove styles item should appear in the styles list.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {Boolean} showRemoveStylesItem
  */
	showRemoveStylesItem: _propTypes2.default.bool,

	/**
  * List of the styles the button is able to handle.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {Array} styles
  */
	styles: _propTypes2.default.arrayOf(_propTypes2.default.object),

	/**
  * The tabIndex of the button in its toolbar current state. A value other than -1
  * means that the button has focus and is the active element.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {Number} tabIndex
  */
	tabIndex: _propTypes2.default.number,

	/**
  * Callback provided by the button host to notify when the styles list has been expanded.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {Function} toggleDropdown
  */
	toggleDropdown: _propTypes2.default.func
};
exports.default = ButtonBackgroundColor;

/***/ }),

/***/ "./src/components/buttons/button-bold.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-bold.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonBold class provides functionality for styling an selection with strong (bold) style.
 *
 * @class ButtonBold
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonBold = function (_React$Component) {
	_inherits(ButtonBold, _React$Component);

	function ButtonBold() {
		_classCallCheck(this, ButtonBold);

		return _possibleConstructorReturn(this, (ButtonBold.__proto__ || Object.getPrototypeOf(ButtonBold)).apply(this, arguments));
	}

	_createClass(ButtonBold, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonBold
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonBold
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button  ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.bold,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-bold',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.bold },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'bold' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default bold
   * @memberof ButtonBold
   * @property {String} key
   * @static
   */

	}]);

	return ButtonBold;
}(_react2.default.Component);

ButtonBold.defaultProps = {
	command: 'bold',
	keystroke: {
		fn: 'execCommand',
		keys: CKEDITOR.CTRL + 66 /* B*/
		, name: 'bold'
	},
	style: 'coreStyles_bold'
};
ButtonBold.key = 'bold';
exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonBold))));

/***/ }),

/***/ "./src/components/buttons/button-camera-image.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-camera-image.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonCameraImage class takes photo from camera and inserts it to the content.
 *
 * @class ButtonCameraImage
 */
var ButtonCameraImage = function (_React$Component) {
	_inherits(ButtonCameraImage, _React$Component);

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonCameraImage
  */
	function ButtonCameraImage(props) {
		_classCallCheck(this, ButtonCameraImage);

		var _this = _possibleConstructorReturn(this, (ButtonCameraImage.__proto__ || Object.getPrototypeOf(ButtonCameraImage)).call(this, props));

		_this.takePhoto = function () {
			var videoEl = _this._videoContainerRef.current;
			var canvasEl = _this._canvasContainerRef.current;

			var context = canvasEl.getContext('2d');

			var height = _this._videoHeight;
			var width = _this.props.videoWidth;

			if (width && height) {
				canvasEl.width = width;
				canvasEl.height = height;

				context.drawImage(videoEl, 0, 0, width, height);

				var imgURL = canvasEl.toDataURL('image/png');

				var el = CKEDITOR.dom.element.createFromHtml('<img src="' + imgURL + '">');

				var editor = _this.context.editor.get('nativeEditor');

				editor.insertElement(el);

				_this.props.cancelExclusive();

				editor.fire('actionPerformed', _this);

				editor.fire('imageCameraAdd', el);
			}
		};

		_this._handleStreamError = function (error) {
			window.alert('An error occurred! ' + error);
		};

		_this._handleStreamSuccess = function (stream) {
			var videoEl = _this._videoContainerRef.current;
			var canvasEl = _this._canvasContainerRef.current;

			videoEl.addEventListener('canplay', function () {
				var height = videoEl.videoHeight / (videoEl.videoWidth / _this.props.videoWidth);

				if (isNaN(height)) {
					height = _this.props.videoWidth / (4 / 3);
				}

				videoEl.setAttribute('width', _this.props.videoWidth);
				videoEl.setAttribute('height', height);
				canvasEl.setAttribute('width', _this.props.videoWidth);
				canvasEl.setAttribute('height', height);

				_this._videoHeight = height;
			}, false);

			_this._stream = stream;

			if (navigator.mozGetUserMedia) {
				videoEl.mozSrcObject = stream;
			} else {
				videoEl.srcObject = stream;
			}

			videoEl.play();

			_this._buttonTakePhotoRef.current.disabled = false;
		};

		_this._buttonTakePhotoRef = _react2.default.createRef();
		_this._canvasContainerRef = _react2.default.createRef();
		_this._videoContainerRef = _react2.default.createRef();
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * Focuses the take photo button.
  *
  * @instance
  * @memberof ButtonCameraImage
  * @method componentDidMount
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default cameraImage
  * @memberof ButtonCameraImage
  * @property {String} key
  * @static
  */


	_createClass(ButtonCameraImage, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this._buttonTakePhotoRef.current.focus();
		}

		/**
   * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
   *
   * @instance
   * @memberof ButtonCameraImage
   * @method componentWillUnmount
   */

	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			if (this._stream) {
				if (this._stream.stop) {
					this._stream.stop();
				} else if (this._stream.getVideoTracks) {
					this._stream.getVideoTracks().forEach(function (track) {
						track.stop();
					});
				}
				this._stream = null;
			}
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonCameraImage
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',


		/**
   * Fired when an image is being taken from the camera and added as an element to the editor.
   *
   * @event ButtonCameraImage#imageCameraAdd
   * @memberof ButtonCameraImage
   * @param {CKEDITOR.dom.element} el The created img element in editor.
   */
		value: function render() {
			var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

			getUserMedia.call(navigator, {
				video: true,
				audio: false
			}, this._handleStreamSuccess, this._handleStreamError);

			return _react2.default.createElement(
				'div',
				{ className: 'ae-camera' },
				_react2.default.createElement(
					'video',
					{ ref: this._videoContainerRef },
					'Video stream not available.'
				),
				_react2.default.createElement(
					'button',
					{
						className: 'ae-camera-shoot',
						onClick: this.takePhoto,
						ref: this._buttonTakePhotoRef },
					'Take photo'
				),
				_react2.default.createElement('canvas', {
					className: 'ae-camera-canvas',
					ref: this._canvasContainerRef
				})
			);
		}

		/**
   * Takes photo from the video stream and inserts in into editor's content.
   *
   * @fires ButtonCameraImage#imageCameraAdd
   * @instance
   * @memberof ButtonCameraImage
   * @method takePhoto
   */


		/**
   * Displays error message in case of video stream capturing failure.
   *
   * @instance
   * @memberof ButtonCameraImage
   * @method _handleStreamError
   * @param {Event} error The fired event in case of error.
   * @protected
   */


		/**
   * Starts streaming video in the video element and sets width/height to the video
   * and canvas elements.
   *
   * @instance
   * @memberof ButtonCameraImage
   * @method _handleStreamSuccess
   * @param {Object} stream The video stream
   * @protected
   */

	}]);

	return ButtonCameraImage;
}(_react2.default.Component);

ButtonCameraImage.contextType = _editorContext2.default;
ButtonCameraImage.defaultProps = {
	videoWidth: 320
};
ButtonCameraImage.key = 'cameraImage';
exports.default = ButtonCameraImage;

/***/ }),

/***/ "./src/components/buttons/button-camera.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-camera.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCameraImage = __webpack_require__(/*! ./button-camera-image.jsx */ "./src/components/buttons/button-camera-image.jsx");

var _buttonCameraImage2 = _interopRequireDefault(_buttonCameraImage);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonCamera class renders in two different ways:
 *
 * - Normal: Just a button that allows to switch to the edition mode.
 * - Exclusive: Renders ButtonCameraImage in order to take photo from the camera.
 *
 * @class ButtonCamera
 */
var ButtonCamera = function (_React$Component) {
	_inherits(ButtonCamera, _React$Component);

	function ButtonCamera() {
		_classCallCheck(this, ButtonCamera);

		return _possibleConstructorReturn(this, (ButtonCamera.__proto__ || Object.getPrototypeOf(ButtonCamera)).apply(this, arguments));
	}

	_createClass(ButtonCamera, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonCamera
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.renderExclusive) {
				return _react2.default.createElement(_buttonCameraImage2.default, this.props);
			} else {
				var disabled = !(navigator.getUserMedia || navigator.webkitGetUserMedia && location.protocol === 'https' || navigator.mozGetUserMedia || navigator.msGetUserMedia);

				var label = disabled ? AlloyEditor.Strings.cameraDisabled : AlloyEditor.Strings.camera;

				return _react2.default.createElement(
					'button',
					{
						'aria-label': label,
						className: 'ae-button',
						'data-type': 'button-image-camera',
						disabled: disabled,
						onClick: this.props.requestExclusive.bind(ButtonCamera.key),
						tabIndex: this.props.tabIndex,
						title: label },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'camera' })
				);
			}
		}
		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default camera
   * @memberof ButtonCamera
   * @property {String} key
   * @static
   */

	}]);

	return ButtonCamera;
}(_react2.default.Component);

ButtonCamera.key = 'camera';
exports.default = ButtonCamera;

/***/ }),

/***/ "./src/components/buttons/button-code.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-code.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonCode class provides wraps a selection in `pre` element.
 *
 * @class ButtonCode
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonCode = function (_React$Component) {
	_inherits(ButtonCode, _React$Component);

	function ButtonCode() {
		_classCallCheck(this, ButtonCode);

		return _possibleConstructorReturn(this, (ButtonCode.__proto__ || Object.getPrototypeOf(ButtonCode)).apply(this, arguments));
	}

	_createClass(ButtonCode, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonCode
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonCode
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.code,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-code',
					onClick: this.applyStyle,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.code },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'code' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default code
   * @memberof ButtonCode
   * @property {String} key
   * @static
   */

	}]);

	return ButtonCode;
}(_react2.default.Component);

ButtonCode.defaultProps = {
	style: {
		element: 'pre'
	}
};
ButtonCode.key = 'code';
exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonCode)));

/***/ }),

/***/ "./src/components/buttons/button-color.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-color.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonColor class provides functionality for changing text color in a document.
 *
 *
 * @class ButtonColor
 */
var ButtonColor = function (_React$Component) {
	_inherits(ButtonColor, _React$Component);

	function ButtonColor() {
		_classCallCheck(this, ButtonColor);

		return _possibleConstructorReturn(this, (ButtonColor.__proto__ || Object.getPrototypeOf(ButtonColor)).apply(this, arguments));
	}

	_createClass(ButtonColor, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var _this2 = this;

			var activeColor = AlloyEditor.Strings.normal;

			var colors = this._getColors();

			colors.some(function (item) {
				if (_this2._checkActive(item.style)) {
					activeColor = item.name;
				}
			});

			var _props = this.props,
			    expanded = _props.expanded,
			    tabIndex = _props.tabIndex,
			    toggleDropdown = _props.toggleDropdown;


			var buttonStylesProps = {
				activeStyle: activeColor,
				onDismiss: toggleDropdown,
				showRemoveStylesItem: false,
				styles: colors
			};

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': expanded,
						className: 'ae-toolbar-element',
						onClick: toggleDropdown,
						role: 'combobox',
						tabIndex: tabIndex },
					_react2.default.createElement(
						'span',
						null,
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'color-picker' })
					)
				),
				expanded && _react2.default.createElement(_buttonStylesList2.default, buttonStylesProps)
			);
		}
	}, {
		key: '_applyStyle',
		value: function _applyStyle(className) {
			var _this3 = this;

			var editor = this.context.editor.get('nativeEditor');

			var styleConfig = {
				element: 'span',
				attributes: {
					class: className
				}
			};

			var style = new CKEDITOR.style(styleConfig);

			editor.getSelection().lock();

			this._getColors().forEach(function (item) {
				if (_this3._checkActive(item.style)) {
					editor.removeStyle(new CKEDITOR.style(item.style));
				}
			});

			editor.applyStyle(style);

			editor.getSelection().unlock();

			editor.fire('actionPerformed', this);
		}

		/**
   * Checks if the given color definition is applied to the current selection in the editor.
   *
   * @instance
   * @memberof ButtonColor
   * @method _checkActive
   * @param {Object} styleConfig Color definition as per http://docs.ckeditor.com/#!/api/CKEDITOR.style.
   * @protected
   * @return {Boolean} Returns true if the color is applied to the selection, false otherwise.
   */

	}, {
		key: '_checkActive',
		value: function _checkActive(styleConfig) {
			var nativeEditor = this.context.editor.get('nativeEditor');

			// Styles with wildcard element (*) won't be considered active by CKEditor. Defaulting
			// to a 'span' element works for most of those cases with no defined element.
			styleConfig = CKEDITOR.tools.merge({ element: 'span' }, styleConfig);

			var style = new CKEDITOR.style(styleConfig);

			return style.checkActive(nativeEditor.elementPath(), nativeEditor);
		}

		/**
   * Returns an array of colors. Each color consists of two properties:
   * - name - The style name, for example "default".
   * - style - An object with one property, called `element` which value
   *          represents the style which have to be applied to the element.
   * - styleFn - The function that is invoked to apply the style to the element.
   *
   * @instance
   * @memberof ButtonColor
   * @method _getColor
   * @protected
   * @return {Array<object>} An array of objects containing the colors.
   */

	}, {
		key: '_getColors',
		value: function _getColors() {
			return this.props.styles || [{
				name: AlloyEditor.Strings.primary,
				style: {
					element: 'span',
					attributes: {
						class: 'text-primary'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-primary')
			}, {
				name: AlloyEditor.Strings.success,
				style: {
					element: 'span',
					attributes: {
						class: 'text-success'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-success')
			}, {
				name: AlloyEditor.Strings.danger,
				style: {
					element: 'span',
					attributes: {
						class: 'text-danger'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-danger')
			}, {
				name: AlloyEditor.Strings.warning,
				style: {
					element: 'span',
					attributes: {
						class: 'text-warning'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-warning')
			}, {
				name: AlloyEditor.Strings.info,
				style: {
					element: 'span',
					attributes: {
						class: 'text-info'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-info')
			}, {
				name: AlloyEditor.Strings.dark,
				style: {
					element: 'span',
					attributes: {
						class: 'text-dark'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-dark')
			}, {
				name: AlloyEditor.Strings.darkGray,
				style: {
					element: 'span',
					attributes: {
						class: 'text-gray-dark'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-gray-dark')
			}, {
				name: AlloyEditor.Strings.secondary,
				style: {
					element: 'span',
					attributes: {
						class: 'text-secondary'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-secondary')
			}, {
				name: AlloyEditor.Strings.light,
				style: {
					element: 'span',
					attributes: {
						class: 'text-dark'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-light')
			}, {
				name: AlloyEditor.Strings.lighter,
				style: {
					element: 'span',
					attributes: {
						class: 'text-dark'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-lighter')
			}, {
				name: AlloyEditor.Strings.white,
				style: {
					element: 'span',
					attributes: {
						class: 'text-dark'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-white')
			}];
		}
	}]);

	return ButtonColor;
}(_react2.default.Component);

ButtonColor.contextType = _editorContext2.default;
ButtonColor.key = 'color';
ButtonColor.propTypes = {
	/**
  * Indicates whether the styles list is expanded or not.
  *
  * @instance
  * @memberof ButtonColor
  * @property {Boolean} expanded
  */
	expanded: _propTypes2.default.bool,

	/**
  * The label that should be used for accessibility purposes.
  *
  * @instance
  * @memberof ButtonColor
  * @property {String} label
  */
	label: _propTypes2.default.string,

	/**
  * Indicates whether the remove styles item should appear in the styles list.
  *
  * @instance
  * @memberof ButtonColor
  * @property {Boolean} showRemoveStylesItem
  */
	showRemoveStylesItem: _propTypes2.default.bool,

	/**
  * List of the styles the button is able to handle.
  *
  * @instance
  * @memberof ButtonColor
  * @property {Array} styles
  */
	styles: _propTypes2.default.arrayOf(_propTypes2.default.object),

	/**
  * The tabIndex of the button in its toolbar current state. A value other than -1
  * means that the button has focus and is the active element.
  *
  * @instance
  * @memberof ButtonColor
  * @property {Number} tabIndex
  */
	tabIndex: _propTypes2.default.number,

	/**
  * Callback provided by the button host to notify when the styles list has been expanded.
  *
  * @instance
  * @memberof ButtonColor
  * @property {Function} toggleDropdown
  */
	toggleDropdown: _propTypes2.default.func
};
exports.default = ButtonColor;

/***/ }),

/***/ "./src/components/buttons/button-command-list-item.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-command-list-item.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonCommandListItem class is a UI class that renders a ButtonCommand that can be used inside
 * a list as an item, with a string representation of its behaviour.
 *
 * @class ButtonCommandListItem
 * @uses ButtonCommand
 */
var ButtonCommandListItem = function (_React$Component) {
	_inherits(ButtonCommandListItem, _React$Component);

	function ButtonCommandListItem() {
		_classCallCheck(this, ButtonCommandListItem);

		return _possibleConstructorReturn(this, (ButtonCommandListItem.__proto__ || Object.getPrototypeOf(ButtonCommandListItem)).apply(this, arguments));
	}

	_createClass(ButtonCommandListItem, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonCommandListItem
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': this.props.description,
					className: this._getClassName(),
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex },
				this.props.description
			);
		}

		/**
   * Returns the class name of Widget.
   *
   * @instance
   * @memberof ButtonCommandListItem
   * @method _getClassName
   * @protected
   * @return {String} The class name of the Widget.
   */

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default buttonCommandListItem
   * @memberof ButtonCommandListItem
   * @property {String} key
   * @static
   */

	}, {
		key: '_getClassName',
		value: function _getClassName() {
			var className = 'ae-container ae-toolbar-element';

			return className;
		}
	}]);

	return ButtonCommandListItem;
}(_react2.default.Component);

ButtonCommandListItem.key = 'buttonCommandListItem';
exports.default = (0, _buttonCommand2.default)(ButtonCommandListItem);

/***/ }),

/***/ "./src/components/buttons/button-commands-list.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-commands-list.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _buttonCommandListItem = __webpack_require__(/*! ./button-command-list-item.jsx */ "./src/components/buttons/button-command-list-item.jsx");

var _buttonCommandListItem2 = _interopRequireDefault(_buttonCommandListItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonCommandsList class provides functionality for showing a list of commands that can be
 * executed to the current selection..
 *
 * @class ButtonCommandsList
 * @uses WidgetFocusManager
 */
var ButtonCommandsList = function (_React$Component) {
	_inherits(ButtonCommandsList, _React$Component);

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonCommandsList
  * @method getDefaultProps
  * @return {Object} The default properties.
  */
	function ButtonCommandsList(props) {
		_classCallCheck(this, ButtonCommandsList);

		var _this = _possibleConstructorReturn(this, (ButtonCommandsList.__proto__ || Object.getPrototypeOf(ButtonCommandsList)).call(this, props));

		_this._ref = _react2.default.createRef();
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * Focuses on the list node to allow keyboard interaction.
  *
  * @instance
  * @memberof ButtonCommandsList
  * @method componentDidMount
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default buttonCommandsList
  * @memberof ButtonCommandsList
  * @property {String} key
  * @static
  */


	_createClass(ButtonCommandsList, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this._ref.current.focus();
		}

		/**
   * Lifecycle. Renders the UI of the list.
   *
   * @instance
   * @memberof ButtonCommandsList
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{
					className: 'ae-arrow-box ae-arrow-box-top-left ae-dropdown',
					onFocus: this.focus,
					onKeyDown: this.handleKey,
					ref: this._ref,
					tabIndex: '0' },
				_react2.default.createElement(
					'ul',
					{
						className: 'ae-listbox',
						id: this.props.listId,
						role: 'listbox' },
					this._renderActions(this.props.commands)
				)
			);
		}

		/**
   * Renders instances of ButtonCommandListItem with the description of the row action that will be executed.
   *
   * @instance
   * @memberof ButtonCommandsList
   * @method _renderActions
   * @protected
   * @return {Array} Rendered instances of ButtonCommandListItem class
   */

	}, {
		key: '_renderActions',
		value: function _renderActions(commands) {
			var items = void 0;

			if (commands && commands.length) {
				items = commands.map(function (item) {
					return _react2.default.createElement(
						'li',
						{ key: item.command, role: 'option' },
						_react2.default.createElement(_buttonCommandListItem2.default, {
							command: item.command,
							description: typeof item.label === 'string' ? item.label : item.label(),
							icon: item.icon
						})
					);
				});
			}

			return items;
		}
	}]);

	return ButtonCommandsList;
}(_react2.default.Component);

ButtonCommandsList.defaultProps = {
	circular: false,
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	}
};
ButtonCommandsList.key = 'buttonCommandsList';
exports.default = (0, _widgetFocusManager2.default)(ButtonCommandsList);

/***/ }),

/***/ "./src/components/buttons/button-dropdown.jsx":
/*!****************************************************!*\
  !*** ./src/components/buttons/button-dropdown.jsx ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonDropdown class provides markup and keyboard navigation behaviour to a dropdown
 * opened from a button.
 *
 * @class ButtonDropdown
 */
var ButtonDropdown = function (_React$Component) {
	_inherits(ButtonDropdown, _React$Component);

	function ButtonDropdown() {
		_classCallCheck(this, ButtonDropdown);

		return _possibleConstructorReturn(this, (ButtonDropdown.__proto__ || Object.getPrototypeOf(ButtonDropdown)).apply(this, arguments));
	}

	_createClass(ButtonDropdown, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonDropdown
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonDropdown
   * @method getDefaultProps
   */
		value: function render() {
			return _react2.default.createElement(
				'div',
				{
					className: 'ae-arrow-box ae-arrow-box-top-left ae-dropdown',
					onFocus: this.focus,
					onKeyDown: this.handleKey,
					tabIndex: '0' },
				_react2.default.createElement(
					'ul',
					{ className: 'ae-listbox', role: 'listbox' },
					this.props.children
				)
			);
		}

		/**
   * The name which will be used as an alias of the dropdown in the configuration.
   *
   * @default dropdown
   * @memberof ButtonDropdown
   * @property {String} key
   * @static
   */

	}]);

	return ButtonDropdown;
}(_react2.default.Component);

ButtonDropdown.defaultProps = {
	circular: false,
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	}
};
ButtonDropdown.key = 'dropdown';
exports.default = (0, _widgetFocusManager2.default)(ButtonDropdown);

/***/ }),

/***/ "./src/components/buttons/button-embed-edit.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-embed-edit.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var KEY_ENTER = 13;
var KEY_ESC = 27;

/**
 * The ButtonEmbedEdit class provides functionality for creating and editing an embed link in a document.
 * Provides UI for creating and editing an embed link.
 *
 * @class ButtonEmbedEdit
 */

var ButtonEmbedEdit = function (_React$Component) {
	_inherits(ButtonEmbedEdit, _React$Component);

	function ButtonEmbedEdit(props) {
		_classCallCheck(this, ButtonEmbedEdit);

		var _this = _possibleConstructorReturn(this, (ButtonEmbedEdit.__proto__ || Object.getPrototypeOf(ButtonEmbedEdit)).call(this, props));

		_this._clearLink = function () {
			_this.setState({
				linkHref: ''
			});
		};

		_this._embedLink = function () {
			var nativeEditor = _this.context.editor.get('nativeEditor');

			nativeEditor.execCommand('embedUrl', {
				url: _this.state.linkHref
			});

			// We need to cancelExclusive with the bound parameters in case the button is used
			// inside another in exclusive mode (such is the case of the link button)
			_this.props.cancelExclusive();
		};

		_this._focusLinkInput = function () {
			_this.linkInput.current.focus();
		};

		_this._handleKeyDown = function (event) {
			if (event.keyCode === KEY_ENTER || event.keyCode === KEY_ESC) {
				event.preventDefault();
			}

			if (event.keyCode === KEY_ENTER) {
				_this._embedLink();
			} else if (event.keyCode === KEY_ESC) {
				var editor = _this.context.editor.get('nativeEditor');

				// We need to cancelExclusive with the bound parameters in case the button is used
				// inside another in exclusive mode (such is the case of the link button)
				_this.props.cancelExclusive();

				editor.fire('actionPerformed', _this);
			}
		};

		_this._handleLinkHrefChange = function (event) {
			_this.setState({
				linkHref: event.target.value
			});
		};

		_this._removeEmbed = function () {
			var editor = _this.context.editor.get('nativeEditor');

			var embedWrapper = _this.state.element.getAscendant(function (element) {
				return element.hasClass('cke_widget_wrapper');
			});

			embedWrapper.remove();

			editor.fire('actionPerformed', _this);
		};

		_this.linkInput = _react2.default.createRef();
		_this.state = _this.getInitialState();
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * Focuses on the link input to immediately allow editing. This should only happen if the component
  * is rendered in exclusive mode to prevent aggressive focus stealing.
  *
  * @instance
  * @memberof ButtonEmbedEdit
  * @method componentDidMount
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default embedEdit
  * @memberof ButtonEmbedEdit
  * @property {String} key
  * @static
  */


	_createClass(ButtonEmbedEdit, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (this.props.renderExclusive || this.props.manualSelection) {
				// We need to wait for the next rendering cycle before focusing to avoid undesired
				// scrolls on the page
				if (window.requestAnimationFrame) {
					window.requestAnimationFrame(this._focusLinkInput);
				} else {
					setTimeout(this._focusLinkInput, 0);
				}
			}
		}

		/**
   * Lifecycle. Invoked when a component is receiving new props.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method componentWillReceiveProps
   */

	}, {
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps() {
			this.setState(this.getInitialState());
		}

		/**
   * Lifecycle. Invoked once before the component is mounted.
   * The return value will be used as the initial value of this.state.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method getInitialState
   */

	}, {
		key: 'getInitialState',
		value: function getInitialState() {
			// Can't access context from constructor, so get editor from props.
			var editor = this.props.context.editor.get('nativeEditor');
			var embed = void 0;

			var selection = editor.getSelection();

			if (selection) {
				var selectedElement = selection.getSelectedElement();

				if (selectedElement) {
					embed = selectedElement.findOne('[data-widget="ae_embed"]');
				}
			}

			var href = embed ? embed.getAttribute('data-ae-embed-url') : '';

			return {
				element: embed,
				initialLink: {
					href: href
				},
				linkHref: href
			};
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var clearLinkStyle = {
				opacity: this.state.linkHref ? 1 : 0
			};

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-edit-link' },
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.deleteEmbed,
						className: 'ae-button',
						'data-type': 'button-embed-remove',
						disabled: !this.state.element,
						onClick: this._removeEmbed,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.deleteEmbed },
					_react2.default.createElement(_buttonIcon2.default, { className: 'ae-icon-svg-trash', symbol: 'trash' })
				),
				_react2.default.createElement(
					'div',
					{ className: 'ae-container-input xxl' },
					_react2.default.createElement('input', {
						className: 'ae-input',
						onChange: this._handleLinkHrefChange,
						onKeyDown: this._handleKeyDown,
						placeholder: AlloyEditor.Strings.editLink,
						ref: this.linkInput,
						type: 'text',
						value: this.state.linkHref
					}),
					_react2.default.createElement(
						'button',
						{
							'aria-label': AlloyEditor.Strings.clearInput,
							className: 'ae-button ae-button-clear',
							onClick: this._clearLink,
							style: clearLinkStyle,
							title: AlloyEditor.Strings.clear },
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'times-clear' })
					)
				),
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.confirm,
						className: 'ae-button',
						disabled: !this._isValidState(),
						onClick: this._embedLink,
						title: AlloyEditor.Strings.confirm },
					_react2.default.createElement(_buttonIcon2.default, { className: 'ae-icon-svg-check', symbol: 'check' })
				)
			);
		}

		/**
   * Clears the link input. This only changes the component internal state, but does not
   * affect the link element of the editor. Only the _removeLink and _updateLink methods
   * are translated to the editor element.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _clearLink
   * @protected
   */


		/**
   * Triggers the embedUrl command to transform the link into an embed media object
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _embedLink
   * @protected
   */


		/**
   * Focuses the user cursor on the widget's input.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _focusLinkInput
   * @protected
   */


		/**
   * Monitors key interaction inside the input element to respond to the keys:
   * - Enter: Creates/updates the link.
   * - Escape: Discards the changes.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _handleKeyDown
   * @param {SyntheticEvent} event The keyboard event.
   * @protected
   */


		/**
   * Updates the component state when the link input changes on user interaction.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _handleLinkHrefChange
   * @param {SyntheticEvent} event The change event.
   * @protected
   */

	}, {
		key: '_isValidState',


		/**
   * Verifies that the current link state is valid so the user can save the link. A valid state
   * means that we have a non-empty href that's different from the original one.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _isValidState
   * @protected
   * @return {Boolean} True if the state is valid, false otherwise
   */
		value: function _isValidState() {
			var validState = this.state.linkHref && this.state.linkHref !== this.state.initialLink.href;

			return validState;
		}

		/**
   * Removes the embed in the editor element.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _removeEmbed
   * @protected
   */

	}]);

	return ButtonEmbedEdit;
}(_react2.default.Component);

ButtonEmbedEdit.contextType = _editorContext2.default;
ButtonEmbedEdit.key = 'embedEdit';
exports.default = _editorContext2.default.toProps(ButtonEmbedEdit);

/***/ }),

/***/ "./src/components/buttons/button-embed-video-edit.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-embed-video-edit.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var KEY_ENTER = 13;
var KEY_ESC = 27;

/**
 * The ButtonEmbedVideoEdit class provides functionality for changing text color in a document.
 *
 * @uses ButtonIcon
 *
 * @class ButtonEmbedVideoEdit
 */

var ButtonEmbedVideoEdit = function (_React$Component) {
	_inherits(ButtonEmbedVideoEdit, _React$Component);

	function ButtonEmbedVideoEdit(props) {
		_classCallCheck(this, ButtonEmbedVideoEdit);

		var _this = _possibleConstructorReturn(this, (ButtonEmbedVideoEdit.__proto__ || Object.getPrototypeOf(ButtonEmbedVideoEdit)).call(this, props));

		_this._embedVideoURL = function () {
			var nativeEditor = _this.context.editor.get('nativeEditor');

			nativeEditor.execCommand('embedUrl', {
				type: 'video',
				url: _this.state.videoURL
			});

			// We need to cancelExclusive with the bound parameters in case the button is used
			// inside another in exclusive mode (such is the case of the link button)
			_this.props.cancelExclusive();
		};

		_this._focusVideoUrlInput = function () {
			_reactDom2.default.findDOMNode(_this.refs.linkInput).focus();
		};

		_this._handleKeyDown = function (event) {
			if (event.keyCode === KEY_ENTER || event.keyCode === KEY_ESC) {
				event.preventDefault();
			}

			if (event.keyCode === KEY_ENTER) {
				_this._embedVideoURL();
			} else if (event.keyCode === KEY_ESC) {
				_this.props.cancelExclusive();
			}
		};

		_this._handleVideoURLChange = function (event) {
			_this.setState({
				videoURL: event.target.value
			});
		};

		_this.state = _this.getInitialState();
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * Focuses on the link input to immediately allow editing. This should only happen if the component
  * is rendered in exclusive mode to prevent aggressive focus stealing.
  *
  * @instance
  * @memberof ButtonEmbedVideoEdit
  * @method componentDidMount
  */


	_createClass(ButtonEmbedVideoEdit, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (this.props.renderExclusive || this.props.manualSelection) {
				// We need to wait for the next rendering cycle before focusing to avoid undesired
				// scrolls on the page
				if (window.requestAnimationFrame) {
					window.requestAnimationFrame(this._focusVideoUrlInput);
				} else {
					setTimeout(this._focusVideoUrlInput, 0);
				}
			}
		}

		/**
   * Lifecycle. Invoked when a component is receiving new props.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method componentWillReceiveProps
   */

	}, {
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps() {
			var newState = this.getInitialState();

			this.setState({
				all: undefined,
				keys: undefined,
				new: newState,
				old: undefined
			});
		}

		/**
   * Lifecycle. Invoked once before the component is mounted.
   * The return value will be used as the initial value of this.state.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method getInitialState
   */

	}, {
		key: 'getInitialState',
		value: function getInitialState() {
			// Can't access context from constructor, so get editor from props.
			var editor = this.props.context.editor.get('nativeEditor');
			var element = void 0;

			var selection = editor.getSelection();

			if (selection) {
				var selectedElement = selection.getSelectedElement();

				if (selectedElement) {
					element = selectedElement.findOne('[data-widget="videoembed"]');
				}
			}

			var videoURL = element ? element.getAttribute('data-embed-video-url') : '';

			return {
				element: element,
				initialEmbed: {
					videoURL: videoURL
				},
				videoURL: videoURL
			};
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var inputPlaceholder = AlloyEditor.Strings.pasteVideoLink;

			var clearVideoURLStyle = {
				opacity: this.state.videoURL ? 1 : 0
			};

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-embed-video-edit' },
				_react2.default.createElement(
					'div',
					{ className: 'ae-container-input xxl' },
					_react2.default.createElement('input', {
						className: 'ae-input',
						onChange: this._handleVideoURLChange,
						onKeyDown: this._handleKeyDown,
						placeholder: inputPlaceholder,
						ref: 'linkInput',
						type: 'text',
						value: this.state.videoURL
					}),
					_react2.default.createElement('button', {
						'aria-label': AlloyEditor.Strings.clearInput,
						className: 'ae-button ae-icon-remove',
						onClick: this._clearLink,
						style: clearVideoURLStyle,
						title: AlloyEditor.Strings.clear
					})
				),
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.confirm,
						className: 'ae-button',
						disabled: !this._isValidState(),
						onClick: this._embedVideoURL,
						title: AlloyEditor.Strings.confirm },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'check' })
				)
			);
		}

		/**
   * Clears the link input. This only changes the component internal state, but does not
   * affect the link element of the editor. Only the _removeLink and _updateLink methods
   * are translated to the editor element.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method _clearLink
   * @protected
   */

	}, {
		key: '_clearLink',
		value: function _clearLink() {
			this.setState({
				videoURL: ''
			});
		}

		/**
   * Triggers the embedVideoUrl command to transform the link into an embed media object
   *
   * @instance
   * @memberof EmbedVideoEdit
   * @method _embedVideoURL
   * @protected
   */


		/**
   * Focuses the user cursor on the widget's input.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method _focusVideoUrlInput
   * @protected
   */


		/**
   * Monitors key interaction inside the input element to respond to the keys:
   * - Enter: Creates/updates the link.
   * - Escape: Discards the changes.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method _handleKeyDown
   * @param {SyntheticEvent} event The keyboard event.
   * @protected
   */


		/**
   * Updates the component state when the link input changes on user interaction.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method _handleVideoURLChange
   * @param {SyntheticEvent} event The change event.
   * @protected
   */

	}, {
		key: '_isValidState',


		/**
   * Verifies that the current link state is valid so the user can save the link. A valid state
   * means that we have a non-empty videoURL that's different from the original one.
   *
   * @instance
   * @memberof EmbedVideoEdit
   * @method _isValidState
   * @protected
   * @return {Boolean} True if the state is valid, false otherwise
   */
		value: function _isValidState() {
			var validState = this.state.videoURL && this.state.videoURL !== this.state.initialEmbed.videoURL;

			return validState;
		}
	}]);

	return ButtonEmbedVideoEdit;
}(_react2.default.Component);

ButtonEmbedVideoEdit.contextType = _editorContext2.default;
ButtonEmbedVideoEdit.key = 'embedVideoEdit';
exports.default = _editorContext2.default.toProps(ButtonEmbedVideoEdit);

/***/ }),

/***/ "./src/components/buttons/button-embed-video.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-embed-video.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonEmbedVideoEdit = __webpack_require__(/*! ./button-embed-video-edit.jsx */ "./src/components/buttons/button-embed-video-edit.jsx");

var _buttonEmbedVideoEdit2 = _interopRequireDefault(_buttonEmbedVideoEdit);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonEmbedVideo class provides functionality for changing text color in a document.
 *
 * @class ButtonEmbedVideo
 */
var ButtonEmbedVideo = function (_React$Component) {
	_inherits(ButtonEmbedVideo, _React$Component);

	function ButtonEmbedVideo() {
		_classCallCheck(this, ButtonEmbedVideo);

		return _possibleConstructorReturn(this, (ButtonEmbedVideo.__proto__ || Object.getPrototypeOf(ButtonEmbedVideo)).apply(this, arguments));
	}

	_createClass(ButtonEmbedVideo, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.renderExclusive) {
				return _react2.default.createElement(_buttonEmbedVideoEdit2.default, this.props);
			} else {
				return _react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.video,
						className: 'ae-button',
						'data-type': 'button-embed-video',
						onClick: this.props.requestExclusive,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.video },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'video' })
				);
			}
		}
	}]);

	return ButtonEmbedVideo;
}(_react2.default.Component);

ButtonEmbedVideo.key = 'embedVideo';
ButtonEmbedVideo.propTypes = {
	/**
  * The label that should be used for accessibility purposes.
  *
  * @instance
  * @memberof ButtonEmbedVideo
  * @property {String} label
  */
	label: _propTypes2.default.string,

	/**
  * The tabIndex of the button in its toolbar current state. A value other than -1
  * means that the button has focus and is the active element.
  *
  * @instance
  * @memberof ButtonEmbedVideo
  * @property {Number} tabIndex
  */
	tabIndex: _propTypes2.default.number
};
exports.default = ButtonEmbedVideo;

/***/ }),

/***/ "./src/components/buttons/button-embed.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-embed.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonEmbedEdit = __webpack_require__(/*! ./button-embed-edit.jsx */ "./src/components/buttons/button-embed-edit.jsx");

var _buttonEmbedEdit2 = _interopRequireDefault(_buttonEmbedEdit);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonEmbed class provides functionality for creating and editing an embed link in a document.
 * ButtonEmbed renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonEmbedEdit UI with all the link edition controls.
 *
 * @class ButtonEmbed
 * @uses ButtonKeystroke
 */
var ButtonEmbed = function (_React$Component) {
	_inherits(ButtonEmbed, _React$Component);

	function ButtonEmbed() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonEmbed);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonEmbed.__proto__ || Object.getPrototypeOf(ButtonEmbed)).call.apply(_ref, [this].concat(args))), _this), _this._requestExclusive = function () {
			_this.props.requestExclusive(ButtonEmbed.key);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}
	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonEmbed
  * @method getDefaultProps
  * @return {Object} The default properties.
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default embed
  * @memberof ButtonEmbed
  * @property {String} key
  * @static
  */


	_createClass(ButtonEmbed, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonEmbed
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.renderExclusive) {
				return _react2.default.createElement(_buttonEmbedEdit2.default, this.props);
			} else {
				return _react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.link,
						className: 'ae-button',
						'data-type': 'button-embed',
						onClick: this._requestExclusive,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.link },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'plus' })
				);
			}
		}

		/**
   * Requests the link button to be rendered in exclusive mode to allow the embedding of a link.
   *
   * @instance
   * @memberof ButtonEmbed
   * @method _requestExclusive
   * @protected
   */

	}]);

	return ButtonEmbed;
}(_react2.default.Component);

ButtonEmbed.defaultProps = {
	keystroke: {
		fn: '_requestExclusive',
		keys: CKEDITOR.CTRL + CKEDITOR.SHIFT + 76 /* L*/
		, name: 'embed'
	}
};
ButtonEmbed.key = 'embed';
exports.default = (0, _buttonKeystroke2.default)(ButtonEmbed);

/***/ }),

/***/ "./src/components/buttons/button-h1.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-h1.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonH1 class provides wraps a selection in `h1` element.
 *
 * @class ButtonH1
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonH1 = function (_React$Component) {
	_inherits(ButtonH1, _React$Component);

	function ButtonH1() {
		_classCallCheck(this, ButtonH1);

		return _possibleConstructorReturn(this, (ButtonH1.__proto__ || Object.getPrototypeOf(ButtonH1)).apply(this, arguments));
	}

	_createClass(ButtonH1, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonH1
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonH1
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.h1,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-h1',
					onClick: this.applyStyle,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.h1 },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'h1' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default h1
   * @memberof ButtonH1
   * @property {String} key
   * @static
   */

	}]);

	return ButtonH1;
}(_react2.default.Component);

ButtonH1.defaultProps = {
	style: {
		element: 'h1'
	}
};
ButtonH1.key = 'h1';
exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonH1)));

/***/ }),

/***/ "./src/components/buttons/button-h2.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-h2.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonH2 class provides wraps a selection in `h2` element.
 *
 * @class ButtonH2
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonH2 = function (_React$Component) {
	_inherits(ButtonH2, _React$Component);

	function ButtonH2() {
		_classCallCheck(this, ButtonH2);

		return _possibleConstructorReturn(this, (ButtonH2.__proto__ || Object.getPrototypeOf(ButtonH2)).apply(this, arguments));
	}

	_createClass(ButtonH2, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonH2
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonH2
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.h2,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-h2',
					onClick: this.applyStyle,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.h2 },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'h2' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default h2
   * @memberof ButtonH2
   * @property {String} key
   * @static
   */

	}]);

	return ButtonH2;
}(_react2.default.Component);

ButtonH2.defaultProps = {
	style: {
		element: 'h2'
	}
};
ButtonH2.key = 'h2';
exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonH2)));

/***/ }),

/***/ "./src/components/buttons/button-hline.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-hline.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonHline class provides inserts horizontal line.
 *
 * @class ButtonHline
 * @uses ButtonCommand
 */
var ButtonHline = function (_React$Component) {
	_inherits(ButtonHline, _React$Component);

	function ButtonHline() {
		_classCallCheck(this, ButtonHline);

		return _possibleConstructorReturn(this, (ButtonHline.__proto__ || Object.getPrototypeOf(ButtonHline)).apply(this, arguments));
	}

	_createClass(ButtonHline, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonHline
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonHline
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.horizontalrule,
					className: 'ae-button',
					'data-type': 'button-hline',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.horizontalrule },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'hr' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default hline
   * @memberof ButtonHline
   * @property {String} key
   * @static
   */

	}]);

	return ButtonHline;
}(_react2.default.Component);

ButtonHline.defaultProps = {
	command: 'horizontalrule'
};
ButtonHline.key = 'hline';
exports.default = (0, _buttonCommand2.default)(ButtonHline);

/***/ }),

/***/ "./src/components/buttons/button-icon.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-icon.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = ButtonIcon;

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

function ButtonIcon(_ref) {
	var _ref$className = _ref.className,
	    className = _ref$className === undefined ? '' : _ref$className,
	    symbol = _ref.symbol;

	return _react2.default.createElement(
		_editorContext2.default.Consumer,
		null,
		function (_ref2) {
			var editor = _ref2.editor;

			var nativeEditor = editor.get('nativeEditor');
			var spritemap = nativeEditor.config.spritemap || '';
			var path = spritemap + '#' + symbol;
			var classNamePrefix = className ? ' ' + className : '';
			var combinedClassName = 'ae-svg-icon' + classNamePrefix;

			return _react2.default.createElement(
				'svg',
				{ className: combinedClassName, height: '18', width: '18' },
				_react2.default.createElement('use', { href: path })
			);
		}
	);
}

/***/ }),

/***/ "./src/components/buttons/button-image-align-center.jsx":
/*!**************************************************************!*\
  !*** ./src/components/buttons/button-image-align-center.jsx ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonImageAlignCenter class provides functionality for aligning an image in the center.
 *
 * @class ButtonImageAlignCenter
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignCenter = function (_React$Component) {
	_inherits(ButtonImageAlignCenter, _React$Component);

	function ButtonImageAlignCenter() {
		_classCallCheck(this, ButtonImageAlignCenter);

		return _possibleConstructorReturn(this, (ButtonImageAlignCenter.__proto__ || Object.getPrototypeOf(ButtonImageAlignCenter)).apply(this, arguments));
	}

	_createClass(ButtonImageAlignCenter, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonImageAlignCenter
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonImageAlignCenter
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignCenter,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-image-align-center',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignCenter },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-image-center' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default imageCenter
   * @memberof ButtonImageAlignCenter
   * @property {String} key
   * @static
   */

	}]);

	return ButtonImageAlignCenter;
}(_react2.default.Component);

ButtonImageAlignCenter.defaultProps = {
	command: 'justifycenter'
};
ButtonImageAlignCenter.key = 'imageCenter';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignCenter)));

/***/ }),

/***/ "./src/components/buttons/button-image-align-left.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-image-align-left.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonImageAlignLeft class provides functionality for aligning an image on left.
 *
 * @class ButtonImageAlignLeft
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignLeft = function (_React$Component) {
	_inherits(ButtonImageAlignLeft, _React$Component);

	function ButtonImageAlignLeft() {
		_classCallCheck(this, ButtonImageAlignLeft);

		return _possibleConstructorReturn(this, (ButtonImageAlignLeft.__proto__ || Object.getPrototypeOf(ButtonImageAlignLeft)).apply(this, arguments));
	}

	_createClass(ButtonImageAlignLeft, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonImageAlignLeft
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonImageAlignLeft
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignLeft,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-image-align-left',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignLeft },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-image-left' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default imageLeft
   * @memberof ButtonImageAlignLeft
   * @property {String} key
   * @static
   */

	}]);

	return ButtonImageAlignLeft;
}(_react2.default.Component);

ButtonImageAlignLeft.defaultProps = {
	command: 'justifyleft'
};
ButtonImageAlignLeft.key = 'imageLeft';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignLeft)));

/***/ }),

/***/ "./src/components/buttons/button-image-align-right.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-image-align-right.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonImageAlignRight class provides functionality for aligning an image on right.
 *
 * @class ButtonImageAlignRight
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignRight = function (_React$Component) {
	_inherits(ButtonImageAlignRight, _React$Component);

	function ButtonImageAlignRight() {
		_classCallCheck(this, ButtonImageAlignRight);

		return _possibleConstructorReturn(this, (ButtonImageAlignRight.__proto__ || Object.getPrototypeOf(ButtonImageAlignRight)).apply(this, arguments));
	}

	_createClass(ButtonImageAlignRight, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonImageAlignRight
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonImageAlignRight
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignRight,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-image-align-right',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignRight },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-image-right' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default imageRight
   * @memberof ButtonImageAlignRight
   * @property {String} key
   * @static
   */

	}]);

	return ButtonImageAlignRight;
}(_react2.default.Component);

ButtonImageAlignRight.defaultProps = {
	command: 'justifyright'
};
ButtonImageAlignRight.key = 'imageRight';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignRight)));

/***/ }),

/***/ "./src/components/buttons/button-image.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-image.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonImage class inserts an image to the content.
 *
 * @class ButtonImage
 */
var ButtonImage = function (_React$Component) {
	_inherits(ButtonImage, _React$Component);

	function ButtonImage(props) {
		_classCallCheck(this, ButtonImage);

		var _this = _possibleConstructorReturn(this, (ButtonImage.__proto__ || Object.getPrototypeOf(ButtonImage)).call(this, props));

		_this.handleClick = function () {
			_this.fileInput.current.click();
		};

		_this._onInputChange = function () {
			var inputEl = _this.fileInput.current;

			// On IE11 the function might be called with an empty array of
			// files. In such a case, no actions will be taken.
			if (!inputEl.files.length) {
				return;
			}

			var reader = new FileReader();
			var file = inputEl.files[0];

			reader.onload = function (event) {
				var editor = _this.context.editor.get('nativeEditor');

				var result = editor.fire('beforeImageAdd', {
					imageFiles: file
				});

				if (result) {
					var el = CKEDITOR.dom.element.createFromHtml('<img src="' + event.target.result + '">');

					editor.insertElement(el);

					editor.fire('actionPerformed', _this);

					var imageData = {
						el: el,
						file: file
					};

					editor.fire('imageAdd', imageData);
				}
			};

			reader.readAsDataURL(file);

			inputEl.value = '';
		};

		_this.fileInput = _react2.default.createRef();
		return _this;
	}

	/**
  * Lifecycle. Renders the UI of the button.
  *
  * @instance
  * @memberof ButtonImage
  * @method render
  * @return {Object} The content which should be rendered.
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default image
  * @memberof ButtonImage
  * @property {String} key
  * @static
  */


	_createClass(ButtonImage, [{
		key: 'render',
		value: function render() {
			var inputSyle = { display: 'none' };

			return _react2.default.createElement(
				'div',
				null,
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.image,
						className: 'ae-button',
						'data-type': 'button-image',
						onClick: this.handleClick,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.image },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'document-image' })
				),
				_react2.default.createElement('input', {
					accept: 'image/*',
					onChange: this._onInputChange,
					ref: this.fileInput,
					style: inputSyle,
					type: 'file'
				})
			);
		}

		/**
   * Simulates click on the input element. This will open browser's native file open dialog.
   *
   * @instance
   * @memberof ButtonImage
   * @method handleClick
   * @param {SyntheticEvent} event The received click event on the button.
   */


		/**
   * On input change, reads the chosen file and fires an event `beforeImageAdd` with the image which will be added
   * to the content. The image file will be passed in the `imageFiles` property.
   * If any of the listeners returns `false` or cancels the event, the image won't be added to the content.
   * Otherwise, an event `imageAdd` will be fired with the inserted element into the editable area.
   * The passed params will be:
   * - `el` - the created img element
   * - `file` - the original image file from the input element
   *
   * @fires ButtonImage#beforeImageAdd
   * @fires ButtonImage#imageAdd
   * @instance
   * @memberof ButtonImage
   * @method _onInputChange
   * @protected
   */

	}]);

	return ButtonImage;
}(_react2.default.Component);

ButtonImage.contextType = _editorContext2.default;
ButtonImage.key = 'imageFromFile';
exports.default = ButtonImage;

/***/ }),

/***/ "./src/components/buttons/button-indent-block.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-indent-block.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonIndentBlock class provides functionality for indenting the selected blocks.
 *
 * @class ButtonIndentBlock
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonIndentBlock = function (_React$Component) {
	_inherits(ButtonIndentBlock, _React$Component);

	function ButtonIndentBlock() {
		_classCallCheck(this, ButtonIndentBlock);

		return _possibleConstructorReturn(this, (ButtonIndentBlock.__proto__ || Object.getPrototypeOf(ButtonIndentBlock)).apply(this, arguments));
	}

	_createClass(ButtonIndentBlock, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonIndentBlock
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonIndentBlock
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.indent,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-indent-block',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.indent },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'indent-less' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default indentBlock
   * @memberof ButtonIndentBlock
   * @property {String} key
   * @static
   */

	}]);

	return ButtonIndentBlock;
}(_react2.default.Component);

ButtonIndentBlock.defaultProps = {
	command: 'indent'
};
ButtonIndentBlock.key = 'indentBlock';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonIndentBlock)));

/***/ }),

/***/ "./src/components/buttons/button-italic.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-italic.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonItalic class provides functionality for styling an selection with italic (em) style.
 *
 * @class ButtonItalic
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonItalic = function (_React$Component) {
	_inherits(ButtonItalic, _React$Component);

	function ButtonItalic() {
		_classCallCheck(this, ButtonItalic);

		return _possibleConstructorReturn(this, (ButtonItalic.__proto__ || Object.getPrototypeOf(ButtonItalic)).apply(this, arguments));
	}

	_createClass(ButtonItalic, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonItalic
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonItalic
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.italic,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-italic',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.italic },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'italic' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default italic
   * @memberof ButtonItalic
   * @property {String} key
   * @static
   */

	}]);

	return ButtonItalic;
}(_react2.default.Component);

ButtonItalic.defaultProps = {
	command: 'italic',
	keystroke: {
		fn: 'execCommand',
		keys: CKEDITOR.CTRL + 73 /* I*/
		, name: 'italic'
	},
	style: 'coreStyles_italic'
};
ButtonItalic.key = 'italic';
exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonItalic))));

/***/ }),

/***/ "./src/components/buttons/button-item-selector-audio.jsx":
/*!***************************************************************!*\
  !*** ./src/components/buttons/button-item-selector-audio.jsx ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * @class ButtonItemSelectorAudio
 * @uses ButtonCommand
 */
var ButtonItemSelectorAudio = function (_React$Component) {
	_inherits(ButtonItemSelectorAudio, _React$Component);

	function ButtonItemSelectorAudio() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonItemSelectorAudio);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonItemSelectorAudio.__proto__ || Object.getPrototypeOf(ButtonItemSelectorAudio)).call.apply(_ref, [this].concat(args))), _this), _this._handleClick = function () {
			_this.execCommand(null);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(ButtonItemSelectorAudio, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.audio,
					className: 'ae-button',
					'data-type': 'button-audio',
					onClick: this._handleClick,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.audio },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'audio' })
			);
		}
	}]);

	return ButtonItemSelectorAudio;
}(_react2.default.Component);

ButtonItemSelectorAudio.defaultProps = {
	command: 'audioselector'
};
ButtonItemSelectorAudio.key = 'audio';
exports.default = (0, _buttonCommand2.default)(ButtonItemSelectorAudio);

/***/ }),

/***/ "./src/components/buttons/button-item-selector-image.jsx":
/*!***************************************************************!*\
  !*** ./src/components/buttons/button-item-selector-image.jsx ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * @class ButtonItemSelectorImage
 * @uses ButtonCommand
 */
var ButtonItemSelectorImage = function (_React$Component) {
	_inherits(ButtonItemSelectorImage, _React$Component);

	function ButtonItemSelectorImage() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonItemSelectorImage);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonItemSelectorImage.__proto__ || Object.getPrototypeOf(ButtonItemSelectorImage)).call.apply(_ref, [this].concat(args))), _this), _this._handleClick = function () {
			_this.execCommand(null);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(ButtonItemSelectorImage, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.image,
					className: 'ae-button',
					'data-type': 'button-image',
					onClick: this._handleClick,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.image },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'picture' })
			);
		}
	}]);

	return ButtonItemSelectorImage;
}(_react2.default.Component);

ButtonItemSelectorImage.defaultProps = {
	command: 'imageselector'
};
ButtonItemSelectorImage.key = 'image';
exports.default = (0, _buttonCommand2.default)(ButtonItemSelectorImage);

/***/ }),

/***/ "./src/components/buttons/button-item-selector-video.jsx":
/*!***************************************************************!*\
  !*** ./src/components/buttons/button-item-selector-video.jsx ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * @class ButtonItemSelectorVideo
 * @uses ButtonCommand
 */
var ButtonItemSelectorVideo = function (_React$Component) {
	_inherits(ButtonItemSelectorVideo, _React$Component);

	function ButtonItemSelectorVideo() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonItemSelectorVideo);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonItemSelectorVideo.__proto__ || Object.getPrototypeOf(ButtonItemSelectorVideo)).call.apply(_ref, [this].concat(args))), _this), _this._handleClick = function () {
			_this.execCommand(null);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(ButtonItemSelectorVideo, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.video,
					className: 'ae-button',
					'data-type': 'button-video',
					onClick: this._handleClick,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.video },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'video' })
			);
		}
	}]);

	return ButtonItemSelectorVideo;
}(_react2.default.Component);

ButtonItemSelectorVideo.defaultProps = {
	command: 'videoselector'
};
ButtonItemSelectorVideo.key = 'video';
exports.default = (0, _buttonCommand2.default)(ButtonItemSelectorVideo);

/***/ }),

/***/ "./src/components/buttons/button-link-autocomplete-list.jsx":
/*!******************************************************************!*\
  !*** ./src/components/buttons/button-link-autocomplete-list.jsx ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonLinkAutocompleteList class provides functionality for showing a list of
 * items that can be selected for the link.
 *
 * @class ButtonLinkAutocompleteList
 * @uses WidgetFocusManager
 */
var ButtonLinkAutocompleteList = function (_React$Component) {
	_inherits(ButtonLinkAutocompleteList, _React$Component);

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonLinkAutocompleteList
  * @method getDefaultProps
  * @return {Object} The default properties.
  */
	function ButtonLinkAutocompleteList(props) {
		_classCallCheck(this, ButtonLinkAutocompleteList);

		var _this = _possibleConstructorReturn(this, (ButtonLinkAutocompleteList.__proto__ || Object.getPrototypeOf(ButtonLinkAutocompleteList)).call(this, props));

		_this.state = {
			items: []
		};
		return _this;
	}

	/**
  * Lifecycle. Invoked when a component is receiving new props.
  * This method is not called for the initial render.
  *
  * @instance
  * @memberof ButtonLinkAutocompleteList
  * @method componentWillReceiveProps
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default buttonLinkAutocompleteList
  * @memberof ButtonLinkAutocompleteList
  * @property {String} key
  * @static
  */


	_createClass(ButtonLinkAutocompleteList, [{
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps(nextProps) {
			if (!nextProps.term || nextProps.term !== this.props.term) {
				clearTimeout(this._timeout);

				if (nextProps.term) {
					this._timeout = setTimeout(this._updateItems, this.props.delay);
				} else {
					this.setState({
						items: []
					});
				}
			}

			if (nextProps.autocompleteSelected) {
				setTimeout(this.focus, 0);
				this.props.setAutocompleteState({
					selected: false
				});
			}
		}

		/**
   * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
   *
   * @instance
   * @memberof ButtonLinkAutocompleteList
   * @method componentWillUnmount
   */

	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			clearTimeout(this._timeout);
		}

		/**
   * Lifecycle. Renders the UI of the list.
   *
   * @instance
   * @memberof ButtonLinkAutocompleteList
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			if (!this.props.expanded || !this.state.items.length) {
				return null;
			}

			return _react2.default.createElement(
				_buttonDropdown2.default,
				null,
				this._renderAutocompleteItems(this.state.items)
			);
		}

		/**
   * Lifecycle. Invoked before rendering when new props or state are being received.
   * This method is not called for the initial render or when forceUpdate is used.
   *
   * @instance
   * @memberof ButtonLinkAutocompleteList
   * @method  shouldComponentUpdate
   * @return {Boolean} Returns false when the transition to the new props and state will not
   * require a component update.
   */

	}, {
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(nextProps, nextState) {
			return nextProps.expanded !== this.props.expanded || nextProps.term !== this.props.term || nextState.items !== this.state.items;
		}

		/**
   * Renders a set of list items for the provided items
   *
   * @instance
   * @memberof ButtonLinkAutocompleteList
   * @method _renderAutocompleteItems
   * @param {Array} items List of autocomplete items to render
   * @protected
   * @return {Array} Rendered list item instances
   */

	}, {
		key: '_renderAutocompleteItems',
		value: function _renderAutocompleteItems(items) {
			var _this2 = this;

			items = items || [];

			var handleLinkAutocompleteClick = this.props.handleLinkAutocompleteClick;

			return items.map(function (item) {
				var className = _this2.props.term === item.url ? 'ae-toolbar-element active' : 'ae-toolbar-element';

				return _react2.default.createElement(
					'li',
					{ key: item.url, role: 'option' },
					_react2.default.createElement(
						'button',
						{
							className: className,
							'data-value': item.url,
							onClick: handleLinkAutocompleteClick },
						item.title
					)
				);
			});
		}

		/**
   * Retrieves the data according to {this.props.term} and calls setState() with the returned data
   *
   * @instance
   * @memberof ButtonLinkAutocompleteList
   * @method _updateItems
   * @protected
   */

	}, {
		key: '_updateItems',
		value: function _updateItems() {
			var _this3 = this;

			if (!this.props.term) {
				return;
			}

			var promise = Promise.resolve(this.props.data(this.props.term));

			promise.then(function (items) {
				if (items.length && !_this3.props.expanded) {
					_this3.props.toggleDropdown();
				}

				_this3.setState({
					items: items
				});
			});
		}
	}]);

	return ButtonLinkAutocompleteList;
}(_react2.default.Component);

ButtonLinkAutocompleteList.defaultProps = {
	circular: false,
	data: [],
	delay: 100,
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	}
};
ButtonLinkAutocompleteList.key = 'buttonLinkAutocompleteList';
exports.default = (0, _widgetFocusManager2.default)(ButtonLinkAutocompleteList);

/***/ }),

/***/ "./src/components/buttons/button-link-browse.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-link-browse.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonProps = __webpack_require__(/*! ../base/button-props */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonLinkEditBrowse = __webpack_require__(/*! ./button-link-edit-browse.jsx */ "./src/components/buttons/button-link-edit-browse.jsx");

var _buttonLinkEditBrowse2 = _interopRequireDefault(_buttonLinkEditBrowse);

var _buttonLink = __webpack_require__(/*! ./button-link.jsx */ "./src/components/buttons/button-link.jsx");

var _buttonLink2 = _interopRequireDefault(_buttonLink);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonLinkBrowse class provides functionality for changing text color in a document.
 *
 * @uses ButtonKeystroke
 * @uses ButtonProps
 *
 * @class ButtonLinkBrowse
 */
var ButtonLinkBrowse = function (_React$Component) {
	_inherits(ButtonLinkBrowse, _React$Component);

	function ButtonLinkBrowse() {
		_classCallCheck(this, ButtonLinkBrowse);

		return _possibleConstructorReturn(this, (ButtonLinkBrowse.__proto__ || Object.getPrototypeOf(ButtonLinkBrowse)).apply(this, arguments));
	}

	_createClass(ButtonLinkBrowse, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.renderExclusive) {
				this.props = this.mergeButtonCfgProps();

				return _react2.default.createElement(_buttonLinkEditBrowse2.default, this.props);
			} else {
				return _react2.default.createElement(_buttonLink2.default, this.props);
			}
		}

		/**
   * Requests the link button to be rendered in exclusive mode to allow the creation of a link.
   *
   * @protected
   * @method _requestExclusive
   */

	}, {
		key: '_requestExclusive',
		value: function _requestExclusive() {
			this.props.requestExclusive(ButtonLinkBrowse.key);
		}
	}]);

	return ButtonLinkBrowse;
}(_react2.default.Component);

ButtonLinkBrowse.defaultProps = {
	keystroke: {
		fn: '_requestExclusive',
		keys: CKEDITOR.CTRL + 76 /* L*/
		, name: 'linkBrowse'
	}
};
ButtonLinkBrowse.key = 'linkBrowse';
ButtonLinkBrowse.propTypes = {
	/**
  * The label that should be used for accessibility purposes.
  *
  * @property {String} label
  */
	label: _propTypes2.default.string,

	/**
  * The tabIndex of the button in its toolbar current state. A value other than -1
  * means that the button has focus and is the active element.
  *
  * @property {Number} tabIndex
  */
	tabIndex: _propTypes2.default.number
};
exports.default = (0, _buttonProps2.default)((0, _buttonKeystroke2.default)(ButtonLinkBrowse));

/***/ }),

/***/ "./src/components/buttons/button-link-edit-browse.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-link-edit-browse.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonLinkEdit = __webpack_require__(/*! ./button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The LinkEditBrowse class provides functionality for creating and editing a link in a document,
 * and also allows to link to an existing file in DM.
 * Provides UI for creating, editing and removing a link.
 *
 * @class ButtonLinkEditBrowse
 */
var ButtonLinkEditBrowse = function (_React$Component) {
	_inherits(ButtonLinkEditBrowse, _React$Component);

	/**
  *
  * @inheritDoc
  */
	function ButtonLinkEditBrowse(props) {
		_classCallCheck(this, ButtonLinkEditBrowse);

		var _this = _possibleConstructorReturn(this, (ButtonLinkEditBrowse.__proto__ || Object.getPrototypeOf(ButtonLinkEditBrowse)).call(this, props));

		_this._browseClick = function () {
			var editor = _this.context.editor.get('nativeEditor');
			var url = editor.config.documentBrowseLinkUrl;
			var browseLinkCallback = editor.config.documentBrowseLinkCallback;
			var linkTarget = _this.linkEditButtonRef.current ? _this.linkEditButtonRef.current.state.linkTarget : '';

			var changeLinkCallback = function changeLinkCallback(selectedItem) {
				_this._updateLink(selectedItem.value, linkTarget, selectedItem.title);
			};

			if (_lang2.default.isFunction(browseLinkCallback)) {
				browseLinkCallback.apply(null, [editor, url, changeLinkCallback]);
			}
		};

		_this._updateLink = function (linkHref, linkTarget, linkTitle) {
			var editor = _this.context.editor.get('nativeEditor');
			var linkUtils = new CKEDITOR.Link(editor, { appendProtocol: false });
			var linkAttrs = {
				target: linkTarget
			};
			var modifySelection = { advance: true };

			if (linkHref) {
				if (editor.plugins && editor.plugins.creole && !linkTitle) {
					linkHref = location.origin + linkHref;
				}

				if (_this.state.element) {
					linkAttrs.href = linkHref;

					linkUtils.update(linkAttrs, _this.state.element, modifySelection);
				} else {
					linkUtils.create(linkHref, linkAttrs, modifySelection);
				}

				editor.fire('actionPerformed', _this);
			}
		};

		var link = new CKEDITOR.Link(
		// Can't access context from constructor, so get editor from props.
		_this.props.context.editor.get('nativeEditor')).getFromSelection();

		var href = link ? link.getAttribute('href') : '';

		_this.linkEditButtonRef = _react2.default.createRef();

		_this.state = {
			element: link,
			linkHref: href
		};
		return _this;
	}

	/**
  * Lifecycle. Renders the UI of the button.
  *
  * @method render
  * @return {Object} The content which should be rendered.
  */


	_createClass(ButtonLinkEditBrowse, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-link-edit-browse' },
				_react2.default.createElement(_buttonLinkEdit2.default, _extends({ ref: this.linkEditButtonRef }, this.props)),
				_react2.default.createElement(
					'button',
					{
						'aria-label': 'Browse',
						className: 'ae-button',
						onClick: this._browseClick,
						title: 'browse' },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'folder' })
				)
			);
		}

		/**
   * Opens an item selector dialog.
   *
   * @protected
   * @method _browseClick
   */


		/**
   * Updates the link in the editor element. If the element didn't exist previously, it will
   * create a new <a> element with the href specified in the link input.
   *
   * @protected
   * @method _updateLink
   * @param {String} linkHref href value for the link
   * @param {String} linkTarget target value for the link
   * @param {String} linkTitle if the link is a title that points to a wiki page (only works for creole)
   */

	}]);

	return ButtonLinkEditBrowse;
}(_react2.default.Component);

ButtonLinkEditBrowse.contextType = _editorContext2.default;
ButtonLinkEditBrowse.key = 'linkEditBrowse';
exports.default = _editorContext2.default.toProps(ButtonLinkEditBrowse);

/***/ }),

/***/ "./src/components/buttons/button-link-edit.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-link-edit.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonLinkAutocompleteList = __webpack_require__(/*! ./button-link-autocomplete-list.jsx */ "./src/components/buttons/button-link-autocomplete-list.jsx");

var _buttonLinkAutocompleteList2 = _interopRequireDefault(_buttonLinkAutocompleteList);

var _buttonLinkTargetEdit = __webpack_require__(/*! ./button-link-target-edit.jsx */ "./src/components/buttons/button-link-target-edit.jsx");

var _buttonLinkTargetEdit2 = _interopRequireDefault(_buttonLinkTargetEdit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonLinkEdit class provides functionality for creating and editing a link in a document.
 * Provides UI for creating, editing and removing a link.
 *
 * @class ButtonLinkEdit
 * @uses WidgetDropdown
 * @uses WidgetFocusManager
 */
var ButtonLinkEdit = function (_React$Component) {
	_inherits(ButtonLinkEdit, _React$Component);

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonLinkEdit
  * @method getDefaultProps
  * @return {Object} The default properties.
  */
	function ButtonLinkEdit(props) {
		_classCallCheck(this, ButtonLinkEdit);

		var _this = _possibleConstructorReturn(this, (ButtonLinkEdit.__proto__ || Object.getPrototypeOf(ButtonLinkEdit)).call(this, props));

		_this._clearLink = function () {
			_this.setState({
				linkHref: ''
			});

			_this._focusLinkInput();
		};

		_this._handleKeyDown = function (event) {
			if (event.keyCode === 13 || event.keyCode === 27) {
				event.preventDefault();
			}

			if (event.keyCode === 13) {
				_this._updateLink();
			} else if (event.keyCode === 40) {
				_this.setState({
					autocompleteSelected: true
				});
			} else if (event.keyCode === 27) {
				var editor = _this.context.editor.get('nativeEditor');

				new CKEDITOR.Link(editor).advanceSelection();

				_this.context.editor.get('nativeEditor').fire('actionPerformed', _this);
			}
		};

		_this._handleLinkHrefChange = function (event) {
			_this.setState({
				linkHref: event.target.value
			});

			_this._focusLinkInput();
		};

		_this._handleLinkTargetChange = function (event) {
			_this.setState({
				itemDropdown: null,
				linkTarget: event.target.getAttribute('data-value')
			});

			_this._focusLinkInput();
		};

		_this._removeLink = function () {
			var editor = _this.context.editor.get('nativeEditor');
			var linkUtils = new CKEDITOR.Link(editor);
			var selection = editor.getSelection();
			var bookmarks = selection.createBookmarks();

			linkUtils.remove(_this.state.element, { advance: true });

			selection.selectBookmarks(bookmarks);

			// We need to cancelExclusive with the bound parameters in case the button is used
			// inside another in exclusive mode (such is the case of the link button)
			_this.props.cancelExclusive();

			editor.fire('actionPerformed', _this);
		};

		_this._updateLink = function () {
			var editor = _this.context.editor.get('nativeEditor');
			var linkUtils = new CKEDITOR.Link(editor, {
				appendProtocol: _this.props.appendProtocol
			});
			var linkAttrs = {
				target: _this.state.linkTarget || null
			};
			var modifySelection = { advance: true };

			if (_this.state.linkHref) {
				if (_this.state.element) {
					linkAttrs.href = _this.state.linkHref;

					linkUtils.update(linkAttrs, _this.state.element, modifySelection);
				} else {
					if (!_this.state.linkTarget) linkAttrs = {};

					linkUtils.create(_this.state.linkHref, linkAttrs, modifySelection);
				}

				editor.fire('actionPerformed', _this);
			}

			// We need to cancelExclusive with the bound parameters in case the button is used
			// inside another in exclusive mode (such is the case of the link button)
			_this.props.cancelExclusive();
		};

		_this.linkInput = _react2.default.createRef();
		_this.state = _this._getInitialState();
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * Focuses on the link input to immediately allow editing. This should only happen if the component
  * is rendered in exclusive mode to prevent aggressive focus stealing.
  *
  * @instance
  * @memberof ButtonLinkEdit
  * @method componentDidMount
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default linkEdit
  * @memberof ButtonLinkEdit
  * @property {String} key
  * @static
  */


	_createClass(ButtonLinkEdit, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (this.props.renderExclusive || this.props.manualSelection) {
				// We need to wait for the next rendering cycle before focusing to avoid undesired
				// scrolls on the page
				this._focusLinkInput();
			}
		}

		/**
   * Lifecycle. Invoked when a component is receiving new props.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method componentWillReceiveProps
   */

	}, {
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps() {
			this.setState(this._getInitialState());
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var targetSelector = {
				allowedTargets: this.props.allowedTargets,
				editor: this.context.editor,
				handleLinkTargetChange: this._handleLinkTargetChange,
				selectedTarget: this.state.linkTarget || AlloyEditor.Strings.linkTargetDefault
			};

			targetSelector = this.mergeDropdownProps(targetSelector, _buttonLinkTargetEdit2.default.key);

			var autocompleteDropdown = void 0;

			if (this.props.data) {
				var dataFn = this.props.data;

				if (!_lang2.default.isFunction(dataFn)) {
					var items = this.props.data;

					dataFn = function dataFn() {
						return items;
					};
				}

				var autocompleteDropdownProps = {
					autocompleteSelected: this.state.autocompleteSelected,
					data: dataFn,
					editor: this.context.editor,
					handleLinkAutocompleteClick: this._handleLinkAutocompleteClick,
					onDismiss: this.props.toggleDropdown,
					setAutocompleteState: this._setAutocompleteState,
					term: this.state.linkHref
				};

				autocompleteDropdownProps = this.mergeDropdownProps(autocompleteDropdownProps, _buttonLinkAutocompleteList2.default.key);

				autocompleteDropdown = _react2.default.createElement(_buttonLinkAutocompleteList2.default, autocompleteDropdownProps);
			}

			var buttonClearLink = void 0;

			if (this.state.linkHref) {
				buttonClearLink = _react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.clearInput,
						className: 'ae-button ae-button-clear',
						onClick: this._clearLink,
						title: AlloyEditor.Strings.clear },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'times-circle' })
				);
			}

			var placeholderProp = {};

			if (!CKEDITOR.env.ie && AlloyEditor.Strings) {
				placeholderProp.placeholder = AlloyEditor.Strings.editLink;
			}

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-edit-link' },
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.removeLink,
						className: 'ae-button',
						disabled: !this.state.element,
						onClick: this._removeLink,
						title: AlloyEditor.Strings.remove },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'chain-broken' })
				),
				_react2.default.createElement(
					'div',
					{ className: 'ae-container-input xxl' },
					this.props.showTargetSelector && _react2.default.createElement(_buttonLinkTargetEdit2.default, targetSelector),
					_react2.default.createElement(
						'div',
						{ className: 'ae-container-input' },
						_react2.default.createElement('input', _extends({
							className: 'ae-input',
							onChange: this._handleLinkHrefChange,
							onKeyDown: this._handleKeyDown
						}, placeholderProp, {
							ref: this.linkInput,
							type: 'text',
							value: this.state.linkHref
						})),
						autocompleteDropdown
					),
					buttonClearLink
				),
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.confirm,
						className: 'ae-button',
						disabled: !this._isValidState(),
						onClick: this._updateLink,
						title: AlloyEditor.Strings.confirm },
					_react2.default.createElement(_buttonIcon2.default, { className: 'ae-icon-svg-check', symbol: 'check' })
				)
			);
		}

		/**
   * The return value will be used as the initial value of this.state.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _getInitialState
   * @protected
   * @return {Object}
   */

	}, {
		key: '_getInitialState',
		value: function _getInitialState() {
			// Can't access context from contructor, so get editor from props.
			var editor = this.props.context.editor;
			var defaultLinkTarget = this.props.defaultLinkTarget;


			var link = new CKEDITOR.Link(editor.get('nativeEditor')).getFromSelection();
			var href = link && link.getAttribute('href') || '';
			var target = link && link.getAttribute('target') || defaultLinkTarget;

			return {
				autocompleteSelected: false,
				element: link,
				initialLink: {
					href: href,
					target: target
				},
				linkHref: href,
				linkTarget: target
			};
		}

		/**
   * Clears the link input. This only changes the component internal state, but does not
   * affect the link element of the editor. Only the _removeLink and _updateLink methods
   * are translated to the editor element.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _clearLink
   * @protected
   */

	}, {
		key: '_focusLinkInput',


		/**
   * Focuses the user cursor on the widget's input.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _focusLinkInput
   * @protected
   */
		value: function _focusLinkInput() {
			var instance = this;

			var focusLinkEl = function focusLinkEl() {
				instance.linkInput.current.focus();
			};

			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(focusLinkEl);
			} else {
				setTimeout(focusLinkEl, 0);
			}
		}

		/**
   * Monitors key interaction inside the input element to respond to the keys:
   * - Enter: Creates/updates the link.
   * - Escape: Discards the changes.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _handleKeyDown
   * @param {SyntheticEvent} event The keyboard event.
   * @protected
   */


		/**
   * Updates the component state when the link input changes on user interaction.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _handleLinkHrefChange
   * @param {SyntheticEvent} event The change event.
   * @protected
   */


		/**
   * Updates the component state when the link target changes on user interaction.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _handleLinkTargetChange
   * @param {SyntheticEvent} event The click event.
   * @protected
   */

	}, {
		key: '_handleLinkAutocompleteClick',


		/**
   * Updates the component state when an autocomplete link result is selected by user interaction.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _handleLinkAutocompleteClick
   * @param {SyntheticEvent} event The click event.
   * @protected
   */
		value: function _handleLinkAutocompleteClick(event) {
			this.setState({
				itemDropdown: null,
				linkHref: event.target.getAttribute('data-value')
			});

			this._focusLinkInput();
		}

		/**
   * Verifies that the current link state is valid so the user can save the link. A valid state
   * means that we have a non-empty href and that either that or the link target are different
   * from the original link.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _isValidState
   * @protected
   * @return {Boolean} [description]
   */

	}, {
		key: '_isValidState',
		value: function _isValidState() {
			var validState = this.state.linkHref && (this.state.linkHref !== this.state.initialLink.href || this.state.linkTarget !== this.state.initialLink.target);

			return validState;
		}

		/**
   * Removes the link in the editor element.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _removeLink
   * @protected
   */

	}, {
		key: '_setAutocompleteState',


		/**
   * Update autocompleteSelected state to focus and select autocompleteÂ´s dropdown
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _setAutocompleteState
   * @protected
   */
		value: function _setAutocompleteState(state) {
			this.setState({
				autocompleteSelected: state.selected
			});
		}

		/**
   * Updates the link in the editor element. If the element didn't exist previously, it will
   * create a new <a> element with the href specified in the link input.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _updateLink
   * @protected
   */

	}]);

	return ButtonLinkEdit;
}(_react2.default.Component);

ButtonLinkEdit.contextType = _editorContext2.default;
ButtonLinkEdit.defaultProps = {
	appendProtocol: true,
	autocompleteUrl: '',
	circular: true,
	customIndexStart: true,
	defaultLinkTarget: '',
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	},
	showTargetSelector: true
};
ButtonLinkEdit.key = 'linkEdit';
exports.default = _editorContext2.default.toProps((0, _widgetDropdown2.default)((0, _widgetFocusManager2.default)(ButtonLinkEdit)));

/***/ }),

/***/ "./src/components/buttons/button-link-target-edit.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-link-target-edit.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonTargetList = __webpack_require__(/*! ./button-target-list.jsx */ "./src/components/buttons/button-target-list.jsx");

var _buttonTargetList2 = _interopRequireDefault(_buttonTargetList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonLinkTargetEdit class provides functionality for changing the target of a link
 * in the document.
 *
 * @class ButtonLinkTargetEdit
 */
var ButtonLinkTargetEdit = function (_React$Component) {
	_inherits(ButtonLinkTargetEdit, _React$Component);

	function ButtonLinkTargetEdit() {
		_classCallCheck(this, ButtonLinkTargetEdit);

		return _possibleConstructorReturn(this, (ButtonLinkTargetEdit.__proto__ || Object.getPrototypeOf(ButtonLinkTargetEdit)).apply(this, arguments));
	}

	_createClass(ButtonLinkTargetEdit, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonLinkTargetEdit
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var handleLinkTargetChange = this.props.handleLinkTargetChange;
			var allowedLinkTargets = this.props.allowedTargets;

			return _react2.default.createElement(
				'div',
				{
					className: 'ae-container-dropdown ae-container-dropdown-medium ae-container-edit-link-target ae-has-dropdown',
					tabIndex: '0' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': this.props.selectedTarget,
						className: 'ae-toolbar-element',
						onClick: this.props.toggleDropdown,
						role: 'combobox',
						tabIndex: this.props.tabIndex,
						title: this.props.selectedTarget },
					_react2.default.createElement(
						'div',
						{ className: 'ae-container' },
						_react2.default.createElement(
							'span',
							{ className: 'ae-container-dropdown-selected-item' },
							this.props.selectedTarget
						),
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'caret-bottom' })
					)
				),
				this.props.expanded && _react2.default.createElement(_buttonTargetList2.default, {
					allowedLinkTargets: allowedLinkTargets,
					handleLinkTargetChange: handleLinkTargetChange,
					onDismiss: this.props.toggleDropdown,
					selectedTarget: this.props.selectedTarget
				})
			);
		}

		/**
   * Lifecycle. Invoked before rendering when new props or state are being received.
   * This method is not called for the initial render or when forceUpdate is used.
   *
   * @instance
   * @memberof ButtonLinkTargetEdit
   * @method  shouldComponentUpdate
   * @return {Boolean} Returns false when the transition to the new props and state will not
   * require a component update.
   */

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default linkTargetEdit
   * @memberof ButtonLinkTargetEdit
   * @property {String} key
   * @static
   */

	}, {
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(nextProps) {
			return nextProps.expanded !== this.props.expanded || nextProps.selectedTarget !== this.props.selectedTarget;
		}
	}]);

	return ButtonLinkTargetEdit;
}(_react2.default.Component);

ButtonLinkTargetEdit.key = 'linkTargetEdit';
exports.default = ButtonLinkTargetEdit;

/***/ }),

/***/ "./src/components/buttons/button-link.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-link.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonProps = __webpack_require__(/*! ../base/button-props */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonLinkEdit = __webpack_require__(/*! ./button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonLink class provides functionality for creating and editing a link in a document. ButtonLink
 * renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonLinkEdit UI with all the link edition controls.
 *
 * @class ButtonLink
 * @uses ButtonProps
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 */
var ButtonLink = function (_React$Component) {
	_inherits(ButtonLink, _React$Component);

	function ButtonLink() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonLink);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonLink.__proto__ || Object.getPrototypeOf(ButtonLink)).call.apply(_ref, [this].concat(args))), _this), _this._requestExclusive = function () {
			_this.props.requestExclusive(ButtonLink.key);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonLink
  * @method getDefaultProps
  * @return {Object} The default properties.
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default link
  * @memberof ButtonLink
  * @property {String} key
  * @static
  */


	_createClass(ButtonLink, [{
		key: 'isActive',


		/**
   * Checks if the current selection is contained within a link.
   *
   * @instance
   * @memberof ButtonLink
   * @method isActive
   * @return {Boolean} True if the selection is inside a link, false otherwise.
   */
		value: function isActive() {
			return new CKEDITOR.Link(this.context.editor.get('nativeEditor')).getFromSelection() !== null;
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonLink
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			if (this.props.renderExclusive) {
				var props = this.mergeButtonCfgProps();

				return _react2.default.createElement(_buttonLinkEdit2.default, props);
			} else {
				return _react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.link,
						className: cssClass,
						'data-type': 'button-link',
						onClick: this._requestExclusive,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.link },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'link' })
				);
			}
		}

		/**
   * Requests the link button to be rendered in exclusive mode to allow the creation of a link.
   *
   * @instance
   * @memberof ButtonLink
   * @method _requestExclusive
   * @protected
   */

	}]);

	return ButtonLink;
}(_react2.default.Component);

ButtonLink.contextType = _editorContext2.default;
ButtonLink.defaultProps = {
	keystroke: {
		fn: '_requestExclusive',
		keys: CKEDITOR.CTRL + 76 /* L*/
		, name: 'link'
	}
};
ButtonLink.key = 'link';
exports.default = (0, _buttonProps2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)(ButtonLink)));

/***/ }),

/***/ "./src/components/buttons/button-ol.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-ol.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonOrderedList class provides functionality for creating ordered lists in an editor.
 *
 * @class ButtonOrderedList
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonOrderedList = function (_React$Component) {
	_inherits(ButtonOrderedList, _React$Component);

	function ButtonOrderedList() {
		_classCallCheck(this, ButtonOrderedList);

		return _possibleConstructorReturn(this, (ButtonOrderedList.__proto__ || Object.getPrototypeOf(ButtonOrderedList)).apply(this, arguments));
	}

	_createClass(ButtonOrderedList, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonOrderedList
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonOrderedList
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.numberedlist,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-ol',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.numberedlist },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'list-ol' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default ol
   * @memberof ButtonOrderedList
   * @property {String} key
   * @static
   */

	}]);

	return ButtonOrderedList;
}(_react2.default.Component);

ButtonOrderedList.defaultProps = {
	command: 'numberedlist',
	style: {
		element: 'ol'
	}
};
ButtonOrderedList.key = 'ol';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonOrderedList)));

/***/ }),

/***/ "./src/components/buttons/button-outdent-block.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-outdent-block.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonOutdentBlock class provides functionality for outdenting blocks.
 *
 * @class ButtonOutdentBlock
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonOutdentBlock = function (_React$Component) {
	_inherits(ButtonOutdentBlock, _React$Component);

	function ButtonOutdentBlock() {
		_classCallCheck(this, ButtonOutdentBlock);

		return _possibleConstructorReturn(this, (ButtonOutdentBlock.__proto__ || Object.getPrototypeOf(ButtonOutdentBlock)).apply(this, arguments));
	}

	_createClass(ButtonOutdentBlock, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonOutdentBlock
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonOutdentBlock
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.outdent,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-outdent-block',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.outdent },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'indent-more' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default outdentBlock
   * @memberof ButtonOutdentBlock
   * @property {String} key
   * @static
   */

	}]);

	return ButtonOutdentBlock;
}(_react2.default.Component);

ButtonOutdentBlock.defaultProps = {
	command: 'outdent'
};
ButtonOutdentBlock.key = 'outdentBlock';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonOutdentBlock)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-align-left.jsx":
/*!****************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-align-left.jsx ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonParagraphAlignLeft class provides functionality for aligning a paragraph on left.
 *
 * @class ButtonParagraphAlignLeft
 *
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphAlignLeft = function (_React$Component) {
	_inherits(ButtonParagraphAlignLeft, _React$Component);

	function ButtonParagraphAlignLeft() {
		_classCallCheck(this, ButtonParagraphAlignLeft);

		return _possibleConstructorReturn(this, (ButtonParagraphAlignLeft.__proto__ || Object.getPrototypeOf(ButtonParagraphAlignLeft)).apply(this, arguments));
	}

	_createClass(ButtonParagraphAlignLeft, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonParagraphAlignLeft
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonParagraphAlignLeft
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignLeft,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-paragraph-align-left',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignLeft },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-left' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default paragraphLeft
   * @memberof ButtonParagraphAlignLeft
   * @property {String} key
   * @static
   */

	}]);

	return ButtonParagraphAlignLeft;
}(_react2.default.Component);

ButtonParagraphAlignLeft.defaultProps = {
	command: 'justifyleft'
};
ButtonParagraphAlignLeft.key = 'paragraphLeft';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphAlignLeft)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-align-right.jsx":
/*!*****************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-align-right.jsx ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonParagraphAlignRight class provides functionality for aligning a paragraph on right.
 *
 * @class ButtonParagraphAlignRight
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphAlignRight = function (_React$Component) {
	_inherits(ButtonParagraphAlignRight, _React$Component);

	function ButtonParagraphAlignRight() {
		_classCallCheck(this, ButtonParagraphAlignRight);

		return _possibleConstructorReturn(this, (ButtonParagraphAlignRight.__proto__ || Object.getPrototypeOf(ButtonParagraphAlignRight)).apply(this, arguments));
	}

	_createClass(ButtonParagraphAlignRight, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonParagraphAlignRight
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonParagraphAlignRight
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignRight,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-paragraph-align-right',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignRight },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-right' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default paragraphRight
   * @memberof ButtonParagraphAlignRight
   * @property {String} key
   * @static
   */

	}]);

	return ButtonParagraphAlignRight;
}(_react2.default.Component);

ButtonParagraphAlignRight.defaultProps = {
	command: 'justifyright'
};
ButtonParagraphAlignRight.key = 'paragraphRight';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphAlignRight)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-align.jsx":
/*!***********************************************************!*\
  !*** ./src/components/buttons/button-paragraph-align.jsx ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonParagraphAlign class provides functionality to work with table rows.
 *
 * @class ButtonParagraphAlign
 */
var ButtonParagraphAlign = function (_React$Component) {
	_inherits(ButtonParagraphAlign, _React$Component);

	function ButtonParagraphAlign() {
		_classCallCheck(this, ButtonParagraphAlign);

		return _possibleConstructorReturn(this, (ButtonParagraphAlign.__proto__ || Object.getPrototypeOf(ButtonParagraphAlign)).apply(this, arguments));
	}

	_createClass(ButtonParagraphAlign, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonParagraphAlign
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var buttonCommandsList = void 0;
			var buttonCommandsListId = void 0;

			if (this.props.expanded) {
				buttonCommandsListId = ButtonParagraphAlign.key + 'List';
				buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, {
					commands: this._getCommands(),
					inlineIcons: false,
					listId: buttonCommandsListId,
					onDismiss: this.props.toggleDropdown
				});
			}

			var editor = this.context.editor.get('nativeEditor');

			var activeCommand = this._getCommands().filter(function (alignment) {
				var command = editor.getCommand(alignment.command);

				return command ? command.state === CKEDITOR.TRISTATE_ON : false;
			}).pop();

			var iconClassName = activeCommand.icon;

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-dropdown ae-container-dropdown-xsmall ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': activeCommand.label,
						'aria-owns': buttonCommandsListId,
						className: 'ae-toolbar-element',
						onClick: this.props.toggleDropdown,
						role: 'combobox',
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.row },
					_react2.default.createElement(
						'div',
						{ className: 'ae-container' },
						_react2.default.createElement(_buttonIcon2.default, { symbol: iconClassName }),
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'caret-bottom' })
					)
				),
				buttonCommandsList
			);
		}

		/**
   * Returns a list of commands. If a list of commands was passed
   * as property `commands`, it will take a precedence over the default ones.
   *
   * @instance
   * @memberof ButtonParagraphAlign
   * @method _getCommands
   * @protected
   * @return {Array} The list of available commands.
   */

	}, {
		key: '_getCommands',
		value: function _getCommands() {
			return this.props.commands || [{
				command: 'justifyleft',
				icon: 'align-left',
				label: AlloyEditor.Strings.alignLeft
			}, {
				command: 'justifycenter',
				icon: 'align-center',
				label: AlloyEditor.Strings.alignCenter
			}, {
				command: 'justifyright',
				icon: 'align-right',
				label: AlloyEditor.Strings.alignRight
			}, {
				command: 'justifyblock',
				icon: 'align-justify',
				label: AlloyEditor.Strings.alignJustify
			}];
		}
	}]);

	return ButtonParagraphAlign;
}(_react2.default.Component);

ButtonParagraphAlign.contextType = _editorContext2.default;
ButtonParagraphAlign.key = 'paragraphAlign';
exports.default = ButtonParagraphAlign;

/***/ }),

/***/ "./src/components/buttons/button-paragraph-center.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-center.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonParagraphCenter class provides functionality for centering a paragraph.
 *
 * @class ButtonParagraphCenter
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphCenter = function (_React$Component) {
	_inherits(ButtonParagraphCenter, _React$Component);

	function ButtonParagraphCenter() {
		_classCallCheck(this, ButtonParagraphCenter);

		return _possibleConstructorReturn(this, (ButtonParagraphCenter.__proto__ || Object.getPrototypeOf(ButtonParagraphCenter)).apply(this, arguments));
	}

	_createClass(ButtonParagraphCenter, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonParagraphCenter
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonParagraphCenter
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignCenter,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-paragraph-center',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignCenter },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-center' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default paragraphCenter
   * @memberof ButtonParagraphCenter
   * @property {String} key
   * @static
   */

	}]);

	return ButtonParagraphCenter;
}(_react2.default.Component);

ButtonParagraphCenter.defaultProps = {
	command: 'justifycenter'
};
ButtonParagraphCenter.key = 'paragraphCenter';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphCenter)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-justify.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-justify.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonParagraphJustify class provides functionality for justfying a paragraph.
 *
 * @class ButtonParagraphJustify
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphJustify = function (_React$Component) {
	_inherits(ButtonParagraphJustify, _React$Component);

	function ButtonParagraphJustify() {
		_classCallCheck(this, ButtonParagraphJustify);

		return _possibleConstructorReturn(this, (ButtonParagraphJustify.__proto__ || Object.getPrototypeOf(ButtonParagraphJustify)).apply(this, arguments));
	}

	_createClass(ButtonParagraphJustify, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonParagraphJustify
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonParagraphJustify
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignJustify,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-paragraph-justify',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignJustify },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-justify' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default paragraphJustify
   * @memberof ButtonParagraphJustify
   * @property {String} key
   * @static
   */

	}]);

	return ButtonParagraphJustify;
}(_react2.default.Component);

ButtonParagraphJustify.defaultProps = {
	command: 'justifyblock'
};
ButtonParagraphJustify.key = 'paragraphJustify';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphJustify)));

/***/ }),

/***/ "./src/components/buttons/button-quote.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-quote.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonQuote class wraps a selection in `blockquote` element.
 *
 * @class ButtonQuote
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonQuote = function (_React$Component) {
	_inherits(ButtonQuote, _React$Component);

	function ButtonQuote() {
		_classCallCheck(this, ButtonQuote);

		return _possibleConstructorReturn(this, (ButtonQuote.__proto__ || Object.getPrototypeOf(ButtonQuote)).apply(this, arguments));
	}

	_createClass(ButtonQuote, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonQuote
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonQuote
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.quote,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-quote',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.quote },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'quote-right' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default quote
   * @memberof ButtonQuote
   * @property {String} key
   * @static
   */

	}]);

	return ButtonQuote;
}(_react2.default.Component);

ButtonQuote.defaultProps = {
	command: 'blockquote',
	style: {
		element: 'blockquote'
	}
};
ButtonQuote.key = 'quote';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonQuote)));

/***/ }),

/***/ "./src/components/buttons/button-remove-format.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-remove-format.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonRemoveFormat class removes style formatting.
 *
 * @class ButtonRemoveFormat
 * @uses ButtonCommand
 */
var ButtonRemoveFormat = function (_React$Component) {
	_inherits(ButtonRemoveFormat, _React$Component);

	function ButtonRemoveFormat() {
		_classCallCheck(this, ButtonRemoveFormat);

		return _possibleConstructorReturn(this, (ButtonRemoveFormat.__proto__ || Object.getPrototypeOf(ButtonRemoveFormat)).apply(this, arguments));
	}

	_createClass(ButtonRemoveFormat, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonRemoveFormat
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonRemoveFormat
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.removeformat,
					className: 'ae-button',
					'data-type': 'button-removeformat',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.removeformat },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'remove-style' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default removeFormat
   * @memberof ButtonRemoveFormat
   * @property {String} key
   * @static
   */

	}]);

	return ButtonRemoveFormat;
}(_react2.default.Component);

ButtonRemoveFormat.defaultProps = {
	command: 'removeFormat'
};
ButtonRemoveFormat.key = 'removeFormat';
exports.default = (0, _buttonCommand2.default)(ButtonRemoveFormat);

/***/ }),

/***/ "./src/components/buttons/button-remove-image.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-remove-image.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonRemoveImage class removes an image using a CKEDITOR.command.
 *
 * @class ButtonRemoveImage
 * @uses ButtonCommand
 */
var ButtonRemoveImage = function (_React$Component) {
	_inherits(ButtonRemoveImage, _React$Component);

	function ButtonRemoveImage() {
		_classCallCheck(this, ButtonRemoveImage);

		return _possibleConstructorReturn(this, (ButtonRemoveImage.__proto__ || Object.getPrototypeOf(ButtonRemoveImage)).apply(this, arguments));
	}

	_createClass(ButtonRemoveImage, [{
		key: 'render',


		/**
   * @inheritDoc
   */
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.removeImage,
					'aria-pressed': false,
					className: 'ae-button',
					onClick: this.execCommand,
					title: AlloyEditor.Strings.removeImage },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'times-circle' })
			);
		}
	}]);

	return ButtonRemoveImage;
}(_react2.default.Component);

ButtonRemoveImage.defaultProps = {
	command: 'removeImage'
};
ButtonRemoveImage.key = 'removeImage';
exports.default = (0, _buttonCommand2.default)(ButtonRemoveImage);

/***/ }),

/***/ "./src/components/buttons/button-separator.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-separator.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The ButtonSeparator function renders a simple separator.
 */
function ButtonSeparator(_props) {
  return _react2.default.createElement('span', { className: 'ae-separator' });
}

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default separator
 * @memberof ButtonSeparator
 * @property {String} key
 * @static
 */
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

ButtonSeparator.key = 'separator';

exports.default = ButtonSeparator;

/***/ }),

/***/ "./src/components/buttons/button-spacing.jsx":
/*!***************************************************!*\
  !*** ./src/components/buttons/button-spacing.jsx ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonSpacing class provides functionality for changing text spacing in a document.
 *
 * @class ButtonSpacing
 */
var ButtonSpacing = function (_React$Component) {
	_inherits(ButtonSpacing, _React$Component);

	function ButtonSpacing() {
		_classCallCheck(this, ButtonSpacing);

		return _possibleConstructorReturn(this, (ButtonSpacing.__proto__ || Object.getPrototypeOf(ButtonSpacing)).apply(this, arguments));
	}

	_createClass(ButtonSpacing, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var _this2 = this;

			var activeSpacing = '1.0x';

			var spacings = this._getSpacings();

			spacings.forEach(function (item) {
				if (_this2._checkActive(item.style)) {
					activeSpacing = item.name;
				}
			});

			var _props = this.props,
			    editor = _props.editor,
			    expanded = _props.expanded,
			    tabIndex = _props.tabIndex,
			    toggleDropdown = _props.toggleDropdown;


			var buttonStylesProps = {
				activeStyle: activeSpacing,
				editor: editor,
				onDismiss: toggleDropdown,
				showRemoveStylesItem: false,
				styles: spacings
			};

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-container-dropdown-small ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': expanded,
						className: 'ae-toolbar-element',
						onClick: toggleDropdown,
						role: 'combobox',
						tabIndex: tabIndex },
					_react2.default.createElement(
						'span',
						null,
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'separator' }),
						'\xA0',
						activeSpacing
					)
				),
				expanded && _react2.default.createElement(_buttonStylesList2.default, buttonStylesProps)
			);
		}
	}, {
		key: '_applyStyle',
		value: function _applyStyle(className) {
			var _this3 = this;

			var editor = this.context.editor.get('nativeEditor');

			var styleConfig = {
				element: 'div',
				attributes: {
					class: className
				}
			};

			var style = new CKEDITOR.style(styleConfig);

			editor.getSelection().lock();

			this._getSpacings().forEach(function (item) {
				if (_this3._checkActive(item.style)) {
					editor.removeStyle(new CKEDITOR.style(item.style));
				}
			});

			editor.applyStyle(style);

			editor.getSelection().unlock();

			editor.fire('actionPerformed', this);
		}

		/**
   * Checks if the given spacing definition is applied to the current selection in the editor.
   *
   * @instance
   * @memberof Spacing
   * @method _checkActive
   * @param {Object} styleConfig Spacing definition as per http://docs.ckeditor.com/#!/api/CKEDITOR.style.
   * @protected
   * @return {Boolean} Returns true if the spacing is applied to the selection, false otherwise.
   */

	}, {
		key: '_checkActive',
		value: function _checkActive(styleConfig) {
			var nativeEditor = this.context.editor.get('nativeEditor');

			var active = true;

			var elementPath = nativeEditor.elementPath();

			if (elementPath && elementPath.lastElement) {
				styleConfig.attributes.class.split(' ').forEach(function (className) {
					active = active && elementPath.lastElement.hasClass(className);
				});
			} else {
				active = false;
			}

			return active;
		}

		/**
   * Returns an array of spacings. Each spacing consists from three properties:
   * - name - the style name, for example "default"
   * - style - an object with one property, called `element` which value
   * represents the style which have to be applied to the element.
   * - styleFn - a function which applies selected style to the editor selection
   *
   * @instance
   * @memberof Spacing
   * @method _getSpacings
   * @protected
   * @return {Array<object>} An array of objects containing the spacings.
   */

	}, {
		key: '_getSpacings',
		value: function _getSpacings() {
			return this.props.styles || [{
				name: '1.0x',
				style: {
					element: 'div',
					attributes: {
						class: ''
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, '')
			}, {
				name: '1.5x',
				style: {
					element: 'div',
					attributes: {
						class: 'mt-1 mb-1'
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, 'mt-1 mb-1')
			}, {
				name: '2.0x',
				style: {
					element: 'div',
					attributes: {
						class: 'mt-2 mb-2'
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, 'mt-2 mb-2')
			}, {
				name: '3.0x',
				style: {
					element: 'div',
					attributes: {
						class: 'mt-3 mb-3'
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, 'mt-3 mb-3')
			}, {
				name: '4.0x',
				style: {
					element: 'div',
					attributes: {
						class: 'mt-4 mb-4'
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, 'mt-4 mb-4')
			}, {
				name: '5.0x',
				style: {
					element: 'div',
					attributes: {
						class: 'mt-5 mb-5'
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, 'mt-5 mb-5')
			}];
		}
	}]);

	return ButtonSpacing;
}(_react2.default.Component);

ButtonSpacing.contextType = _editorContext2.default;
ButtonSpacing.key = 'spacing';
ButtonSpacing.propTypes = {
	/**
  * Indicates whether the styles list is expanded or not.
  *
  * @instance
  * @memberof Spacing
  * @property {Boolean} expanded
  */
	expanded: _propTypes2.default.bool,

	/**
  * The label that should be used for accessibility purposes.
  *
  * @instance
  * @memberof Spacing
  * @property {String} label
  */
	label: _propTypes2.default.string,

	/**
  * Indicates whether the remove styles item should appear in the styles list.
  *
  * @instance
  * @memberof Spacing
  * @property {Boolean} showRemoveStylesItem
  */
	showRemoveStylesItem: _propTypes2.default.bool,

	/**
  * List of the styles the button is able to handle.
  *
  * @instance
  * @memberof Spacing
  * @property {Array} styles
  */
	styles: _propTypes2.default.arrayOf(_propTypes2.default.object),

	/**
  * The tabIndex of the button in its toolbar current state. A value other than -1
  * means that the button has focus and is the active element.
  *
  * @instance
  * @memberof Spacing
  * @property {Number} tabIndex
  */
	tabIndex: _propTypes2.default.number,

	/**
  * Callback provided by the button host to notify when the styles list has been expanded.
  *
  * @instance
  * @memberof Spacing
  * @property {Function} toggleDropdown
  */
	toggleDropdown: _propTypes2.default.func
};
exports.default = ButtonSpacing;

/***/ }),

/***/ "./src/components/buttons/button-strike.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-strike.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonStrike class styles a selection with strike style.
 *
 * @class ButtonStrike
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonStrike = function (_React$Component) {
	_inherits(ButtonStrike, _React$Component);

	function ButtonStrike() {
		_classCallCheck(this, ButtonStrike);

		return _possibleConstructorReturn(this, (ButtonStrike.__proto__ || Object.getPrototypeOf(ButtonStrike)).apply(this, arguments));
	}

	_createClass(ButtonStrike, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   * @instance
   * @memberof ButtonStrike
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonStrike
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.strike,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-strike',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.strike },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'strikethrough' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default strike
   * @memberof ButtonStrike
   * @property {String} key
   * @static
   */

	}]);

	return ButtonStrike;
}(_react2.default.Component);

ButtonStrike.defaultProps = {
	command: 'strike',
	style: 'coreStyles_strike'
};
ButtonStrike.key = 'strike';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonStrike)));

/***/ }),

/***/ "./src/components/buttons/button-styles-list-header.jsx":
/*!**************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-header.jsx ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonsStylesListHeader class provides the header of an list of style items.
 *
 * @class ButtonsStylesListHeader
 */
var ButtonsStylesListHeader = function (_React$Component) {
	_inherits(ButtonsStylesListHeader, _React$Component);

	function ButtonsStylesListHeader() {
		_classCallCheck(this, ButtonsStylesListHeader);

		return _possibleConstructorReturn(this, (ButtonsStylesListHeader.__proto__ || Object.getPrototypeOf(ButtonsStylesListHeader)).apply(this, arguments));
	}

	_createClass(ButtonsStylesListHeader, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonsStylesListHeader
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.styles && this.props.styles.length) {
				return _react2.default.createElement(
					'span',
					{ className: 'ae-list-header' },
					this.props.name
				);
			} else {
				return null;
			}
		}
	}]);

	return ButtonsStylesListHeader;
}(_react2.default.Component);

ButtonsStylesListHeader.key = 'buttonStylesListHeader';
exports.default = ButtonsStylesListHeader;

/***/ }),

/***/ "./src/components/buttons/button-styles-list-item-remove.jsx":
/*!*******************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-item-remove.jsx ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonStylesListItemRemove class provides functionality for previewing a style definition
 * inside a list and applying it to the current editor selection.
 *
 * @class ButtonStylesListItemRemove
 */
var ButtonStylesListItemRemove = function (_React$Component) {
	_inherits(ButtonStylesListItemRemove, _React$Component);

	function ButtonStylesListItemRemove() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonStylesListItemRemove);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonStylesListItemRemove.__proto__ || Object.getPrototypeOf(ButtonStylesListItemRemove)).call.apply(_ref, [this].concat(args))), _this), _this._removeStyles = function () {
			var editor = _this.context.editor.get('nativeEditor');

			editor.execCommand('removeFormat');

			_this.props.removeBlocks.forEach(function (blockItem) {
				var blockStyle = new CKEDITOR.style({ element: blockItem });

				editor.removeStyle(blockStyle);
			});

			editor.fire('actionPerformed', _this);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonStylesListItemRemove
  * @method getDefaultProps
  * @return {Object} The default properties.
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default buttonStylesListItemRemove
  * @memberof ButtonStylesListItemRemove
  * @property {String} key
  * @static
  */


	_createClass(ButtonStylesListItemRemove, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonStylesListItemRemove
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			return _react2.default.createElement(
				'li',
				{ role: 'option' },
				_react2.default.createElement(
					'button',
					{
						className: 'ae-toolbar-element',
						onClick: this._removeStyles,
						tabIndex: this.props.tabIndex },
					AlloyEditor.Strings.normal
				)
			);
		}

		/**
   * Removes all inline styles and configured block elements applied to the current selection.
   *
   * @instance
   * @memberof ButtonStylesListItemRemove
   * @method _removeStyles
   * @protected
   */

	}]);

	return ButtonStylesListItemRemove;
}(_react2.default.Component);

ButtonStylesListItemRemove.contextType = _editorContext2.default;
ButtonStylesListItemRemove.defaultProps = {
	removeBlocks: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'pre']
};
ButtonStylesListItemRemove.key = 'buttonStylesListItemRemove';
exports.default = ButtonStylesListItemRemove;

/***/ }),

/***/ "./src/components/buttons/button-styles-list-item.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-item.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonStylesListItem class provides functionality for previewing a style definition
 * inside a list and applying it to the current editor selection.
 *
 * @class ButtonStylesListItem
 * @uses ButtonActionStyle
 * @uses ButtonStyle
 */
var ButtonStylesListItem = function (_React$Component) {
	_inherits(ButtonStylesListItem, _React$Component);

	function ButtonStylesListItem() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonStylesListItem);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonStylesListItem.__proto__ || Object.getPrototypeOf(ButtonStylesListItem)).call.apply(_ref, [this].concat(args))), _this), _this._onClick = function () {
			if (_this.props.styleFn) {
				_this.props.styleFn();
			} else {
				// Typically, we want the style to be the only one applied to the current selection, so
				// we execute the 'removeFormat' command first. Note that block styles won't be cleaned.
				// However, this is consistent with other editors implementations of this feature.
				_this.context.editor.get('nativeEditor').execCommand('removeFormat');

				_this.applyStyle();
			}
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default buttonStylesListItem
  * @memberof ButtonStylesListItem
  * @property {String} key
  * @static
  */


	_createClass(ButtonStylesListItem, [{
		key: 'componentWillMount',


		/**
   * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
   *
   * @instance
   * @memberof ButtonStylesListItem
   * @method componentWillMount
   */
		value: function componentWillMount() {
			// Styles with wildcard element (*) generate an empty tag in their preview < class="custom-class" />.
			// We default to element span and remove the margins to obtain a more consistent set of previews.
			var styleCfg = {
				element: 'span',
				styles: {
					margin: 0
				}
			};

			styleCfg = CKEDITOR.tools.merge(styleCfg, this.props.style);

			this._preview = new CKEDITOR.style(styleCfg).buildPreview(this.props.name);
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonStylesListItem
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			// We need to use dangerouselySetInnterHTML since we're not in control of the style
			// preview that is generated by CKEditor.
			var className = this.props.name === this.props.activeStyle ? 'ae-toolbar-element active' : 'ae-toolbar-element';

			return _react2.default.createElement('button', {
				className: className,
				dangerouslySetInnerHTML: { __html: this._preview },
				onClick: this._onClick,
				tabIndex: this.props.tabIndex
			});
		}

		/**
   * Applies the item style to the editor selection.
   *
   * @instance
   * @memberof ButtonStylesListItem
   * @method _onClick
   * @protected
   */

	}]);

	return ButtonStylesListItem;
}(_react2.default.Component);

ButtonStylesListItem.contextType = _editorContext2.default;
ButtonStylesListItem.key = 'buttonStylesListItem';
exports.default = (0, _buttonActionStyle2.default)((0, _buttonStyle2.default)(ButtonStylesListItem));

/***/ }),

/***/ "./src/components/buttons/button-styles-list.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-styles-list.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _buttonStylesListHeader = __webpack_require__(/*! ./button-styles-list-header.jsx */ "./src/components/buttons/button-styles-list-header.jsx");

var _buttonStylesListHeader2 = _interopRequireDefault(_buttonStylesListHeader);

var _buttonStylesListItemRemove = __webpack_require__(/*! ./button-styles-list-item-remove.jsx */ "./src/components/buttons/button-styles-list-item-remove.jsx");

var _buttonStylesListItemRemove2 = _interopRequireDefault(_buttonStylesListItemRemove);

var _buttonStylesListItem = __webpack_require__(/*! ./button-styles-list-item.jsx */ "./src/components/buttons/button-styles-list-item.jsx");

var _buttonStylesListItem2 = _interopRequireDefault(_buttonStylesListItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonStylesList class provides functionality for showing a list of styles that can be
 * applied to the current selection..
 *
 * @class ButtonStylesList
 * @uses WidgetFocusManager
 */
var ButtonStylesList = function (_React$Component) {
	_inherits(ButtonStylesList, _React$Component);

	function ButtonStylesList() {
		_classCallCheck(this, ButtonStylesList);

		return _possibleConstructorReturn(this, (ButtonStylesList.__proto__ || Object.getPrototypeOf(ButtonStylesList)).apply(this, arguments));
	}

	_createClass(ButtonStylesList, [{
		key: 'componentDidMount',


		/**
   * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
   *
   * Focuses on the list node to allow keyboard interaction.
   *
   * @instance
   * @memberof ButtonStylesList
   * @method componentDidMount
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonStylesList
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function componentDidMount() {
			_reactDom2.default.findDOMNode(this).focus();
		}

		/**
   * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
   *
   * @instance
   * @memberof ButtonStylesList
   * @method componentWillMount
   */


		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @memberof ButtonStylesList
   * @static
   * @property {String} key
   * @default buttonStylesList
   */

	}, {
		key: 'componentWillMount',
		value: function componentWillMount() {
			var blockStyles = [];
			var inlineStyles = [];
			var objectStyles = [];

			this.props.styles.forEach(function (item) {
				var style = new CKEDITOR.style(item.style);

				if (style.type === CKEDITOR.STYLE_BLOCK) {
					blockStyles.push(item);
				} else if (style.type === CKEDITOR.STYLE_INLINE) {
					inlineStyles.push(item);
				} else if (style.type === CKEDITOR.STYLE_OBJECT) {
					objectStyles.push(item);
				}
			});

			this._blockStyles = blockStyles;
			this._inlineStyles = inlineStyles;
			this._objectStyles = objectStyles;
		}

		/**
   * Lifecycle. Renders the UI of the list.
   *
   * @instance
   * @memberof ButtonStylesList
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var removeStylesItem = void 0;

			if (this.props.showRemoveStylesItem) {
				removeStylesItem = _react2.default.createElement(_buttonStylesListItemRemove2.default, {
					onDismiss: this.props.toggleDropdown
				});
			}

			return _react2.default.createElement(
				_buttonDropdown2.default,
				this.props,
				removeStylesItem,
				_react2.default.createElement(_buttonStylesListHeader2.default, {
					name: AlloyEditor.Strings.blockStyles,
					styles: this._blockStyles
				}),
				this._renderStylesItems(this._blockStyles),
				_react2.default.createElement(_buttonStylesListHeader2.default, {
					name: AlloyEditor.Strings.inlineStyles,
					styles: this._inlineStyles
				}),
				this._renderStylesItems(this._inlineStyles),
				_react2.default.createElement(_buttonStylesListHeader2.default, {
					name: AlloyEditor.Strings.objectStyles,
					styles: this._objectStyles
				}),
				this._renderStylesItems(this._objectStyles)
			);
		}

		/**
   * Renders instances of ButtonStylesListItem with the preview of the correspondent block, inline or object styles.
   *
   * @instance
   * @memberof ButtonStylesList
   * @method _renderStylesItems
   * @param {Array} styles List of styles for which preview should be rendered.
   * @protected
   * @return {Array} Rendered instances of ButtonStylesListItem class
   */

	}, {
		key: '_renderStylesItems',
		value: function _renderStylesItems(styles) {
			var _this2 = this;

			var items = void 0;

			if (styles && styles.length) {
				items = styles.map(function (item) {
					return _react2.default.createElement(
						'li',
						{ key: item.name, role: 'option' },
						_react2.default.createElement(_buttonStylesListItem2.default, {
							activeStyle: _this2.props.activeStyle,
							name: item.name,
							style: item.style,
							styleFn: item.styleFn
						})
					);
				});
			}

			return items;
		}
	}]);

	return ButtonStylesList;
}(_react2.default.Component);

ButtonStylesList.defaultProps = {
	circular: false,
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	},
	showRemoveStylesItem: true
};
ButtonStylesList.key = 'buttonStylesList';
exports.default = (0, _widgetFocusManager2.default)(ButtonStylesList);

/***/ }),

/***/ "./src/components/buttons/button-styles.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-styles.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonStyles class provides functionality for styling a selection with a list of
 * configurable and customizable styles. The allowed styles follow CKEDITOR.Style configuration
 * (http://docs.ckeditor.com/#!/api/CKEDITOR.style)
 *
 * @class ButtonStyles
 */
var ButtonStyles = function (_React$Component) {
	_inherits(ButtonStyles, _React$Component);

	function ButtonStyles() {
		_classCallCheck(this, ButtonStyles);

		return _possibleConstructorReturn(this, (ButtonStyles.__proto__ || Object.getPrototypeOf(ButtonStyles)).apply(this, arguments));
	}

	_createClass(ButtonStyles, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonStyles
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var _this2 = this;

			var activeStyle = AlloyEditor.Strings.normal;

			var styles = this._getStyles();

			styles.forEach(function (item) {
				if (_this2._checkActive(item.style)) {
					activeStyle = item.name;
				}
			});

			var buttonStylesList = void 0;

			if (this.props.expanded) {
				buttonStylesList = _react2.default.createElement(_buttonStylesList2.default, {
					activeStyle: activeStyle,
					onDismiss: this.props.toggleDropdown,
					showRemoveStylesItem: this.props.showRemoveStylesItem,
					styles: styles
				});
			}

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-dropdown ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': AlloyEditor.Strings.styles + ' ' + activeStyle,
						className: 'ae-toolbar-element',
						onClick: this.props.toggleDropdown,
						role: 'combobox',
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.styles + ' ' + activeStyle },
					_react2.default.createElement(
						'div',
						{ className: 'ae-container' },
						_react2.default.createElement(
							'span',
							{ className: 'ae-container-dropdown-selected-item' },
							activeStyle
						),
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'caret-bottom' })
					)
				),
				buttonStylesList
			);
		}

		/**
   * Checks if the given style definition is applied to the current selection in the editor.
   *
   * @instance
   * @memberof ButtonStyles
   * @method _checkActive
   * @param {Object} styleConfig Style definition as per http://docs.ckeditor.com/#!/api/CKEDITOR.style.
   * @protected
   * @return {Boolean} Returns true if the style is applied to the selection, false otherwise.
   */


		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default styles
   * @memberof ButtonStyles
   * @property {String} key
   * @static
   */

	}, {
		key: '_checkActive',
		value: function _checkActive(styleConfig) {
			var nativeEditor = this.context.editor.get('nativeEditor');

			// Styles with wildcard element (*) won't be considered active by CKEditor. Defaulting
			// to a 'span' element works for most of those cases with no defined element.
			styleConfig = CKEDITOR.tools.merge({ element: 'span' }, styleConfig);

			var style = new CKEDITOR.style(styleConfig);

			return style.checkActive(nativeEditor.elementPath(), nativeEditor);
		}

		/**
   * Returns an array of styles. Each style consists from two properties:
   * - name - the style name, for example "h1"
   * - style - an object with one property, called `element` which value
   * represents the style which have to be applied to the element.
   *
   * @instance
   * @memberof ButtonStyles
   * @method _getStyles
   * @protected
   * @return {Array<object>} An array of objects containing the styles.
   */

	}, {
		key: '_getStyles',
		value: function _getStyles() {
			return this.props.styles || [{
				name: AlloyEditor.Strings.h1,
				style: {
					element: 'h1'
				}
			}, {
				name: AlloyEditor.Strings.h2,
				style: {
					element: 'h2'
				}
			}, {
				name: AlloyEditor.Strings.formatted,
				style: {
					element: 'pre'
				}
			}, {
				name: AlloyEditor.Strings.cite,
				style: {
					element: 'cite'
				}
			}, {
				name: AlloyEditor.Strings.code,
				style: {
					element: 'code'
				}
			}];
		}
	}]);

	return ButtonStyles;
}(_react2.default.Component);

ButtonStyles.contextType = _editorContext2.default;
ButtonStyles.key = 'styles';
exports.default = ButtonStyles;

/***/ }),

/***/ "./src/components/buttons/button-subscript.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-subscript.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonSubscript class provides functionality for applying subscript style to a text selection.
 *
 * @class ButtonSubscript
 *
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonSubscript = function (_React$Component) {
	_inherits(ButtonSubscript, _React$Component);

	function ButtonSubscript() {
		_classCallCheck(this, ButtonSubscript);

		return _possibleConstructorReturn(this, (ButtonSubscript.__proto__ || Object.getPrototypeOf(ButtonSubscript)).apply(this, arguments));
	}

	_createClass(ButtonSubscript, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonSubscript
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonSubscript
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.subscript,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-subscript',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.subscript },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'subscript' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default subscript
   * @memberof ButtonSubscript
   * @property {String} key
   * @static
   */

	}]);

	return ButtonSubscript;
}(_react2.default.Component);

ButtonSubscript.defaultProps = {
	command: 'subscript',
	style: 'coreStyles_subscript'
};
ButtonSubscript.key = 'subscript';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonSubscript)));

/***/ }),

/***/ "./src/components/buttons/button-superscript.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-superscript.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonSuperscript class provides functionality for applying superscript style to a text selection.
 *
 * @class ButtonSuperscript
 *
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonSuperscript = function (_React$Component) {
	_inherits(ButtonSuperscript, _React$Component);

	function ButtonSuperscript() {
		_classCallCheck(this, ButtonSuperscript);

		return _possibleConstructorReturn(this, (ButtonSuperscript.__proto__ || Object.getPrototypeOf(ButtonSuperscript)).apply(this, arguments));
	}

	_createClass(ButtonSuperscript, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonSuperscript
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonSuperscript
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.superscript,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-superscript',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.superscript },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'superscript' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default superscript
   * @memberof ButtonSuperscript
   * @property {String} key
   * @static
   */

	}]);

	return ButtonSuperscript;
}(_react2.default.Component);

ButtonSuperscript.defaultProps = {
	command: 'superscript',
	style: 'coreStyles_superscript'
};
ButtonSuperscript.key = 'superscript';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonSuperscript)));

/***/ }),

/***/ "./src/components/buttons/button-table-cell.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-table-cell.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonTableCell class provides functionality to work with table cells.
 *
 * @class ButtonTableCell
 */
var ButtonTableCell = function (_React$Component) {
	_inherits(ButtonTableCell, _React$Component);

	function ButtonTableCell() {
		_classCallCheck(this, ButtonTableCell);

		return _possibleConstructorReturn(this, (ButtonTableCell.__proto__ || Object.getPrototypeOf(ButtonTableCell)).apply(this, arguments));
	}

	_createClass(ButtonTableCell, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableCell
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var buttonCommandsList = void 0;
			var buttonCommandsListId = void 0;

			if (this.props.expanded) {
				buttonCommandsListId = ButtonTableCell.key + 'List';
				buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, {
					commands: this._getCommands(),
					listId: buttonCommandsListId,
					onDismiss: this.props.toggleDropdown
				});
			}

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': AlloyEditor.Strings.cell,
						'aria-owns': buttonCommandsListId,
						className: 'ae-button',
						onClick: this.props.toggleDropdown,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.cell },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'add-cell' })
				),
				buttonCommandsList
			);
		}

		/**
   * Returns a list of commands. If a list of commands was passed
   * as property `commands`, it will take a precedence over the default ones.
   *
   * @instance
   * @memberof ButtonTableCell
   * @method _getCommands
   * @protected
   * @return {Array} The list of available commands.
   */

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default tableCell
   * @memberof ButtonTableCell
   * @property {String} key
   * @static
   */

	}, {
		key: '_getCommands',
		value: function _getCommands() {
			return this.props.commands || [{
				command: 'cellInsertBefore',
				label: AlloyEditor.Strings.cellInsertBefore
			}, {
				command: 'cellInsertAfter',
				label: AlloyEditor.Strings.cellInsertAfter
			}, {
				command: 'cellDelete',
				label: AlloyEditor.Strings.cellDelete
			}, {
				command: 'cellMerge',
				label: AlloyEditor.Strings.cellMerge
			}, {
				command: 'cellMergeDown',
				label: AlloyEditor.Strings.cellMergeDown
			}, {
				command: 'cellMergeRight',
				label: AlloyEditor.Strings.cellMergeRight
			}, {
				command: 'cellHorizontalSplit',
				label: AlloyEditor.Strings.cellSplitHorizontal
			}, {
				command: 'cellVerticalSplit',
				label: AlloyEditor.Strings.cellSplitVertical
			}];
		}
	}]);

	return ButtonTableCell;
}(_react2.default.Component);

ButtonTableCell.key = 'tableCell';
exports.default = ButtonTableCell;

/***/ }),

/***/ "./src/components/buttons/button-table-column.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-table-column.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonTableColumn class provides functionality to work with table columns.
 *
 * @class ButtonTableColumn
 */
var ButtonTableColumn = function (_React$Component) {
	_inherits(ButtonTableColumn, _React$Component);

	function ButtonTableColumn() {
		_classCallCheck(this, ButtonTableColumn);

		return _possibleConstructorReturn(this, (ButtonTableColumn.__proto__ || Object.getPrototypeOf(ButtonTableColumn)).apply(this, arguments));
	}

	_createClass(ButtonTableColumn, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableColumn
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var buttonCommandsList = void 0;
			var buttonCommandsListId = void 0;

			if (this.props.expanded) {
				buttonCommandsListId = ButtonTableColumn.key + 'List';
				buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, {
					commands: this._getCommands(),
					listId: buttonCommandsListId,
					onDismiss: this.props.toggleDropdown
				});
			}

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': AlloyEditor.Strings.column,
						'aria-owns': buttonCommandsListId,
						className: 'ae-button',
						onClick: this.props.toggleDropdown,
						role: 'listbox',
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.column },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'add-column' })
				),
				buttonCommandsList
			);
		}

		/**
   * Returns a list of commands. If a list of commands was passed
   * as property `commands`, it will take a precedence over the default ones.
   *
   * @instance
   * @memberof ButtonTableColumn
   * @method _getCommands
   * @protected
   * @return {Array} The list of available commands.
   */

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default tableColumn
   * @memberof ButtonTableColumn
   * @property {String} key
   * @static
   */

	}, {
		key: '_getCommands',
		value: function _getCommands() {
			return this.props.commands || [{
				command: 'columnInsertBefore',
				label: AlloyEditor.Strings.columnInsertBefore
			}, {
				command: 'columnInsertAfter',
				label: AlloyEditor.Strings.columnInsertAfter
			}, {
				command: 'columnDelete',
				label: AlloyEditor.Strings.columnDelete
			}];
		}
	}]);

	return ButtonTableColumn;
}(_react2.default.Component);

ButtonTableColumn.key = 'tableColumn';
exports.default = ButtonTableColumn;

/***/ }),

/***/ "./src/components/buttons/button-table-edit.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-table-edit.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var KEY_ENTER = 13;
var KEY_ESC = 27;

var INPUT_NAMES = {
	COLS: 'cols',
	ROWS: 'rows'
};

var MINIMUM_GRID_VALUE = 1;

/**
 * The ButtonTableEdit class provides functionality for creating and editing a table in a document.
 * Provides UI for creating a table.
 *
 * @class ButtonTableEdit
 */

var ButtonTableEdit = function (_React$Component) {
	_inherits(ButtonTableEdit, _React$Component);

	/**
  * Lifecycle. Invoked once before the component is mounted.
  *
  * @instance
  * @memberof ButtonTableEdit
  * @method getInitialState
  */


	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonTableEdit
  * @method getDefaultProps
  */
	function ButtonTableEdit(props) {
		_classCallCheck(this, ButtonTableEdit);

		var _this = _possibleConstructorReturn(this, (ButtonTableEdit.__proto__ || Object.getPrototypeOf(ButtonTableEdit)).call(this, props));

		_this._createTable = function () {
			var editor = _this.context.editor.get('nativeEditor');
			var tableUtils = new CKEDITOR.Table(editor);

			tableUtils.create({
				attrs: _this.props.tableAttributes,
				cols: _this.state.cols,
				rows: _this.state.rows
			});

			_this.props.cancelExclusive();

			editor.fire('actionPerformed', _this);
		};

		_this._handleChange = function (inputName, event) {
			var state = {};

			if (inputName === INPUT_NAMES.COLS || inputName === INPUT_NAMES.ROWS) {
				state[inputName] = Math.min(event.target.value, MINIMUM_GRID_VALUE);
			} else {
				state[inputName] = event.target.value;
			}

			_this.setState(state);
		};

		_this._handleKeyDown = function (event) {
			if (event.keyCode === KEY_ENTER || event.keyCode === KEY_ESC) {
				event.preventDefault();
			}

			if (event.keyCode === KEY_ENTER) {
				_this._createTable();
			} else if (event.keyCode === KEY_ESC) {
				_this.props.cancelExclusive();
			}
		};

		_this.rowsRef = _react2.default.createRef();
		_this.colsRef = _react2.default.createRef();
		_this.state = {
			cols: 3,
			rows: 3
		};
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client (not on the server),
  * immediately after the initial rendering occurs.
  *
  * Focuses on the link input to immediately allow editing.
  *
  * @instance
  * @memberof ButtonTableEdit
  * @method componentDidMount
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default tableEdit
  * @memberof ButtonTableEdit
  * @property {String} key
  * @static
  */


	_createClass(ButtonTableEdit, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.rowsRef.current.focus();
		}

		/**
   * Creates a table.
   *
   * @instance
   * @memberof ButtonTableEdit
   * @method _createTable
   * @protected
   */


		/**
   * Handles a change in input value. Sets the provided value from the user back to the input.
   *
   * @instance
   * @memberof ButtonTableEdit
   * @method _handleChange
   * @param {String} inputName The name of the input which value should be updated.
   * @param {SyntheticEvent} event The provided event.
   * @protected
   */


		/**
   * Monitors key interaction inside the input element to respond to the keys:
   * - Enter: Creates the table.
   * - Escape: Discards the changes.
   *
   * @instance
   * @memberof ButtonTableEdit
   * @method _handleKeyDown
   * @param {SyntheticEvent} event The keyboard event.
   * @protected
   */

	}, {
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableEdit
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var time = Date.now();
			var rowsId = time + INPUT_NAMES.ROWS;
			var colsId = time + INPUT_NAMES.COLS;

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-edit-table' },
				_react2.default.createElement(
					'label',
					{ htmlFor: rowsId },
					AlloyEditor.Strings.rows
				),
				_react2.default.createElement(
					'div',
					{ className: 'ae-container-input small' },
					_react2.default.createElement('input', {
						className: 'ae-input',
						id: rowsId,
						min: MINIMUM_GRID_VALUE,
						onChange: this._handleChange.bind(this, INPUT_NAMES.ROWS),
						onKeyDown: this._handleKeyDown,
						placeholder: 'Rows',
						ref: this.rowsRef,
						type: 'number',
						value: this.state.rows
					})
				),
				_react2.default.createElement(
					'label',
					{ htmlFor: colsId },
					AlloyEditor.Strings.columns
				),
				_react2.default.createElement(
					'div',
					{ className: 'ae-container-input small' },
					_react2.default.createElement('input', {
						className: 'ae-input',
						id: colsId,
						min: MINIMUM_GRID_VALUE,
						onChange: this._handleChange.bind(this, INPUT_NAMES.COLS),
						onKeyDown: this._handleKeyDown,
						placeholder: 'Colums',
						ref: this.colsRef,
						type: 'number',
						value: this.state.cols
					})
				),
				_react2.default.createElement(
					'button',
					{
						'aria-label': 'Confirm',
						className: 'ae-button',
						onClick: this._createTable },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'check' })
				)
			);
		}
	}]);

	return ButtonTableEdit;
}(_react2.default.Component);

ButtonTableEdit.contextType = _editorContext2.default;
ButtonTableEdit.defaultProps = {
	tableAttributes: {
		border: 1,
		cellPadding: 0,
		cellSpacing: 0,
		style: 'table-layout: fixed; width: 100%;'
	}
};
ButtonTableEdit.key = 'tableEdit';
exports.default = ButtonTableEdit;

/***/ }),

/***/ "./src/components/buttons/button-table-heading.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-table-heading.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonTableHeading class provides functionality to work with table heading.
 *
 * @class ButtonTableHeading
 */
var ButtonTableHeading = function (_React$Component) {
	_inherits(ButtonTableHeading, _React$Component);

	function ButtonTableHeading() {
		_classCallCheck(this, ButtonTableHeading);

		return _possibleConstructorReturn(this, (ButtonTableHeading.__proto__ || Object.getPrototypeOf(ButtonTableHeading)).apply(this, arguments));
	}

	_createClass(ButtonTableHeading, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableHeading
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var buttonCommandsList = void 0;
			var buttonCommandsListId = void 0;

			if (this.props.expanded) {
				buttonCommandsListId = ButtonTableHeading.key + 'List';
				buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, {
					commands: this._getCommands(),
					listId: buttonCommandsListId,
					onDismiss: this.props.toggleDropdown
				});
			}

			var activeHeading = new CKEDITOR.Table(this.context.editor.get('nativeEditor')).getHeading();
			var activeHeadingIntro = AlloyEditor.Strings.headers + ':';
			var activeHeadingLabel = AlloyEditor.Strings['headers' + activeHeading];

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-dropdown-xl ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': '',
						className: 'ae-toolbar-element',
						onClick: this.props.toggleDropdown,
						role: 'combobox',
						tabIndex: this.props.tabIndex,
						title: '' },
					_react2.default.createElement(
						'div',
						{ className: 'ae-container' },
						_react2.default.createElement(
							'span',
							{ className: 'ae-container-dropdown-selected-item' },
							activeHeadingIntro,
							' ',
							_react2.default.createElement(
								'strong',
								null,
								activeHeadingLabel
							)
						),
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'caret-bottom' })
					)
				),
				buttonCommandsList
			);
		}

		/**
   * Returns a list of commands. If a list of commands was passed
   * as property `commands`, it will take a precedence over the default ones.
   *
   * @instance
   * @memberof ButtonTableHeading
   * @method _getCommands
   * @protected
   * @return {Array} The list of available commands.
   */


		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default tableRow
   * @memberof ButtonTableHeading
   * @property {String} key
   * @static
   */

	}, {
		key: '_getCommands',
		value: function _getCommands() {
			return this.props.commands || [{
				command: 'tableHeadingNone',
				label: AlloyEditor.Strings.headersNone
			}, {
				command: 'tableHeadingRow',
				label: AlloyEditor.Strings.headersRow
			}, {
				command: 'tableHeadingColumn',
				label: AlloyEditor.Strings.headersColumn
			}, {
				command: 'tableHeadingBoth',
				label: AlloyEditor.Strings.headersBoth
			}];
		}
	}]);

	return ButtonTableHeading;
}(_react2.default.Component);

ButtonTableHeading.contextType = _editorContext2.default;
ButtonTableHeading.key = 'tableHeading';
exports.default = ButtonTableHeading;

/***/ }),

/***/ "./src/components/buttons/button-table-remove.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-table-remove.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonTableRemove class provides functionality for removing a table
 *
 * @class ButtonTableRemove
 */
var ButtonTableRemove = function (_React$Component) {
	_inherits(ButtonTableRemove, _React$Component);

	function ButtonTableRemove() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonTableRemove);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonTableRemove.__proto__ || Object.getPrototypeOf(ButtonTableRemove)).call.apply(_ref, [this].concat(args))), _this), _this._removeTable = function () {
			var editor = _this.context.editor.get('nativeEditor');
			var tableUtils = new CKEDITOR.Table(editor);

			tableUtils.remove();

			editor.fire('actionPerformed', _this);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default tableRemove
  * @memberof ButtonTableRemove
  * @property {String} key
  * @static
  */


	_createClass(ButtonTableRemove, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableRemove
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.deleteTable,
					className: 'ae-button',
					'data-type': 'button-table-remove',
					onClick: this._removeTable,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.deleteTable },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'trash' })
			);
		}

		/**
   * Removes the table in the editor element.
   *
   * @instance
   * @memberof ButtonTableRemove
   * @method _removeTable
   * @protected
   */

	}]);

	return ButtonTableRemove;
}(_react2.default.Component);

ButtonTableRemove.contextType = _editorContext2.default;
ButtonTableRemove.key = 'tableRemove';
exports.default = ButtonTableRemove;

/***/ }),

/***/ "./src/components/buttons/button-table-row.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-table-row.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonTableRow class provides functionality to work with table rows.
 *
 * @class ButtonTableRow
 */
var ButtonTableRow = function (_React$Component) {
	_inherits(ButtonTableRow, _React$Component);

	function ButtonTableRow() {
		_classCallCheck(this, ButtonTableRow);

		return _possibleConstructorReturn(this, (ButtonTableRow.__proto__ || Object.getPrototypeOf(ButtonTableRow)).apply(this, arguments));
	}

	_createClass(ButtonTableRow, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableRow
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var buttonCommandsList = void 0;
			var buttonCommandsListId = void 0;

			if (this.props.expanded) {
				buttonCommandsListId = ButtonTableRow.key + 'List';
				buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, {
					commands: this._getCommands(),
					listId: buttonCommandsListId,
					onDismiss: this.props.toggleDropdown
				});
			}

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': AlloyEditor.Strings.row,
						'aria-owns': buttonCommandsListId,
						className: 'ae-button',
						onClick: this.props.toggleDropdown,
						role: 'combobox',
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.row },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'add-row' })
				),
				buttonCommandsList
			);
		}

		/**
   * Returns a list of commands. If a list of commands was passed
   * as property `commands`, it will take a precedence over the default ones.
   *
   * @instance
   * @memberof ButtonTableRow
   * @method _getCommands
   * @protected
   * @return {Array} The list of available commands.
   */

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default tableRow
   * @memberof ButtonTableRow
   * @property {String} key
   * @static
   */

	}, {
		key: '_getCommands',
		value: function _getCommands() {
			return this.props.commands || [{
				command: 'rowInsertBefore',
				label: AlloyEditor.Strings.rowInsertBefore
			}, {
				command: 'rowInsertAfter',
				label: AlloyEditor.Strings.rowInsertAfter
			}, {
				command: 'rowDelete',
				label: AlloyEditor.Strings.rowDelete
			}];
		}
	}]);

	return ButtonTableRow;
}(_react2.default.Component);

ButtonTableRow.key = 'tableRow';
exports.default = ButtonTableRow;

/***/ }),

/***/ "./src/components/buttons/button-table.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-table.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonTableEdit = __webpack_require__(/*! ./button-table-edit.jsx */ "./src/components/buttons/button-table-edit.jsx");

var _buttonTableEdit2 = _interopRequireDefault(_buttonTableEdit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonTable class provides functionality for creating and editing a table in a document. ButtonTable
 * renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonTableEdit UI with all the table edition controls.
 *
 * @class ButtonTable
 */
var ButtonTable = function (_React$Component) {
	_inherits(ButtonTable, _React$Component);

	function ButtonTable() {
		_classCallCheck(this, ButtonTable);

		return _possibleConstructorReturn(this, (ButtonTable.__proto__ || Object.getPrototypeOf(ButtonTable)).apply(this, arguments));
	}

	_createClass(ButtonTable, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTable
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.renderExclusive) {
				return _react2.default.createElement(_buttonTableEdit2.default, this.props);
			} else {
				return _react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.table,
						className: 'ae-button',
						'data-type': 'button-table',
						onClick: this.props.requestExclusive,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.table },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'table' })
				);
			}
		}
		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default table
   * @memberof ButtonTable
   * @property {String} key
   * @static
   */

	}]);

	return ButtonTable;
}(_react2.default.Component);

ButtonTable.key = 'table';
exports.default = ButtonTable;

/***/ }),

/***/ "./src/components/buttons/button-target-list.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-target-list.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonTargetList class provides functionality for changing the target of a link
 * in the document.
 *
 * @class ButtonTargetList
 * @uses WidgetFocusManager
 */
var ButtonTargetList = function (_React$Component) {
	_inherits(ButtonTargetList, _React$Component);

	function ButtonTargetList() {
		_classCallCheck(this, ButtonTargetList);

		return _possibleConstructorReturn(this, (ButtonTargetList.__proto__ || Object.getPrototypeOf(ButtonTargetList)).apply(this, arguments));
	}

	_createClass(ButtonTargetList, [{
		key: 'componentDidMount',


		/**
   * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
   *
   * @instance
   * @memberof ButtonTargetList
   * @method componentDidMount
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonTargetList
   * @method getDefaultProps
   */
		value: function componentDidMount() {
			_reactDom2.default.findDOMNode(this).focus();
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTargetList
   * @method render
   * @return {Object} The content which should be rendered.
   */


		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default linkTargetEdit
   * @memberof ButtonTargetList
   * @property {String} key
   * @static
   */

	}, {
		key: 'render',
		value: function render() {
			var listTargets = this._renderListTargets();

			return _react2.default.createElement(
				_buttonDropdown2.default,
				this.props,
				listTargets
			);
		}

		/**
   * Returns the the allowed link target items.
   *
   * @instance
   * @memberof ButtonTargetList
   * @method _getAllowedTargetItems
   * @protected
   * @return {Array} The allowed target items.
   */

	}, {
		key: '_getAllowedTargetItems',
		value: function _getAllowedTargetItems() {
			return this.props.allowedLinkTargets || [{
				label: AlloyEditor.Strings.linkTargetDefault,
				value: ''
			}, {
				label: AlloyEditor.Strings.linkTargetSelf,
				value: '_self'
			}, {
				label: AlloyEditor.Strings.linkTargetBlank,
				value: '_blank'
			}, {
				label: AlloyEditor.Strings.linkTargetParent,
				value: '_parent'
			}, {
				label: AlloyEditor.Strings.linkTargetTop,
				value: '_top'
			}];
		}

		/**
   * Renders the allowed link target items.
   *
   * @instance
   * @memberof ButtonTargetList
   * @method _renderListTargets
   * @protected
   * @return {Object} Returns the rendered link items
   */

	}, {
		key: '_renderListTargets',
		value: function _renderListTargets() {
			var _this2 = this;

			var targets = this._getAllowedTargetItems();

			var handleLinkTargetChange = this.props.handleLinkTargetChange;

			targets = targets.map(function (target) {
				var className = _this2.props.selectedTarget === target.value ? 'ae-toolbar-element active' : 'ae-toolbar-element';

				return _react2.default.createElement(
					'li',
					{ key: target.value, role: 'option' },
					_react2.default.createElement(
						'button',
						{
							className: className,
							'data-value': target.value,
							onClick: handleLinkTargetChange },
						target.label
					)
				);
			});

			return targets;
		}
	}]);

	return ButtonTargetList;
}(_react2.default.Component);

ButtonTargetList.defaultProps = {
	circular: true,
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	}
};
ButtonTargetList.key = 'targetList';
exports.default = (0, _widgetFocusManager2.default)(ButtonTargetList);

/***/ }),

/***/ "./src/components/buttons/button-twitter.jsx":
/*!***************************************************!*\
  !*** ./src/components/buttons/button-twitter.jsx ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var MAX_TWEET_LENGTH = 280;

/**
 * The ButtonTwitter class provides functionality for creating a link which
 * allows people to tweet part of the content in the editor.
 *
 * @class ButtonTwitter
 * @uses ButtonStateClasses
 */

var ButtonTwitter = function (_React$Component) {
	_inherits(ButtonTwitter, _React$Component);

	function ButtonTwitter() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonTwitter);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonTwitter.__proto__ || Object.getPrototypeOf(ButtonTwitter)).call.apply(_ref, [this].concat(args))), _this), _this.handleClick = function () {
			var editor = _this.context.editor.get('nativeEditor');

			var linkUtils = new CKEDITOR.Link(editor);

			if (_this.isActive()) {
				linkUtils.remove(linkUtils.getFromSelection());
			} else {
				linkUtils.create(_this._getHref(), {
					class: 'ae-twitter-link',
					target: '_blank'
				});
			}

			editor.fire('actionPerformed', _this);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default twitter
  * @memberof ButtonTwitter
  * @property {String} key
  * @static
  */


	/**
  * Creates or removes the twitter link on the selection.
  *
  * @instance
  * @memberof ButtonTwitter
  * @method handleClick
  */


	_createClass(ButtonTwitter, [{
		key: 'isActive',


		/**
   * Checks if the current selection is contained within a link that points to twitter.com/intent/tweet.
   *
   * @instance
   * @memberof ButtonTwitter
   * @method isActive
   * @return {Boolean} True if the selection is inside a twitter link, false otherwise.
   */
		value: function isActive() {
			var link = new CKEDITOR.Link(this.context.editor.get('nativeEditor')).getFromSelection();

			return link && link.getAttribute('href').indexOf('twitter.com/intent/tweet') !== -1;
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTwitter
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.twitter,
					className: cssClass,
					'data-type': 'button-twitter',
					onClick: this.handleClick,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.twitter },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'twitter' })
			);
		}

		/**
   * Generates the appropriate twitter url based on the selected text and the configuration
   * options received via props.
   *
   * @instance
   * @memberof ButtonTwitter
   * @method _getHref
   * @protected
   * @return {String} A valid twitter url with the selected text and given configuration.
   */

	}, {
		key: '_getHref',
		value: function _getHref() {
			var nativeEditor = this.context.editor.get('nativeEditor');
			var selectedText = nativeEditor.getSelection().getSelectedText().substring(0, MAX_TWEET_LENGTH);
			var url = this.props.url;
			var via = this.props.via;
			var twitterHref = 'https://twitter.com/intent/tweet?text=' + selectedText;

			if (url) {
				twitterHref += '&url=' + url;
			}

			if (via) {
				twitterHref += '&via=' + via;
			}

			return twitterHref;
		}
	}]);

	return ButtonTwitter;
}(_react2.default.Component);

ButtonTwitter.contextType = _editorContext2.default;
ButtonTwitter.key = 'twitter';
exports.default = (0, _buttonStateClasses2.default)(ButtonTwitter);

/***/ }),

/***/ "./src/components/buttons/button-ul.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-ul.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonUnorderedlist class provides functionality for creating unordered lists in an editor.
 *
 * @class ButtonUnorderedlist
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonUnorderedlist = function (_React$Component) {
	_inherits(ButtonUnorderedlist, _React$Component);

	function ButtonUnorderedlist() {
		_classCallCheck(this, ButtonUnorderedlist);

		return _possibleConstructorReturn(this, (ButtonUnorderedlist.__proto__ || Object.getPrototypeOf(ButtonUnorderedlist)).apply(this, arguments));
	}

	_createClass(ButtonUnorderedlist, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonUnorderedlist
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonUnorderedlist
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.bulletedlist,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-ul',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.bulletedlist },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'list-ul' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default ul
   * @memberof ButtonUnorderedlist
   * @property {String} key
   * @static
   */

	}]);

	return ButtonUnorderedlist;
}(_react2.default.Component);

ButtonUnorderedlist.defaultProps = {
	command: 'bulletedlist',
	style: {
		element: 'ul'
	}
};
ButtonUnorderedlist.key = 'ul';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonUnorderedlist)));

/***/ }),

/***/ "./src/components/buttons/button-underline.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-underline.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonUnderline class provides functionality for underlying a text selection.
 *
 * @class ButtonUnderline
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonUnderline = function (_React$Component) {
	_inherits(ButtonUnderline, _React$Component);

	function ButtonUnderline() {
		_classCallCheck(this, ButtonUnderline);

		return _possibleConstructorReturn(this, (ButtonUnderline.__proto__ || Object.getPrototypeOf(ButtonUnderline)).apply(this, arguments));
	}

	_createClass(ButtonUnderline, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonUnderline
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonUnderline
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.underline,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-underline',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.underline },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'underline' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default underline
   * @memberof ButtonUnderline
   * @property {String} key
   * @static
   */

	}]);

	return ButtonUnderline;
}(_react2.default.Component);

ButtonUnderline.defaultProps = {
	command: 'underline',
	keystroke: {
		fn: 'execCommand',
		keys: CKEDITOR.CTRL + 85 /* U*/
		, name: 'underline'
	},
	style: 'coreStyles_underline'
};
ButtonUnderline.key = 'underline';
exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonUnderline))));

/***/ }),

/***/ "./src/components/buttons/index.js":
/*!*****************************************!*\
  !*** ./src/components/buttons/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _ButtonAccessibilityI;

var _buttonAccessibilityImageAlt = __webpack_require__(/*! ./button-accessibility-image-alt.jsx */ "./src/components/buttons/button-accessibility-image-alt.jsx");

var _buttonAccessibilityImageAlt2 = _interopRequireDefault(_buttonAccessibilityImageAlt);

var _buttonBackgroundColor = __webpack_require__(/*! ./button-background-color.jsx */ "./src/components/buttons/button-background-color.jsx");

var _buttonBackgroundColor2 = _interopRequireDefault(_buttonBackgroundColor);

var _buttonBold = __webpack_require__(/*! ./button-bold.jsx */ "./src/components/buttons/button-bold.jsx");

var _buttonBold2 = _interopRequireDefault(_buttonBold);

var _buttonCameraImage = __webpack_require__(/*! ./button-camera-image.jsx */ "./src/components/buttons/button-camera-image.jsx");

var _buttonCameraImage2 = _interopRequireDefault(_buttonCameraImage);

var _buttonCamera = __webpack_require__(/*! ./button-camera.jsx */ "./src/components/buttons/button-camera.jsx");

var _buttonCamera2 = _interopRequireDefault(_buttonCamera);

var _buttonCode = __webpack_require__(/*! ./button-code.jsx */ "./src/components/buttons/button-code.jsx");

var _buttonCode2 = _interopRequireDefault(_buttonCode);

var _buttonColor = __webpack_require__(/*! ./button-color.jsx */ "./src/components/buttons/button-color.jsx");

var _buttonColor2 = _interopRequireDefault(_buttonColor);

var _buttonCommandListItem = __webpack_require__(/*! ./button-command-list-item.jsx */ "./src/components/buttons/button-command-list-item.jsx");

var _buttonCommandListItem2 = _interopRequireDefault(_buttonCommandListItem);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _buttonEmbedEdit = __webpack_require__(/*! ./button-embed-edit.jsx */ "./src/components/buttons/button-embed-edit.jsx");

var _buttonEmbedEdit2 = _interopRequireDefault(_buttonEmbedEdit);

var _buttonEmbedVideoEdit = __webpack_require__(/*! ./button-embed-video-edit.jsx */ "./src/components/buttons/button-embed-video-edit.jsx");

var _buttonEmbedVideoEdit2 = _interopRequireDefault(_buttonEmbedVideoEdit);

var _buttonEmbedVideo = __webpack_require__(/*! ./button-embed-video.jsx */ "./src/components/buttons/button-embed-video.jsx");

var _buttonEmbedVideo2 = _interopRequireDefault(_buttonEmbedVideo);

var _buttonEmbed = __webpack_require__(/*! ./button-embed.jsx */ "./src/components/buttons/button-embed.jsx");

var _buttonEmbed2 = _interopRequireDefault(_buttonEmbed);

var _buttonH = __webpack_require__(/*! ./button-h1.jsx */ "./src/components/buttons/button-h1.jsx");

var _buttonH2 = _interopRequireDefault(_buttonH);

var _buttonH3 = __webpack_require__(/*! ./button-h2.jsx */ "./src/components/buttons/button-h2.jsx");

var _buttonH4 = _interopRequireDefault(_buttonH3);

var _buttonHline = __webpack_require__(/*! ./button-hline.jsx */ "./src/components/buttons/button-hline.jsx");

var _buttonHline2 = _interopRequireDefault(_buttonHline);

var _buttonImageAlignCenter = __webpack_require__(/*! ./button-image-align-center.jsx */ "./src/components/buttons/button-image-align-center.jsx");

var _buttonImageAlignCenter2 = _interopRequireDefault(_buttonImageAlignCenter);

var _buttonImageAlignLeft = __webpack_require__(/*! ./button-image-align-left.jsx */ "./src/components/buttons/button-image-align-left.jsx");

var _buttonImageAlignLeft2 = _interopRequireDefault(_buttonImageAlignLeft);

var _buttonImageAlignRight = __webpack_require__(/*! ./button-image-align-right.jsx */ "./src/components/buttons/button-image-align-right.jsx");

var _buttonImageAlignRight2 = _interopRequireDefault(_buttonImageAlignRight);

var _buttonImage = __webpack_require__(/*! ./button-image.jsx */ "./src/components/buttons/button-image.jsx");

var _buttonImage2 = _interopRequireDefault(_buttonImage);

var _buttonIndentBlock = __webpack_require__(/*! ./button-indent-block.jsx */ "./src/components/buttons/button-indent-block.jsx");

var _buttonIndentBlock2 = _interopRequireDefault(_buttonIndentBlock);

var _buttonItalic = __webpack_require__(/*! ./button-italic.jsx */ "./src/components/buttons/button-italic.jsx");

var _buttonItalic2 = _interopRequireDefault(_buttonItalic);

var _buttonItemSelectorAudio = __webpack_require__(/*! ./button-item-selector-audio.jsx */ "./src/components/buttons/button-item-selector-audio.jsx");

var _buttonItemSelectorAudio2 = _interopRequireDefault(_buttonItemSelectorAudio);

var _buttonItemSelectorImage = __webpack_require__(/*! ./button-item-selector-image.jsx */ "./src/components/buttons/button-item-selector-image.jsx");

var _buttonItemSelectorImage2 = _interopRequireDefault(_buttonItemSelectorImage);

var _buttonItemSelectorVideo = __webpack_require__(/*! ./button-item-selector-video.jsx */ "./src/components/buttons/button-item-selector-video.jsx");

var _buttonItemSelectorVideo2 = _interopRequireDefault(_buttonItemSelectorVideo);

var _buttonLinkAutocompleteList = __webpack_require__(/*! ./button-link-autocomplete-list.jsx */ "./src/components/buttons/button-link-autocomplete-list.jsx");

var _buttonLinkAutocompleteList2 = _interopRequireDefault(_buttonLinkAutocompleteList);

var _buttonLinkBrowse = __webpack_require__(/*! ./button-link-browse.jsx */ "./src/components/buttons/button-link-browse.jsx");

var _buttonLinkBrowse2 = _interopRequireDefault(_buttonLinkBrowse);

var _buttonLinkEditBrowse = __webpack_require__(/*! ./button-link-edit-browse.jsx */ "./src/components/buttons/button-link-edit-browse.jsx");

var _buttonLinkEditBrowse2 = _interopRequireDefault(_buttonLinkEditBrowse);

var _buttonLinkEdit = __webpack_require__(/*! ./button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

var _buttonLinkTargetEdit = __webpack_require__(/*! ./button-link-target-edit.jsx */ "./src/components/buttons/button-link-target-edit.jsx");

var _buttonLinkTargetEdit2 = _interopRequireDefault(_buttonLinkTargetEdit);

var _buttonLink = __webpack_require__(/*! ./button-link.jsx */ "./src/components/buttons/button-link.jsx");

var _buttonLink2 = _interopRequireDefault(_buttonLink);

var _buttonOl = __webpack_require__(/*! ./button-ol.jsx */ "./src/components/buttons/button-ol.jsx");

var _buttonOl2 = _interopRequireDefault(_buttonOl);

var _buttonOutdentBlock = __webpack_require__(/*! ./button-outdent-block.jsx */ "./src/components/buttons/button-outdent-block.jsx");

var _buttonOutdentBlock2 = _interopRequireDefault(_buttonOutdentBlock);

var _buttonParagraphAlignLeft = __webpack_require__(/*! ./button-paragraph-align-left.jsx */ "./src/components/buttons/button-paragraph-align-left.jsx");

var _buttonParagraphAlignLeft2 = _interopRequireDefault(_buttonParagraphAlignLeft);

var _buttonParagraphAlignRight = __webpack_require__(/*! ./button-paragraph-align-right.jsx */ "./src/components/buttons/button-paragraph-align-right.jsx");

var _buttonParagraphAlignRight2 = _interopRequireDefault(_buttonParagraphAlignRight);

var _buttonParagraphAlign = __webpack_require__(/*! ./button-paragraph-align.jsx */ "./src/components/buttons/button-paragraph-align.jsx");

var _buttonParagraphAlign2 = _interopRequireDefault(_buttonParagraphAlign);

var _buttonParagraphCenter = __webpack_require__(/*! ./button-paragraph-center.jsx */ "./src/components/buttons/button-paragraph-center.jsx");

var _buttonParagraphCenter2 = _interopRequireDefault(_buttonParagraphCenter);

var _buttonParagraphJustify = __webpack_require__(/*! ./button-paragraph-justify.jsx */ "./src/components/buttons/button-paragraph-justify.jsx");

var _buttonParagraphJustify2 = _interopRequireDefault(_buttonParagraphJustify);

var _buttonQuote = __webpack_require__(/*! ./button-quote.jsx */ "./src/components/buttons/button-quote.jsx");

var _buttonQuote2 = _interopRequireDefault(_buttonQuote);

var _buttonRemoveFormat = __webpack_require__(/*! ./button-remove-format.jsx */ "./src/components/buttons/button-remove-format.jsx");

var _buttonRemoveFormat2 = _interopRequireDefault(_buttonRemoveFormat);

var _buttonRemoveImage = __webpack_require__(/*! ./button-remove-image.jsx */ "./src/components/buttons/button-remove-image.jsx");

var _buttonRemoveImage2 = _interopRequireDefault(_buttonRemoveImage);

var _buttonSeparator = __webpack_require__(/*! ./button-separator.jsx */ "./src/components/buttons/button-separator.jsx");

var _buttonSeparator2 = _interopRequireDefault(_buttonSeparator);

var _buttonSpacing = __webpack_require__(/*! ./button-spacing.jsx */ "./src/components/buttons/button-spacing.jsx");

var _buttonSpacing2 = _interopRequireDefault(_buttonSpacing);

var _buttonStrike = __webpack_require__(/*! ./button-strike.jsx */ "./src/components/buttons/button-strike.jsx");

var _buttonStrike2 = _interopRequireDefault(_buttonStrike);

var _buttonStylesListHeader = __webpack_require__(/*! ./button-styles-list-header.jsx */ "./src/components/buttons/button-styles-list-header.jsx");

var _buttonStylesListHeader2 = _interopRequireDefault(_buttonStylesListHeader);

var _buttonStylesListItemRemove = __webpack_require__(/*! ./button-styles-list-item-remove.jsx */ "./src/components/buttons/button-styles-list-item-remove.jsx");

var _buttonStylesListItemRemove2 = _interopRequireDefault(_buttonStylesListItemRemove);

var _buttonStylesListItem = __webpack_require__(/*! ./button-styles-list-item.jsx */ "./src/components/buttons/button-styles-list-item.jsx");

var _buttonStylesListItem2 = _interopRequireDefault(_buttonStylesListItem);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

var _buttonStyles = __webpack_require__(/*! ./button-styles.jsx */ "./src/components/buttons/button-styles.jsx");

var _buttonStyles2 = _interopRequireDefault(_buttonStyles);

var _buttonSubscript = __webpack_require__(/*! ./button-subscript.jsx */ "./src/components/buttons/button-subscript.jsx");

var _buttonSubscript2 = _interopRequireDefault(_buttonSubscript);

var _buttonSuperscript = __webpack_require__(/*! ./button-superscript.jsx */ "./src/components/buttons/button-superscript.jsx");

var _buttonSuperscript2 = _interopRequireDefault(_buttonSuperscript);

var _buttonTableCell = __webpack_require__(/*! ./button-table-cell.jsx */ "./src/components/buttons/button-table-cell.jsx");

var _buttonTableCell2 = _interopRequireDefault(_buttonTableCell);

var _buttonTableColumn = __webpack_require__(/*! ./button-table-column.jsx */ "./src/components/buttons/button-table-column.jsx");

var _buttonTableColumn2 = _interopRequireDefault(_buttonTableColumn);

var _buttonTableEdit = __webpack_require__(/*! ./button-table-edit.jsx */ "./src/components/buttons/button-table-edit.jsx");

var _buttonTableEdit2 = _interopRequireDefault(_buttonTableEdit);

var _buttonTableHeading = __webpack_require__(/*! ./button-table-heading.jsx */ "./src/components/buttons/button-table-heading.jsx");

var _buttonTableHeading2 = _interopRequireDefault(_buttonTableHeading);

var _buttonTableRemove = __webpack_require__(/*! ./button-table-remove.jsx */ "./src/components/buttons/button-table-remove.jsx");

var _buttonTableRemove2 = _interopRequireDefault(_buttonTableRemove);

var _buttonTableRow = __webpack_require__(/*! ./button-table-row.jsx */ "./src/components/buttons/button-table-row.jsx");

var _buttonTableRow2 = _interopRequireDefault(_buttonTableRow);

var _buttonTable = __webpack_require__(/*! ./button-table.jsx */ "./src/components/buttons/button-table.jsx");

var _buttonTable2 = _interopRequireDefault(_buttonTable);

var _buttonTargetList = __webpack_require__(/*! ./button-target-list.jsx */ "./src/components/buttons/button-target-list.jsx");

var _buttonTargetList2 = _interopRequireDefault(_buttonTargetList);

var _buttonTwitter = __webpack_require__(/*! ./button-twitter.jsx */ "./src/components/buttons/button-twitter.jsx");

var _buttonTwitter2 = _interopRequireDefault(_buttonTwitter);

var _buttonUl = __webpack_require__(/*! ./button-ul.jsx */ "./src/components/buttons/button-ul.jsx");

var _buttonUl2 = _interopRequireDefault(_buttonUl);

var _buttonUnderline = __webpack_require__(/*! ./button-underline.jsx */ "./src/components/buttons/button-underline.jsx");

var _buttonUnderline2 = _interopRequireDefault(_buttonUnderline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /**
                                                                                                                                                                                                                   * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                   * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                   */

exports.default = (_ButtonAccessibilityI = {}, _defineProperty(_ButtonAccessibilityI, _buttonAccessibilityImageAlt2.default.key, _buttonAccessibilityImageAlt2.default), _defineProperty(_ButtonAccessibilityI, _buttonBackgroundColor2.default.key, _buttonBackgroundColor2.default), _defineProperty(_ButtonAccessibilityI, _buttonBold2.default.key, _buttonBold2.default), _defineProperty(_ButtonAccessibilityI, _buttonCameraImage2.default.key, _buttonCameraImage2.default), _defineProperty(_ButtonAccessibilityI, _buttonCamera2.default.key, _buttonCamera2.default), _defineProperty(_ButtonAccessibilityI, _buttonCode2.default.key, _buttonCode2.default), _defineProperty(_ButtonAccessibilityI, _buttonColor2.default.key, _buttonColor2.default), _defineProperty(_ButtonAccessibilityI, _buttonCommandListItem2.default.key, _buttonCommandListItem2.default), _defineProperty(_ButtonAccessibilityI, _buttonCommandsList2.default.key, _buttonCommandsList2.default), _defineProperty(_ButtonAccessibilityI, _buttonDropdown2.default.key, _buttonDropdown2.default), _defineProperty(_ButtonAccessibilityI, _buttonEmbedEdit2.default.key, _buttonEmbedEdit2.default), _defineProperty(_ButtonAccessibilityI, _buttonEmbed2.default.key, _buttonEmbed2.default), _defineProperty(_ButtonAccessibilityI, _buttonEmbedVideoEdit2.default.key, _buttonEmbedVideoEdit2.default), _defineProperty(_ButtonAccessibilityI, _buttonEmbedVideo2.default.key, _buttonEmbedVideo2.default), _defineProperty(_ButtonAccessibilityI, _buttonH2.default.key, _buttonH2.default), _defineProperty(_ButtonAccessibilityI, _buttonH4.default.key, _buttonH4.default), _defineProperty(_ButtonAccessibilityI, _buttonHline2.default.key, _buttonHline2.default), _defineProperty(_ButtonAccessibilityI, _buttonImageAlignCenter2.default.key, _buttonImageAlignCenter2.default), _defineProperty(_ButtonAccessibilityI, _buttonImageAlignLeft2.default.key, _buttonImageAlignLeft2.default), _defineProperty(_ButtonAccessibilityI, _buttonImageAlignRight2.default.key, _buttonImageAlignRight2.default), _defineProperty(_ButtonAccessibilityI, _buttonImage2.default.key, _buttonImage2.default), _defineProperty(_ButtonAccessibilityI, _buttonIndentBlock2.default.key, _buttonIndentBlock2.default), _defineProperty(_ButtonAccessibilityI, _buttonItalic2.default.key, _buttonItalic2.default), _defineProperty(_ButtonAccessibilityI, _buttonItemSelectorAudio2.default.key, _buttonItemSelectorAudio2.default), _defineProperty(_ButtonAccessibilityI, _buttonItemSelectorImage2.default.key, _buttonItemSelectorImage2.default), _defineProperty(_ButtonAccessibilityI, _buttonItemSelectorVideo2.default.key, _buttonItemSelectorVideo2.default), _defineProperty(_ButtonAccessibilityI, _buttonLinkAutocompleteList2.default.key, _buttonLinkAutocompleteList2.default), _defineProperty(_ButtonAccessibilityI, _buttonLinkBrowse2.default.key, _buttonLinkBrowse2.default), _defineProperty(_ButtonAccessibilityI, _buttonLinkEditBrowse2.default.key, _buttonLinkEditBrowse2.default), _defineProperty(_ButtonAccessibilityI, _buttonLinkEdit2.default.key, _buttonLinkEdit2.default), _defineProperty(_ButtonAccessibilityI, _buttonLinkTargetEdit2.default.key, _buttonLinkTargetEdit2.default), _defineProperty(_ButtonAccessibilityI, _buttonLink2.default.key, _buttonLink2.default), _defineProperty(_ButtonAccessibilityI, _buttonOl2.default.key, _buttonOl2.default), _defineProperty(_ButtonAccessibilityI, _buttonOutdentBlock2.default.key, _buttonOutdentBlock2.default), _defineProperty(_ButtonAccessibilityI, _buttonParagraphAlign2.default.key, _buttonParagraphAlign2.default), _defineProperty(_ButtonAccessibilityI, _buttonParagraphAlignLeft2.default.key, _buttonParagraphAlignLeft2.default), _defineProperty(_ButtonAccessibilityI, _buttonParagraphAlignRight2.default.key, _buttonParagraphAlignRight2.default), _defineProperty(_ButtonAccessibilityI, _buttonParagraphCenter2.default.key, _buttonParagraphCenter2.default), _defineProperty(_ButtonAccessibilityI, _buttonParagraphJustify2.default.key, _buttonParagraphJustify2.default), _defineProperty(_ButtonAccessibilityI, _buttonQuote2.default.key, _buttonQuote2.default), _defineProperty(_ButtonAccessibilityI, _buttonRemoveFormat2.default.key, _buttonRemoveFormat2.default), _defineProperty(_ButtonAccessibilityI, _buttonRemoveImage2.default.key, _buttonRemoveImage2.default), _defineProperty(_ButtonAccessibilityI, _buttonSeparator2.default.key, _buttonSeparator2.default), _defineProperty(_ButtonAccessibilityI, _buttonSpacing2.default.key, _buttonSpacing2.default), _defineProperty(_ButtonAccessibilityI, _buttonStrike2.default.key, _buttonStrike2.default), _defineProperty(_ButtonAccessibilityI, _buttonStylesListHeader2.default.key, _buttonStylesListHeader2.default), _defineProperty(_ButtonAccessibilityI, _buttonStylesListItemRemove2.default.key, _buttonStylesListItemRemove2.default), _defineProperty(_ButtonAccessibilityI, _buttonStylesListItem2.default.key, _buttonStylesListItem2.default), _defineProperty(_ButtonAccessibilityI, _buttonStylesList2.default.key, _buttonStylesList2.default), _defineProperty(_ButtonAccessibilityI, _buttonStyles2.default.key, _buttonStyles2.default), _defineProperty(_ButtonAccessibilityI, _buttonSubscript2.default.key, _buttonSubscript2.default), _defineProperty(_ButtonAccessibilityI, _buttonSuperscript2.default.key, _buttonSuperscript2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableCell2.default.key, _buttonTableCell2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableColumn2.default.key, _buttonTableColumn2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableEdit2.default.key, _buttonTableEdit2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableHeading2.default.key, _buttonTableHeading2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableRemove2.default.key, _buttonTableRemove2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableRow2.default.key, _buttonTableRow2.default), _defineProperty(_ButtonAccessibilityI, _buttonTable2.default.key, _buttonTable2.default), _defineProperty(_ButtonAccessibilityI, _buttonTargetList2.default.key, _buttonTargetList2.default), _defineProperty(_ButtonAccessibilityI, _buttonTwitter2.default.key, _buttonTwitter2.default), _defineProperty(_ButtonAccessibilityI, _buttonUl2.default.key, _buttonUl2.default), _defineProperty(_ButtonAccessibilityI, _buttonUnderline2.default.key, _buttonUnderline2.default), _ButtonAccessibilityI);

/***/ }),

/***/ "./src/components/compat/button-action-style.js":
/*!******************************************************!*\
  !*** ./src/components/compat/button-action-style.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * ButtonActionStyle is a mixin that provides applying style
 * implementation for a button based on the `applyStyle` and
 * `removeStyle` API of CKEDITOR.
 *
 * To execute properly, the component has to expose the following
 * methods which can be obtained out of the box using the {{#crossLink
 * "ButtonStyle"}}{{/crossLink}} mixin:
 * - `Function` {{#crossLink "ButtonStyle/isActive"}}{{/crossLink}} to
 *    check the active state
 * - `Function` {{#crossLink "ButtonStyle/getStyle"}}{{/crossLink}} to
 *    return the style that should be applied
 *
 * @class ButtonActionStyle
 */
var ButtonActionStyle = {
	/**
  * Removes or applies the component style to the current selection.
  *
  * @instance
  * @memberof ButtonActionStyle
  * @method applyStyle
  */
	applyStyle: function applyStyle() {
		if (_lang2.default.isFunction(this.isActive) && _lang2.default.isFunction(this.getStyle)) {
			var editor = this.props.editor.get('nativeEditor');

			editor.getSelection().lock();

			if (this.isActive()) {
				editor.removeStyle(this.getStyle());
			} else {
				editor.applyStyle(this.getStyle());
			}

			editor.getSelection().unlock();

			editor.fire('actionPerformed', this);
		}
	}
}; /**
    * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
    * SPDX-License-Identifier: LGPL-3.0-or-later
    */

exports.default = ButtonActionStyle;

/***/ }),

/***/ "./src/components/compat/button-command-active.js":
/*!********************************************************!*\
  !*** ./src/components/compat/button-command-active.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * ButtonCommandActive is a mixin that provides an `isActive` method to
 * determine if a context-aware command is currently in an active state.
 *
 * @class ButtonCommandActive
 */
var ButtonCommandActive = {
	/**
  * Checks if the command is active in the current selection.
  *
  * @instance
  * @memberof ButtonCommandActive
  * @method isActive
  * @return {Boolean} True if the command is active, false otherwise.
  */
	isActive: function isActive() {
		var editor = this.props.editor.get('nativeEditor');

		var command = editor.getCommand(this.props.command);

		return command ? command.state === CKEDITOR.TRISTATE_ON : false;
	}
};

exports.default = ButtonCommandActive;

/***/ }),

/***/ "./src/components/compat/button-command.js":
/*!*************************************************!*\
  !*** ./src/components/compat/button-command.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * ButtonCommand is a mixin that executes a command via CKEDITOR's API.
 *
 * @class ButtonCommand
 */
var ButtonCommand = {
	// Allows validating props being passed to the component.
	propTypes: {
		/**
   * The command that should be executed.
   *
   * @instance
   * @memberof ButtonCommand
   * @property {String} command
   */
		command: _propTypes2.default.string.isRequired,

		/**
   * Indicates that the command may cause the editor to have a different.
   *
   * @instance
   * @memberof ButtonCommand
   * @property {boolean} modifiesSelection
   */
		modifiesSelection: _propTypes2.default.bool
	},

	/**
  * Executes a CKEditor command and fires `actionPerformed` event.
  *
  * @instance
  * @memberof ButtonCommand
  * @param {Object=} data Optional data to be passed to CKEDITOR's `execCommand` method.
  * @method execCommand
  */
	execCommand: function execCommand(data) {
		var editor = this.props.editor.get('nativeEditor');

		editor.execCommand(this.props.command, data);

		if (this.props.modifiesSelection) {
			editor.selectionChange(true);
		}

		editor.fire('actionPerformed', this);
	}
}; /**
    * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
    * SPDX-License-Identifier: LGPL-3.0-or-later
    */

exports.default = ButtonCommand;

/***/ }),

/***/ "./src/components/compat/button-keystroke.js":
/*!***************************************************!*\
  !*** ./src/components/compat/button-keystroke.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * ButtonKeystroke is a mixin that provides a `keystroke` prop that allows configuring
 * a function of the instance to be invoked upon the keystroke activation.
 *
 * @class ButtonKeystroke
 */
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var ButtonKeystroke = {
	// Allows validating props being passed to the component.
	propTypes: {
		/**
   * The keystroke definition. An object with the following properties:
   * - fn: The function to be executed
   * - keys: The keystroke definition, as expected by http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-setKeystroke
   * - name: The name for the CKEditor command that will be created. If empty,
   * a random name will be created on the fly
   *
   * @instance
   * @memberof ButtonKeystroke
   * @property {Object} keystroke
   */
		keystroke: _propTypes2.default.object.isRequired
	},

	/**
  * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
  *
  * @instance
  * @memberof ButtonKeystroke
  * @method componentWillMount
  */
	componentWillMount: function componentWillMount() {
		var nativeEditor = this.props.editor.get('nativeEditor');
		var keystroke = this.props.keystroke;

		var commandName = keystroke.name || (Math.random() * 1e9 >>> 0).toString();

		var command = nativeEditor.getCommand(commandName);

		if (!command) {
			command = new CKEDITOR.command(nativeEditor, {
				exec: function (editor) {
					var keystrokeFn = keystroke.fn;

					if (_lang2.default.isString(keystrokeFn)) {
						this[keystrokeFn].call(this, editor);
					} else if (_lang2.default.isFunction(keystrokeFn)) {
						keystrokeFn.call(this, editor);
					}
				}.bind(this)
			});

			nativeEditor.addCommand(commandName, command);
		}

		this._defaultKeystrokeCommand = nativeEditor.keystrokeHandler.keystrokes[keystroke.keys];

		nativeEditor.setKeystroke(keystroke.keys, commandName);
	},


	/**
  * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
  *
  * @instance
  * @memberof ButtonKeystroke
  * @method componentWillUnmount
  */
	componentWillUnmount: function componentWillUnmount() {
		this.props.editor.get('nativeEditor').setKeystroke(this.props.keystroke.keys, this._defaultKeystrokeCommand);
	}
};

exports.default = ButtonKeystroke;

/***/ }),

/***/ "./src/components/compat/button-props.js":
/*!***********************************************!*\
  !*** ./src/components/compat/button-props.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _buttonLinkEdit = __webpack_require__(/*! ../buttons/button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * ButtonProps is a mixin that provides a style prop and some methods to apply the resulting
 * style and checking if it is present in a given path or selection.
 *
 * @class ButtonProps
 */
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var ButtonProps = {
	// Allows validating props being passed to the component.
	propTypes: {
		/**
   * The editor instance where the component is being used.
   *
   * @instance
   * @memberof ButtonProps
   * @property {Object} editor
   */
		editor: _propTypes2.default.object.isRequired
	},

	/**
  * Merges the properties, passed to the current component with user's configuration
  * via `buttonCfg` property.
  *
  * @instance
  * @memberof ButtonProps
  * @method mergeButtonCfgProps
  * @param {Object} props The properties to be merged with the provided configuration for this
  * button. If not passed, the user configuration will be merged with `this.props`
  * @return {Object} The merged properties
  */
	mergeButtonCfgProps: function mergeButtonCfgProps(props) {
		props = props || this.props;

		var nativeEditor = this.props.editor.get('nativeEditor');
		var buttonCfg = nativeEditor.config.buttonCfg || {};
		var result = CKEDITOR.tools.merge(props, buttonCfg[_buttonLinkEdit2.default.key]);

		return result;
	}
};

exports.default = ButtonProps;

/***/ }),

/***/ "./src/components/compat/button-state-classes.js":
/*!*******************************************************!*\
  !*** ./src/components/compat/button-state-classes.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * ButtonStateClasses is a mixin that decorates the domElement of a component
 * with different CSS classes based on the current state of the element.
 *
 * To check for state, the component can expose the following methods:
 * - `Function` **isActive** to check the active state
 * - `Function` **isDisabled** to check the disabled state
 *
 * @class ButtonStateClasses
 */
var ButtonStateClasses = {
	/**
  * Returns the list of state classes associated to the current element's state, according
  * to the results of the isActive and isDisabled methods.
  *
  * @instance
  * @memberof ButtonStateClasses
  * @method getStateClasses
  * @return {String} A string with the state CSS classes.
  */
	getStateClasses: function getStateClasses() {
		var stateClasses = '';

		// Check for active state
		if (_lang2.default.isFunction(this.isActive) && this.isActive()) {
			stateClasses += 'ae-button-pressed';
		}

		// Check for disabled state
		if (_lang2.default.isFunction(this.isDisabled) && this.isDisabled()) {
			stateClasses += ' ae-button-disabled';
		}

		return stateClasses;
	}
}; /**
    * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
    * SPDX-License-Identifier: LGPL-3.0-or-later
    */

exports.default = ButtonStateClasses;

/***/ }),

/***/ "./src/components/compat/button-style.js":
/*!***********************************************!*\
  !*** ./src/components/compat/button-style.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * ButtonStyle is a mixin that provides a style prop and some methods to
 * apply the resulting style and checking if it is present in a given
 * path or selection.
 *
 * @class ButtonStyle
 */
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var ButtonStyle = {
	// Allows validating props being passed to the component.
	propTypes: {
		/**
   * The style the button should handle. Allowed values are:
   * - Object as described by
   *   http://docs.ckeditor.com/#!/api/CKEDITOR.style.
   * - String pointing to an object inside the editor instance
   *   configuration. For example, `style = 'coreStyles_bold'` will
   *   try to retrieve the style object from
   *   `editor.config.coreStyles_bold`. Nested properties such as
   *   `style = 'myplugin.myConfig.myStyle'` are also supported
   *   and will try to retrieve the style object from the editor
   *   configuration as well.
   *
   * @instance
   * @memberof ButtonStyle
   * @property {Object|String} style
   */
		style: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.string]),

		/**
   * The style function the button should handle.
   * If specified, style function has higher priority than style property.
   *
   * @instance
   * @memberof ButtonStyle
   * @property {function} styleFn
   */
		styleFn: _propTypes2.default.func
	},

	/**
  * Lifecycle. Invoked once, both on the client and server,
  * immediately before the initial rendering occurs.
  *
  * @instance
  * @memberof ButtonStyle
  * @method componentWillMount
  */
	componentWillMount: function componentWillMount() {
		var style = this.props.style;

		if (_lang2.default.isString(style)) {
			var parts = style.split('.');
			var currentMember = this.props.editor.get('nativeEditor').config;
			var property = parts.shift();

			while (property && _lang2.default.isObject(currentMember) && _lang2.default.isObject(currentMember[property])) {
				currentMember = currentMember[property];
				property = parts.shift();
			}

			if (_lang2.default.isObject(currentMember)) {
				style = currentMember;
			}
		}

		this._style = new CKEDITOR.style(style);
	},


	/**
  * Lifecycle. Invoked immediately before a component is unmounted
  * from the DOM.
  *
  * @instance
  * @memberof ButtonStyle
  * @method componentWillUnmount
  */
	componentWillUnmount: function componentWillUnmount() {
		this._style = null;
	},


	/**
  * Returns instance of CKEDITOR.style which represents the current
  * button style.
  *
  * @instance
  * @memberof ButtonStyle
  * @method getStyle
  * @return {CKEDITOR.style} The current style representation.
  */
	getStyle: function getStyle() {
		return this._style;
	},


	/**
  * Checks if style is active in the current selection.
  *
  * @instance
  * @memberof ButtonStyle
  * @method isActive
  * @return {Boolean} True if style is active, false otherwise.
  */
	isActive: function isActive() {
		var editor = this.props.editor.get('nativeEditor');

		var elementPath = editor.elementPath();

		return this.getStyle().checkActive(elementPath, editor);
	}
};

exports.default = ButtonStyle;

/***/ }),

/***/ "./src/components/compat/index.js":
/*!****************************************!*\
  !*** ./src/components/compat/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _buttonActionStyle = __webpack_require__(/*! ./button-action-style */ "./src/components/compat/button-action-style.js");

Object.defineProperty(exports, 'ButtonActionStyle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonActionStyle).default;
  }
});

var _buttonCommandActive = __webpack_require__(/*! ./button-command-active */ "./src/components/compat/button-command-active.js");

Object.defineProperty(exports, 'ButtonCommandActive', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonCommandActive).default;
  }
});

var _buttonCommand = __webpack_require__(/*! ./button-command */ "./src/components/compat/button-command.js");

Object.defineProperty(exports, 'ButtonCommand', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonCommand).default;
  }
});

var _buttonKeystroke = __webpack_require__(/*! ./button-keystroke */ "./src/components/compat/button-keystroke.js");

Object.defineProperty(exports, 'ButtonKeystroke', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonKeystroke).default;
  }
});

var _buttonProps = __webpack_require__(/*! ./button-props */ "./src/components/compat/button-props.js");

Object.defineProperty(exports, 'ButtonProps', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonProps).default;
  }
});

var _buttonStateClasses = __webpack_require__(/*! ./button-state-classes */ "./src/components/compat/button-state-classes.js");

Object.defineProperty(exports, 'ButtonStateClasses', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonStateClasses).default;
  }
});

var _buttonStyle = __webpack_require__(/*! ./button-style */ "./src/components/compat/button-style.js");

Object.defineProperty(exports, 'ButtonStyle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonStyle).default;
  }
});

var _toolbarButtons = __webpack_require__(/*! ./toolbar-buttons */ "./src/components/compat/toolbar-buttons.js");

Object.defineProperty(exports, 'ToolbarButtons', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_toolbarButtons).default;
  }
});

var _widgetArrowBox = __webpack_require__(/*! ./widget-arrow-box */ "./src/components/compat/widget-arrow-box.js");

Object.defineProperty(exports, 'WidgetArrowBox', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetArrowBox).default;
  }
});

var _widgetDropdown = __webpack_require__(/*! ./widget-dropdown */ "./src/components/compat/widget-dropdown.js");

Object.defineProperty(exports, 'WidgetDropdown', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetDropdown).default;
  }
});

var _widgetExclusive = __webpack_require__(/*! ./widget-exclusive */ "./src/components/compat/widget-exclusive.js");

Object.defineProperty(exports, 'WidgetExclusive', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetExclusive).default;
  }
});

var _widgetFocusManager = __webpack_require__(/*! ./widget-focus-manager */ "./src/components/compat/widget-focus-manager.js");

Object.defineProperty(exports, 'WidgetFocusManager', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetFocusManager).default;
  }
});

var _widgetInteractionPoint = __webpack_require__(/*! ./widget-interaction-point */ "./src/components/compat/widget-interaction-point.js");

Object.defineProperty(exports, 'WidgetInteractionPoint', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetInteractionPoint).default;
  }
});

var _widgetPosition = __webpack_require__(/*! ./widget-position */ "./src/components/compat/widget-position.js");

Object.defineProperty(exports, 'WidgetPosition', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetPosition).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "./src/components/compat/toolbar-buttons.js":
/*!**************************************************!*\
  !*** ./src/components/compat/toolbar-buttons.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * ToolbarButtons is a mixin which provides a list of buttons which have
 * to be displayed on the current toolbar depending on user preferences
 * and given state.
 *
 * @class ToolbarButtons
 */
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var ToolbarButtons = {
	/**
  * Analyses the current selection and returns the buttons or button
  * groups to be rendered.
  *
  * @instance
  * @method getToolbarButtonGroups
  * @param {Array} buttons The buttons could be shown, prior to the state filtering.
  * @param {Object} additionalProps Additional props that should be passed down to the buttons.
  * @return {Array} An Array which contains the buttons or button groups that should be rendered.
  */
	getToolbarButtonGroups: function getToolbarButtonGroups(buttons, additionalProps) {
		var instance = this;

		if (_lang2.default.isFunction(buttons)) {
			buttons = buttons.call(this) || [];
		}

		return buttons.reduce(function (list, button) {
			if (Array.isArray(button)) {
				list.push(instance.getToolbarButtons(button, additionalProps));
				return list;
			} else {
				return instance.getToolbarButtons(buttons, additionalProps);
			}
		}, []);
	},


	/**
  * Analyzes the current selection and the buttons exclusive mode value to figure out which
  * buttons should be present in a given state.
  *
  * @instance
  * @memberof ToolbarButtons
  * @method getToolbarButtons
  * @param {Array} buttons The buttons could be shown, prior to the state filtering.
  * @param {Object} additionalProps Additional props that should be passed down to the buttons.
  * @return {Array} An Array which contains the buttons that should be rendered.
  */
	getToolbarButtons: function getToolbarButtons(buttons, additionalProps) {
		var buttonProps = {};

		var nativeEditor = this.props.editor.get('nativeEditor');
		var buttonCfg = nativeEditor.config.buttonCfg || {};

		if (_lang2.default.isFunction(buttons)) {
			buttons = buttons.call(this) || [];
		}

		var toolbarButtons = this.filterExclusive(buttons.filter(function (button) {
			return button && (AlloyEditor.Buttons[button] || AlloyEditor.Buttons[button.name]);
		}).map(function (button) {
			if (_lang2.default.isString(button)) {
				buttonProps[button] = buttonCfg[button];
				button = AlloyEditor.Buttons[button];
			} else if (_lang2.default.isString(button.name)) {
				buttonProps[AlloyEditor.Buttons[button.name].key] = CKEDITOR.tools.merge(buttonCfg[button], button.cfg);
				button = AlloyEditor.Buttons[button.name];
			}

			return button;
		})).map(function (button, index) {
			var props = this.mergeExclusiveProps({
				editor: this.props.editor,
				key: button.key !== 'separator' ? button.key : button.key + '-' + index,
				tabKey: button.key,
				tabIndex: this.props.trigger && this.props.trigger.props.tabKey === button.key ? 0 : -1,
				trigger: this.props.trigger
			}, button.key);

			props = this.mergeDropdownProps(props, button.key);

			if (additionalProps) {
				props = CKEDITOR.tools.merge(props, additionalProps);
			}

			props = CKEDITOR.tools.merge(props, buttonProps[button.key]);

			return _react2.default.createElement(button, props);
		}, this);

		return toolbarButtons;
	}
};

exports.default = ToolbarButtons;

/***/ }),

/***/ "./src/components/compat/widget-arrow-box.js":
/*!***************************************************!*\
  !*** ./src/components/compat/widget-arrow-box.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Provides functionality for displaying Widget Arrow box on top or on bottom of the widget
 * depending on the point of user interaction with the editor.
 *
 * @class WidgetArrowBox
 */
var WidgetArrowBox = {
	/**
  * Returns the list of arrow box classes associated to the current element's state. It relies
  * on the getInteractionPoint method to calculate the selection direction.
  *
  * @instance
  * @memberof WidgetArrowBox
  * @method getArrowBoxClasses
  * @return {String} A string with the arrow box CSS classes.
  */
	getArrowBoxClasses: function getArrowBoxClasses() {
		var arrowBoxClasses = 'ae-arrow-box';

		if (_lang2.default.isFunction(this.getInteractionPoint) && this.getInteractionPoint()) {
			if (this.getInteractionPoint().direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
				arrowBoxClasses += ' ae-arrow-box-top';
			} else {
				arrowBoxClasses += ' ae-arrow-box-bottom';
			}
		}

		return arrowBoxClasses;
	}
}; /**
    * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
    * SPDX-License-Identifier: LGPL-3.0-or-later
    */

exports.default = WidgetArrowBox;

/***/ }),

/***/ "./src/components/compat/widget-dropdown.js":
/*!**************************************************!*\
  !*** ./src/components/compat/widget-dropdown.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Provides functionality for managing different dropdowns inside a widget.
 *
 * @class WidgetDropdown
 */
var WidgetDropdown = {
	/**
  * Lifecycle. Invoked when a component is receiving new props.
  * This method is not called for the initial render.
  *
  * @instance
  * @memberof WidgetDropdown
  * @method componentWillReceiveProps
  */
	componentWillReceiveProps: function componentWillReceiveProps(_nextProps) {
		this.setState({
			dropdownTrigger: null,
			itemDropdown: null
		});
	},


	/**
  * Lifecycle. Invoked once before the component is mounted.
  *
  * @instance
  * @memberof WidgetDropdown
  * @method getInitialState
  */
	getInitialState: function getInitialState() {
		return {
			dropdownTrigger: null,
			itemDropdown: null
		};
	},


	/**
  * Merges the provided object with two more properties:
  * - expanded - boolean flag which indicates if an widget should be
  *   rendered exclusively.
  * - toggleDropdown - function, which can be used by an widget in
  *   order to obtain exclusive state.
  *
  * @instance
  * @memberof WidgetDropdown
  * @method mergeDropdownProps
  * @param {Object} obj The properties container which should be merged with the properties, related
  *    to dropdown state.
  * @param {Object} itemKey They key of an React Widget which contains the dropdown.
  * @return {Object} The merged object.
  */
	mergeDropdownProps: function mergeDropdownProps(obj, itemKey) {
		return CKEDITOR.tools.merge(obj, {
			expanded: this.state.itemDropdown === itemKey ? true : false,
			tabIndex: this.state.dropdownTrigger === itemKey ? 0 : -1,
			toggleDropdown: this.toggleDropdown.bind(this, itemKey)
		});
	},


	/**
  * Sets the active dropdown of the widget or discards the toggled
  * item from the state.
  *
  * @instance
  * @memberof WidgetDropdown
  * @method toggleDropdown
  * @param {Object} itemDropdown The widget which requests to toggle its dropdown.
  * @param {Number} toggleDirection User movement direction when toggled via keyboard.
  */
	toggleDropdown: function toggleDropdown(itemDropdown, toggleDirection) {
		this.setState({
			dropdownTrigger: itemDropdown,
			itemDropdown: itemDropdown !== this.state.itemDropdown ? itemDropdown : null
		}, function () {
			if (!this.state.itemDropdown) {
				if (this.moveFocus) {
					this.moveFocus(toggleDirection);
				} else {
					_reactDom2.default.findDOMNode(this).focus();
				}
			}
		});
	}
}; /**
    * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
    * SPDX-License-Identifier: LGPL-3.0-or-later
    */

exports.default = WidgetDropdown;

/***/ }),

/***/ "./src/components/compat/widget-exclusive.js":
/*!***************************************************!*\
  !*** ./src/components/compat/widget-exclusive.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * Provides functionality for managing exclusive state of an widget.
 * The exclusive state means that a button may request to be the only rendered
 * widget in its parent container. WidgetExclusive will manage this state by
 * filtering and suppressing the other sibling widgets from displaying.
 *
 * @class WidgetExclusive
 */
var WidgetExclusive = {
	/**
  * Cancels the exclusive state of an widget.
  *
  * @instance
  * @memberof WidgetExclusive
  * @method cancelExclusive
  * @param {Object} itemExclusive The widget which exclusive state should be canceled.
  */
	cancelExclusive: function cancelExclusive(itemExclusive) {
		if (this.state.itemExclusive === itemExclusive) {
			this.setState({
				itemExclusive: null
			});
		}
	},


	/**
  * Lifecycle. Invoked when a component is receiving new props.
  * This method is not called for the initial render.
  * Calling this.setState() within this function will not trigger an
  * additional render.
  *
  * @instance
  * @memberof WidgetExclusive
  * @method componentWillReceiveProps
  * @param {Object} nextProps Object containing the current set of properties.
  */
	componentWillReceiveProps: function componentWillReceiveProps(_nextProps) {
		// Receiving properties means that the component is being
		// re-rendered.  Re-rendering is triggered by editorInteraction,
		// so we have to reset the exclusive state and render the UI
		// according to the new selection.
		this.setState({
			itemExclusive: null
		});
	},


	/**
  * Filters the items and returns only those with exclusive state.
  *
  * @instance
  * @memberof WidgetExclusive
  * @method filterExclusive
  * @param {Array} items The widgets to be filtered.
  * @return {Array|Object} The item with executive state.
  */
	filterExclusive: function filterExclusive(items) {
		var _this = this;

		return items.filter(function (item) {
			if (_this.state.itemExclusive) {
				if (_this.state.itemExclusive === item.key) {
					return item;
				}
			} else {
				return item;
			}
		});
	},


	/**
  * Merges the provided object with three more properties:
  * - cancelExclusive - function, which can be used by a widget in
  *   order to cancel executive state.
  * - renderExclusive - boolean flag which indicates if an widget
  *   should be rendered exclusively.
  * - requestExclusive - function, which can be used by a widget in
  *   order to obtain exclusive state.
  *
  * @instance
  * @memberof WidgetExclusive
  * @method mergeExclusiveProps
  * @param {Object} obj The properties container which should be merged with the properties, related
  *    to exclusive state.
  * @param {Object} itemKey They key of an React Widget which should be rendered exclusively.
  * @return {Object} The merged object.
  */
	mergeExclusiveProps: function mergeExclusiveProps(obj, itemKey) {
		return CKEDITOR.tools.merge(obj, {
			cancelExclusive: this.cancelExclusive.bind(this, itemKey),
			renderExclusive: this.state.itemExclusive === itemKey,
			requestExclusive: this.requestExclusive.bind(this, itemKey)
		});
	},


	/**
  * Requests and sets exclusive state of an widget.
  *
  * @instance
  * @memberof WidgetExclusive
  * @method requestExclusive
  * @param {Object} itemExclusive The widget which requests exclusive state.
  */
	requestExclusive: function requestExclusive(itemExclusive) {
		this.setState({
			itemExclusive: itemExclusive
		});
	}
};

exports.default = WidgetExclusive;

/***/ }),

/***/ "./src/components/compat/widget-focus-manager.js":
/*!*******************************************************!*\
  !*** ./src/components/compat/widget-focus-manager.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DIRECTION_NONE = 0; /**
                         * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                         * SPDX-License-Identifier: LGPL-3.0-or-later
                         */

var DIRECTION_NEXT = 1;
var DIRECTION_PREV = -1;

var ACTION_NONE = 0;
var ACTION_MOVE_FOCUS = 1;
var ACTION_DISMISS_FOCUS = 2;

/**
 * WidgetFocusManager is a mixin that provides keyboard navigation inside a widget. To do this,
 * it exposes the following props and methods:
 *
 * @class WidgetFocusManager
 */
var WidgetFocusManager = {
	// Allows validating props being passed to the component.
	propTypes: {
		/**
   * Callback method to be invoked when the focus manager is to be dismissed. This happens
   * in the following scenarios if a dismiss callback has been specified:
   * - A dismiss key has been pressed
   * - In a non-circular focus manager, when:
   *     - The active descendant is the first one and a prev key has been pressed.
   *     - The active descendant is the last one and a next key has been pressed.
   *
   * @instance
   * @memberof WidgetFocusManager
   * @property {Function} onDismiss
   */
		onDismiss: _propTypes2.default.func,

		/**
   * Indicates if focus should be set to the first/last descendant when the limits are reached.
   *
   * @instance
   * @memberof WidgetFocusManager
   * @property {boolean} circular
   */
		circular: _propTypes2.default.bool.isRequired,

		/**
   * Indicate if should focus the first child of a container
   * @instance
   * @memberof WidgetFocusManager
   * @property {Boolean} focusFirstChild
   */
		focusFirstChild: _propTypes2.default.bool,

		/**
   * String representing the CSS selector used to define the elements that should be handled.
   *
   * @instance
   * @memberof WidgetFocusManager
   * @property {String} descendants
   */
		descendants: _propTypes2.default.string.isRequired,

		/**
   * Object representing the keys used to navigate between descendants. The format for the prop is:
   * `{dismiss: value, dismissNext: value, dismissPrev: value, next: value, prev: value}` where
   * value can be both a number or an array of numbers with the allowed keyCodes.
   *
   * @instance
   * @memberof WidgetFocusManager
   * @property {Object} keys
   */
		keys: _propTypes2.default.object.isRequired
	},

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method componentDidMount
  */
	componentDidMount: function componentDidMount() {
		this._refresh();
	},


	/**
  * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
  * Refreshes the descendants list.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method componentDidUpdate
  */
	componentDidUpdate: function componentDidUpdate() {
		this._refresh();
	},


	/**
  * Focuses the current active descendant.
  *
  * Several Widgets can be nested in a component hierarchy by attaching this focus method to
  * the widget DOM node, transferring the DOM focus control to the inner FocusManager.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method focus
  */
	focus: function focus(event) {
		if (!event || this._isValidTarget(event.target)) {
			if (this._descendants && this._descendants.length) {
				var activeDescendantEl = this._descendants[this._activeDescendant];
				// When user clicks with the mouse, the activeElement is already set and there
				// is no need to focus it. Focusing of the active descendant (usually some button) is required
				// in case of keyboard navigation, because the focused element might be not the first button,
				// but the div element, which contains the button.
				if (document.activeElement !== activeDescendantEl && !this.props.focusFirstChild) {
					if (this._descendants.indexOf(document.activeElement) === -1) {
						activeDescendantEl.focus();
					}
				}

				if (event) {
					event.stopPropagation();
					event.preventDefault();
				}
			}
		}
	},


	/**
  * Handles the key events on a DOM node to execute the appropriate navigation when needed.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @param {Object} event The Keyboard event that was detected on the widget DOM node.
  * @method handleKey
  */
	handleKey: function handleKey(event) {
		if (this._isValidTarget(event.target) && this._descendants) {
			var action = this._getFocusAction(event);

			if (action.type) {
				event.stopPropagation();
				event.preventDefault();

				if (action.type === ACTION_MOVE_FOCUS) {
					this._moveFocus(action.direction);
				}

				if (action.type === ACTION_DISMISS_FOCUS) {
					this.props.onDismiss(action.direction);
				}
			}
		}
	},


	/**
  * Moves the focus among descendants in the especified direction.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method moveFocus
  * @param {number} direction The direction (1 or -1) of the focus movement among descendants.
  */
	moveFocus: function moveFocus(direction) {
		direction = _lang2.default.isNumber(direction) ? direction : 0;

		this._moveFocus(direction);
	},


	/**
  * Returns the action, if any, that a keyboard event in the current focus manager state
  * should produce.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method _getFocusAction
  * @param {object} event The Keyboard event.
  * @protected
  * @return {Object} An action object with type and direction properties.
  */
	_getFocusAction: function _getFocusAction(event) {
		var action = {
			type: ACTION_NONE
		};

		if (this.props.keys) {
			var direction = this._getFocusMoveDirection(event);

			if (direction) {
				action.direction = direction;
				action.type = ACTION_MOVE_FOCUS;
			}

			var dismissAction = this._getFocusDismissAction(event, direction);

			if (dismissAction.dismiss) {
				action.direction = dismissAction.direction;
				action.type = ACTION_DISMISS_FOCUS;
			}
		}

		return action;
	},


	/**
  * Returns the dismiss action, if any, the focus manager should execute to yield the focus. This
  * will happen in any of these scenarios if a dismiss callback has been specified:
  * - A dismiss key has been pressed
  * - In a non-circular focus manager, when:
  *     - The active descendant is the first one and a prev key has been pressed.
  *     - The active descendant is the last one and a next key has been pressed.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method _getFocusDismissAction
  * @param {Number} focusMoveDirection The focus movement direction (if any).
  * @param {Object} event The Keyboard event.
  * @protected
  * @return {Object} A dismiss action with dismiss and direction properties.
  */
	_getFocusDismissAction: function _getFocusDismissAction(event, focusMoveDirection) {
		var dismissAction = {
			direction: focusMoveDirection,
			dismiss: false
		};

		if (this.props.onDismiss) {
			if (this._isValidKey(event.keyCode, this.props.keys.dismiss)) {
				dismissAction.dismiss = true;
			}
			if (this._isValidKey(event.keyCode, this.props.keys.dismissNext)) {
				dismissAction.dismiss = true;
				dismissAction.direction = DIRECTION_NEXT;
			}
			if (this._isValidKey(event.keyCode, this.props.keys.dismissPrev)) {
				dismissAction.dismiss = true;
				dismissAction.direction = DIRECTION_PREV;
			}

			if (!dismissAction.dismiss && !this.props.circular && focusMoveDirection) {
				dismissAction.dismiss = focusMoveDirection === DIRECTION_PREV && this._activeDescendant === 0 || focusMoveDirection === DIRECTION_NEXT && this._activeDescendant === this._descendants.length - 1;
			}
		}

		return dismissAction;
	},


	/**
  * Returns the direction, if any, in which the focus should be moved. In presence of the
  * shift key modifier, the direction of the movement is inverted.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method _getFocusMoveDirection
  * @param {Object} event The Keyboard event.
  * @protected
  * @return {Number} The computed direction of the expected focus movement.
  */
	_getFocusMoveDirection: function _getFocusMoveDirection(event) {
		var direction = DIRECTION_NONE;

		if (this._isValidKey(event.keyCode, this.props.keys.next)) {
			direction = DIRECTION_NEXT;
		}
		if (this._isValidKey(event.keyCode, this.props.keys.prev)) {
			direction = DIRECTION_PREV;
		}

		if (event.shifKey) {
			direction *= -1;
		}

		return direction;
	},


	/**
  * Indicates if a given keyCode is valid for the given set of keys.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method _isValidKey
  * @param {Array|Number} keys A key set. Can be a number an array of numbers representing the allowed keyCodes.
  * @param {Number} keyCode An event keyCode.
  * @protected
  * @return {Boolean} A boolean value indicating if the key is valid.
  */
	_isValidKey: function _isValidKey(keyCode, keys) {
		return _lang2.default.isArray(keys) ? keys.indexOf(keyCode) !== -1 : keyCode === keys;
	},


	/**
  * Indicates if a given element is valid for focus management. User input elements such as
  * input, select or textarea are excluded.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method _isValidKey
  * @param {DOMNode} element A DOM element.
  * @protected
  * @return {Boolean} A boolean value indicating if the element is valid.
  */
	_isValidTarget: function _isValidTarget(element) {
		var tagName = element.tagName.toLowerCase();

		return tagName !== 'input' && tagName !== 'select' && tagName !== 'textarea';
	},


	/**
  * Moves the focus among descendants in the especified direction.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method _moveFocus
  * @param {number} direction The direction (1 or -1) of the focus movement among descendants.
  * @protected
  */
	_moveFocus: function _moveFocus(direction) {
		var numDescendants = this._descendants.length;

		var descendant = this._descendants[this._activeDescendant];

		descendant.setAttribute('tabIndex', -1);

		this._activeDescendant += direction;

		if (this.props.circular) {
			// Calculate proper modulo result since remainder operator doesn't behave in the
			// same way for negative numbers
			this._activeDescendant = (this._activeDescendant % numDescendants + numDescendants) % numDescendants;
		} else {
			this._activeDescendant = Math.max(Math.min(this._activeDescendant, numDescendants - 1), 0);
		}

		descendant = this._descendants[this._activeDescendant];

		descendant.setAttribute('tabIndex', 0);
		descendant.focus();
	},


	/**
  * Refreshes the descendants list by executing the CSS selector again and resets the descendants tabIndex.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method _refresh
  * @protected
  */
	_refresh: function _refresh() {
		var _this = this;

		var domNode = _reactDom2.default.findDOMNode(this);

		if (domNode) {
			var descendants = domNode.querySelectorAll(this.props.descendants);

			var priorityDescendants = [];

			this._descendants = [];

			Array.prototype.slice.call(descendants).forEach(function (item) {
				var dataTabIndex = item.getAttribute('data-tabindex');

				if (dataTabIndex) {
					priorityDescendants.push(item);
				} else {
					_this._descendants.push(item);
				}
			});

			priorityDescendants = priorityDescendants.sort(function (a, b) {
				return _lang2.default.toInt(a.getAttribute('data-tabindex')) > _lang2.default.toInt(b.getAttribute('data-tabindex'));
			});

			this._descendants = priorityDescendants.concat(this._descendants);

			this._activeDescendant = 0;

			this._descendants.some(function (item, index) {
				if (item.getAttribute('tabindex') === '0') {
					_this._activeDescendant = index;
					_this.focus();

					return true;
				}
			});
		}
	}
};

exports.default = WidgetFocusManager;

/***/ }),

/***/ "./src/components/compat/widget-interaction-point.js":
/*!***********************************************************!*\
  !*** ./src/components/compat/widget-interaction-point.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Provides functionality for calculating the point of interaction of the user with the Editor.
 *
 * @class WidgetInteractionPoint
 */
var WidgetInteractionPoint = {
	// Allows validating props being passed to the component.
	propTypes: {
		/**
   * The provided editor event.
   *
   * @instance
   * @memberof WidgetInteractionPoint
   * @property {SyntheticEvent} editorEvent
   */
		editorEvent: _propTypes2.default.object
	},

	/**
  * Returns the position, in page coordinates, according to which a widget should appear.
  * Depending on the direction of the selection, the wdiget may appear above of or on bottom of the selection.
  *
  * It depends on the props editorEvent to analyze the following user-interaction parameters:
  * - {Object} selectionData The data about the selection in the editor as returned from
  * {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
  * - {Number} pos Contains the coordinates of the position, considered as most appropriate.
  * This may be the point where the user released the mouse, or just the beginning or the end of
  * the selection.
  *
  * @instance
  * @memberof WidgetInteractionPoint
  * @method getInteractionPoint
  * @return {Object} An Object which contains the following properties:
  * direction, x, y, where x and y are in page coordinates and direction can be one of these:
  * CKEDITOR.SELECTION_BOTTOM_TO_TOP or CKEDITOR.SELECTION_TOP_TO_BOTTOM
  */
	getInteractionPoint: function getInteractionPoint() {
		var eventPayload = this.props.editorEvent ? this.props.editorEvent.data : null;

		if (!eventPayload) {
			return;
		}

		var selectionData = eventPayload.selectionData;

		var nativeEvent = eventPayload.nativeEvent;

		var pos = {
			x: eventPayload.nativeEvent.pageX,
			y: selectionData.region.top
		};

		var direction = selectionData.region.direction;

		var endRect = selectionData.region.endRect;

		var startRect = selectionData.region.startRect;

		if (endRect && startRect && startRect.top === endRect.top) {
			direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
		}

		var x = void 0;
		var y = void 0;

		// If we have the point where user released the mouse, show Toolbar at this point
		// otherwise show it on the middle of the selection.

		if (pos.x && pos.y) {
			x = this._getXPoint(selectionData, pos.x);

			if (direction === CKEDITOR.SELECTION_BOTTOM_TO_TOP) {
				y = Math.min(pos.y, selectionData.region.top);
			} else {
				y = Math.max(pos.y, this._getYPoint(selectionData, nativeEvent));
			}
		} else {
			x = selectionData.region.left + selectionData.region.width / 2;

			if (direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
				y = this._getYPoint(selectionData, nativeEvent);
			} else {
				y = selectionData.region.top;
			}
		}

		return {
			direction: direction,
			x: x,
			y: y
		};
	},


	/**
  * Returns the position of the Widget.
  *
  * @instance
  * @memberof WidgetInteractionPoint
  * @method _getXPoint
  * @param {Object} eventX The X coordinate received from the native event (mouseup).
  * @param {Object} selectionData The data about the selection in the editor as returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
  * @protected
  * @return {Number} The calculated X point in page coordinates.
  */
	_getXPoint: function _getXPoint(selectionData, eventX) {
		var region = selectionData.region;

		var left = region.startRect ? region.startRect.left : region.left;
		var right = region.endRect ? region.endRect.right : region.right;

		var x = void 0;

		if (left < eventX && right > eventX) {
			x = eventX;
		} else {
			var leftDist = Math.abs(left - eventX);
			var rightDist = Math.abs(right - eventX);

			if (leftDist < rightDist) {
				// user raised the mouse on left on the selection
				x = left;
			} else {
				x = right;
			}
		}

		return x;
	},


	/**
  * Returns the position of the Widget.
  *
  * @instance
  * @memberof WidgetInteractionPoint
  * @method _getYPoint
  * @param {Object} nativeEvent The data about event is fired
  * @param {Object} selectionData The data about the selection in the editor as returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
  * @protected
  * @return {Number} The calculated Y point in page coordinates.
  */
	_getYPoint: function _getYPoint(selectionData, nativeEvent) {
		var y = 0;

		if (selectionData && nativeEvent) {
			var elementTarget = new CKEDITOR.dom.element(nativeEvent.target);

			if (elementTarget.$ && elementTarget.getStyle('overflow') === 'auto') {
				y = nativeEvent.target.offsetTop + nativeEvent.target.offsetHeight;
			} else {
				y = selectionData.region.bottom;
			}
		}

		return y;
	}
}; /**
    * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
    * SPDX-License-Identifier: LGPL-3.0-or-later
    */

exports.default = WidgetInteractionPoint;

/***/ }),

/***/ "./src/components/compat/widget-position.js":
/*!**************************************************!*\
  !*** ./src/components/compat/widget-position.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetInteractionPoint = __webpack_require__(/*! ./widget-interaction-point */ "./src/components/compat/widget-interaction-point.js");

var _widgetInteractionPoint2 = _interopRequireDefault(_widgetInteractionPoint);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Calculates the position where an Widget should be displayed based on
 * the point where user interacted with the editor.
 *
 * @class WidgetPosition
 * @uses WidgetInteractionPoint
 */
var WidgetPosition = {
	mixins: [_widgetInteractionPoint2.default],

	// Allows validating props being passed to the component.
	propTypes: {
		/**
   * Should the widget to be restricted to the viewport, or not.
   *
   * @instance
   * @memberof WidgetPosition
   * @property {Boolean} constrainToViewport
   * @default true
   */
		constrainToViewport: _propTypes2.default.bool,

		/**
   * The gutter (vertical and horizontal) between the interaction
   * point and where the widget should be rendered.
   *
   * @instance
   * @memberof WidgetPosition
   * @property {Object} gutter
   * @default {
   *     left: 0,
   *     top: 10
   * }
   */
		gutter: _propTypes2.default.object
	},

	/**
  * Lifecycle. Returns the default values of the properties used in
  * the widget.
  *
  * @instance
  * @memberof WidgetPosition
  * @method getDefaultProps
  */
	getDefaultProps: function getDefaultProps() {
		return {
			gutter: {
				left: 0,
				top: 10
			},
			constrainToViewport: true
		};
	},


	/**
  * Cancels an scheduled animation frame.
  *
  * @instance
  * @memberof WidgetPosition
  * @method cancelAnimation
  */
	cancelAnimation: function cancelAnimation() {
		if (window.cancelAnimationFrame) {
			window.cancelAnimationFrame(this._animationFrameId);
		}
	},


	/**
  * Returns an object which contains the position of the element in
  * page coordinates, restricted to fit to given viewport.
  *
  * @instance
  * @memberof WidgetPosition
  * @method getConstrainedPosition
  * @param {Object} attrs The following properties, provided as numbers:
  * - height
  * - left
  * - top
  * - width
  * @param {Object} viewPaneSize Optional. If not provided, the current viewport will be used. Should contain at least these properties:
  * - width
  * @return {Object} An object with `x` and `y` properties, which represent the constrained position of the
  * element.
  */
	getConstrainedPosition: function getConstrainedPosition(attrs, viewPaneSize) {
		viewPaneSize = viewPaneSize || new CKEDITOR.dom.window(window).getViewPaneSize();

		var x = attrs.left;
		var y = attrs.top;

		if (attrs.left + attrs.width > viewPaneSize.width) {
			x -= attrs.left + attrs.width - viewPaneSize.width;
		}

		if (y < 0) {
			y = 0;
		}

		return {
			x: x,
			y: y
		};
	},


	/**
  * Returns the position of the Widget taking in consideration the
  * {{#crossLink "WidgetPosition/gutter:attribute"}}{{/crossLink}} attribute.
  *
  * @instance
  * @memberof WidgetPosition
  * @protected
  * @method  getWidgetXYPoint
  * @param {Number} left The left offset in page coordinates where Toolbar should be shown.
  * @param {Number} top The top offset in page coordinates where Toolbar should be shown.
  * @param {Number} direction The direction of the selection. May be one of the following:
  * CKEDITOR.SELECTION_BOTTOM_TO_TOP or CKEDITOR.SELECTION_TOP_TO_BOTTOM
  * @return {Array} An Array with left and top offsets in page coordinates.
  */
	getWidgetXYPoint: function getWidgetXYPoint(left, top, direction) {
		var domNode = _reactDom2.default.findDOMNode(this);

		var gutter = this.props.gutter;
		var offsetWidth = domNode.offsetWidth;
		var halfWidth = offsetWidth / 2;

		if (direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM || direction === CKEDITOR.SELECTION_BOTTOM_TO_TOP) {
			left = left - gutter.left - halfWidth;

			top = direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM ? top + gutter.top : top - domNode.offsetHeight - gutter.top;
		} else if (direction === CKEDITOR.SELECTION_LEFT_TO_RIGHT || direction === CKEDITOR.SELECTION_RIGHT_TO_LEFT) {
			left = direction === CKEDITOR.SELECTION_LEFT_TO_RIGHT ? left + gutter.left + domNode.offsetHeight / 2 : left - 3 * domNode.offsetHeight / 2 - gutter.left;

			top = top - gutter.top - domNode.offsetHeight / 2;
		}

		if (left < 0) {
			left = 0;
		}

		if (left > document.body.offsetWidth - halfWidth) {
			left = document.body.offsetWidth - halfWidth;
		}

		if (top < 0) {
			top = 0;
		}

		return [left, top];
	},


	/**
  * Returns true if the widget is visible, false otherwise
  *
  * @instance
  * @memberof WidgetPosition
  * @method isVisible
  * @return {Boolean} True if the widget is visible, false otherwise
  */
	isVisible: function isVisible() {
		var domNode = _reactDom2.default.findDOMNode(this);

		if (domNode) {
			var domElement = new CKEDITOR.dom.element(domNode);

			return domElement.hasClass('alloy-editor-visible');
		}

		return false;
	},


	/**
  * Moves a widget from a starting point to a destination point.
  *
  * @instance
  * @memberof WidgetPosition
  * @method moveToPoint
  * @param  {Object} startPoint The starting point for the movement.
  * @param  {Object} endPoint The destination point for the movement.
  */
	moveToPoint: function moveToPoint(startPoint, endPoint) {
		var domElement = new CKEDITOR.dom.element(_reactDom2.default.findDOMNode(this));

		domElement.setStyles({
			left: startPoint[0] + 'px',
			top: startPoint[1] + 'px',
			opacity: 0,
			pointerEvents: 'none'
		});

		domElement.removeClass('alloy-editor-invisible');

		this._animate(function () {
			domElement.addClass('ae-toolbar-transition');
			domElement.addClass('alloy-editor-visible');
			domElement.setStyles({
				left: endPoint[0] + 'px',
				top: endPoint[1] + 'px',
				opacity: 1
			});

			// 150ms to match transition-duration for .ae-toolbar-transition:
			setTimeout(function () {
				domElement.setStyles({
					pointerEvents: ''
				});
			}, 150);
		});
	},


	/**
  * Shows the widget with the default animation transition.
  *
  * @instance
  * @memberof WidgetPosition
  * @method show
  */
	show: function show() {
		var domNode = _reactDom2.default.findDOMNode(this);
		var uiNode = this.props.editor.get('uiNode');

		var scrollTop = uiNode ? uiNode.scrollTop : 0;

		if (!this.isVisible() && domNode) {
			var interactionPoint = this.getInteractionPoint();

			if (interactionPoint) {
				var domElement = new CKEDITOR.dom.element(domNode);

				var finalX = void 0,
				    finalY = void 0,
				    initialX = void 0,
				    initialY = void 0;

				finalX = initialX = parseFloat(domElement.getStyle('left'));
				finalY = initialY = parseFloat(domElement.getStyle('top'));

				if (this.props.constrainToViewport) {
					var res = this.getConstrainedPosition({
						height: parseFloat(domNode.offsetHeight),
						left: finalX,
						top: finalY,
						width: parseFloat(domNode.offsetWidth)
					});

					finalX = res.x;
					finalY = res.y;
				}

				if (interactionPoint.direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
					initialY = this.props.selectionData.region.bottom + scrollTop;
				} else {
					initialY = this.props.selectionData.region.top + scrollTop;
				}

				this.moveToPoint([initialX, initialY], [finalX, finalY]);
			}
		}
	},


	/**
  * Updates the widget position based on the current interaction point.
  *
  * @instance
  * @memberof WidgetPosition
  * @method updatePosition
  */
	updatePosition: function updatePosition() {
		var interactionPoint = this.getInteractionPoint();

		var domNode = _reactDom2.default.findDOMNode(this);

		if (interactionPoint && domNode) {
			var uiNode = this.props.editor.get('uiNode') || document.body;
			var uiNodeStyle = getComputedStyle(uiNode);
			var uiNodeMarginLeft = parseInt(uiNodeStyle.getPropertyValue('margin-left'), 10);
			var uiNodeMarginRight = parseInt(uiNodeStyle.getPropertyValue('margin-right'), 10);
			var totalWidth = uiNodeMarginLeft + uiNode.clientWidth + uiNodeMarginRight;

			var scrollTop = uiNode.tagName !== 'BODY' ? uiNode.scrollTop : 0;

			var xy = this.getWidgetXYPoint(interactionPoint.x, interactionPoint.y, interactionPoint.direction);
			xy[1] += scrollTop;

			if (xy[0] < 0) {
				xy[0] = 0;
			}
			if (xy[0] > totalWidth - domNode.offsetWidth) {
				xy[0] = totalWidth - domNode.offsetWidth;
			}

			new CKEDITOR.dom.element(domNode).setStyles({
				left: xy[0] + 'px',
				top: xy[1] + 'px'
			});
		}
	},


	/**
  * Requests an animation frame, if possible, to simulate an animation.
  *
  * @instance
  * @memberof WidgetPosition
  * @method _animate
  * @param {Function} callback The function to be executed on the scheduled frame.
  * @protected
  */
	_animate: function _animate(callback) {
		if (window.requestAnimationFrame) {
			this._animationFrameId = window.requestAnimationFrame(callback);
		} else {
			callback();
		}
	}
}; /**
    * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
    * SPDX-License-Identifier: LGPL-3.0-or-later
    */

exports.default = WidgetPosition;

/***/ }),

/***/ "./src/components/main.jsx":
/*!*********************************!*\
  !*** ./src/components/main.jsx ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _editorContext = __webpack_require__(/*! ../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _widgetExclusive = __webpack_require__(/*! ./base/widget-exclusive */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ./base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The main editor UI class manages a hierarchy of widgets (toolbars and buttons).
 *
 * @class UI
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 */
var UI = function (_React$Component) {
	_inherits(UI, _React$Component);

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof UI
  * @method getDefaultProps
  * @return {Object} The default properties.
  */
	function UI(props) {
		_classCallCheck(this, UI);

		var _this = _possibleConstructorReturn(this, (UI.__proto__ || Object.getPrototypeOf(UI)).call(this, props));

		_this._onDismissToolbarFocus = function () {
			var editor = _this.context.editor.get('nativeEditor');

			editor.focus();
		};

		_this.state = {
			hidden: false
		};
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * @instance
  * @memberof UI
  * @method componentDidMount
  */


	_createClass(UI, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var _this2 = this;

			var editor = this.context.editor.get('nativeEditor');

			editor.on('editorInteraction', this._onEditorInteraction, this);
			editor.on('actionPerformed', this._onActionPerformed, this);
			editor.on('key', this._onEditorKey, this);

			// Set up events for hiding the UI when user stops interacting with the editor.
			// This may happen when he just clicks outside of the editor. However,
			// this does not include a situation when he clicks on some button, part of
			// editor's UI.

			// It is not easy to debounce _setUIHidden on mousedown, because if we
			// debounce it, when the handler is being invoked, the target might be no more part
			// of the editor's UI - onActionPerformed causes re-render.
			this._mousedownListener = function (event) {
				_this2._setUIHidden(event.target);
			};

			this._keyDownListener = CKEDITOR.tools.debounce(function (_event) {
				_this2._setUIHidden(document.activeElement);
			}, this.props.eventsDelay, this);

			document.addEventListener('mousedown', this._mousedownListener);
			document.addEventListener('keydown', this._keyDownListener);
		}

		/**
   * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
   * Fires `ariaUpdate` event passing ARIA related messages.
   * Fires `editorUpdate` event passing the previous and current properties and state.
   *
   * @instance
   * @memberof UI
   * @method componentDidUpdate
   */

	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps, prevState) {
			var domNode = _reactDom2.default.findDOMNode(this);

			var editor = this.context.editor.get('nativeEditor');

			if (domNode) {
				editor.fire('ariaUpdate', {
					message: this._getAvailableToolbarsMessage(domNode)
				});
			}

			editor.fire('editorUpdate', {
				prevProps: prevProps,
				prevState: prevState,
				props: this.props,
				state: this.state
			});
		}
	}, {
		key: '_getAriaUpdateTemplate',
		value: function _getAriaUpdateTemplate(ariaUpdate) {
			if (!this._ariaUpdateTemplates) {
				this._ariaUpdateTemplates = {};
			}

			if (!this._ariaUpdateTemplates[ariaUpdate]) {
				this._ariaUpdateTemplates[ariaUpdate] = new CKEDITOR.template(this._getAriaUpdates()[ariaUpdate]);
			}

			return this._ariaUpdateTemplates[ariaUpdate];
		}

		/**
   * Returns the templates for ARIA messages.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _getAriaUpdates
   * @return {Object} ARIA relates messages. Default:
   * {
   *      noToolbar: AlloyEditor.Strings.ariaUpdateNoToolbar,
   *      oneToolbar: AlloyEditor.Strings.ariaUpdateOneToolbar,
   *      manyToolbars: AlloyEditor.Strings.ariaUpdateManyToolbars
   *  }
   */

	}, {
		key: '_getAriaUpdates',
		value: function _getAriaUpdates() {
			return this.props.ariaUpdates || {
				noToolbar: AlloyEditor.Strings.ariaUpdateNoToolbar,
				oneToolbar: AlloyEditor.Strings.ariaUpdateOneToolbar,
				manyToolbars: AlloyEditor.Strings.ariaUpdateManyToolbars
			};
		}

		/**
   * Returns an ARIA message which represents the number of currently available toolbars.
   *
   * @instance
   * @memberof UI
   * @method _getAvailableToolbarsMessage
   * @protected
   * @param {CKEDITOR.dom.element} domNode The DOM node from which the available toolbars will be retrieved.
   * @return {String} The ARIA message for the number of available toolbars
   */

	}, {
		key: '_getAvailableToolbarsMessage',
		value: function _getAvailableToolbarsMessage(domNode) {
			var toolbarsNodeList = domNode.querySelectorAll('[role="toolbar"]');

			if (!toolbarsNodeList.length) {
				return this._getAriaUpdates().noToolbar;
			} else {
				var toolbarNames = Array.prototype.slice.call(toolbarsNodeList).map(function (toolbar) {
					return toolbar.getAttribute('aria-label');
				});

				var ariaUpdate = toolbarNames.length === 1 ? 'oneToolbar' : 'manyToolbars';

				return this._getAriaUpdateTemplate(ariaUpdate).output({
					toolbars: toolbarNames.join(',').replace(/,([^,]*)$/, ' and ' + '$1')
				});
			}
		}

		/**
   * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
   *
   * @instance
   * @memberof UI
   * @method componentWillUnmount
   */

	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			if (this._mousedownListener) {
				document.removeEventListener('mousedown', this._mousedownListener);
			}

			if (this._keyDownListener) {
				this._keyDownListener.detach();
				document.removeEventListener('keydown', this._keyDownListener);
			}
		}

		/**
   * Lifecycle. Renders the UI of the editor. This may include several toolbars and buttons.
   * The editor's UI also takes care of rendering the items in exclusive mode.
   *
   * @instance
   * @memberof UI
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var _this3 = this;

			if (this.state.hidden) {
				return null;
			}

			var toolbars = Object.keys(this.props.toolbars).map(function (toolbar) {
				return AlloyEditor.Toolbars[toolbar] || window[toolbar];
			});

			toolbars = this.filterExclusive(toolbars).map(function (toolbar) {
				var props = _this3.mergeExclusiveProps({
					config: _this3.props.toolbars[toolbar.key],
					editor: _this3.context.editor,
					editorEvent: _this3.state.editorEvent,
					key: toolbar.key,
					onDismiss: _this3._onDismissToolbarFocus,
					selectionData: _this3.state.selectionData
				}, toolbar.key);

				return _react2.default.createElement(toolbar, props);
			});

			return _react2.default.createElement(
				'div',
				{ className: 'ae-toolbars', onKeyDown: this.handleKey },
				toolbars
			);
		}

		/**
   * Listener to the editor's `actionPerformed` event. Sets state and redraws the UI of the editor.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _onActionPerformed
   * @param {SynteticEvent} event The provided event
   */

	}, {
		key: '_onActionPerformed',
		value: function _onActionPerformed(_event) {
			var editor = this.context.editor.get('nativeEditor');

			editor.focus();

			this.setState({
				itemExclusive: null,
				selectionData: editor.getSelectionData()
			});
		}

		/**
   * Executed when a dismiss key is pressed over a toolbar to return the focus to the editor.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _onDismissToolbarFocus
   */

	}, {
		key: '_onEditorInteraction',


		/**
   * Listener to the editor's `userInteraction` event. Retrieves the data about the user selection and
   * provides it via component's state property.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _onEditorInteraction
   * @param {SynteticEvent} event The provided event
   */
		value: function _onEditorInteraction(event) {
			this.setState({
				editorEvent: event,
				hidden: false,
				itemExclusive: null,
				selectionData: event.data.selectionData
			});
		}

		/**
   * Focuses on the active toolbar when the combination ALT+F10 is pressed inside the editor.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _onEditorKey
   */

	}, {
		key: '_onEditorKey',
		value: function _onEditorKey(event) {
			var nativeEvent = event.data.domEvent.$;

			if (nativeEvent.altKey && nativeEvent.keyCode === 121) {
				this.focus();
			}
		}

		/**
   * Checks if the target with which the user interacted is part of editor's UI or it is
   * the editable area. If none of these, sets the state of editor's UI to be hidden.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _setUIHidden
   * @param {DOMElement} target The DOM element with which user interacted lastly.
   */

	}, {
		key: '_setUIHidden',
		value: function _setUIHidden(target) {
			var domNode = _reactDom2.default.findDOMNode(this);

			if (domNode) {
				var editable = this.context.editor.get('nativeEditor').editable();
				var parentNode = target.parentNode;
				var targetNode = new CKEDITOR.dom.node(target);

				if (!editable) {
					this.setState({
						hidden: true
					});
				} else {
					var res = editable.$ === target || editable.contains(targetNode) || new CKEDITOR.dom.element(domNode).contains(targetNode);

					if (parentNode) {
						res = res || parentNode.id === 'ckimgrsz';
					}

					if (!res) {
						this.setState({
							hidden: true
						});
					}
				}
			}
		}
	}]);

	return UI;
}(_react2.default.Component);

/**
 * Fired when component updates and when it is rendered in the DOM.
 * The payload consists from a `message` property containing the ARIA message.
 *
 * @event ariaUpdate
 */

/**
 * Fired when component updates. The payload consists from an object with the following
 * properties:
 * - prevProps - The previous properties of the component
 * - prevState - The previous state of the component
 * - props - The current properties of the component
 * - state - The current state of the component
 *
 * @event ariaUpdate
 */

UI.contextType = _editorContext2.default;
UI.defaultProps = {
	circular: true,
	descendants: '[class^=ae-toolbar-]',
	eventsDelay: 0,
	keys: {
		next: 9
	}
};
UI.propTypes = {
	/**
  * Localized messages for live aria updates. Should include the following messages:
  * - noToolbar: Notification for no available toolbar in the editor.
  * - oneToolbar: Notification for just one available toolbar in the editor.
  * - manyToolbars: Notification for more than one available toolbar in the editor.
  *
  * @instance
  * @memberof UI
  * @property {Object} ariaUpdates
  */
	ariaUpdates: _propTypes2.default.object,

	/**
  * The delay (ms), after which key or mouse events will be processed.
  *
  * @instance
  * @memberof UI
  * @property {Number} eventsDelay
  */
	eventsDelay: _propTypes2.default.number,

	/**
  * The toolbars configuration for this editor instance
  *
  * @instance
  * @memberof UI
  * @property {Object} toolbars
  */
	toolbars: _propTypes2.default.object.isRequired
};
exports.default = (0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)(UI));

/***/ }),

/***/ "./src/components/toolbars/index.js":
/*!******************************************!*\
  !*** ./src/components/toolbars/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ToolbarAdd$key$Toolb;

var _toolbarAdd = __webpack_require__(/*! ./toolbar-add.jsx */ "./src/components/toolbars/toolbar-add.jsx");

var _toolbarAdd2 = _interopRequireDefault(_toolbarAdd);

var _toolbarStyles = __webpack_require__(/*! ./toolbar-styles.jsx */ "./src/components/toolbars/toolbar-styles.jsx");

var _toolbarStyles2 = _interopRequireDefault(_toolbarStyles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /**
                                                                                                                                                                                                                   * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                   * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                   */

exports.default = (_ToolbarAdd$key$Toolb = {}, _defineProperty(_ToolbarAdd$key$Toolb, _toolbarAdd2.default.key, _toolbarAdd2.default), _defineProperty(_ToolbarAdd$key$Toolb, _toolbarStyles2.default.key, _toolbarStyles2.default), _ToolbarAdd$key$Toolb);

/***/ }),

/***/ "./src/components/toolbars/toolbar-add.jsx":
/*!*************************************************!*\
  !*** ./src/components/toolbars/toolbar-add.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _toolbarButtons = __webpack_require__(/*! ../base/toolbar-buttons */ "./src/components/base/toolbar-buttons.js");

var _toolbarButtons2 = _interopRequireDefault(_toolbarButtons);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetExclusive = __webpack_require__(/*! ../base/widget-exclusive */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _buttonIcon = __webpack_require__(/*! ../buttons/button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var POSITION_LEFT = 1;
var POSITION_RIGHT = 2;

/**
 * The ToolbarAdd class provides functionality for adding content to the editor.
 *
 * @class ToolbarAdd
 * @uses ToolbarButtons
 * @uses WidgetDropdown
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 */

var ToolbarAdd = function (_React$Component) {
	_inherits(ToolbarAdd, _React$Component);

	function ToolbarAdd(props) {
		_classCallCheck(this, ToolbarAdd);

		var _this = _possibleConstructorReturn(this, (ToolbarAdd.__proto__ || Object.getPrototypeOf(ToolbarAdd)).call(this, props));

		_this.state = {};
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client (not on the server),
  * immediately after the initial rendering occurs.
  *
  * @instance
  * @memberof ToolbarAdd
  * @method componentDidMount
  */


	_createClass(ToolbarAdd, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this._updatePosition();
		}

		/**
   * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof ToolbarAdd
   * @method componentDidUpdate
   * @param {Object} prevProps The previous state of the component's properties.
   * @param {Object} prevState Component's previous state.
   */

	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(_prevProps, _prevState) {
			this._updatePosition();

			// In case of exclusive rendering, focus the first descendant (button)
			// so the user will be able to start interacting with the buttons immediately.
			if (this.props.renderExclusive) {
				this.focus();
			}
		}

		/**
   * Lifecycle. Renders the buttons for adding content or hides the toolbar
   * if user interacted with a non-editable element.
   *
   * @instance
   * @memberof ToolbarAdd
   * @method render
   * @return {Object|null} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			// Some operations such as `requestExclusive` may force editor to blur which will
			// invalidate the `props.editorEvent` stored value, without causing a `props` change.
			// For example, if the editor is empty, `ae_placeholder` plugin will remove
			// the target from the DOM and will prevent `add` toolbar from rendering.
			//
			// It should be safe to assume that if you have been able to render the toolbar
			// and request the exclusive mode, then rendering might be kept until the exclusive mode is left.
			if (!this.state.itemExclusive && this.props.editorEvent && this.props.editorEvent.data.nativeEvent.target && !this.props.editorEvent.data.nativeEvent.target.isContentEditable) {
				return null;
			}

			var buttons = this._getButtons();
			var className = this._getToolbarClassName();

			return _react2.default.createElement(
				'div',
				{
					'aria-label': AlloyEditor.Strings.add,
					className: className,
					'data-tabindex': this.props.config.tabIndex || 0,
					onFocus: this.focus.bind(this),
					onKeyDown: this.handleKey.bind(this),
					role: 'toolbar',
					tabIndex: '-1' },
				_react2.default.createElement(
					'div',
					{ className: 'ae-container' },
					buttons
				)
			);
		}

		/**
   * Returns a list of buttons that will eventually render to HTML.
   *
   * @instance
   * @memberof ToolbarAdd
   * @method _getButtons
   * @protected
   * @return {Object} The buttons which have to be rendered.
   */

	}, {
		key: '_getButtons',
		value: function _getButtons() {
			var buttons = void 0;

			if (this.props.renderExclusive) {
				buttons = this.getToolbarButtons(this.props.config.buttons);
			} else {
				if (this.props.selectionData && this.props.selectionData.region) {
					buttons = _react2.default.createElement(
						'button',
						{
							'aria-label': AlloyEditor.Strings.add,
							className: 'ae-button ae-button-add',
							onClick: this.props.requestExclusive.bind(this, ToolbarAdd.key),
							title: AlloyEditor.Strings.add },
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'plus' })
					);
				}
			}

			return buttons;
		}

		/**
   * Returns the class name of the toolbar in case of both exclusive and normal mode.
   *
   * @instance
   * @memberof ToolbarAdd
   * @method _getToolbarClassName
   * @protected
   * @return {String} The class name which have to be applied to the DOM element.
   */

	}, {
		key: '_getToolbarClassName',
		value: function _getToolbarClassName() {
			var cssClass = 'ae-toolbar-add';

			if (this.props.renderExclusive) {
				cssClass = 'ae-toolbar ' + this.getArrowBoxClasses();
			}

			return cssClass;
		}

		/**
   * Calculates and sets the position of the toolbar in exclusive or normal mode.
   *
   * @instance
   * @memberof ToolbarAdd
   * @method _updatePosition
   * @protected
   */

	}, {
		key: '_updatePosition',
		value: function _updatePosition() {
			var region = void 0;

			// If component is not mounted, there is nothing to do
			if (!_reactDom2.default.findDOMNode(this)) {
				return;
			}

			if (this.props.renderExclusive) {
				this.updatePosition();
				this.show();
			} else {
				if (this.props.selectionData) {
					region = this.props.selectionData.region;
				}

				if (region) {
					var domNode = _reactDom2.default.findDOMNode(this);

					var domElement = new CKEDITOR.dom.element(domNode);

					var startRect = region.startRect || region;

					var nativeEditor = this.context.editor.get('nativeEditor');

					var clientRect = nativeEditor.editable().getClientRect();

					var offsetLeft = void 0;

					var position = this.props.config.position || this.props.position;

					if (position === POSITION_LEFT) {
						offsetLeft = clientRect.left - domNode.offsetWidth - this.props.gutterExclusive.left + 'px';
					} else {
						offsetLeft = clientRect.right + this.props.gutterExclusive.left + 'px';
					}

					domNode.style.left = offsetLeft;

					domNode.style.top = Math.floor((region.bottom + region.top) / 2) + 'px';

					var uiNode = this.context.editor.get('uiNode');

					var scrollTop = uiNode ? uiNode.scrollTop : 0;

					if (nativeEditor.element.getStyle('overflow') !== 'auto') {
						domNode.style.top = Math.floor(region.top - domNode.offsetHeight / 2 + startRect.height / 2 + scrollTop) + 'px';
					} else {
						domNode.style.top = Math.floor(nativeEditor.element.$.offsetTop + startRect.height / 2 - domNode.offsetHeight / 2) + 'px';
					}

					domNode.style.opacity = 1;

					domElement.removeClass('ae-arrow-box');

					this.cancelAnimation();
				}
			}
		}
	}]);

	return ToolbarAdd;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default add
 * @memberof ToolbarAdd
 * @property {String} key
 * @static
 */


ToolbarAdd.contextType = _editorContext2.default;
ToolbarAdd.key = 'add';

/**
 * Defines the constant for positioning the Toolbar on left of the editable area.
 *
 * @default 1
 * @memberof ToolbarAdd
 * @property {String} left
 * @static
 */
ToolbarAdd.left = POSITION_LEFT;

/**
 * Defines the constant for positioning the Toolbar on right of the editable area.
 *
 * @default 2
 * @memberof ToolbarAdd
 * @property {String} right
 * @static
 */
ToolbarAdd.right = POSITION_RIGHT;

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ToolbarAdd
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ToolbarAdd.defaultProps = {
	circular: true,
	descendants: '.ae-button',
	gutterExclusive: {
		left: 10,
		top: 0
	},
	keys: {
		dismiss: [27],
		next: [39, 40],
		prev: [37, 38]
	},
	position: POSITION_LEFT
};

exports.default = (0, _widgetDropdown2.default)((0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)((0, _toolbarButtons2.default)(ToolbarAdd))));

/***/ }),

/***/ "./src/components/toolbars/toolbar-styles.jsx":
/*!****************************************************!*\
  !*** ./src/components/toolbars/toolbar-styles.jsx ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _toolbarButtons = __webpack_require__(/*! ../base/toolbar-buttons */ "./src/components/base/toolbar-buttons.js");

var _toolbarButtons2 = _interopRequireDefault(_toolbarButtons);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetExclusive = __webpack_require__(/*! ../base/widget-exclusive */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ToolbarStyles class hosts the buttons for styling a text selection.
 *
 * @class ToolbarStyles
 * @uses ToolbarButtons
 * @uses WidgetDropdown
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 */
var ToolbarStyles = function (_React$Component) {
	_inherits(ToolbarStyles, _React$Component);

	function ToolbarStyles(props) {
		_classCallCheck(this, ToolbarStyles);

		var _this = _possibleConstructorReturn(this, (ToolbarStyles.__proto__ || Object.getPrototypeOf(ToolbarStyles)).call(this, props));

		_this.state = {};
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client (not on the server),
  * immediately after the initial rendering occurs.
  *
  * @instance
  * @memberof ToolbarStyles
  * @method componentDidMount
  */


	_createClass(ToolbarStyles, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this._updatePosition();
		}

		/**
   * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof ToolbarStyles
   * @method componentDidUpdate
   * @param {Object} prevProps The previous state of the component's properties.
   * @param {Object} prevState Component's previous state.
   */

	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(_prevProps, _prevState) {
			this._updatePosition();
		}

		/**
   * Lifecycle. Renders the buttons for adding content or hides the toolbar
   * if user interacted with a non-editable element.
   *
   * @instance
   * @memberof ToolbarStyles
   * @method render
   * @return {Object|null} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var currentSelection = this._getCurrentSelection();

			if (currentSelection) {
				var getArrowBoxClassesFn = this._getSelectionFunction(currentSelection.getArrowBoxClasses);
				var arrowBoxClasses = void 0;

				if (getArrowBoxClassesFn) {
					arrowBoxClasses = getArrowBoxClassesFn();
				} else {
					arrowBoxClasses = this.getArrowBoxClasses();
				}

				var cssClasses = 'ae-toolbar-styles ' + arrowBoxClasses;

				var buttons = currentSelection.buttons;

				if ((typeof buttons === 'undefined' ? 'undefined' : _typeof(buttons)) === 'object' && !Array.isArray(buttons)) {
					buttons = buttons[this.context.editor.get('mode')] || buttons['simple'];
				}

				var buttonsGroup = this.getToolbarButtonGroups(buttons, {
					manualSelection: this.props.editorEvent ? this.props.editorEvent.data.manualSelection : null,
					selectionType: currentSelection.name
				});

				var hasGroups = buttonsGroup.filter(function (button) {
					return Array.isArray(button);
				}).length > 0;

				var className = 'ae-container';

				if (hasGroups) {
					className += ' ae-container-column';
				}

				return _react2.default.createElement(
					'div',
					{
						'aria-label': AlloyEditor.Strings.styles,
						className: cssClasses,
						'data-tabindex': this.props.config.tabIndex || 0,
						onFocus: this.focus.bind(this),
						onKeyDown: this.handleKey.bind(this),
						role: 'toolbar',
						tabIndex: '-1' },
					_react2.default.createElement(
						'div',
						{ className: className },
						buttonsGroup.map(function (value, index) {
							if (Array.isArray(value)) {
								return _react2.default.createElement(
									'div',
									{ className: 'ae-row', key: index },
									value.map(function (button) {
										return button;
									})
								);
							} else {
								return value;
							}
						})
					)
				);
			}

			return null;
		}

		/**
   * Retrieve a function from String. It converts a fully qualified string into the mapped function.
   *
   * @instance
   * @memberof ToolbarStyles
   * @method _getSelectionFunction
   * @param {Function|String} selectionFn A function, or a fully qualified string pointing to the desired one (e.g. 'AlloyEditor.SelectionTest.image').
   * @protected
   * @return {Function} The mapped function.
   */

	}, {
		key: '_getSelectionFunction',
		value: function _getSelectionFunction(selectionFn) {
			var selectionFunction = void 0;

			if (_lang2.default.isFunction(selectionFn)) {
				selectionFunction = selectionFn;
			} else if (_lang2.default.isString(selectionFn)) {
				var parts = selectionFn.split('.');
				var currentMember = window;
				var property = parts.shift();

				while (property && _lang2.default.isObject(currentMember) && _lang2.default.isObject(currentMember[property])) {
					currentMember = currentMember[property];
					property = parts.shift();
				}

				if (_lang2.default.isFunction(currentMember)) {
					selectionFunction = currentMember;
				}
			}

			return selectionFunction;
		}

		/**
   * Analyzes the current editor selection and returns the selection configuration that matches.
   *
   * @instance
   * @memberof ToolbarStyles
   * @method _getCurrentSelection
   * @protected
   * @return {Object} The matched selection configuration.
   */

	}, {
		key: '_getCurrentSelection',
		value: function _getCurrentSelection() {
			var eventPayload = this.props.editorEvent ? this.props.editorEvent.data : null;
			var selection = void 0;

			if (eventPayload) {
				this.props.config.selections.some(function (item) {
					var testFn = this._getSelectionFunction(item.test);
					var result = void 0;

					if (testFn) {
						result = eventPayload.manualSelection === item.name || testFn({
							data: eventPayload,
							editor: this.context.editor
						});
					}

					if (result) {
						selection = item;
					}

					return result;
				}, this);
			}

			return selection;
		}

		/**
   * Calculates and sets the position of the toolbar.
   *
   * @instance
   * @memberof ToolbarStyles
   * @method _updatePosition
   * @protected
   */

	}, {
		key: '_updatePosition',
		value: function _updatePosition() {
			// If component is not mounted, there is nothing to do
			if (!_reactDom2.default.findDOMNode(this)) {
				return;
			}

			var currentSelection = this._getCurrentSelection();
			var result = void 0;

			// If current selection has a function called `setPosition`, call it
			// and check the returned value. If false, fallback to the default positioning logic.
			if (currentSelection) {
				var setPositionFn = this._getSelectionFunction(currentSelection.setPosition);

				if (setPositionFn) {
					result = setPositionFn.call(this, {
						editor: this.context.editor,
						editorEvent: this.props.editorEvent,
						selectionData: this.props.selectionData
					});
				}
			}

			if (!result) {
				this.updatePosition();
				this.show();
			}
		}
	}]);

	return ToolbarStyles;
}(_react2.default.Component);

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ToolbarStyles
 * @method getDefaultProps
 * @return {Object} The default properties.
 */


ToolbarStyles.contextType = _editorContext2.default;
ToolbarStyles.defaultProps = {
	circular: true,
	descendants: '.ae-input, .ae-button:not([disabled]), .ae-toolbar-element',
	keys: {
		dismiss: [27],
		next: [39, 40],
		prev: [37, 38]
	}
};

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default styles
 * @memberof ToolbarStyles
 * @property {String} key
 * @static
 */
ToolbarStyles.key = 'styles';

exports.default = (0, _widgetDropdown2.default)((0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)((0, _toolbarButtons2.default)(ToolbarStyles))));

/***/ }),

/***/ "./src/components/uibridge/button.jsx":
/*!********************************************!*\
  !*** ./src/components/uibridge/button.jsx ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_buttonbridge')) {
	var BUTTON_DEFS = {};

	/**
  * Generates a ButtonBridge React class for a given button definition if it has not been
  * already created based on the button name and definition.
  *
  * @private
  * @method generateButtonBridge
  * @param {String} buttonName The button's name
  * @param {Object} buttonDefinition The button's definition
  * @return {Object} The generated or already existing React Button Class
  */

	function generateButtonBridge(buttonName, buttonDefinition, editor) {
		var ButtonBridge = AlloyEditor.Buttons[buttonName];

		BUTTON_DEFS[editor.name] = BUTTON_DEFS[editor.name] || {};
		BUTTON_DEFS[editor.name][buttonName] = BUTTON_DEFS[editor.name][buttonName] || buttonDefinition;

		if (!ButtonBridge) {
			var _class, _temp2;

			ButtonBridge = (_temp2 = _class = function (_React$Component) {
				_inherits(ButtonBridge, _React$Component);

				function ButtonBridge() {
					var _ref;

					var _temp, _this, _ret;

					_classCallCheck(this, ButtonBridge);

					for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
						args[_key] = arguments[_key];
					}

					return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonBridge.__proto__ || Object.getPrototypeOf(ButtonBridge)).call.apply(_ref, [this].concat(args))), _this), _this._handleClick = function () {
						var editor = _this.context.editor.get('nativeEditor');

						var buttonCommand = BUTTON_DEFS[editor.name][buttonName].command;

						var buttonOnClick = BUTTON_DEFS[editor.name][buttonName].onClick;

						if (buttonOnClick) {
							buttonOnClick.call(_this);
						} else {
							editor.execCommand(buttonCommand);
						}

						editor.fire('actionPerformed', _this);
					}, _temp), _possibleConstructorReturn(_this, _ret);
				}

				_createClass(ButtonBridge, [{
					key: 'toFeature',


					// API not yet implemented inside the button
					// bridge. By mocking the unsupported method, we prevent
					// plugins from crashing if they make use of it.
					value: function toFeature() {}
				}, {
					key: 'render',
					value: function render() {
						var editor = this.context.editor.get('nativeEditor');

						var buttonClassName = 'ae-button ae-button-bridge';

						var buttonDisplayName = BUTTON_DEFS[editor.name][buttonName].name || BUTTON_DEFS[editor.name][buttonName].command || buttonName;

						var buttonLabel = BUTTON_DEFS[editor.name][buttonName].label;

						var buttonType = 'button-' + buttonDisplayName;

						var iconClassName = 'ae-icon-' + buttonDisplayName;

						var iconStyle = {};

						var cssStyle = CKEDITOR.skin.getIconStyle(buttonDisplayName);

						if (cssStyle) {
							var cssStyleParts = cssStyle.split(';');

							iconStyle.backgroundImage = cssStyleParts[0].substring(cssStyleParts[0].indexOf(':') + 1);
							iconStyle.backgroundPosition = cssStyleParts[1].substring(cssStyleParts[1].indexOf(':') + 1);
							iconStyle.backgroundSize = cssStyleParts[2].substring(cssStyleParts[2].indexOf(':') + 1);
						}

						return _react2.default.createElement(
							'button',
							{
								'aria-label': buttonLabel,
								className: buttonClassName,
								'data-type': buttonType,
								onClick: this._handleClick,
								tabIndex: this.props.tabIndex,
								title: buttonLabel },
							_react2.default.createElement('span', { className: iconClassName, style: iconStyle })
						);
					}
				}]);

				return ButtonBridge;
			}(_react2.default.Component), _class.contextType = _editorContext2.default, _class.displayName = buttonName, _class.key = buttonName, _temp2);

			AlloyEditor.Buttons[buttonName] = ButtonBridge;
		}

		return ButtonBridge;
	}

	/* istanbul ignore else */
	if (!CKEDITOR.plugins.get('button')) {
		CKEDITOR.UI_BUTTON = 'button';

		CKEDITOR.plugins.add('button', {});
	}

	/**
  * CKEditor plugin that bridges the support offered by CKEditor Button plugin. It takes over the
  * responsibility of registering and creating buttons via:
  * - editor.ui.addButton(name, definition)
  * - editor.ui.add(name, CKEDITOR.UI_BUTTON, definition)
  *
  * @class CKEDITOR.plugins.ae_buttonbridge
  * @requires CKEDITOR.plugins.ae_uibridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_buttonbridge', {
		requires: ['ae_uibridge'],

		/**
   * Set the add handler for UI_BUTTON to our own. We do this in the init phase to override
   * the one in the native plugin in case it's present.
   *
   * @method init
   * @param {Object} editor The CKEditor instance being initialized
   */
		beforeInit: function beforeInit(editor) {
			editor.ui.addButton = function (buttonName, buttonDefinition) {
				this.add(buttonName, CKEDITOR.UI_BUTTON, buttonDefinition);
			};

			editor.ui.addHandler(CKEDITOR.UI_BUTTON, {
				add: generateButtonBridge,
				create: function create(buttonDefinition) {
					var buttonName = 'buttonBridge' + (Math.random() * 1e9 >>> 0);
					var ButtonBridge = generateButtonBridge(buttonName, buttonDefinition);

					return new ButtonBridge();
				}
			});
		}
	});
}

/***/ }),

/***/ "./src/components/uibridge/index.js":
/*!******************************************!*\
  !*** ./src/components/uibridge/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./button.jsx */ "./src/components/uibridge/button.jsx");

__webpack_require__(/*! ./menu-button.jsx */ "./src/components/uibridge/menu-button.jsx");

__webpack_require__(/*! ./menu.jsx */ "./src/components/uibridge/menu.jsx");

__webpack_require__(/*! ./panel-menu-button.jsx */ "./src/components/uibridge/panel-menu-button.jsx");

__webpack_require__(/*! ./richcombo.jsx */ "./src/components/uibridge/richcombo.jsx");

__webpack_require__(/*! ./uibridge */ "./src/components/uibridge/uibridge.js");

/***/ }),

/***/ "./src/components/uibridge/menu-button.jsx":
/*!*************************************************!*\
  !*** ./src/components/uibridge/menu-button.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonDropdown = __webpack_require__(/*! ../buttons/button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_menubuttonbridge')) {
	var MENUBUTTON_DEFS = {};

	/**
  * Generates a MenuButtonBridge React class for a given menuButton definition if it has not been
  * already created based on the button name and definition.
  *
  * @private
  * @method generateMenuButtonBridge
  * @param {String} menuButtonName The menuButton's name
  * @param {Object} menuButtonDefinition The menuButton's definition
  * @return {Object} The generated or already existing React MenuButton Class
  */
	function generateMenuButtonBridge(menuButtonName, menuButtonDefinition, editor) {
		var MenuButtonBridge = AlloyEditor.Buttons[menuButtonName];

		MENUBUTTON_DEFS[editor.name] = MENUBUTTON_DEFS[editor.name] || {};
		MENUBUTTON_DEFS[editor.name][menuButtonName] = MENUBUTTON_DEFS[editor.name][menuButtonName] || menuButtonDefinition;

		if (!MenuButtonBridge) {
			var _class, _temp;

			MenuButtonBridge = (_temp = _class = function (_React$Component) {
				_inherits(MenuButtonBridge, _React$Component);

				function MenuButtonBridge() {
					_classCallCheck(this, MenuButtonBridge);

					return _possibleConstructorReturn(this, (MenuButtonBridge.__proto__ || Object.getPrototypeOf(MenuButtonBridge)).apply(this, arguments));
				}

				_createClass(MenuButtonBridge, [{
					key: 'toFeature',


					// API not yet implemented inside the menubutton
					// bridge. By mocking the unsupported method, we prevent
					// plugins from crashing if they make use of it.
					value: function toFeature() {}
				}, {
					key: 'render',
					value: function render() {
						var editor = this.context.editor.get('nativeEditor');

						var panelMenuButtonDisplayName = MENUBUTTON_DEFS[editor.name][menuButtonName].name || MENUBUTTON_DEFS[editor.name][menuButtonName].command || menuButtonName;

						var buttonClassName = 'ae-button ae-button-bridge';

						var iconClassName = 'ae-icon-' + panelMenuButtonDisplayName;

						var iconStyle = {};

						var cssStyle = CKEDITOR.skin.getIconStyle(panelMenuButtonDisplayName);

						if (cssStyle) {
							var cssStyleParts = cssStyle.split(';');

							iconStyle.backgroundImage = cssStyleParts[0].substring(cssStyleParts[0].indexOf(':') + 1);
							iconStyle.backgroundPosition = cssStyleParts[1].substring(cssStyleParts[1].indexOf(':') + 1);
							iconStyle.backgroundSize = cssStyleParts[2].substring(cssStyleParts[2].indexOf(':') + 1);
						}

						return _react2.default.createElement(
							'div',
							{ className: 'ae-container ae-has-dropdown' },
							_react2.default.createElement(
								'button',
								{
									'aria-expanded': this.props.expanded,
									'aria-label': MENUBUTTON_DEFS[editor.name][menuButtonName].label,
									className: buttonClassName,
									onClick: this.props.toggleDropdown,
									role: 'combobox',
									tabIndex: this.props.tabIndex,
									title: MENUBUTTON_DEFS[editor.name][menuButtonName].label },
								_react2.default.createElement('span', {
									className: iconClassName,
									style: iconStyle
								})
							),
							this.props.expanded && _react2.default.createElement(
								_buttonDropdown2.default,
								{
									onDismiss: this.props.toggleDropdown },
								this._getMenuItems()
							)
						);
					}
				}, {
					key: '_getMenuItems',
					value: function _getMenuItems() {
						var editor = this.context.editor.get('nativeEditor');
						var items = menuButtonDefinition.onMenu();
						var menuItems = Object.keys(items).map(function (key) {
							var menuItem = editor.getMenuItem(key);

							if (!menuItem) {
								return null;
							}

							var menuItemDefinition = menuItem.definition || menuItem;
							var menuItemState = items[key];

							var className = 'ae-toolbar-element ' + (menuItemState === CKEDITOR.TRISTATE_ON ? 'active' : '');
							var disabled = menuItemState === CKEDITOR.TRISTATE_DISABLED;
							var onClick = function onClick() {
								if (menuItemDefinition.command) {
									editor.execCommand(menuItemDefinition.command);
								} else if (menuItemDefinition.onClick) {
									menuItemDefinition.onClick.apply(menuItemDefinition);
								}
							};

							return _react2.default.createElement(
								'li',
								{ key: menuItem.name, role: 'option' },
								_react2.default.createElement(
									'button',
									{
										className: className,
										disabled: disabled,
										onClick: onClick },
									menuItemDefinition.label
								)
							);
						});

						return menuItems;
					}
				}]);

				return MenuButtonBridge;
			}(_react2.default.Component), _class.contextType = _editorContext2.default, _class.displayName = menuButtonName, _class.key = menuButtonName, _temp);

			AlloyEditor.Buttons[menuButtonName] = MenuButtonBridge;
		}

		return MenuButtonBridge;
	}

	/* istanbul ignore else */
	if (!CKEDITOR.plugins.get('menubutton')) {
		CKEDITOR.UI_MENU_BUTTON = 'menubutton';

		CKEDITOR.plugins.add('menubutton', {});
	}

	/**
  * CKEditor plugin that bridges the support offered by CKEditor MenuButton plugin. It takes over the
  * responsibility of registering and creating menuButtons via:
  * - editor.ui.addMenuButton(name, definition)
  * - editor.ui.add(name, CKEDITOR.UI_MENUBUTTON, definition)
  *
  * @class CKEDITOR.plugins.ae_menubuttonbridge
  * @requires CKEDITOR.plugins.ae_uibridge
  * @requires CKEDITOR.plugins.ae_menubridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_menubuttonbridge', {
		requires: ['ae_uibridge', 'ae_menubridge'],

		/**
   * Set the add handler for UI_MENUBUTTON to our own. We do this in the init phase to override
   * the one in the native plugin in case it's present.
   *
   * @method init
   * @param {Object} editor The CKEditor instance being initialized
   */
		beforeInit: function beforeInit(editor) {
			editor.ui.addMenuButton = function (menuButtonName, menuButtonDefinition) {
				this.add(menuButtonName, CKEDITOR.UI_MENUBUTTON, menuButtonDefinition);
			};

			editor.ui.addHandler(CKEDITOR.UI_MENUBUTTON, {
				add: generateMenuButtonBridge,
				create: function create(menuButtonDefinition) {
					var menuButtonName = 'buttonBridge' + (Math.random() * 1e9 >>> 0);
					var MenuButtonBridge = generateMenuButtonBridge(menuButtonName, menuButtonDefinition);

					return new MenuButtonBridge();
				}
			});
		}
	});
}

/***/ }),

/***/ "./src/components/uibridge/menu.jsx":
/*!******************************************!*\
  !*** ./src/components/uibridge/menu.jsx ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_menubridge')) {
	/**
  * CKEditor plugin that bridges the support offered by CKEditor Menu plugin. It takes over the
  * responsibility of adding, removing and retrieving menu groups and items
  * - editor.addMenuGroup(name, order)
  * - editor.addMenuItem(name, definition)
  * - editor.addMenuItems(definitions)
  * - editor.getMenuItem(name)
  * - editor.removeMenuItem(name)
  *
  * @class CKEDITOR.plugins.ae_menubridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_menubridge', {
		/**
   * Set the add handler for UI_BUTTON to our own. We do this in the init phase to override
   * the one in the native plugin in case it's present.
   *
   * @method init
   * @param {Object} editor The CKEditor instance being initialized
   */
		beforeInit: function beforeInit(editor) {
			// Do nothing if the real menu plugin is present
			if (CKEDITOR.plugins.get('menu')) {
				return;
			}

			var groups = [];
			var groupsOrder = editor._.menuGroups = {};
			var menuItems = editor._.menuItems = {};

			for (var i = 0; i < groups.length; i++) {
				groupsOrder[groups[i]] = i + 1;
			}

			/**
    * Registers an item group to the editor context menu in order to make it
    * possible to associate it with menu items later.
    *
    * @method addMenuGroup
    * @param {String} name Specify a group name.
    * @param {Number} [order=100] Define the display sequence of this group
    * inside the menu. A smaller value gets displayed first.
    */
			editor.addMenuGroup = function (name, order) {
				groupsOrder[name] = order || 100;
			};

			/**
    * Adds an item from the specified definition to the editor context menu.
    *
    * @method addMenuItem
    * @param {String} name The menu item name.
    * @param {Object} definition The menu item definition.
    */
			editor.addMenuItem = function (name, definition) {
				if (groupsOrder[definition.group]) {
					menuItems[name] = {
						name: name,
						definition: definition
					};
				}
			};

			/**
    * Adds one or more items from the specified definition object to the editor context menu.
    *
    * @method addMenuItems
    * @param {Object} definitions Object where keys are used as itemName and corresponding values as definition for a {@link #addMenuItem} call.
    */
			editor.addMenuItems = function (definitions) {
				for (var itemName in definitions) {
					if (Object.prototype.hasOwnProperty.call(definitions, itemName)) {
						this.addMenuItem(itemName, definitions[itemName]);
					}
				}
			};

			/**
    * Retrieves a particular menu item definition from the editor context menu.
    *
    * @method getMenuItem
    * @param {String} name The name of the desired menu item.
    * @return {Object}
    */
			editor.getMenuItem = function (name) {
				return menuItems[name];
			};

			/**
    * Removes a particular menu item added before from the editor context menu.
    *
    * @method  removeMenuItem
    * @param {String} name The name of the desired menu item.
    */
			editor.removeMenuItem = function (name) {
				delete menuItems[name];
			};
		}
	});
}

/***/ }),

/***/ "./src/components/uibridge/panel-menu-button.jsx":
/*!*******************************************************!*\
  !*** ./src/components/uibridge/panel-menu-button.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonDropdown = __webpack_require__(/*! ../buttons/button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_panelmenubuttonbridge')) {
	var PANEL_MENU_DEFS = {};

	/**
  * Generates a PanelMenuButtonBridge React class for a given panelmenubutton definition if it has not been
  * already created based on the panelmenubutton name and definition.
  *
  * @private
  * @method generatePanelMenuButtonBridge
  * @param {String} panelMenuButtonName The panel button name
  * @param {Object} panelMenuButtonDefinition The panel button definition
  * @return {Object} The generated or already existing React PanelMenuButton Class
  */
	var generatePanelMenuButtonBridge = function generatePanelMenuButtonBridge(panelMenuButtonName, panelMenuButtonDefinition, editor) {
		var PanelMenuButtonBridge = AlloyEditor.Buttons[panelMenuButtonName];

		PANEL_MENU_DEFS[editor.name] = PANEL_MENU_DEFS[editor.name] || {};
		PANEL_MENU_DEFS[editor.name][panelMenuButtonName] = PANEL_MENU_DEFS[editor.name][panelMenuButtonName] || panelMenuButtonDefinition;

		if (!PanelMenuButtonBridge) {
			var _class, _temp;

			PanelMenuButtonBridge = (_temp = _class = function (_React$Component) {
				_inherits(PanelMenuButtonBridge, _React$Component);

				function PanelMenuButtonBridge() {
					_classCallCheck(this, PanelMenuButtonBridge);

					return _possibleConstructorReturn(this, (PanelMenuButtonBridge.__proto__ || Object.getPrototypeOf(PanelMenuButtonBridge)).apply(this, arguments));
				}

				_createClass(PanelMenuButtonBridge, [{
					key: 'createPanel',


					// API not yet implemented inside the panel menu button bridge. By mocking the unsupported methods, we
					// prevent plugins from crashing if they make use of them.
					value: function createPanel() {}
				}, {
					key: 'render',
					value: function render() {
						var editor = this.context.editor.get('nativeEditor');

						var panelMenuButtonDisplayName = PANEL_MENU_DEFS[editor.name][panelMenuButtonName].name || PANEL_MENU_DEFS[editor.name][panelMenuButtonName].command || panelMenuButtonName;

						var buttonClassName = 'ae-button ae-button-bridge';

						var iconClassName = 'ae-icon-' + panelMenuButtonDisplayName;

						var iconStyle = {};

						var cssStyle = CKEDITOR.skin.getIconStyle(panelMenuButtonDisplayName);

						if (cssStyle) {
							var cssStyleParts = cssStyle.split(';');

							iconStyle.backgroundImage = cssStyleParts[0].substring(cssStyleParts[0].indexOf(':') + 1);
							iconStyle.backgroundPosition = cssStyleParts[1].substring(cssStyleParts[1].indexOf(':') + 1);
							iconStyle.backgroundSize = cssStyleParts[2].substring(cssStyleParts[2].indexOf(':') + 1);
						}

						var panel = void 0;

						if (this.props.expanded) {
							panel = this._getPanel();
						}

						return _react2.default.createElement(
							'div',
							{ className: 'ae-container ae-has-dropdown' },
							_react2.default.createElement(
								'button',
								{
									'aria-expanded': this.props.expanded,
									'aria-label': PANEL_MENU_DEFS[editor.name][panelMenuButtonName].label,
									className: buttonClassName,
									onClick: this.props.toggleDropdown,
									role: 'combobox',
									tabIndex: this.props.tabIndex,
									title: PANEL_MENU_DEFS[editor.name][panelMenuButtonName].label },
								_react2.default.createElement('span', {
									className: iconClassName,
									style: iconStyle
								})
							),
							panel
						);
					}
				}, {
					key: '_getPanel',
					value: function _getPanel() {
						var editor = this.context.editor.get('nativeEditor');

						var panelMenuButtonOnBlock = PANEL_MENU_DEFS[editor.name][panelMenuButtonName].onBlock;

						var panel = {
							hide: this.props.toggleDropdown,
							show: this.props.toggleDropdown
						};

						var blockElement = new CKEDITOR.dom.element('div');

						var block = {
							element: blockElement,
							keys: {}
						};

						/* istanbul ignore else */
						if (panelMenuButtonOnBlock) {
							panelMenuButtonOnBlock.call(this, panel, block);
						}

						// TODO
						// Use block.keys to configure the panel keyboard navigation

						return _react2.default.createElement(
							_buttonDropdown2.default,
							{ onDismiss: this.props.toggleDropdown },
							_react2.default.createElement('div', {
								className: blockElement.getAttribute('class'),
								dangerouslySetInnerHTML: {
									__html: blockElement.getHtml()
								}
							})
						);
					}
				}]);

				return PanelMenuButtonBridge;
			}(_react2.default.Component), _class.contextType = _editorContext2.default, _class.displayName = panelMenuButtonName, _class.key = panelMenuButtonName, _temp);

			AlloyEditor.Buttons[panelMenuButtonName] = PanelMenuButtonBridge;
		}

		return PanelMenuButtonBridge;
	};

	/* istanbul ignore else */
	if (!CKEDITOR.plugins.get('panelmenubutton')) {
		CKEDITOR.UI_PANELBUTTON = 'panelmenubutton';

		CKEDITOR.plugins.add('panelmenubutton', {});
	}

	/* istanbul ignore else */
	if (!CKEDITOR.plugins.get('panelbutton')) {
		CKEDITOR.UI_PANELBUTTON = 'panelbutton';

		CKEDITOR.plugins.add('panelbutton', {});
	}

	/**
  * CKEditor plugin that bridges the support offered by CKEditor PanelButton plugin. It takes over the
  * responsibility of registering and creating buttons via:
  * - editor.ui.addPanelMenuButton(name, definition)
  * - editor.ui.add(name, CKEDITOR.UI_PANELBUTTON, definition)
  *
  * @class CKEDITOR.plugins.ae_panelmenubuttonbridge
  * @requires CKEDITOR.plugins.ae_uibridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_panelmenubuttonbridge', {
		requires: ['ae_uibridge'],

		/**
   * Set the add handler for UI_PANELBUTTON to our own. We do this in the init phase to override
   * the one in the native plugin in case it's present
   *
   * @method init
   * @param {Object} editor The CKEditor instance being initialized
   */
		beforeInit: function beforeInit(editor) {
			editor.ui.addPanelMenuButton = function (panelMenuButtonName, panelMenuButtonDefinition) {
				this.add(panelMenuButtonName, CKEDITOR.UI_PANELBUTTON, panelMenuButtonDefinition);
			};

			editor.ui.addHandler(CKEDITOR.UI_PANELBUTTON, {
				add: generatePanelMenuButtonBridge,
				create: function create(panelMenuButtonDefinition) {
					var panelMenuButtonName = 'panelMenuButtonBridge' + (Math.random() * 1e9 >>> 0);
					var PanelMenuButtonBridge = generatePanelMenuButtonBridge(panelMenuButtonName, panelMenuButtonDefinition);

					return new PanelMenuButtonBridge();
				}
			});
		}
	});
}

/***/ }),

/***/ "./src/components/uibridge/richcombo.jsx":
/*!***********************************************!*\
  !*** ./src/components/uibridge/richcombo.jsx ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonDropdown = __webpack_require__(/*! ../buttons/button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _buttonIcon = __webpack_require__(/*! ../buttons/button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_richcombobridge')) {
	var RICH_COMBO_DEFS = {};

	/**
  * Generates a RichComboBridge React class for a given richcombo definition if it has not been
  * already created based on the richcombo name and definition.
  *
  * @method generateRichComboBridge
  * @private
  * @param {String} richComboName The rich combo name
  * @param {Object} richComboDefinition The rich combo definition
  * @return {Object} The generated or already existing React RichCombo Class
  */
	var generateRichComboBridge = function generateRichComboBridge(richComboName, richComboDefinition, editor) {
		var RichComboBridge = AlloyEditor.Buttons[richComboName];

		RICH_COMBO_DEFS[editor.name] = RICH_COMBO_DEFS[editor.name] || {};
		RICH_COMBO_DEFS[editor.name][richComboName] = RICH_COMBO_DEFS[editor.name][richComboName] || richComboDefinition;
		RICH_COMBO_DEFS[editor.name][richComboName].currentValue = undefined;

		if (!RichComboBridge) {
			var _class, _temp;

			RichComboBridge = (_temp = _class = function (_React$Component) {
				_inherits(RichComboBridge, _React$Component);

				function RichComboBridge(props) {
					_classCallCheck(this, RichComboBridge);

					var _this = _possibleConstructorReturn(this, (RichComboBridge.__proto__ || Object.getPrototypeOf(RichComboBridge)).call(this, props));

					_this._onClick = function (event) {
						var editor = _this.context.editor.get('nativeEditor');

						var editorCombo = RICH_COMBO_DEFS[editor.name][richComboName];

						if (editorCombo.onClick) {
							var newValue = event.currentTarget.getAttribute('data-value');

							editorCombo.onClick.call(_this, newValue);

							RICH_COMBO_DEFS[editor.name][richComboName].currentValue = newValue;

							editor.fire('actionPerformed', _this);
						}
					};

					_this.state = {
						value: RICH_COMBO_DEFS[editor.name][richComboName].currentValue
					};
					return _this;
				}

				// API not yet implemented inside the richcombo bridge. By mocking the unsupported methods, we
				// prevent plugins from crashing if they make use of them.


				_createClass(RichComboBridge, [{
					key: 'commit',
					value: function commit() {}
				}, {
					key: 'createPanel',
					value: function createPanel() {}
				}, {
					key: 'disable',
					value: function disable() {}
				}, {
					key: 'enable',
					value: function enable() {}
				}, {
					key: 'getState',
					value: function getState() {}
				}, {
					key: 'hideGroup',
					value: function hideGroup() {}
				}, {
					key: 'hideItem',
					value: function hideItem() {}
				}, {
					key: 'mark',
					value: function mark() {}
				}, {
					key: 'showAll',
					value: function showAll() {}
				}, {
					key: 'startGroup',
					value: function startGroup() {}
				}, {
					key: 'unmarkAll',
					value: function unmarkAll() {}
				}, {
					key: 'add',
					value: function add(value, preview, title) {
						this._items.push({
							preview: preview,
							title: title,
							value: value
						});
					}
				}, {
					key: 'componentWillMount',
					value: function componentWillMount() {
						var editor = this.context.editor.get('nativeEditor');

						var editorCombo = RICH_COMBO_DEFS[editor.name][richComboName];

						this._items = [];

						this.setValue = this._setValue;

						if (editorCombo.init) {
							editorCombo.init.call(this);
						}

						if (editorCombo.onRender) {
							editorCombo.onRender.call(this);
						}
					}
				}, {
					key: 'componentWillUnmount',
					value: function componentWillUnmount() {
						this._cacheValue(this.state.value);

						this.setValue = this._cacheValue;
					}
				}, {
					key: 'getValue',
					value: function getValue() {
						return this.state.value;
					}
				}, {
					key: 'render',
					value: function render() {
						var editor = this.context.editor.get('nativeEditor');

						var richComboLabel = RICH_COMBO_DEFS[editor.name][richComboName].currentValue || richComboDefinition.label;

						return _react2.default.createElement(
							'div',
							{ className: 'ae-container-dropdown ae-has-dropdown' },
							_react2.default.createElement(
								'button',
								{
									'aria-expanded': this.props.expanded,
									'aria-label': richComboLabel,
									className: 'ae-toolbar-element',
									onClick: this.props.toggleDropdown,
									role: 'combobox',
									tabIndex: this.props.tabIndex,
									title: richComboLabel },
								_react2.default.createElement(
									'div',
									{ className: 'ae-container' },
									_react2.default.createElement(
										'span',
										{ className: 'ae-container-dropdown-selected-item' },
										richComboLabel
									),
									_react2.default.createElement(_buttonIcon2.default, { symbol: 'caret-bottom' })
								)
							),
							this.props.expanded && _react2.default.createElement(
								_buttonDropdown2.default,
								{
									onDismiss: this.props.toggleDropdown },
								this._getItems()
							)
						);
					}
				}, {
					key: '_cacheValue',
					value: function _cacheValue(value) {
						var editor = this.context.editor.get('nativeEditor');

						RICH_COMBO_DEFS[editor.name][richComboName].currentValue = value;
					}
				}, {
					key: '_getItems',
					value: function _getItems() {
						var _this2 = this;

						var richCombo = this;

						var items = this._items.map(function (item) {
							var className = 'ae-toolbar-element ' + (item.value === _this2.state.value ? 'active' : '');

							return _react2.default.createElement(
								'li',
								{ key: item.title, role: 'option' },
								_react2.default.createElement('button', {
									className: className,
									dangerouslySetInnerHTML: {
										__html: item.preview
									},
									'data-value': item.value,
									onClick: richCombo._onClick
								})
							);
						});

						return items;
					}
				}, {
					key: '_setValue',
					value: function _setValue(value) {
						this._cacheValue(value);

						this.setState({
							value: value
						});
					}
				}]);

				return RichComboBridge;
			}(_react2.default.Component), _class.contextType = _editorContext2.default, _class.displayName = richComboName, _class.key = richComboName, _temp);

			AlloyEditor.Buttons[richComboName] = RichComboBridge;
		}

		return RichComboBridge;
	};

	/* istanbul ignore else */
	if (!CKEDITOR.plugins.get('richcombo')) {
		CKEDITOR.UI_RICHCOMBO = 'richcombo';

		CKEDITOR.plugins.add('richcombo', {});
	}

	/**
  * CKEditor plugin that bridges the support offered by CKEditor RichCombo plugin. It takes over the
  * responsibility of registering and creating rich combo elements via:
  * - editor.ui.addRichCombo(name, definition)
  * - editor.ui.add(name, CKEDITOR.UI_RICHCOMBO, definition)
  *
  * @class CKEDITOR.plugins.ae_richcombobridge
  * @requires CKEDITOR.plugins.ae_uibridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_richcombobridge', {
		requires: ['ae_uibridge'],

		/**
   * Set the add handler for UI_RICHCOMBO to our own. We do this in the init phase to override
   * the one in the original plugin in case it's present
   *
   * @method init
   * @param {Object} editor The CKEditor instance being initialized
   */
		beforeInit: function beforeInit(editor) {
			editor.ui.addRichCombo = function (richComboName, richComboDefinition) {
				this.add(richComboName, CKEDITOR.UI_RICHCOMBO, richComboDefinition);
			};

			editor.ui.addHandler(CKEDITOR.UI_RICHCOMBO, {
				add: generateRichComboBridge,
				create: function create(richComboDefinition) {
					var richComboName = 'richComboBridge' + (Math.random() * 1e9 >>> 0);
					var RichComboBridge = generateRichComboBridge(richComboName, richComboDefinition);

					return new RichComboBridge();
				}
			});
		}
	});
}

/***/ }),

/***/ "./src/components/uibridge/uibridge.js":
/*!*********************************************!*\
  !*** ./src/components/uibridge/uibridge.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_uibridge')) {
	/**
  * CKEditor plugin that extends CKEDITOR.ui.add function so an add handler can be specified
  * on top of the original ones. It bridges the calls to add components via:
  * - editor.ui.add(name, type, definition)
  *
  * @class CKEDITOR.plugins.ae_uibridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_uibridge', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   *
   * @method beforeInit
   * @param {Object} editor The current editor instance
   */
		beforeInit: function beforeInit(editor) {
			var originalUIAddFn = editor.ui.add;

			editor.ui.add = function (name, type, definition) {
				originalUIAddFn.call(this, name, type, definition);

				var typeHandler = this._.handlers[type];

				if (typeHandler && typeHandler.add) {
					typeHandler.add(name, definition, editor);
					AlloyEditor.registerBridgeButton(name, editor.__processingPlugin__.plugin.name);
				}
			};
		}
	});
}

/***/ }),

/***/ "./src/core/debounce.js":
/*!******************************!*\
  !*** ./src/core/debounce.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * Debounce util function. If a function execution is expensive, it might be debounced. This means
 * that it will be executed after some amount of time after its last call. For example, if we attach a
 * a function on scroll event, it might be called hundreds times per second. In this case it may be
 * debounced with, let's say 100ms. The real execution of this function will happen 100ms after last
 * scroll event.
 *
 * @memberof CKEDITOR.tools
 * @method debounce
 * @param {Array} args An array of arguments which the callback will receive.
 * @param {Function} callback The callback which has to be called after given timeout.
 * @param {Number} timeout Timeout in milliseconds after which the callback will be called.
 * @param {Object} context The context in which the callback will be called. This argument is optional.
 * @static
 */
function debounce(callback, timeout, context) {
  var args = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

  var debounceHandle = void 0;

  var callFn = function callFn() {
    for (var _len = arguments.length, callArgs = Array(_len), _key = 0; _key < _len; _key++) {
      callArgs[_key] = arguments[_key];
    }

    /* eslint-disable no-invalid-this */
    var callContext = context || this;
    /* eslint-enable no-invalid-this */

    clearTimeout(debounceHandle);

    debounceHandle = setTimeout(function () {
      callback.apply(callContext, [].concat(callArgs, _toConsumableArray(args)));
    }, timeout);
  };

  callFn.detach = function () {
    clearTimeout(debounceHandle);
  };

  return callFn;
}

CKEDITOR.tools.debounce = CKEDITOR.tools.debounce || debounce;

exports.default = debounce;

/***/ }),

/***/ "./src/core/index.js":
/*!***************************!*\
  !*** ./src/core/index.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debounce = undefined;

var _debounce = __webpack_require__(/*! ./debounce */ "./src/core/debounce.js");

var _debounce2 = _interopRequireDefault(_debounce);

__webpack_require__(/*! ./link */ "./src/core/link.js");

__webpack_require__(/*! ./plugins */ "./src/core/plugins.js");

__webpack_require__(/*! ./selection-region */ "./src/core/selection-region.js");

__webpack_require__(/*! ./table */ "./src/core/table.js");

__webpack_require__(/*! ./tools */ "./src/core/tools.js");

__webpack_require__(/*! ./uicore */ "./src/core/uicore.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.debounce = _debounce2.default; /**
                                        * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                        * SPDX-License-Identifier: LGPL-3.0-or-later
                                        */

/***/ }),

/***/ "./src/core/link.js":
/*!**************************!*\
  !*** ./src/core/link.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var REGEX_BOOKMARK_SCHEME = /^#.*/i;
var REGEX_EMAIL_SCHEME = /^[a-z0-9\u0430-\u044F._-]+@/i;
var REGEX_URI_SCHEME = /^(?:[a-z][a-z0-9+\-.]*):|^\//i;

/**
 * Link class utility. Provides methods for create, delete and update links.
 *
 * @class CKEDITOR.Link
 * @constructor
 * @param {Object} editor The CKEditor instance.
 */
function Link(editor, config) {
	this._editor = editor;
	this.appendProtocol = config && config.appendProtocol === false ? false : true;
}

Link.prototype = {
	constructor: Link,

	/**
  * Advances the editor selection to the next available position after a
  * given link or the one in the current selection.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method advanceSelection
  * @param {CKEDITOR.dom.element} link The link element which link style should be removed.
  */
	advanceSelection: function advanceSelection(link) {
		link = link || this.getFromSelection();

		var range = this._editor.getSelection().getRanges()[0];

		if (link) {
			range.moveToElementEditEnd(link);

			var nextNode = range.getNextEditableNode();

			if (nextNode && !this._editor.element.equals(nextNode.getCommonAncestor(link))) {
				var whitespace = /\s/.exec(nextNode.getText());

				var offset = whitespace ? whitespace.index + 1 : 0;

				range.setStart(nextNode, offset);
				range.setEnd(nextNode, offset);
			}
		}

		this._editor.getSelection().selectRanges([range]);
	},


	/**
  * Create a link with given URI as href.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method create
  * @param {Object} attrs A config object with link attributes. These might be arbitrary DOM attributes.
  * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
  * @param {String} URI The URI of the link.
  */
	create: function create(URI, attrs, modifySelection) {
		var selection = this._editor.getSelection();

		var range = selection.getRanges()[0];

		if (range.collapsed) {
			var text = new CKEDITOR.dom.text(URI, this._editor.document);
			range.insertNode(text);
			range.selectNodeContents(text);
		}

		URI = this._getCompleteURI(URI);

		var linkAttrs = CKEDITOR.tools.merge({
			'data-cke-saved-href': URI,
			href: URI
		}, attrs);

		var style = new CKEDITOR.style({
			attributes: linkAttrs,
			element: 'a'
		});

		style.type = CKEDITOR.STYLE_INLINE;
		style.applyToRange(range, this._editor);

		if (modifySelection && modifySelection.advance) {
			this.advanceSelection();
		} else {
			range.select();
		}
	},


	/**
  * Retrieves a link from the current selection.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method getFromSelection
  * @return {CKEDITOR.dom.element} The retrieved link or null if not found.
  */
	getFromSelection: function getFromSelection() {
		var selection = this._editor.getSelection();

		var selectedElement = selection.getSelectedElement();

		if (selectedElement && selectedElement.is('a')) {
			return selectedElement;
		}

		if (selectedElement && CKEDITOR.env.ie) {
			var children = selectedElement.getChildren();

			var count = children.count();

			for (var i = 0; i < count; i++) {
				var node = children.getItem(i);

				if (node.is('a')) {
					return node;
				}
			}
		}

		var range = selection.getRanges()[0];

		if (range) {
			range.shrink(CKEDITOR.SHRINK_TEXT);

			return this._editor.elementPath(range.getCommonAncestor()).contains('a', 1);
		}

		return null;
	},


	/**
  * Removes a link from the editor.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method remove
  * @param {CKEDITOR.dom.element} link The link element which link style should be removed.
  * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
  */
	remove: function remove(link, modifySelection) {
		var editor = this._editor;

		if (link) {
			if (modifySelection && modifySelection.advance) {
				this.advanceSelection();
			}

			link.remove(editor);
		} else {
			var style = new CKEDITOR.style({
				alwaysRemoveElement: 1,
				element: 'a',
				type: CKEDITOR.STYLE_INLINE
			});

			// 'removeStyle()' removes the style from the editor's current selection.
			//  We need to force the selection to be the whole link element
			//  to remove it properly.

			var selection = editor.getSelection();
			selection.selectElement(selection.getStartElement());

			editor.removeStyle(style);
		}
	},


	/**
  * Updates the href of an already existing link.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method update
  * @param {CKEDITOR.dom.element} link The link element which href should be removed.
  * @param {Object|String} attrs The attributes to update or remove. Attributes with null values will be removed.
  * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
  */
	update: function update(attrs, link, modifySelection) {
		var instance = this;

		link = link || this.getFromSelection();

		if (typeof attrs === 'string') {
			var uri = instance._getCompleteURI(attrs);

			link.setAttributes({
				'data-cke-saved-href': uri,
				href: uri
			});
		} else if ((typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs)) === 'object') {
			var removeAttrs = [];

			var setAttrs = {};

			Object.keys(attrs).forEach(function (key) {
				if (attrs[key] === null) {
					if (key === 'href') {
						removeAttrs.push('data-cke-saved-href');
					}

					removeAttrs.push(key);
				} else {
					if (key === 'href') {
						var _uri = instance._getCompleteURI(attrs[key]);

						setAttrs['data-cke-saved-href'] = _uri;
						setAttrs[key] = _uri;
					} else {
						setAttrs[key] = attrs[key];
					}
				}
			});

			link.removeAttributes(removeAttrs);
			link.setAttributes(setAttrs);
		}

		if (modifySelection && modifySelection.advance) {
			this.advanceSelection(link);
		}
	},


	/**
  * Checks if the URI begins with a '#' symbol to determine if it's an on page bookmark.
  * If it doesn't, it then checks if the URI has an '@' symbol. If it does and the URI
  * looks like an email and doesn't have 'mailto:', 'mailto:' is added to the URI.
  * If it doesn't and the URI doesn't have a scheme, the default 'http' scheme with
  * hierarchical path '//' is added to the URI.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method _getCompleteURI
  * @param {String} URI The URI of the link.
  * @protected
  * @return {String} The URI updated with the protocol.
  */
	_getCompleteURI: function _getCompleteURI(URI) {
		if (REGEX_BOOKMARK_SCHEME.test(URI)) {
			return URI;
		} else if (REGEX_EMAIL_SCHEME.test(URI)) {
			URI = 'mailto:' + URI;
		} else if (!REGEX_URI_SCHEME.test(URI)) {
			URI = this.appendProtocol ? 'http://' + URI : URI;
		}

		return URI;
	}
};

CKEDITOR.Link = CKEDITOR.Link || Link;

/***/ }),

/***/ "./src/core/plugins.js":
/*!*****************************!*\
  !*** ./src/core/plugins.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

// Wraps each of the plugin lifecycle methods in a closure that will
// set up the editor.__processingPlugin__ variable so it can be globally
// accessed exposing the plugin being processed and the lifecycle phase
// in which it is happening
//
// @param {Object} plugin The plugin to wrap lifecycle methods
var wrapPluginLifecycle = function wrapPluginLifecycle(plugin) {
	var methods = ['beforeInit', 'init', 'afterInit'];

	methods.forEach(function (methodName) {
		if (plugin[methodName]) {
			plugin[methodName] = CKEDITOR.tools.override(plugin[methodName], function (originalPluginMethod) {
				var payload = {
					phase: methodName,
					plugin: plugin
				};

				return function (editor) {
					editor.__processingPlugin__ = payload;

					// eslint-disable-next-line no-invalid-this
					originalPluginMethod.call(this, editor);

					editor.__processingPlugin__ = null;
				};
			});
		}
	});
};

// Filters the requires object to remove unwanted dependencies. At this point
// only 'toolbar' has been identified, but more can appear. An unwanted plugin
// dependency is one that prevents a necessary plugin from being removed
//
// @param {string|Array<string>} requires The requires object
// @return {string} The filtered requires object
var filterUnwantedDependencies = function filterUnwantedDependencies(requires) {
	if (typeof requires === 'string') {
		requires = requires.split(',');
	}

	return requires.filter(function (require) {
		return require !== 'toolbar';
	});
};

/**
 * CKEDITOR.plugins class utility which adds additional methods to those of CKEditor.
 *
 * @class CKEDITOR.plugins
 */

/**
 * Overrides CKEDITOR.plugins.load method so we can extend the lifecycle methods of
 * the loaded plugins to add some metainformation about the plugin being processed
 *
 * @param {String/Array} names The name of the resource to load. It may be a
 * string with a single resource name, or an array with several names.
 * @param {Function} callback A function to be called when all resources
 * are loaded. The callback will receive an array containing all loaded names.
 * @param {Object} [scope] The scope object to be used for the callback call.
 * @memberof CKEDITOR.plugins
 * @method load
 * @static
 */
CKEDITOR.plugins.load = CKEDITOR.tools.override(CKEDITOR.plugins.load, function (pluginsLoad) {
	// Wrap original load function so we can transform the plugin input parameter
	// before passing it down to the original callback
	return function (names, callback, scope) {
		// eslint-disable-next-line no-invalid-this
		pluginsLoad.call(this, names, function (plugins) {
			if (callback) {
				Object.keys(plugins).forEach(function (pluginName) {
					var plugin = plugins[pluginName];

					if (plugin.requires) {
						plugin.requires = filterUnwantedDependencies(plugin.requires);
					}

					wrapPluginLifecycle(plugin);
				});

				callback.call(scope, plugins);
			}
		});
	};
});

/***/ }),

/***/ "./src/core/selection-region.js":
/*!**************************************!*\
  !*** ./src/core/selection-region.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

if (!CKEDITOR.plugins.get('ae_selectionregion')) {
	CKEDITOR.SELECTION_TOP_TO_BOTTOM = 0;
	CKEDITOR.SELECTION_BOTTOM_TO_TOP = 1;
	CKEDITOR.SELECTION_LEFT_TO_RIGHT = 2;
	CKEDITOR.SELECTION_RIGHT_TO_LEFT = 3;

	/**
  * SelectionRegion utility class which provides metadata about the selection. The metadata may be the start and end
  * rectangles, caret region, etc. **This class is not intended to be used standalone. Its functions will
  * be merged into each editor instance, so the developer may use them directly via the editor, without making
  * an instance of this class**.
  *
  * @class SelectionRegion
  * @constructor
  */
	function SelectionRegion() {}

	SelectionRegion.prototype = {
		constructor: SelectionRegion,

		/**
   * Creates selection from two points in page coordinates.
   *
   * @instance
   * @memberof SelectionRegion
   * @method createSelectionFromPoint
   * @param {Number} x X point in page coordinates.
   * @param {Number} y Y point in page coordinates.
   */
		createSelectionFromPoint: function createSelectionFromPoint(x, y) {
			this.createSelectionFromRange(x, y, x, y);
		},


		/**
   * Creates selection from range. A range consists from two points in page coordinates.
   *
   * @instance
   * @memberof SelectionRegion
   * @method createSelectionFromRange
   * @param {Number} startX X coordinate of the first point.
   * @param {Number} startY Y coordinate of the first point.
   * @param {Number} endX X coordinate of the second point.
   * @param {Number} endY Y coordinate of the second point.
   */
		createSelectionFromRange: function createSelectionFromRange(startX, startY, endX, endY) {
			var end = void 0;
			var endContainer = void 0;
			var endOffset = void 0;
			var range = void 0;
			var start = void 0;
			var startContainer = void 0;
			var startOffset = void 0;

			if (typeof document.caretPositionFromPoint === 'function') {
				start = document.caretPositionFromPoint(startX, startY);
				end = document.caretPositionFromPoint(endX, endY);

				startContainer = start.offsetNode;
				endContainer = end.offsetNode;

				startOffset = start.offset;
				endOffset = end.offset;

				range = this.createRange();
			} else if (typeof document.caretRangeFromPoint === 'function') {
				start = document.caretRangeFromPoint(startX, startY);
				end = document.caretRangeFromPoint(endX, endY);

				startContainer = start.startContainer;
				endContainer = end.startContainer;

				startOffset = start.startOffset;
				endOffset = end.startOffset;

				range = this.createRange();
			}

			if (range && document.getSelection) {
				range.setStart(new CKEDITOR.dom.node(startContainer), startOffset);
				range.setEnd(new CKEDITOR.dom.node(endContainer), endOffset);

				this.getSelection().selectRanges([range]);
			} else if (typeof document.body.createTextRange === 'function') {
				var selection = this.getSelection();

				selection.unlock();

				range = document.body.createTextRange();
				range.moveToPoint(startX, startY);

				var endRange = range.duplicate();
				endRange.moveToPoint(endX, endY);

				range.setEndPoint('EndToEnd', endRange);
				range.select();

				this.getSelection().lock();
			}
		},


		/**
   * Returns the region of the current position of the caret. The points are in page coordinates.
   *
   * @instance
   * @memberof SelectionRegion
   * @method getCaretRegion
   * @return {Object} Returns object with the following properties:
   * - bottom
   * - left
   * - right
   * - top
   */
		getCaretRegion: function getCaretRegion() {
			var selection = this.getSelection();

			var region = {
				bottom: 0,
				left: 0,
				right: 0,
				top: 0
			};

			var bookmarks = selection.createBookmarks();

			if (!bookmarks.length) {
				return region;
			}

			var bookmarkNodeEl = bookmarks[0].startNode.$;

			bookmarkNodeEl.style.display = 'inline-block';

			region = new CKEDITOR.dom.element(bookmarkNodeEl).getClientRect();

			bookmarkNodeEl.parentNode.removeChild(bookmarkNodeEl);

			var scrollPos = new CKEDITOR.dom.window(window).getScrollPosition();

			region.bottom = scrollPos.y + region.bottom;
			region.left = scrollPos.x + region.left;
			region.right = scrollPos.x + region.right;
			region.top = scrollPos.y + region.top;

			return region;
		},


		/**
   * Returns data for the current selection.
   *
   * @instance
   * @memberof SelectionRegion
   * @method getSelectionData
   * @return {Object|null} Returns an object with the following data:
   * - element - The currently selected element, if any
   * - text - The selected text
   * - region - The data, returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionRegion:method"}}{{/crossLink}}
   */
		getSelectionData: function getSelectionData() {
			var selection = this.getSelection();

			if (!selection.getNative()) {
				return null;
			}

			var result = {
				element: selection.getSelectedElement(),
				text: selection.getSelectedText()
			};

			result.region = this.getSelectionRegion(selection);

			return result;
		},


		/**
   * Returns the region of the current selection.
   *
   * @instance
   * @memberof SelectionRegion
   * @method getSelectionRegion
   * @return {Object} Returns object which is being returned from
   * {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getClientRectsRegion:method"}}{{/crossLink}} with three more properties:
   * - direction - the direction of the selection. Can be one of these:
   *   1. CKEDITOR.SELECTION_TOP_TO_BOTTOM
   *   2. CKEDITOR.SELECTION_BOTTOM_TO_TOP
   * - height - The height of the selection region
   * - width - The width of the selection region
   */
		getSelectionRegion: function getSelectionRegion() {
			var region = this.getClientRectsRegion();

			region.direction = this.getSelectionDirection();

			region.height = region.bottom - region.top;
			region.width = region.right - region.left;

			return region;
		},


		/**
   * Returns true if the current selection is empty, false otherwise.
   *
   * @instance
   * @memberof SelectionRegion
   * @method isSelectionEmpty
   * @return {Boolean} Returns true if the current selection is empty, false otherwise.
   */
		isSelectionEmpty: function isSelectionEmpty() {
			var selection = this.getSelection();

			if (selection.getType() === CKEDITOR.SELECTION_NONE) {
				return true;
			}

			var ranges = selection.getRanges();
			return ranges && ranges.length === 1 && ranges[0].collapsed;
		},


		/**
   * Returns object with data about the [client rectangles](https://developer.mozilla.org/en-US/docs/Web/API/Element.getClientRects) of the selection,
   * normalized across browses. All offsets below are in page coordinates.
   *
   * @instance
   * @memberof SelectionRegion
   * @method getClientRectsRegion
   * @return {Object} Returns object with the following data:
   * - bottom - bottom offset of all client rectangles
   * - left - left offset of all client rectangles
   * - right - right offset of all client rectangles
   * - top - top offset of all client rectangles
   * - startRect - An Object, which contains the following information:
   *     + bottom - bottom offset
   *     + height - the height of the rectangle
   *     + left - left offset of the selection
   *     + right - right offset of the selection
   *     + top - top offset of the selection
   *     + width - the width of the rectangle
   * - endRect - An Object, which contains the following information:
   *     + bottom - bottom offset
   *     + height - the height of the rectangle
   *     + left - left offset of the selection
   *     + right - right offset of the selection
   *     + top - top offset of the selection
   *     + width - the width of the rectangle
   *
   * If there is no native selection, the objects will be filled with 0.
   */
		getClientRectsRegion: function getClientRectsRegion() {
			var selection = this.getSelection();
			var nativeSelection = selection.getNative();

			var defaultRect = {
				bottom: 0,
				height: 0,
				left: 0,
				right: 0,
				top: 0,
				width: 0
			};

			var region = {
				bottom: 0,
				endRect: defaultRect,
				left: 0,
				right: 0,
				top: 0,
				startRect: defaultRect
			};

			if (!nativeSelection) {
				return region;
			}

			var bottom = 0;
			var clientRects = void 0;
			var left = Infinity;
			var right = -Infinity;
			var top = Infinity;

			if (nativeSelection.createRange) {
				clientRects = nativeSelection.createRange().getClientRects();
			} else {
				clientRects = nativeSelection.rangeCount > 0 ? nativeSelection.getRangeAt(0).getClientRects() : [];
			}

			if (clientRects.length === 0) {
				region = this.getCaretRegion();
			} else {
				for (var i = 0, length = clientRects.length; i < length; i++) {
					var item = clientRects[i];

					if (item.left < left) {
						left = item.left;
					}

					if (item.right > right) {
						right = item.right;
					}

					if (item.top < top) {
						top = item.top;
					}

					if (item.bottom > bottom) {
						bottom = item.bottom;
					}
				}

				var scrollPos = new CKEDITOR.dom.window(window).getScrollPosition();

				region.bottom = scrollPos.y + bottom;
				region.left = scrollPos.x + left;
				region.right = scrollPos.x + right;
				region.top = scrollPos.y + top;

				if (clientRects.length) {
					var endRect = clientRects[clientRects.length - 1];
					var startRect = clientRects[0];

					region.endRect = {
						bottom: scrollPos.y + endRect.bottom,
						height: endRect.height,
						left: scrollPos.x + endRect.left,
						right: scrollPos.x + endRect.right,
						top: scrollPos.y + endRect.top,
						width: endRect.width
					};

					region.startRect = {
						bottom: scrollPos.y + startRect.bottom,
						height: startRect.height,
						left: scrollPos.x + startRect.left,
						right: scrollPos.x + startRect.right,
						top: scrollPos.y + startRect.top,
						width: startRect.width
					};
				}
			}

			return region;
		},


		/**
   * Retrieves the direction of the selection. The direction is from top to bottom or from bottom to top.
   * For IE < 9 it is not possible, so the direction for these browsers will be always CKEDITOR.SELECTION_TOP_TO_BOTTOM.
   *
   * @instance
   * @memberof SelectionRegion
   * @method getSelectionDirection
   * @return {Number} Returns a number which represents selection direction. It might be one of these:
   * - CKEDITOR.SELECTION_TOP_TO_BOTTOM;
   * - CKEDITOR.SELECTION_BOTTOM_TO_TOP;
   */
		getSelectionDirection: function getSelectionDirection() {
			var direction = CKEDITOR.SELECTION_TOP_TO_BOTTOM;
			var selection = this.getSelection();
			var nativeSelection = selection.getNative();

			if (!nativeSelection) {
				return direction;
			}

			var anchorNode = void 0;

			if ((anchorNode = nativeSelection.anchorNode) && anchorNode.compareDocumentPosition) {
				var position = anchorNode.compareDocumentPosition(nativeSelection.focusNode);

				if (!position && nativeSelection.anchorOffset > nativeSelection.focusOffset || position === Node.DOCUMENT_POSITION_PRECEDING) {
					direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
				}
			}

			return direction;
		}
	};

	CKEDITOR.plugins.add('ae_selectionregion', {
		init: function init(editor) {
			var attr = void 0;
			var hasOwnProperty = Object.prototype.hasOwnProperty;

			for (attr in SelectionRegion.prototype) {
				if (hasOwnProperty.call(SelectionRegion.prototype, attr) && typeof editor[attr] === 'undefined') {
					editor[attr] = SelectionRegion.prototype[attr];
				}
			}
		}
	});
}

/***/ }),

/***/ "./src/core/table.js":
/*!***************************!*\
  !*** ./src/core/table.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var IE_NON_DIRECTLY_EDITABLE_ELEMENT = {
	table: 1,
	col: 1,
	colgroup: 1,
	tbody: 1,
	td: 1,
	tfoot: 1,
	th: 1,
	thead: 1,
	tr: 1
};

/**
 * Table class utility. Provides methods for create, delete and update tables.
 *
 * @class CKEDITOR.Table
 * @constructor
 * @param {Object} editor The CKEditor instance.
 */

function Table(editor) {
	this._editor = editor;
}

Table.HEADING_BOTH = 'Both';
Table.HEADING_COL = 'Column';
Table.HEADING_NONE = 'None';
Table.HEADING_ROW = 'Row';

Table.prototype = {
	constructor: Table,

	/**
  * Creates a table.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method create
  * @param {Object} config Table configuration object
  * @return {Object} The created table
  */
	create: function create(config) {
		var editor = this._editor;
		var table = this._createElement('table');

		config = config || {};

		// Generate the rows and cols.
		var tbody = table.append(this._createElement('tbody'));
		var rows = config.rows || 1;
		var cols = config.cols || 1;

		for (var i = 0; i < rows; i++) {
			var row = tbody.append(this._createElement('tr'));
			for (var j = 0; j < cols; j++) {
				var cell = row.append(this._createElement('td'));

				cell.appendBogus();
			}
		}

		this.setAttributes(table, config.attrs);
		this.setHeading(table, config.heading);

		// Insert the table element if we're creating one.
		editor.insertElement(table);

		var firstCell = new CKEDITOR.dom.element(table.$.rows[0].cells[0]);
		var range = editor.createRange();
		range.moveToPosition(firstCell, CKEDITOR.POSITION_AFTER_START);
		range.select();

		return table;
	},


	/**
  * Retrieves a table from the current selection.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method getFromSelection
  * @return {CKEDITOR.dom.element} The retrieved table or null if not found.
  */
	getFromSelection: function getFromSelection() {
		var table = void 0;
		var selection = this._editor.getSelection();
		var selected = selection.getSelectedElement();

		if (selected && selected.is('table')) {
			table = selected;
		} else {
			var ranges = selection.getRanges();

			if (ranges.length > 0) {
				// Webkit could report the following range on cell selection (#4948):
				// <table><tr><td>[&nbsp;</td></tr></table>]

				/* istanbul ignore else */
				if (CKEDITOR.env.webkit) {
					ranges[0].shrink(CKEDITOR.NODE_ELEMENT);
				}

				table = this._editor.elementPath(ranges[0].getCommonAncestor(true)).contains('table', 1);
			}
		}

		return table;
	},


	/**
  * Checks if a given table can be considered as editable. This method
  * workarounds a limitation of IE where for some elements (like table),
  * `isContentEditable` returns always false. This is because IE does not support
  * `contenteditable` on such elements. However, despite such elements
  * cannot be set as content editable directly, a content editable SPAN,
  * or DIV element can be placed inside the individual table cells.
  * See https://msdn.microsoft.com/en-us/library/ms537837%28v=VS.85%29.aspx
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method isEditable
  * @param {CKEDITOR.dom.element} el The table element to test if editable
  * @return {Boolean}
  */
	isEditable: function isEditable(el) {
		if (!CKEDITOR.env.ie || !el.is(IE_NON_DIRECTLY_EDITABLE_ELEMENT)) {
			return !el.isReadOnly();
		}

		if (el.hasAttribute('contenteditable')) {
			return el.getAttribute('contenteditable') !== 'false';
		}

		return this.isEditable(el.getParent());
	},


	/**
  * Returns which heading style is set for the given table.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method getHeading
  * @param {CKEDITOR.dom.element} table The table to gather the heading from. If null, it will be retrieved from the current selection.
  * @return {String} The heading of the table. Expected values are `CKEDITOR.Table.NONE`, `CKEDITOR.Table.ROW`, `CKEDITOR.Table.COL` and `CKEDITOR.Table.BOTH`.
  */
	getHeading: function getHeading(table) {
		table = table || this.getFromSelection();

		if (!table) {
			return null;
		}

		var rowHeadingSettings = table.$.tHead !== null;

		var colHeadingSettings = true;

		// Check if all of the first cells in every row are TH
		for (var row = 0; row < table.$.rows.length; row++) {
			// If just one cell isn't a TH then it isn't a header column
			var cell = table.$.rows[row].cells[0];

			if (cell && cell.nodeName.toLowerCase() !== 'th') {
				colHeadingSettings = false;
				break;
			}
		}

		var headingSettings = Table.HEADING_NONE;

		if (rowHeadingSettings) {
			headingSettings = Table.HEADING_ROW;
		}

		if (colHeadingSettings) {
			headingSettings = headingSettings === Table.HEADING_ROW ? Table.HEADING_BOTH : Table.HEADING_COL;
		}

		return headingSettings;
	},


	/**
  * Removes a table from the editor.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method remove
  * @param {CKEDITOR.dom.element} table The table element which table style should be removed.
  */
	remove: function remove(table) {
		var editor = this._editor;

		if (table) {
			table.remove();
		} else {
			table = editor.elementPath().contains('table', 1);

			if (table) {
				// If the table's parent has only one child remove it as well (unless it's a table cell, or the editable element) (#5416, #6289, #12110)
				var parent = table.getParent();
				var editable = editor.editable();

				if (parent.getChildCount() === 1 && !parent.is('td', 'th') && !parent.equals(editable)) {
					table = parent;
				}

				var range = editor.createRange();
				range.moveToPosition(table, CKEDITOR.POSITION_BEFORE_START);
				table.remove();
			}
		}
	},


	/**
  * Assigns provided attributes to a table.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method setAttributes
  * @param {Object} table The table to which the attributes should be assigned
  * @param {Object} attrs The attributes which have to be assigned to the table
  */
	setAttributes: function setAttributes(table, attrs) {
		if (attrs) {
			Object.keys(attrs).forEach(function (attr) {
				table.setAttribute(attr, attrs[attr]);
			});
		}
	},


	/**
  * Sets the appropriate table heading style to a table.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method setHeading
  * @param {CKEDITOR.dom.element} table The table element to which the heading should be set. If null, it will be retrieved from the current selection.
  * @param {String} heading The table heading to be set. Accepted values are: `CKEDITOR.Table.NONE`, `CKEDITOR.Table.ROW`, `CKEDITOR.Table.COL` and `CKEDITOR.Table.BOTH`.
  */
	setHeading: function setHeading(table, heading) {
		table = table || this.getFromSelection();

		var i = void 0;
		var newCell = void 0;
		var tableHead = void 0;
		var tableBody = table.getElementsByTag('tbody').getItem(0);

		var tableHeading = this.getHeading(table);
		var hadColHeading = tableHeading === Table.HEADING_COL || tableHeading === Table.HEADING_BOTH;

		var needColHeading = heading === Table.HEADING_COL || heading === Table.HEADING_BOTH;
		var needRowHeading = heading === Table.HEADING_ROW || heading === Table.HEADING_BOTH;

		// If we need row heading and don't have a <thead> element yet, move the
		// first row of the table to the head and convert the nodes to <th> ones.
		if (!table.$.tHead && needRowHeading) {
			var tableFirstRow = tableBody.getElementsByTag('tr').getItem(0);
			var tableFirstRowChildCount = tableFirstRow.getChildCount();

			// Change TD to TH:
			for (i = 0; i < tableFirstRowChildCount; i++) {
				var cell = tableFirstRow.getChild(i);

				// Skip bookmark nodes. (#6155)
				if (cell.type === CKEDITOR.NODE_ELEMENT && !cell.data('cke-bookmark')) {
					cell.renameNode('th');
					cell.setAttribute('scope', 'col');
				}
			}

			tableHead = this._createElement(table.$.createTHead());
			tableHead.append(tableFirstRow.remove());
		}

		// If we don't need row heading and we have a <thead> element, move the
		// row out of there and into the <tbody> element.
		if (table.$.tHead !== null && !needRowHeading) {
			// Move the row out of the THead and put it in the TBody:
			tableHead = this._createElement(table.$.tHead);

			var previousFirstRow = tableBody.getFirst();

			while (tableHead.getChildCount() > 0) {
				var newFirstRow = tableHead.getFirst();
				var newFirstRowChildCount = newFirstRow.getChildCount();

				for (i = 0; i < newFirstRowChildCount; i++) {
					newCell = newFirstRow.getChild(i);

					if (newCell.type === CKEDITOR.NODE_ELEMENT) {
						newCell.renameNode('td');
						newCell.removeAttribute('scope');
					}
				}

				newFirstRow.insertBefore(previousFirstRow);
			}

			tableHead.remove();
		}

		tableHeading = this.getHeading(table);
		var hasColHeading = tableHeading === Table.HEADING_COL || tableHeading === Table.HEADING_BOTH;

		// If we need column heading and the table doesn't have it, convert every first cell in
		// every row into a `<th scope="row">` element.
		if (!hasColHeading && needColHeading) {
			for (i = 0; i < table.$.rows.length; i++) {
				if (table.$.rows[i].cells[0].nodeName.toLowerCase() !== 'th') {
					newCell = new CKEDITOR.dom.element(table.$.rows[i].cells[0]);
					newCell.renameNode('th');
					newCell.setAttribute('scope', 'row');
				}
			}
		}

		// If we don't need column heading but the table has it, convert every first cell in every
		// row back into a `<td>` element.
		if (hadColHeading && !needColHeading) {
			for (i = 0; i < table.$.rows.length; i++) {
				var row = new CKEDITOR.dom.element(table.$.rows[i]);

				if (row.getParent().getName() === 'tbody') {
					newCell = new CKEDITOR.dom.element(row.$.cells[0]);
					newCell.renameNode('td');
					newCell.removeAttribute('scope');
				}
			}
		}
	},


	/**
  * Creates a new CKEDITOR.dom.element using the passed tag name.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @protected
  * @method _createElement
  * @param {String} name The tag name from which an element should be created
  * @return {CKEDITOR.dom.element} Instance of CKEDITOR DOM element class
  */
	_createElement: function _createElement(name) {
		return new CKEDITOR.dom.element(name, this._editor.document);
	}
};

CKEDITOR.on('instanceReady', function (event) {
	var headingCommands = [Table.HEADING_NONE, Table.HEADING_ROW, Table.HEADING_COL, Table.HEADING_BOTH];

	var tableUtils = new Table(event.editor);

	headingCommands.forEach(function (heading) {
		event.editor.addCommand('tableHeading' + heading, {
			exec: function exec(_editor) {
				tableUtils.setHeading(null, heading);
			}
		});
	});
});

CKEDITOR.Table = CKEDITOR.Table || Table;

/***/ }),

/***/ "./src/core/tools.js":
/*!***************************!*\
  !*** ./src/core/tools.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * CKEDITOR.tools class utility which adds additional methods to those of CKEditor.
 *
 * @class CKEDITOR.tools
 */

/**
 * Sends a request using the JSONP technique.
 *
 * @memberof CKEDITOR.tools
 * @method jsonp
 * @param {CKEDITOR.template} urlTemplate The template of the URL to be requested. All properties passed in `urlParams` can be used, plus a `{callback}`, which represent a JSONP callback, must be defined.
 * @param {Function} callback A function to be called in case of success.
 * @param {Function} errorCallback A function to be called in case of failure.
 * @param {Object} urlParams Parameters to be passed to the `urlTemplate`.
 * @return {Object} An object with the following properties:
 *  - id: the transaction ID
 *  - a `cancel()` method
 * @static
 */
CKEDITOR.tools.jsonp = function (urlTemplate, urlParams, callback, errorCallback) {
	var callbackKey = CKEDITOR.tools.getNextNumber();

	urlParams = urlParams || {};
	urlParams.callback = 'CKEDITOR._.jsonpCallbacks[' + callbackKey + ']';

	if (!CKEDITOR._.jsonpCallbacks) {
		CKEDITOR._.jsonpCallbacks = {};
	}

	CKEDITOR._.jsonpCallbacks[callbackKey] = function (response) {
		setTimeout(function () {
			cleanUp();

			callback(response);
		});
	};

	var scriptElement = new CKEDITOR.dom.element('script');
	scriptElement.setAttribute('src', urlTemplate.output(urlParams));
	scriptElement.on('error', function () {
		cleanUp();

		if (errorCallback) {
			errorCallback();
		}
	});

	function cleanUp() {
		if (scriptElement) {
			scriptElement.remove();
			delete CKEDITOR._.jsonpCallbacks[callbackKey];
			scriptElement = null;
		}
	}

	CKEDITOR.document.getBody().append(scriptElement);

	return {
		cancel: cleanUp,
		id: callbackKey
	};
};

/**
 * Returns a new object containing all of the properties of all the supplied
 * objects. The properties from later objects will overwrite those in earlier
 * objects.
 *
 * Passing in a single object will create a shallow copy of it.
 *
 * @memberof CKEDITOR.tools
 * @method merge
 * @param {Object} objects* One or more objects to merge.
 * @return {Object} A new merged object.
 * @static
 */
CKEDITOR.tools.merge = CKEDITOR.tools.merge || function () {
	var result = {};

	for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		args[_key] = arguments[_key];
	}

	for (var i = 0; i < args.length; ++i) {
		var obj = args[i];

		for (var key in obj) {
			if (Object.prototype.hasOwnProperty.call(obj, key)) {
				result[key] = obj[key];
			}
		}
	}

	return result;
};

/**
 * Simulates event on a DOM element.
 *
 * @memberof CKEDITOR.tools
 * @method simulate
 * @param {DOMElement} element The element on which the event shoud be simualted.
 * @param {String} event The name of the event which have to be simulated.
 * @static
 */
CKEDITOR.tools.simulate = function (element, event) {
	var eventInstance = document.createEvent('Events');
	eventInstance.initEvent(event, true, false);
	element.dispatchEvent(eventInstance);
};

/***/ }),

/***/ "./src/core/uicore.js":
/*!****************************!*\
  !*** ./src/core/uicore.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

if (!CKEDITOR.plugins.get('ae_uicore')) {
	/**
  * UICore class which will handle user interactions with the editor. These interactions
  * might be triggered via mouse, keyboard or touch devices. The class fill fire an event via
  * CKEditor's event system - "editorInteraction". The UI may listen to this event and
  * execute some actions - for example to show/hide toolbars.
  *
  * By default if user presses the Esc key, 'editorInteraction' event won't be fired. However, this behaviour can be changed
  * by setting {{#crossLink "CKEDITOR.plugins.ae_uicore/allowEsc:attribute"}}{{/crossLink}} config property in editor's configuration to true.
  *
  * @class ae_uicore
  */

	/**
  * Fired when user interacts somehow with the browser. This may be clicking with the mouse, pressing keyboard button,
  * or touching screen. This even will be not fired after each interaction. It will be debounced. By default the timeout
  * is 50ms. This value can be overwritten via {{#crossLink "CKEDITOR.plugins.ae_uicore/timeout:attribute"}}{{/crossLink}}
  * property of editor's configuration, like: editor.config.uicore.timeout = 100
  *
  * @memberof ae_uicore
  * @event ae_uicore#editorInteraction
  * @param {Object} data An object which contains the following properties:
  * - nativeEvent - The event as received from CKEditor.
  * - selectionData - The data, returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
  */

	/**
  * Fired by UI elements like Toolbars or Buttons when their state changes. The listener updates the live region with the provided data.
  *
  * @memberof ae_uicore
  * @event ae_uicore#ariaUpdate
  * @param {Object} data An object which contains the following properties:
  * - message - The provided message from the UI element.
  */

	/**
  * If set to true, the editor will still fire {{#crossLink "CKEDITOR.plugins.ae_uicore/editorInteraction:event"}}{{/crossLink}} event,
  * if user presses Esc key.
  *
  * @memberof ae_uicore
  * @attribute allowEsc
  * @default false
  * @type Boolean
  */

	/**
  * Specifies the default timeout after which the {{#crossLink "CKEDITOR.plugins.ae_uicore/editorInteraction:event"}}{{/crossLink}} event
  * will be fired.
  *
  * @memberof ae_uicore
  * @attribute timeout
  * @default 50 (ms)
  * @type Number
  */

	CKEDITOR.plugins.add('ae_uicore', {
		/**
   * Initializer lifecycle implementation for the UICore plugin.
   *
   * @memberof ae_uicore
   * @method init
   * @param {Object} editor The current CKEditor instance.
   * @protected
   */
		init: function init(editor) {
			var ariaState = [];

			var ariaElement = this._createAriaElement(editor.id);

			var uiTasksTimeout = editor.config.uicore ? editor.config.uicore.timeout : 50;

			var handleUI = CKEDITOR.tools.debounce(function (event) {
				ariaState = [];

				if (event.name !== 'keyup' || event.data.$.keyCode !== 27 || editor.config.allowEsc) {
					var selectionData = editor.getSelectionData();

					if (selectionData) {
						editor.fire('editorInteraction', {
							nativeEvent: event.data.$,
							selectionData: selectionData
						});
					}
				}
			}, uiTasksTimeout);

			var handleAria = CKEDITOR.tools.debounce(function (_event) {
				ariaElement.innerHTML = ariaState.join('. ');
			}, uiTasksTimeout);

			var handleMouseLeave = CKEDITOR.tools.debounce(function (event) {
				var aeUINodes = document.querySelectorAll('.ae-ui');

				var found = void 0;

				for (var i = 0; i < aeUINodes.length; i++) {
					if (aeUINodes[i].contains(event.data.$.relatedTarget)) {
						found = true;
						break;
					}
				}

				if (!found) {
					handleUI(event);
				}
			}, uiTasksTimeout);

			editor.on('ariaUpdate', function (event) {
				// handleAria is debounced function, so if it is being called multiple times, it will
				// be canceled until some time passes.
				// For that reason here we explicitly append the current message to the list of messages
				// and call handleAria. Since it is debounced, when some timeout passes,
				// all the messages will be applied to the live region and not only the last one.

				ariaState.push(event.data.message);

				handleAria();
			});

			editor.once('contentDom', function () {
				var editable = editor.editable();

				var focusHandler = editable.attachListener(editable, 'focus', function (event) {
					focusHandler.removeListener();

					editable.attachListener(editable, 'keyup', handleUI);
					editable.attachListener(editable, 'mouseup', handleUI);
					editable.attachListener(editable, 'mouseleave', handleMouseLeave);

					handleUI(event);
				});
			});

			editor.on('destroy', function (_event) {
				ariaElement.parentNode.removeChild(ariaElement);

				handleUI.detach();
			});
		},


		/**
   * Creates and applies an HTML element to the body of the document which will contain ARIA messages.
   *
   * @memberof ae_uicore
   * @method _createAriaElement
   * @param {String} id The provided id of the element. It will be used as prefix for the final element Id.
   * @protected
   * @return {HTMLElement} The created and applied to DOM element.
   */
		_createAriaElement: function _createAriaElement(id) {
			var statusElement = document.createElement('div');

			statusElement.className = 'ae-sr-only';

			statusElement.setAttribute('aria-live', 'polite');
			statusElement.setAttribute('role', 'status');
			statusElement.setAttribute('id', id + 'LiveRegion');

			document.body.appendChild(statusElement);

			return statusElement;
		}
	});
}

/***/ }),

/***/ "./src/oop/attribute.js":
/*!******************************!*\
  !*** ./src/oop/attribute.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _lang = __webpack_require__(/*! ./lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
                                                                                                                                                                                                     * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                     * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                     */

/**
 * Attribute implementation.
 *
 * @class Attribute
 * @constructor
 */
function Attribute(config) {
	this.__config__ = config || {};
	this.__ATTRS__ = {};
}

Attribute.prototype = {
	constructor: Attribute,

	/**
  * Retrieves the value of an attribute.
  *
  * @instance
  * @memberof Attribute
  * @method get
  * @param {String} attr The attribute which value should be retrieved.
  * @return {Any} The value of the attribute.
  */
	get: function get(attr) {
		var currentAttr = this.constructor.ATTRS[attr];

		if (!currentAttr) {
			return;
		}

		if (!this._isInitialized(attr)) {
			this._init(attr);
		}

		var curValue = this.__ATTRS__[attr];

		if (currentAttr.getter) {
			curValue = this._callStringOrFunction(currentAttr.getter, curValue);
		}

		return curValue;
	},


	/**
  * Sets the value of an attribute.
  *
  * @instance
  * @memberof Attribute
  * @method set
  * @param {String} attr The attribute which value should be set.
  * @param {Any} value The value which should be set to the attribute.
  */
	set: function set(attr, value) {
		var currentAttr = this.constructor.ATTRS[attr];

		if (!currentAttr) {
			return;
		}

		if (!this._isInitialized(attr)) {
			this._init(attr);
		}

		if (currentAttr.readOnly) {
			return;
		}

		if (currentAttr.writeOnce && this._isInitialized(attr)) {
			return;
		}

		if (currentAttr.validator && !this._callStringOrFunction(currentAttr.validator, value)) {
			return;
		}

		if (currentAttr.setter) {
			value = this._callStringOrFunction(currentAttr.setter, value);
		}

		this.__ATTRS__[attr] = value;
	},


	/**
  * Calls the provided param as function with the supplied arguments.
  * If param provided as string, a corresponding function in this object will
  * be called. If provided param is a function, it will be directly called.
  *
  * @instance
  * @memberof Attribute
  * @method _callStringOrFunction
  * @param  {Any|Array} args The arguments which will be provided to the called function
  * @param  {String|Function} stringOrFunction The function which should be called
  * @protected
  * @return {Any} The returned value from the called function
  */
	_callStringOrFunction: function _callStringOrFunction(stringOrFunction, args) {
		var result = null;

		if (!_lang2.default.isArray(args)) {
			args = [args];
		}

		if (_lang2.default.isString(stringOrFunction) && _lang2.default.isFunction(this[stringOrFunction])) {
			result = this[stringOrFunction].apply(this, _toConsumableArray(args));
		} else if (_lang2.default.isFunction(stringOrFunction)) {
			result = stringOrFunction.apply(this, args);
		}

		return result;
	},


	/**
  * Initializes an attribute. Sets its default value depending on the flags of the
  * attribute and the passed configuration object to the constructor.
  *
  * @instance
  * @memberof Attribute
  * @method _init
  * @param {String} attr The name of the attribute which have to be initialized.
  * @protected
  */
	_init: function _init(attr) {
		var value = void 0;

		var currentAttr = this.constructor.ATTRS[attr];

		// Check if there is default value or passed one via configuration object
		var hasDefaultValue = Object.prototype.hasOwnProperty.call(currentAttr, 'value');
		var hasPassedValueViaConfig = Object.prototype.hasOwnProperty.call(this.__config__, attr);

		// If there is valueFn, set the value to be the result of invocation of this function
		if (currentAttr.valueFn) {
			value = this._callStringOrFunction(currentAttr.valueFn, value);

			this.__ATTRS__[attr] = value;
		}
		// else if the attribute has readOnly flag, set the default value from the attribute,
		// regardless if there is value or not
		else if (currentAttr.readOnly) {
				value = currentAttr.value;
			}
			// else if the attribute has writeOnce value, set it from the passed configuration or from the
			// default value, in this order. Otherwise, return miserable.
			else if (currentAttr.writeOnce) {
					if (hasPassedValueViaConfig) {
						value = this.__config__[attr];
					} else if (hasDefaultValue) {
						value = currentAttr.value;
					} else {
						return;
					}
				}
				// These two cases below are easy - set the value to be from the passed config or
				// from the default value, in this order.
				else if (hasPassedValueViaConfig) {
						value = this.__config__[attr];
					} else if (hasDefaultValue) {
						value = currentAttr.value;
					}

		// If there is validator, and user passed config object - check the returned value.
		// If it is false, then set as initial value the default one.
		// However, if there is no default value, just return.
		if (currentAttr.validator && hasPassedValueViaConfig && !this._callStringOrFunction(currentAttr.validator, value)) {
			if (hasDefaultValue) {
				value = currentAttr.value;
			} else {
				return;
			}
		}

		// If there is setter and user passed config object - pass the value thought the setter.
		// The value might be one from defaultFn, default value or provided from the config.
		if (currentAttr.setter && hasPassedValueViaConfig) {
			value = this._callStringOrFunction(currentAttr.setter, value);
		}

		// Finally, set the value as initial value to the storage with values.
		this.__ATTRS__[attr] = value;
	},


	/**
  * Checks if an attribute is initialized. An attribute is considered as initialized
  * when there is an own property with this name in the local collection of attribute values
  * for the current instance.
  *
  * @instance
  * @memberof Attribute
  * @method _isInitialized
  * @param {String} attr The attribute which should be checked if it is initialized.
  * @protected
  * @return {Boolean} Returns true if the attribute has been initialized, false otherwise.
  */
	_isInitialized: function _isInitialized(attr) {
		return Object.prototype.hasOwnProperty.call(this.__ATTRS__, attr);
	}
};

exports.default = Attribute;

/***/ }),

/***/ "./src/oop/base.js":
/*!*************************!*\
  !*** ./src/oop/base.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _attribute = __webpack_require__(/*! ./attribute */ "./src/oop/attribute.js");

var _attribute2 = _interopRequireDefault(_attribute);

var _lang = __webpack_require__(/*! ./lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _oop = __webpack_require__(/*! ./oop */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Quick and dirty impl of Base class.
 *
 * @class Base
 * @constructor
 */
function Base(config) {
	Base.superclass.constructor.call(this, config);

	this.init(config);
} /**
   * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
   * SPDX-License-Identifier: LGPL-3.0-or-later
   */

(0, _oop2.default)(Base, _attribute2.default, {
	/**
  * Calls the `initializer` method of each class which extends Base starting from the parent to the child.
  * Will pass the configuration object to each initializer method.
  *
  * @instance
  * @memberof Base
  * @method init
  * @param {Object} config Configuration object
  */
	init: function init(config) {
		this._callChain('initializer', config);
	},


	/**
  * Calls the `destructor` method of each class which extends Base starting from the parent to the child.
  *
  * @instance
  * @memberof Base
  * @method destroy
  */
	destroy: function destroy() {
		this._callChain('destructor');
	},


	/**
  * Calls a method of each class, which is being present in the hierarchy starting from parent to the child.
  *
  * @instance
  * @memberof Base
  * @method _callChain
  * @param {Object|Array} args The arguments with which the method should be invoked
  * @param {String} wat  The method, which should be invoked
  * @protected
  */
	_callChain: function _callChain(wat, args) {
		var arr = [];

		var ctor = this.constructor;

		while (ctor) {
			if (_lang2.default.isFunction(ctor.prototype[wat])) {
				arr.push(ctor.prototype[wat]);
			}

			ctor = ctor.superclass ? ctor.superclass.constructor : null;
		}

		arr = arr.reverse();

		args = _lang2.default.isArray(args) ? args : [args];

		for (var i = 0; i < arr.length; i++) {
			var item = arr[i];

			item.apply(this, args);
		}
	}
});

exports.default = Base;

/***/ }),

/***/ "./src/oop/lang.js":
/*!*************************!*\
  !*** ./src/oop/lang.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * Provides core language utilities.
 *
 * @class Lang
 */
var Lang = {
	/**
  * Check if the passed value is an array.
  *
  * @memberof Lang
  * @method isArray
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is an array, false otherwise.
  * @static
  */
	isArray: function isArray(value) {
		return Object.prototype.toString.call(value) === '[object Array]';
	},


	/**
  * Check if the passed value is boolean.
  *
  * @memberof Lang
  * @method isBoolean
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is boolean, false otherwise.
  * @static
  */
	isBoolean: function isBoolean(value) {
		return typeof value === 'boolean';
	},


	/**
  * Check if the passed value is a function.
  *
  * @memberof Lang
  * @method isFunction
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is a function, false otherwise.
  * @static
  */
	isFunction: function isFunction(value) {
		return typeof value === 'function';
	},


	/**
  * Check if the passed value is NULL.
  *
  * @memberof Lang
  * @method isNull
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is NULL, false otherwise.
  * @static
  */
	isNull: function isNull(value) {
		return value === null;
	},


	/**
  * Check if the passed value is number.
  *
  * @memberof Lang
  * @method isNumber
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is number, false otherwise.
  * @static
  */
	isNumber: function isNumber(value) {
		return typeof value === 'number' && isFinite(value);
	},


	/**
  * Check if the passed value is an object
  *
  * @memberof Lang
  * @method isObject
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is an object, false otherwise.
  * @static
  */
	isObject: function isObject(value) {
		var valueType = typeof value === 'undefined' ? 'undefined' : _typeof(value);

		return value && (valueType === 'object' || Lang.isFunction(value));
	},


	/**
  * Check if the passed value is a string.
  *
  * @memberof Lang
  * @method isString
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is a string, false otherwise.
  * @static
  */
	isString: function isString(value) {
		return typeof value === 'string';
	},


	/**
  * Adds all properties from the supplier to the receiver.
  * The function will add all properties, not only these owned by the supplier.
  *
  * @memberof Lang
  * @method mix
  * @param {Object} receiver The object which will receive properties.
  * @param {Object} supplier The object which provides properties.
  * @return {Object} The modified receiver.
  * @static
  */
	mix: function mix(receiver, supplier) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;

		for (var key in supplier) {
			if (hasOwnProperty.call(supplier, key)) {
				receiver[key] = supplier[key];
			}
		}
	},


	/**
  * Converts value to Integer.
  *
  * @memberof Lang
  * @method toInt
  * @param {Any} value The value which have to be converted to Integer.
  * @return {Integer} The converted value.
  * @static
  */
	toInt: function toInt(value) {
		return parseInt(value, 10);
	}
};

exports.default = Lang;

/***/ }),

/***/ "./src/oop/oop.js":
/*!************************!*\
  !*** ./src/oop/oop.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _lang = __webpack_require__(/*! ./lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sets the prototype, constructor and superclass properties to support an inheritance strategy
 * that can chain constructors and methods. Static members will not be inherited.
 *
 * @memberof OOP
 * @method extend
 * @param {Function} receiver The class which will extend another class.
 * @param {Function} supplier The class which will provide the properties the child class.
 * @param {Object} protoProps Prototype properties to add/override.
 * @param {Object} staticProps Static properties to add/overwrite.
 * @return {Function} The extended class.
 * @static
 */
var extend = function extend(receiver, supplier, protoProps, staticProps) {
	if (!supplier || !receiver) {
		throw new Error('extend failed, verify dependencies');
	}

	var supplierProto = supplier.prototype;

	var receiverProto = Object.create(supplierProto);
	receiver.prototype = receiverProto;

	receiverProto.constructor = receiver;
	receiver.superclass = supplierProto;

	// assign constructor property
	if (supplier !== Object && supplierProto.constructor === Object.prototype.constructor) {
		supplierProto.constructor = supplier;
	}

	// add prototype overrides
	if (protoProps) {
		_lang2.default.mix(receiverProto, protoProps);
	}

	// add object overrides
	if (staticProps) {
		_lang2.default.mix(receiver, staticProps);
	}

	return receiver;
}; /**
    * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
    * SPDX-License-Identifier: LGPL-3.0-or-later
    */

exports.default = extend;

/***/ }),

/***/ "./src/plugins/DragEvent.es.js":
/*!*************************************!*\
  !*** ./src/plugins/DragEvent.es.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var DragEvent = function () {
	function DragEvent(window, document) {
		_classCallCheck(this, DragEvent);

		this.document = document;
		this.window = window;

		this.events = {
			keydown: this.keydown.bind(this),
			mousemove: this.mousemove.bind(this),
			mouseup: this.mouseup.bind(this)
		};
	}

	_createClass(DragEvent, [{
		key: 'start',
		value: function start(event) {
			event.preventDefault();
			event.stopPropagation();

			this.target = event.target;

			this.className = this.target.className;

			this.startPos = {
				x: event.clientX,
				y: event.clientY
			};

			this.update(event);

			this.document.addEventListener('keydown', this.events.keydown, false);
			this.document.addEventListener('mousemove', this.events.mousemove, false);
			this.document.addEventListener('mouseup', this.events.mouseup, false);

			this.document.body.classList.add('dragging-' + this.className);

			if (typeof this.onStart === 'function') {
				this.onStart();
			}
		}
	}, {
		key: 'update',
		value: function update(event) {
			this.currentPos = {
				x: event.clientX,
				y: event.clientY
			};

			this.delta = {
				x: event.clientX - this.startPos.x,
				y: event.clientY - this.startPos.y
			};

			this.keys = {
				alt: event.altKey,
				ctrl: event.ctrlKey,
				shift: event.shiftKey
			};
		}
	}, {
		key: 'mousemove',
		value: function mousemove(event) {
			this.update(event);

			if (typeof this.onDrag === 'function') {
				this.onDrag();
			}

			if (event.which === 0) {
				this.mouseup(event);
			}
		}
	}, {
		key: 'keydown',
		value: function keydown(event) {
			if (event.keyCode === 27) {
				this.release();
			}
		}
	}, {
		key: 'mouseup',
		value: function mouseup(event) {
			this.update(event);

			this.release();

			if (typeof this.onComplete === 'function') {
				this.onComplete();
			}
		}
	}, {
		key: 'release',
		value: function release() {
			this.document.body.classList.remove('dragging-' + this.className);

			this.document.removeEventListener('keydown', this.events.keydown, false);
			this.document.removeEventListener('mousemove', this.events.mousemove, false);
			this.document.removeEventListener('mouseup', this.events.mouseup, false);

			if (typeof this.onRelease === 'function') {
				this.onRelease();
			}
		}
	}]);

	return DragEvent;
}();

exports.DragEvent = DragEvent;
exports.default = DragEvent;

/***/ }),

/***/ "./src/plugins/Resizer.es.js":
/*!***********************************!*\
  !*** ./src/plugins/Resizer.es.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Resizer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _DragEvent = __webpack_require__(/*! ./DragEvent.es */ "./src/plugins/DragEvent.es.js");

var _DragEvent2 = _interopRequireDefault(_DragEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var IMAGE_HANDLES = ['tl', 'tr', 'bl', 'br'];

var POSITION_ELEMENT_FN = {
	bl: function bl(handle, left, top, box) {
		positionElement(handle, -3 + left, box.height - 4 + top);
	},
	br: function br(handle, left, top, box) {
		positionElement(handle, box.width - 4 + left, box.height - 4 + top);
	},
	rm: function rm(handle, left, top, box) {
		positionElement(handle, box.width - 4 + left, Math.round(box.height / 2) - 3 + top);
	},
	tl: function tl(handle, left, top, _box) {
		positionElement(handle, left - 3, top - 3);
	},
	tr: function tr(handle, left, top, box) {
		positionElement(handle, box.width - 4 + left, -3 + top);
	}
};

var positionElement = function positionElement(el, left, top) {
	el.style.left = left + 'px';
	el.style.top = top + 'px';
};

var getBoundingBox = function getBoundingBox(window, el) {
	var rect = el.getBoundingClientRect();

	return {
		height: rect.height,
		left: rect.left + window.pageXOffset,
		top: rect.top + window.pageYOffset,
		width: rect.width
	};
};

var Resizer = function () {
	function Resizer(editor) {
		var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		_classCallCheck(this, Resizer);

		this.cfg = cfg;
		this.editor = editor;

		this.document = editor.document ? editor.document.$ : document;
		this.window = editor.window ? editor.window.$ : window;

		this.box = null;
		this.container = null;
		this.handles = {};
		this.preview = null;
		this.previewBox = null;
		this.result = null;

		this.init();
	}

	_createClass(Resizer, [{
		key: 'init',
		value: function init() {
			var _this = this;

			this.container = this.document.createElement('div');
			this.container.id = 'ckimgrsz';

			this.preview = this.document.createElement('span');

			this.container.appendChild(this.preview);

			this.handles = {};

			IMAGE_HANDLES.forEach(function (handleName) {
				_this.handles[handleName] = _this.createHandle(handleName);
			});

			var keys = Object.keys(this.handles);

			for (var i = 0; i < keys.length; i++) {
				this.container.appendChild(this.handles[keys[i]]);
			}
		}
	}, {
		key: 'createHandle',
		value: function createHandle(name) {
			var el = this.document.createElement('i');

			el.classList.add(name);

			return el;
		}
	}, {
		key: 'isHandle',
		value: function isHandle(el) {
			var keys = Object.keys(this.handles);

			var result = false;

			for (var i = 0; i < keys.length; i++) {
				if (this.handles[keys[i]] === el) {
					result = true;
				}
			}

			return result;
		}
	}, {
		key: 'show',
		value: function show(el) {
			var uiNode = this.editor.config.uiNode || document.body;

			this.el = el;

			this.box = getBoundingBox(this.window, this.el);

			positionElement(this.container, this.box.left, this.box.top + uiNode.scrollTop);

			uiNode.appendChild(this.container);

			this.el.classList.add('ckimgrsz');

			this.showHandles();
		}
	}, {
		key: 'hide',
		value: function hide() {
			var elements = this.document.getElementsByClassName('ckimgrsz');

			for (var i = 0; i < elements.length; i++) {
				elements[i].classList.remove('ckimgrsz');
			}

			this.hideHandles();

			if (this.container.parentNode) {
				this.container.parentNode.removeChild(this.container);
			}
		}
	}, {
		key: 'initDrag',
		value: function initDrag(event) {
			var _this2 = this;

			if (event.button !== 0) {
				return;
			}

			var drag = new _DragEvent2.default(this.window, this.document);

			drag.onStart = function () {
				_this2.showPreview();

				_this2.isDragging = true;

				_this2.editor.getSelection().lock();
			};

			drag.onDrag = function () {
				_this2.calculateSize(drag);

				var editorBounds = _this2.editor.element.$.getBoundingClientRect();

				if (_this2.previewBox.width >= editorBounds.width) {
					return;
				}

				_this2.updatePreview();

				var box = _this2.previewBox;

				_this2.updateHandles(box, box.left, box.top);
			};

			drag.onRelease = function () {
				_this2.hidePreview();

				_this2.isDragging = false;

				_this2.hide();

				_this2.editor.getSelection().unlock();

				_this2.editor.fire('saveSnapshot');
			};

			drag.onComplete = function () {
				_this2.resizeComplete();

				_this2.editor.fire('saveSnapshot');
			};

			drag.start(event);
		}
	}, {
		key: 'updateHandles',
		value: function updateHandles(box) {
			var left = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
			var top = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

			var keys = Object.keys(this.handles);

			for (var i = 0; i < keys.length; i++) {
				POSITION_ELEMENT_FN[keys[i]](this.handles[keys[i]], left, top, box);
			}
		}
	}, {
		key: 'showHandles',
		value: function showHandles() {
			this.updateHandles(this.box);

			var keys = Object.keys(this.handles);

			for (var i = 0; i < keys.length; i++) {
				this.handles[keys[i]].style.display = 'block';
			}
		}
	}, {
		key: 'hideHandles',
		value: function hideHandles() {
			var keys = Object.keys(this.handles);

			for (var i = 0; i < keys.length; i++) {
				this.handles[keys[i]].style.display = 'none';
			}
		}
	}, {
		key: 'showPreview',
		value: function showPreview() {
			this.calculateSize();

			this.updatePreview();

			this.preview.style.display = 'block';
		}
	}, {
		key: 'updatePreview',
		value: function updatePreview() {
			positionElement(this.preview, this.previewBox.left, this.previewBox.top);

			this.preview.style.height = this.previewBox.height + 'px';
			this.preview.style.width = this.previewBox.width + 'px';
		}
	}, {
		key: 'hidePreview',
		value: function hidePreview() {
			var box = getBoundingBox(this.window, this.preview);

			this.result = {
				height: box.height,
				width: box.width
			};

			this.preview.style.display = 'none';
		}
	}, {
		key: 'calculateSize',
		value: function calculateSize(data) {
			this.previewBox = {
				height: this.box.height,
				left: 0,
				top: 0,
				width: this.box.width
			};

			if (!data) {
				return;
			}

			var className = data.target.className;

			if (className.indexOf('r') >= 0) {
				this.previewBox.width = Math.max(32, this.box.width + data.delta.x);
			}

			if (className.indexOf('b') >= 0) {
				this.previewBox.height = Math.max(32, this.box.height + data.delta.y);
			}

			if (className.indexOf('l') >= 0) {
				this.previewBox.width = Math.max(32, this.box.width - data.delta.x);
			}

			if (className.indexOf('t') >= 0) {
				this.previewBox.height = Math.max(32, this.box.height - data.delta.y);
			}

			if (className.indexOf('m') < 0 && !data.keys.shift) {
				var ratio = this.box.width / this.box.height;

				if (this.previewBox.width / this.previewBox.height > ratio) {
					this.previewBox.height = Math.round(this.previewBox.width / ratio);
				} else {
					this.previewBox.width = Math.round(this.previewBox.height * ratio);
				}
			}

			if (className.indexOf('l') >= 0) {
				this.previewBox.left = this.box.width - this.previewBox.width;
			}

			if (className.indexOf('t') >= 0) {
				this.previewBox.top = this.box.height - this.previewBox.height;
			}
		}
	}, {
		key: 'resizeComplete',
		value: function resizeComplete() {
			this.cfg.onComplete(this.el, this.result.width, this.result.height);
		}
	}]);

	return Resizer;
}();

exports.Resizer = Resizer;
exports.default = Resizer;

/***/ }),

/***/ "./src/plugins/addimages.js":
/*!**********************************!*\
  !*** ./src/plugins/addimages.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var isIE = CKEDITOR.env.ie;

if (!CKEDITOR.plugins.get('ae_addimages')) {
	/**
  * CKEditor plugin which allows Drag&Drop of images directly into the editable area. The image will be encoded
  * as Data URI. An event `beforeImageAdd` will be fired with the list of dropped images. If any of the listeners
  * returns `false` or cancels the event, the images won't be added to the content. Otherwise,
  * an event `imageAdd` will be fired with the inserted element into the editable area.
  *
  * @class CKEDITOR.plugins.ae_addimages
  */

	/**
  * Fired before adding images to the editor.
  *
  * @event CKEDITOR.plugins.ae_addimages#beforeImageAdd
  * @instance
  * @memberof CKEDITOR.plugins.ae_addimages
  * @param {Array} imageFiles Array of image files
  */

	/**
  * Fired when an image is being added to the editor successfully.
  *
  * @event CKEDITOR.plugins.ae_addimages#imageAdd
  * @instance
  * @memberof CKEDITOR.plugins.ae_addimages
  * @param {CKEDITOR.dom.element} el The created image with src as Data URI
  * @param {File} file The image file
  */

	CKEDITOR.plugins.add('ae_addimages', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function registers a 'dragenter', 'dragover', 'drop' and `paste` events on the editing area.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			var _this = this;

			editor.once('contentDom', function () {
				var editable = editor.editable();

				editable.attachListener(editable, 'dragenter', _this._onDragEnter, _this, {
					editor: editor
				});

				editable.attachListener(editable, 'dragover', _this._onDragOver, _this, {
					editor: editor
				});

				editable.attachListener(editable, 'drop', _this._onDragDrop, _this, {
					editor: editor
				});

				editable.attachListener(editable, 'paste', _this._onPaste, _this, {
					editor: editor
				});
			});
		},


		/**
   * Accepts an array of dropped files to the editor. Then, it filters the images and sends them for further
   * processing to {{#crossLink "CKEDITOR.plugins.ae_addimages/_processFile:method"}}{{/crossLink}}
   *
   * @fires CKEDITOR.plugins.ae_addimages#beforeImageAdd
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _handleFiles
   * @param {Array} files Array of dropped files. Only the images from this list will be processed.
   * @param {Object} editor The current editor instance
   * @protected
   */
		_handleFiles: function _handleFiles(files, editor) {
			var file = void 0;
			var i = void 0;

			var imageFiles = [];

			for (i = 0; i < files.length; i++) {
				file = files[i];

				if (file.type.indexOf('image') === 0) {
					imageFiles.push(file);
				}
			}

			var result = editor.fire('beforeImageAdd', {
				imageFiles: imageFiles
			});

			if (result) {
				for (i = 0; i < imageFiles.length; i++) {
					file = imageFiles[i];

					this._processFile(file, editor);
				}
			}

			return false;
		},


		/**
   * Handles drag drop event. The function will create a selection from the current
   * point and will send a list of files to be processed to
   * {{#crossLink "CKEDITOR.plugins.ae_addimages/_handleFiles:method"}}{{/crossLink}} method.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _onDragDrop
   * @param {CKEDITOR.dom.event} event dragdrop event, as received natively from CKEditor
   * @protected
   */
		_onDragDrop: function _onDragDrop(event) {
			var nativeEvent = event.data.$;

			var transferFiles = nativeEvent.dataTransfer.files;

			if (transferFiles.length > 0) {
				new CKEDITOR.dom.event(nativeEvent).preventDefault();

				var editor = event.listenerData.editor;

				event.listenerData.editor.createSelectionFromPoint(nativeEvent.clientX, nativeEvent.clientY);

				this._handleFiles(transferFiles, editor);
			}
		},


		/**
   * Handles drag enter event. In case of IE, this function will prevent the event.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _onDragEnter
   * @param {DOM event} event dragenter event, as received natively from CKEditor
   * @protected
   */
		_onDragEnter: function _onDragEnter(event) {
			if (isIE) {
				this._preventEvent(event);
			}
		},


		/**
   * Handles drag over event. In case of IE, this function will prevent the event.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _onDragOver
   * @param {DOM event} event dragover event, as received natively from CKEditor
   * @protected
   */
		_onDragOver: function _onDragOver(event) {
			if (isIE) {
				this._preventEvent(event);
			}
		},


		/**
   * Checks if the pasted data is image and passes it to
   * {{#crossLink "CKEDITOR.plugins.ae_addimages/_processFile:method"}}{{/crossLink}} for processing.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _onPaste
   * @param {CKEDITOR.dom.event} event A `paste` event, as received natively from CKEditor
   * @protected
   */
		_onPaste: function _onPaste(event) {
			if (event.data && event.data.$ && event.data.$.clipboardData && event.data.$.clipboardData.items && event.data.$.clipboardData.items.length > 0) {
				var pastedData = event.data.$.clipboardData.items[0];

				if (pastedData.type.indexOf('image') === 0) {
					var imageFile = pastedData.getAsFile();

					this._processFile(imageFile, event.listenerData.editor);
				}
			}
		},


		/**
   * Prevents a native event.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _preventEvent
   * @param {DOM event} event The event to be prevented.
   * @protected
   */
		_preventEvent: function _preventEvent(event) {
			event = new CKEDITOR.dom.event(event.data.$);

			event.preventDefault();
			event.stopPropagation();
		},


		/**
   * Processes an image file. The function creates an img element and sets as source
   * a Data URI, then fires an 'imageAdd' event via CKEditor's event system.
   *
   * @fires CKEDITOR.plugins.ae_addimages#imageAdd
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _preventEvent
   * @param {DOM event} event The event to be prevented.
   * @protected
   */
		_processFile: function _processFile(file, editor) {
			var reader = new FileReader();

			reader.addEventListener('loadend', function () {
				var bin = reader.result;

				var el = CKEDITOR.dom.element.createFromHtml('<img src="' + bin + '">');

				editor.insertElement(el);

				var imageData = {
					el: el,
					file: file
				};

				editor.fire('imageAdd', imageData);
			});

			reader.readAsDataURL(file);
		}
	});
}

/***/ }),

/***/ "./src/plugins/autolink.js":
/*!*********************************!*\
  !*** ./src/plugins/autolink.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

if (!CKEDITOR.plugins.get('ae_autolink')) {
	// Disables the auto URL detection feature in IE, their lacks functionality:
	// They convert the links only on space. We do on space, comma, semicolon and Enter.
	if (/MSIE ([^;]*)|Trident.*; rv:([0-9.]+)/.test(navigator.userAgent)) {
		document.execCommand('AutoUrlDetect', false, false);
	}

	var KEY_BACK = 8;

	var KEY_COMMA = 188;

	var KEY_ENTER = 13;

	var KEY_SEMICOLON = 186;

	var KEY_SPACE = 32;

	var DELIMITERS = [KEY_COMMA, KEY_ENTER, KEY_SEMICOLON, KEY_SPACE];

	var REGEX_LAST_WORD = /[^\s]+/gim;

	// Seen at https://stackoverflow.com/a/5717133/2103996
	var REGEX_URL = '^(https?:\\/\\/)?' + // protocol
	'((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|' + // domain name
	'((\\d{1,3}\\.){3}\\d{1,3}))' + // OR ip (v4) address
	'(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*' + // port and path
	'(\\?[;&a-z\\d%_.~+=-]*)?' + // query string
	'(\\#[-a-z\\d_]*)?$';

	var REGEX_EMAIL = /[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}/i;

	/**
  * CKEditor plugin which automatically generates links when user types text which looks like URL.
  *
  * @class CKEDITOR.plugins.ae_autolink
  * @constructor
  */
	CKEDITOR.plugins.add('ae_autolink', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function registers the `keyup` event on the editing area.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			var _this = this;

			editor.once('contentDom', function () {
				var editable = editor.editable();

				editable.attachListener(editable, 'keyup', _this._onKeyUp, _this, {
					editor: editor
				});
			});

			editor.on('paste', function (event) {
				if (event.data.method === 'paste') {
					if (event.data.dataValue.indexOf('<') > -1 || event.data.dataValue.indexOf('&lt;') > -1) {
						if (event.data.dataValue.indexOf('<u><font color="') > -1) {
							event.data.dataValue = event.data.dataValue.replace(/<u><font color="#(.*?)">|<\/font><\/u>/g, '');
						}
						return;
					}

					var instance = _this;

					event.data.dataValue = event.data.dataValue.replace(RegExp(REGEX_URL, 'gim'), function (url) {
						if (instance._isValidURL(url)) {
							if (instance._isValidEmail(url)) {
								return '<a href="mailto:' + url + '">' + url + '</a>';
							} else {
								return '<a href="' + url + '">' + url + '</a>';
							}
						}
					});
				}
			});
		},


		/**
   * Retrieves the last word introduced by the user. Reads from the current
   * caret position backwards until it finds the first white space.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _getLastWord
   * @protected
   * @return {String} The last word introduced by user
   */
		_getLastWord: function _getLastWord(editor) {
			var range = editor.getSelection().getRanges()[0];

			if (!range) {
				return;
			}

			var offset = range.startOffset;

			var previousText = '';

			// The user pressed Enter, so we have to look on the previous node
			if (this._currentKeyCode === KEY_ENTER) {
				var previousNode = range.startContainer.getPrevious();

				var lastChild = void 0;

				if (previousNode) {
					// If previous node is a SPACE, (it does not have 'getLast' method),
					// ignore it and find the previous text node
					while (!previousNode.getLast) {
						previousNode = previousNode.getPrevious();
					}

					lastChild = previousNode.getLast();

					// Depending on the browser, the last child node may be a <BR>
					// (which does not have 'getText' method),
					// so ignore it and find the previous text node
					while (lastChild && !lastChild.getText()) {
						lastChild = lastChild.getPrevious();
					}
				}

				// Check if the lastChild is already a link
				if (!(lastChild && lastChild.$.href)) {
					this._startContainer = lastChild;
					previousText = lastChild ? lastChild.getText() : '';
					this._offset = previousText.length;
				}
			} else {
				this._startContainer = range.startContainer;

				// Last character is the delimiter, ignore it
				previousText = this._startContainer.getText().substring(0, offset - 1);

				this._offset = offset - 1;
			}

			var lastWord = '';

			var match = previousText.match(REGEX_LAST_WORD);

			if (match) {
				lastWord = match.pop();
			}

			return lastWord;
		},


		/**
   * Checks if the given link is a valid Email.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method isValidEmail
   * @param {String} link The email we want to know if it is a valid Email
   * @protected
   * @return {Boolean} Returns true if the email is a valid Email, false otherwise
   */
		_isValidEmail: function _isValidEmail(email) {
			return REGEX_EMAIL.test(email);
		},


		/**
   * Checks if the given link is a valid URL.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method isValidURL
   * @param {String} link The link we want to know if it is a valid URL
   * @protected
   * @return {Boolean} Returns true if the link is a valid URL, false otherwise
   */
		_isValidURL: function _isValidURL(link) {
			return RegExp(REGEX_URL, 'i').test(link);
		},


		/**
   * Listens to the `keydown` event and if the keycode is `Backspace`, removes the previously
   * created link.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _onKeyDown
   * @param {EventFacade} event EventFacade object
   * @protected
   */
		_onKeyDown: function _onKeyDown(event) {
			var nativeEvent = event.data.$;

			var editor = event.listenerData.editor;

			var editable = editor.editable();

			editable.removeListener('keydown', this._onKeyDown);

			if (nativeEvent.keyCode === KEY_BACK) {
				event.cancel();
				event.data.preventDefault();

				this._removeLink(editor);
			}

			this._ckLink = null;
		},


		/**
   * Listens to the `Enter` and `Space` key events in order to check if the last word
   * introduced by the user should be replaced by a link element.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _onKeyUp
   * @param {EventFacade} event EventFacade object
   * @protected
   */
		_onKeyUp: function _onKeyUp(event) {
			var nativeEvent = event.data.$;

			this._currentKeyCode = nativeEvent.keyCode;

			if (DELIMITERS.indexOf(this._currentKeyCode) !== -1) {
				var editor = event.listenerData.editor;

				var lastWord = this._getLastWord(editor);

				if (this._isValidURL(lastWord)) {
					this._replaceContentByLink(editor, lastWord);
				}
			}
		},


		/**
   * Replaces content by a link element.
   *
   * @fires CKEDITOR.plugins.ae_autolink#autolinkAdd
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _replaceContentByLink
   * @param {String} content The text that has to be replaced by an link element
   * @protected
   */
		_replaceContentByLink: function _replaceContentByLink(editor, content) {
			var range = editor.createRange();
			var node = CKEDITOR.dom.element.get(this._startContainer);
			var offset = this._offset;

			// Select the content, so CKEDITOR.Link can properly replace it
			range.setStart(node, offset - content.length);
			range.setEnd(node, offset);
			range.select();

			var ckLink = new CKEDITOR.Link(editor);
			ckLink.create(content);
			this._ckLink = ckLink;

			var linkNode = ckLink.getFromSelection();
			editor.fire('autolinkAdd', linkNode);

			this._subscribeToKeyEvent(editor);

			// Now range is on the link and it is selected. We have to
			// return focus to the caret position.
			range = editor.getSelection().getRanges()[0];

			// If user pressed `Enter`, get the next editable node at position 0,
			// otherwise set the cursor at the next character of the link (the white space)
			if (this._currentKeyCode === KEY_ENTER) {
				var nextEditableNode = range.getNextEditableNode();

				range.setStart(nextEditableNode, 0);
				range.setEnd(nextEditableNode, 0);
			} else {
				var enclosedNode = range.getEnclosedNode();

				range.setStart(enclosedNode, 0);
				range.setEnd(enclosedNode, 0);
			}

			range.select();
		},


		/**
   * Fired when a URL is detected in text and converted to a link.
   *
   * @event CKEDITOR.plugins.ae_autolink#autolinkAdd
   * @memberof CKEDITOR.plugins.ae_autolink
   * @param {CKEDITOR.dom.element} el Node of the created link.
   */

		/**
   * Removes the created link element, and replaces it by its text.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _removeLink
   * @protected
   */
		_removeLink: function _removeLink(editor) {
			var range = editor.getSelection().getRanges()[0];
			var caretOffset = range.startOffset;

			// Select the link, so CKEDITOR.Link can properly remove it
			var linkNode = this._startContainer.getNext() || this._startContainer;

			var newRange = editor.createRange();
			newRange.setStart(linkNode, 0);
			newRange.setEndAfter(linkNode);
			newRange.select();

			this._ckLink.remove();

			// Return focus to the caret position
			range.setEnd(range.startContainer, caretOffset);
			range.setStart(range.startContainer, caretOffset);

			range.select();
		},


		/**
   * Subscribe to a key event of the editable aria.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _subscribeToKeyEvent
   * @protected
   */
		_subscribeToKeyEvent: function _subscribeToKeyEvent(editor) {
			var editable = editor.editable();

			// Change the priority of keydown listener - 1 means the highest priority.
			// In Chrome on pressing `Enter` the listener is not being invoked.
			// See http://dev.ckeditor.com/ticket/11861 for more information.
			editable.attachListener(editable, 'keydown', this._onKeyDown, this, {
				editor: editor
			}, 1);
		}
	});
}

/***/ }),

/***/ "./src/plugins/autolist.js":
/*!*********************************!*\
  !*** ./src/plugins/autolist.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

if (!CKEDITOR.plugins.get('ae_autolist')) {
	var KEY_BACK = 8;

	var KEY_SPACE = 32;

	var DEFAULT_CONFIG = [{
		regex: /^\*$/,
		type: 'bulletedlist'
	}, {
		regex: /^1\.$/,
		type: 'numberedlist'
	}];

	/**
  * CKEditor plugin which automatically generates ordered/unordered list when user types text which looks like a list.
  *
  * @class CKEDITOR.plugins.ae_autolist
  * @constructor
  */
	CKEDITOR.plugins.add('ae_autolist', {
		/**
   * Initialization of the plugin, part of CKeditor plugin lifecycle.
   * The function registers the `keydown` event on the content editing area.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolist
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			var _this = this;

			editor.once('contentDom', function () {
				var editable = editor.editable();

				editable.attachListener(editable, 'keydown', _this._onKeyDown, _this, {
					editor: editor
				});
			});
		},


		/**
   * Checks for pressing the `Backspace` key in order to undo the list creation.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolist
   * @method _checkForBackspaceAndUndo
   * @param {Event} event Event object
   * @protected
   */
		_checkForBackspaceAndUndo: function _checkForBackspaceAndUndo(event) {
			var editor = event.listenerData.editor;

			var nativeEvent = event.data.$;

			var editable = editor.editable();

			editable.removeListener('keydown', this._checkForBackspaceAndUndo);

			if (nativeEvent.keyCode === KEY_BACK) {
				editor.execCommand('undo');
				editor.insertHtml(event.listenerData.bullet + '&nbsp;');
				event.data.preventDefault();
			}
		},


		/**
   * Checks current line to find match with MATCHES object to create OL or UL.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolist
   * @method _checkLine
   * @param {editor} Editor object
   * @protected
   * @return {Object|null} Returns an object which contains the detected list config if any
   */
		_getListConfig: function _getListConfig(editor) {
			var configRegex = editor.config.autolist || DEFAULT_CONFIG;

			var range = editor.getSelection().getRanges()[0];

			var textContainer = range.endContainer.getText();

			var bullet = textContainer.substring(0, range.startOffset);

			var text = textContainer.substring(range.startOffset, textContainer.length);

			var index = 0;

			var regexLen = configRegex.length;

			var autolistCfg = null;

			while (!autolistCfg && regexLen > index) {
				var regexItem = configRegex[index];

				if (regexItem.regex.test(bullet)) {
					autolistCfg = {
						bullet: bullet,
						editor: editor,
						text: text,
						type: regexItem.type
					};

					break;
				}

				index++;
			}

			return autolistCfg;
		},


		/**
   * Create list with different types: Bulleted or Numbered list
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolist
   * @method _createList
   * @param {Object} listConfig Object that contains bullet, text and type for creating the list
   * @protected
   */
		_createList: function _createList(listConfig) {
			var editor = listConfig.editor;

			var range = editor.getSelection().getRanges()[0];

			range.endContainer.setText(listConfig.text);
			editor.execCommand(listConfig.type);

			var editable = editor.editable();

			// Subscribe to keydown in order to check if the next key press is `Backspace`.
			// If so, the creation of the list will be discarded.
			editable.attachListener(editable, 'keydown', this._checkForBackspaceAndUndo, this, {
				editor: editor,
				bullet: listConfig.bullet
			}, 1);
		},


		/**
   * Listens to the `Space` key events to check if the last word
   * introduced by the user should be replaced by a list (OL or UL)
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolist
   * @method _onKeyDown
   * @param {Event} event Event object
   * @protected
   */
		_onKeyDown: function _onKeyDown(event) {
			var nativeEvent = event.data.$;

			if (nativeEvent.keyCode === KEY_SPACE) {
				var listConfig = this._getListConfig(event.listenerData.editor);

				if (listConfig) {
					event.data.preventDefault();
					this._createList(listConfig);
				}
			}
		}
	});
}

/***/ }),

/***/ "./src/plugins/dragresize.js":
/*!***********************************!*\
  !*** ./src/plugins/dragresize.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * CKEditor plugin: Dragable image resizing
 * https://github.com/sstur/ck-dragresize
 * - Shows semi-transparent overlay while resizing
 * - Enforces Aspect Ratio (unless holding shift)
 * - Snap to size of other images in editor
 * - Escape while dragging cancels resize
 */
if (!CKEDITOR.plugins.get('ae_dragresize')) {
	var IMAGE_HANDLES = {
		both: ['tl', 'tm', 'tr', 'lm', 'rm', 'bl', 'bm', 'br'],
		height: ['tl', 'tm', 'tr', 'bl', 'bm', 'br'],
		scale: ['tl', 'tr', 'bl', 'br'],
		width: ['tl', 'tr', 'lm', 'rm', 'bl', 'br']
	};

	var POSITION_ELEMENT_FN = {
		bl: function bl(handle, left, top, box) {
			positionElement(handle, -3 + left, box.height - 4 + top);
		},
		bm: function bm(handle, left, top, box) {
			positionElement(handle, Math.round(box.width / 2) - 3 + left, box.height - 4 + top);
		},
		br: function br(handle, left, top, box) {
			positionElement(handle, box.width - 4 + left, box.height - 4 + top);
		},
		lm: function lm(handle, left, top, box) {
			positionElement(handle, -3 + left, Math.round(box.height / 2) - 3 + top);
		},
		tl: function tl(handle, left, top, _box) {
			positionElement(handle, left - 3, top - 3);
		},
		tm: function tm(handle, left, top, box) {
			positionElement(handle, Math.round(box.width / 2) - 3 + left, -3 + top);
		},
		tr: function tr(handle, left, top, box) {
			positionElement(handle, box.width - 4 + left, -3 + top);
		},
		rm: function rm(handle, left, top, box) {
			positionElement(handle, box.width - 4 + left, Math.round(box.height / 2) - 3 + top);
		}
	};

	var IMAGE_SNAP_TO_SIZE = 7;

	var isFirefox = 'MozAppearance' in document.documentElement.style;

	var isWebKit = 'WebkitAppearance' in document.documentElement.style;

	var enablePlugin = isWebKit || isFirefox;

	if (enablePlugin) {
		// CSS is added in a compressed form
		CKEDITOR.addCss('img::selection{color:rgba(0,0,0,0)}img.ckimgrsz{outline:1px dashed #000}#ckimgrsz{position:absolute;width:0;height:0;cursor:default;z-index:10001}#ckimgrsz span{display:none;position:absolute;top:0;left:0;width:0;height:0;background-size:100% 100%;opacity:.65;outline:1px dashed #000}#ckimgrsz i{position:absolute;display:block;width:5px;height:5px;background:#fff;border:1px solid #000}#ckimgrsz i.active,#ckimgrsz i:hover{background:#000}#ckimgrsz i.br,#ckimgrsz i.tl{cursor:nwse-resize}#ckimgrsz i.bm,#ckimgrsz i.tm{cursor:ns-resize}#ckimgrsz i.bl,#ckimgrsz i.tr{cursor:nesw-resize}#ckimgrsz i.lm,#ckimgrsz i.rm{cursor:ew-resize}body.dragging-br,body.dragging-br *,body.dragging-tl,body.dragging-tl *{cursor:nwse-resize!important}body.dragging-bm,body.dragging-bm *,body.dragging-tm,body.dragging-tm *{cursor:ns-resize!important}body.dragging-bl,body.dragging-bl *,body.dragging-tr,body.dragging-tr *{cursor:nesw-resize!important}body.dragging-lm,body.dragging-lm *,body.dragging-rm,body.dragging-rm *{cursor:ew-resize!important}');
	}

	/**
  * Initializes the plugin
  */
	CKEDITOR.plugins.add('ae_dragresize', {
		onLoad: function onLoad() {
			if (!enablePlugin) {
				return;
			}
		},
		init: function init(editor) {
			if (!enablePlugin) {
				return;
			}

			editor.once('contentDom', function (_evt) {
				_init(editor);
			});
		}
	});

	function _init(editor) {
		var window = editor.window.$;

		var document = editor.document.$;

		if (isFirefox) {
			// Disable the native image resizing
			document.execCommand('enableObjectResizing', false, false);
		}

		var snapToSize = typeof IMAGE_SNAP_TO_SIZE === 'undefined' ? null : IMAGE_SNAP_TO_SIZE;

		editor.config.imageScaleResize = editor.config.imageScaleResize || 'both';

		var resizer = new Resizer(editor, {
			imageScaleResize: editor.config.imageScaleResize,
			snapToSize: snapToSize
		});

		var mouseDownListener = function mouseDownListener(e) {
			if (resizer.isHandle(e.target)) {
				resizer.initDrag(e);
			}
		};

		document.addEventListener('mousedown', mouseDownListener, false);

		function selectionChange() {
			var selection = editor.getSelection();

			if (!selection) return;
			// If an element is selected and that element is an IMG
			if (selection.getType() !== CKEDITOR.SELECTION_NONE && selection.getStartElement().is('img')) {
				// And we're not right or middle clicking on the image
				if (!window.event || !window.event.button || window.event.button === 0) {
					resizer.show(selection.getStartElement().$);
				}
			} else {
				resizer.hide();
			}
		}

		editor.on('selectionChange', selectionChange);

		editor.on('getData', function (e) {
			var html = e.data.dataValue || '';
			html = html.replace(/<div id="ckimgrsz"([\s\S]*?)<\/div>/i, '');
			html = html.replace(/\b(ckimgrsz)\b/g, '');
			e.data.dataValue = html;
		});

		editor.on('beforeUndoImage', function () {
			// Remove the handles before undo images are saved
			resizer.hide();
		});

		editor.on('afterUndoImage', function () {
			// Restore the handles after undo images are saved
			selectionChange();
		});

		editor.on('blur', function () {
			// Remove the handles when editor loses focus
			resizer.hide();
		});

		editor.on('beforeModeUnload', function self() {
			editor.removeListener('beforeModeUnload', self);
			resizer.hide();
		});

		editor.on('destroy', function () {
			var resizeElement = document.getElementById('ckimgrsz');

			if (resizeElement) {
				resizeElement.remove();
			}

			if (isFirefox) {
				document.execCommand('enableObjectResizing', false, true);
			}

			document.removeEventListener('mousedown', mouseDownListener);
		});

		// Update the selection when the browser window is resized
		var resizeTimeout = void 0;
		editor.window.on('resize', function () {
			// Cancel any resize waiting to happen
			clearTimeout(resizeTimeout);
			// Delay resize to "debounce"
			resizeTimeout = setTimeout(selectionChange, 50);
		});
	}

	function Resizer(editor, cfg) {
		this.editor = editor;
		this.window = editor.window.$;
		this.document = editor.document.$;
		this.cfg = cfg || {};
		this.init();
	}

	Resizer.prototype = {
		init: function init() {
			var instance = this;

			var container = this.container = this.document.createElement('div');

			container.id = 'ckimgrsz';
			this.preview = this.document.createElement('span');
			container.appendChild(this.preview);

			var handles = this.handles = {};

			IMAGE_HANDLES[this.cfg.imageScaleResize].forEach(function (handleName) {
				handles[handleName] = instance.handles[handleName] = instance.createHandle(handleName);
			});

			for (var n in handles) {
				if (Object.prototype.hasOwnProperty.call(handles, n)) {
					container.appendChild(handles[n]);
				}
			}
		},
		createHandle: function createHandle(name) {
			var el = this.document.createElement('i');
			el.classList.add(name);
			return el;
		},
		isHandle: function isHandle(el) {
			var handles = this.handles;
			for (var n in handles) {
				if (handles[n] === el) {
					return true;
				}
			}
			return false;
		},
		show: function show(el) {
			var uiNode = this.editor.config.uiNode;

			var scrollTop = uiNode ? uiNode.scrollTop : 0;

			this.el = el;
			if (this.cfg.snapToSize) {
				this.otherImages = toArray(this.document.getElementsByTagName('img'));
				this.otherImages.splice(this.otherImages.indexOf(el), 1);
			}
			var box = this.box = getBoundingBox(this.window, el);
			positionElement(this.container, box.left, box.top + scrollTop);

			uiNode = uiNode || document.body;

			uiNode.appendChild(this.container);

			this.el.classList.add('ckimgrsz');
			this.showHandles();
		},
		hide: function hide() {
			// Remove class from all img.ckimgrsz
			var elements = this.document.getElementsByClassName('ckimgrsz');
			for (var i = 0; i < elements.length; ++i) {
				elements[i].classList.remove('ckimgrsz');
			}
			this.hideHandles();
			if (this.container.parentNode) {
				this.container.parentNode.removeChild(this.container);
			}
		},
		initDrag: function initDrag(e) {
			if (e.button !== 0) {
				// right-click or middle-click
				return;
			}
			var resizer = this;
			var drag = new DragEvent(this.window, this.document);
			drag.onStart = function () {
				resizer.showPreview();
				resizer.isDragging = true;
				resizer.editor.getSelection().lock();
			};
			drag.onDrag = function () {
				resizer.calculateSize(this);
				resizer.updatePreview();
				var box = resizer.previewBox;
				resizer.updateHandles(box, box.left, box.top);
			};
			drag.onRelease = function () {
				resizer.isDragging = false;
				resizer.hidePreview();
				resizer.hide();
				resizer.editor.getSelection().unlock();
				// Save an undo snapshot before the image is permanently changed
				resizer.editor.fire('saveSnapshot');
			};
			drag.onComplete = function () {
				resizer.resizeComplete();
				// Save another snapshot after the image is changed
				resizer.editor.fire('saveSnapshot');
			};
			drag.start(e);
		},
		updateHandles: function updateHandles(box, left, top) {
			left = left || 0;
			top = top || 0;
			var handles = this.handles;

			for (var handle in handles) {
				if (Object.prototype.hasOwnProperty.call(handles, handle)) {
					POSITION_ELEMENT_FN[handle](handles[handle], left, top, box);
				}
			}
		},
		showHandles: function showHandles() {
			var handles = this.handles;
			this.updateHandles(this.box);
			for (var n in handles) {
				if (Object.prototype.hasOwnProperty.call(handles, n)) {
					handles[n].style.display = 'block';
				}
			}
		},
		hideHandles: function hideHandles() {
			var handles = this.handles;
			for (var n in handles) {
				if (Object.prototype.hasOwnProperty.call(handles, n)) {
					handles[n].style.display = 'none';
				}
			}
		},
		showPreview: function showPreview() {
			this.preview.style.backgroundImage = 'url("' + this.el.src + '")';
			this.calculateSize();
			this.updatePreview();
			this.preview.style.display = 'block';
		},
		updatePreview: function updatePreview() {
			var box = this.previewBox;
			positionElement(this.preview, box.left, box.top);
			this.preview.style.width = this.previewBox.width + 'px';
			this.preview.style.height = this.previewBox.height + 'px';
		},
		hidePreview: function hidePreview() {
			var box = getBoundingBox(this.window, this.preview);
			this.result = {
				width: box.width,
				height: box.height
			};
			this.preview.style.display = 'none';
		},
		calculateSize: function calculateSize(data) {
			var box = this.previewBox = {
				top: 0,
				left: 0,
				width: this.box.width,
				height: this.box.height
			};

			if (!data) return;

			var attr = data.target.className;

			if (~attr.indexOf('r')) {
				box.width = Math.max(32, this.box.width + data.delta.x);
			}
			if (~attr.indexOf('b')) {
				box.height = Math.max(32, this.box.height + data.delta.y);
			}
			if (~attr.indexOf('l')) {
				box.width = Math.max(32, this.box.width - data.delta.x);
			}
			if (~attr.indexOf('t')) {
				box.height = Math.max(32, this.box.height - data.delta.y);
			}
			// if dragging corner, enforce aspect ratio (unless shift key is being held)
			if (attr.indexOf('m') < 0 && !data.keys.shift) {
				var ratio = this.box.width / this.box.height;
				if (box.width / box.height > ratio) {
					box.height = Math.round(box.width / ratio);
				} else {
					box.width = Math.round(box.height * ratio);
				}
			}

			var snapToSize = this.cfg.snapToSize;

			if (snapToSize) {
				var others = this.otherImages;
				for (var i = 0; i < others.length; i++) {
					var other = getBoundingBox(this.window, others[i]);
					if (Math.abs(box.width - other.width) <= snapToSize && Math.abs(box.height - other.height) <= snapToSize) {
						box.width = other.width;
						box.height = other.height;
						break;
					}
				}
			}

			// recalculate left or top position
			if (~attr.indexOf('l')) {
				box.left = this.box.width - box.width;
			}
			if (~attr.indexOf('t')) {
				box.top = this.box.height - box.height;
			}
		},
		resizeComplete: function resizeComplete() {
			resizeElement.call(this, this.el, this.result.width, this.result.height);
		}
	};

	function DragEvent(window, document) {
		this.window = window;
		this.document = document;
		this.events = {
			mousemove: bind(this.mousemove, this),
			keydown: bind(this.keydown, this),
			mouseup: bind(this.mouseup, this)
		};
	}

	DragEvent.prototype = {
		start: function start(e) {
			e.preventDefault();
			e.stopPropagation();
			this.target = e.target;
			this.attr = e.target.className;
			this.startPos = {
				x: e.clientX,
				y: e.clientY
			};
			this.update(e);
			var events = this.events;
			this.document.addEventListener('mousemove', events.mousemove, false);
			this.document.addEventListener('keydown', events.keydown, false);
			this.document.addEventListener('mouseup', events.mouseup, false);
			this.document.body.classList.add('dragging-' + this.attr);
			if (this.onStart) {
				this.onStart();
			}
		},
		update: function update(e) {
			this.currentPos = {
				x: e.clientX,
				y: e.clientY
			};
			this.delta = {
				x: e.clientX - this.startPos.x,
				y: e.clientY - this.startPos.y
			};
			this.keys = {
				shift: e.shiftKey,
				ctrl: e.ctrlKey,
				alt: e.altKey
			};
		},
		mousemove: function mousemove(e) {
			this.update(e);
			if (this.onDrag) {
				this.onDrag();
			}
			if (e.which === 0) {
				// mouse button released outside window; mouseup wasn't fired (Chrome)
				this.mouseup(e);
			}
		},
		keydown: function keydown(e) {
			// escape key cancels dragging
			if (e.keyCode === 27) {
				this.release();
			}
		},
		mouseup: function mouseup(e) {
			this.update(e);
			this.release();
			if (this.onComplete) {
				this.onComplete();
			}
		},
		release: function release() {
			this.document.body.classList.remove('dragging-' + this.attr);
			var events = this.events;
			this.document.removeEventListener('mousemove', events.mousemove, false);
			this.document.removeEventListener('keydown', events.keydown, false);
			this.document.removeEventListener('mouseup', events.mouseup, false);
			if (this.onRelease) {
				this.onRelease();
			}
		}
	};

	// helper functions
	function toArray(obj) {
		var len = obj.length;

		var arr = new Array(len);
		for (var i = 0; i < len; i++) {
			arr[i] = obj[i];
		}
		return arr;
	}

	function bind(fn, ctx) {
		if (fn.bind) {
			return fn.bind(ctx);
		}
		return function () {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			fn.apply(ctx, args);
		};
	}

	function positionElement(el, left, top) {
		el.style.left = String(left) + 'px';
		el.style.top = String(top) + 'px';
	}

	function resizeElement(el, width, height) {
		var imageScaleResize = this.editor.config.imageScaleResize;
		if (imageScaleResize === 'both') {
			el.setAttribute('width', String(width));
			el.style.width = String(width) + 'px';
			el.setAttribute('height', String(height));
			el.style.height = String(height) + 'px';
		} else if (imageScaleResize === 'width' || imageScaleResize === 'scale') {
			el.removeAttribute('height');
			el.style.height = 'auto';
			el.setAttribute('width', String(width));
			el.style.width = String(width) + 'px';
		} else if (imageScaleResize === 'height') {
			el.setAttribute('height', String(height));
			el.style.height = String(height) + 'px';
			el.removeAttribute('width');
			el.style.width = 'auto';
		}
	}

	function getBoundingBox(window, el) {
		var rect = el.getBoundingClientRect();
		return {
			left: rect.left + window.pageXOffset,
			top: rect.top + window.pageYOffset,
			width: rect.width,
			height: rect.height
		};
	}
}

/***/ }),

/***/ "./src/plugins/dragresize_ie.js":
/*!**************************************!*\
  !*** ./src/plugins/dragresize_ie.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * CKEditor plugin: Image2
 * - Show gripper to resize images on IE
 */
if (!CKEDITOR.plugins.get('ae_dragresize_ie')) {
	var alignmentsObj = {
		center: 1,
		left: 0,
		right: 2
	};

	/*
  * Set cursor css depend on imageScaleResize config
  **/

	var cursor = {
		both: 'nwse-resize',
		height: 'ns-resize',
		scale: 'nwse-resize',
		width: 'ew-resize'
	};

	var regexPercent = /^\s*(\d+%)\s*$/i;

	var template = '<img alt="" src="" />';

	CKEDITOR.plugins.add('ae_dragresize_ie', {
		hidpi: true,

		icons: 'image',

		init: function init(editor) {
			var image = widgetDef(editor);

			// Register the widget.
			editor.widgets.add('image', image);
		},
		onLoad: function onLoad() {
			CKEDITOR.addCss('.cke_image_resizer_nwse-resize{' + 'cursor: nwse-resize;' + '}' + '.cke_image_resizer_ns-resize{' + 'cursor: ns-resize;' + '}' + '.cke_image_resizer_nwse-resize{' + 'cursor: nwse-resize;' + '}' + '.cke_image_resizer_ew-resize{' + 'cursor: ew-resize;' + '}' + '.cke_image_nocaption{' +
			// This is to remove unwanted space so resize
			// wrapper is displayed property.
			'line-height:0' + '}' + '.cke_image_resizer{' + 'display:none;' + 'position:absolute;' + 'width:10px;' + 'height:10px;' + 'bottom:-5px;' + 'right:-5px;' + 'background:#000;' + 'outline:1px solid #fff;' +
			// Prevent drag handler from being misplaced (#11207).
			'line-height:0;' + 'cursor:nwse-resize;' + '}' + '.cke_image_resizer_wrapper{' + 'position:relative;' + 'display:inline-block;' + 'line-height:0;' + '}' + '.cke_widget_wrapper:hover .cke_image_resizer,' + '.cke_image_resizer.cke_image_resizing{' + 'display:block' + '}');
		},


		requires: 'widget'
	});

	// Widget states (forms) depending on alignment and configuration.
	//
	// Non-captioned widget (inline styles)
	// 		ââââââââ¬ââââââââââââââââââââââââââââââââ¬ââââââââââââââââââââââââââââââ
	// 		âAlign âInternal form                  âData                         â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		ânone  â<wrapper>                      â<img />                      â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âleft  â<wrapper style=âfloat:leftâ>   â<img style=âfloat:leftâ />   â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âcenterâ<wrapper>                      â<p style=âtext-align:centerâ>â
	// 		â      â <p style=âtext-align:centerâ> â  <img />                    â
	// 		â      â   <img />                     â</p>                         â
	// 		â      â </p>                          â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âright â<wrapper style=âfloat:rightâ>  â<img style=âfloat:rightâ />  â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ´ââââââââââââââââââââââââââââââââ´ââââââââââââââââââââââââââââââ
	//
	// Non-captioned widget (config.image2_alignClasses defined)
	// 		ââââââââ¬ââââââââââââââââââââââââââââââââ¬ââââââââââââââââââââââââââââââ
	// 		âAlign âInternal form                  âData                         â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		ânone  â<wrapper>                      â<img />                      â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âleft  â<wrapper class=âleftâ>         â<img class=âleftâ />         â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âcenterâ<wrapper>                      â<p class=âcenterâ>           â
	// 		â      â <p class=âcenterâ>            â <img />                     â
	// 		â      â   <img />                     â</p>                         â
	// 		â      â </p>                          â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âright â<wrapper class=ârightâ>        â<img class=ârightâ />        â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ´ââââââââââââââââââââââââââââââââ´ââââââââââââââââââââââââââââââ
	//
	// Captioned widget (inline styles)
	// 		ââââââââ¬âââââââââââââââââââââââââââââââââââââââââ¬âââââââââââââââââââââââââââââââââââââââââ
	// 		âAlign âInternal form                           âData                                    â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		ânone  â<wrapper>                               â<figure />                              â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âleft  â<wrapper style=âfloat:leftâ>            â<figure style=âfloat:leftâ />           â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âcenterâ<wrapper style=âtext-align:centerâ>     â<div style=âtext-align:centerâ>         â
	// 		â      â <figure style=âdisplay:inline-blockâ />â <figure style=âdisplay:inline-blockâ />â
	// 		â      â</wrapper>                              â</p>                                    â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âright â<wrapper style=âfloat:rightâ>           â<figure style=âfloat:rightâ />          â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ´âââââââââââââââââââââââââââââââââââââââââ´âââââââââââââââââââââââââââââââââââââââââ
	//
	// Captioned widget (config.image2_alignClasses defined)
	// 		ââââââââ¬âââââââââââââââââââââââââââââââââââââââââ¬âââââââââââââââââââââââââââââââââââââââââ
	// 		âAlign âInternal form                           âData                                    â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		ânone  â<wrapper>                               â<figure />                              â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âleft  â<wrapper class=âleftâ>                  â<figure class=âleftâ />                 â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âcenterâ<wrapper class=âcenterâ>                â<div class=âcenterâ>                    â
	// 		â      â <figure />                             â <figure />                             â
	// 		â      â</wrapper>                              â</p>                                    â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âright â<wrapper class=ârightâ>                 â<figure class=ârightâ />                â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ´âââââââââââââââââââââââââââââââââââââââââ´âââââââââââââââââââââââââââââââââââââââââ
	//
	// @param {CKEDITOR.editor}
	// @returns {Object}
	function widgetDef(editor) {
		editor.config.imageScaleResize = editor.config.imageScaleResize || 'both';

		editor.on('imageAdd', function (imageData) {
			editor.widgets.initOn(imageData.data.el, 'image');
		});

		var alignClasses = editor.config.image2_alignClasses;

		var captionedClass = editor.config.image2_captionedClass;

		return {
			init: function init() {
				var helpers = CKEDITOR.plugins.image2;

				var image = this.parts.image;

				var data = {
					alt: image.getAttribute('alt') || '',
					hasCaption: !!this.parts.caption,
					height: image.getAttribute('height') || '',
					// Lock ratio is on by default (#10833).
					lock: this.ready ? helpers.checkHasNaturalRatio(image) : true,
					src: image.getAttribute('src'),
					width: image.getAttribute('width') || ''
				};

				// If we used 'a' in widget#parts definition, it could happen that
				// selected element is a child of widget.parts#caption. Since there's no clever
				// way to solve it with CSS selectors, it's done like that. (#11783).
				var link = image.getAscendant('a');

				if (link && this.wrapper.contains(link)) {
					this.parts.link = link;
				}

				// Depending on configuration, read style/class from element and
				// then remove it. Removed style/class will be set on wrapper in #data listener.
				// Note: Center alignment is detected during upcast, so only left/right cases
				// are checked below.
				if (!data.align) {
					var alignElement = data.hasCaption ? this.element : image;

					// Read the initial left/right alignment from the class set on element.
					if (alignClasses) {
						if (alignElement.hasClass(alignClasses[0])) {
							data.align = 'left';
						} else if (alignElement.hasClass(alignClasses[2])) {
							data.align = 'right';
						}

						if (data.align) {
							alignElement.removeClass(alignClasses[alignmentsObj[data.align]]);
						} else {
							data.align = 'none';
						}
					}
					// Read initial float style from figure/image and then remove it.
					else {
							data.align = alignElement.getStyle('float') || 'none';
							alignElement.removeStyle('float');
						}
				}

				// Get rid of extra vertical space when there's no caption.
				// It will improve the look of the resizer.
				this.wrapper[(data.hasCaption ? 'remove' : 'add') + 'Class']('cke_image_nocaption');

				this.setData(data);

				if (editor.config.image2_disableResizer !== true) {
					setupResizer(this);
				}
			},


			// Overrides default method to handle internal mutability of Image2.
			// @see CKEDITOR.plugins.widget#addClass
			addClass: function addClass(className) {
				getStyleableElement(this).addClass(className);
			},


			allowedContent: getWidgetAllowedContent(editor),

			// This widget converts style-driven dimensions to attributes.
			contentTransformations: [['img[width]: sizeToAttribute']],

			data: function data() {
				var features = this.features;

				// Image can't be captioned when figcaption is disallowed (#11004).
				if (this.data.hasCaption && !editor.filter.checkFeature(features.caption)) {
					this.data.hasCaption = false;
				}

				// Image can't be aligned when floating is disallowed (#11004).
				if (this.data.align != 'none' && !editor.filter.checkFeature(features.align)) {
					this.data.align = 'none';
				}

				// Update widget.parts.link since it will not auto-update unless widget
				// is destroyed and re-inited.
				if (!this.data.link) {
					if (this.parts.link) {
						delete this.parts.link;
					}
				} else {
					if (!this.parts.link) {
						this.parts.link = this.parts.image.getParent();
					}
				}

				this.parts.image.setAttributes({
					alt: this.data.alt,

					contenteditable: this.parts.image.getAttribute('contenteditable') ? this.parts.image.getAttribute('contenteditable') : true,

					// This internal is required by the editor.
					'data-cke-saved-src': this.data.src,

					src: this.data.src
				});

				// If shifting non-captioned -> captioned, remove classes
				// related to styles from <img/>.
				if (this.oldData && !this.oldData.hasCaption && this.data.hasCaption) {
					for (var c in this.data.classes) {
						if (Object.prototype.hasOwnProperty.call(this.data.classes, c)) {
							this.parts.image.removeClass(c);
						}
					}
				}

				// Set dimensions of the image according to gathered data.
				// Do it only when the attributes are allowed (#11004).
				if (editor.filter.checkFeature(features.dimension)) {
					setDimensions(this);
				}

				// Cache current data.
				this.oldData = CKEDITOR.tools.extend({}, this.data);
			},


			downcast: downcastWidgetElement(editor),

			draggable: false,

			// This widget has an editable caption.
			editables: {
				caption: {
					selector: 'figcaption',
					allowedContent: 'br em strong sub sup u s; a[!href,target]'
				}
			},

			features: getWidgetFeatures(editor),

			// Overrides default method to handle internal mutability of Image2.
			// @see CKEDITOR.plugins.widget#getClasses
			getClasses: function () {
				var classRegex = new RegExp('^(' + [].concat(captionedClass, alignClasses).join('|') + ')$');

				return function () {
					var classes = this.repository.parseElementClasses(getStyleableElement(this).getAttribute('class'));

					// Neither config.image2_captionedClass nor config.image2_alignClasses
					// do not belong to style classes.
					for (var c in classes) {
						if (classRegex.test(c)) {
							delete classes[c];
						}
					}

					return classes;
				};
			}(),

			getLabel: function getLabel() {
				var label = (this.data.alt || '') + ' ' + this.pathName;

				return label;
			},


			// Overrides default method to handle internal mutability of Image2.
			// @see CKEDITOR.plugins.widget#hasClass
			hasClass: function hasClass(className) {
				return getStyleableElement(this).hasClass(className);
			},


			parts: {
				caption: 'figcaption',
				image: 'img'
			},

			// Overrides default method to handle internal mutability of Image2.
			// @see CKEDITOR.plugins.widget#removeClass
			removeClass: function removeClass(className) {
				getStyleableElement(this).removeClass(className);
			},


			requiredContent: 'img[src,alt]',

			styleableElements: 'img figure',

			// Template of the widget: plain image.
			template: template,

			upcast: upcastWidgetElement(editor)
		};
	}

	/**
  * A set of Enhanced Image (image2) plugin helpers.
  *
  * @class
  * @singleton
  */
	CKEDITOR.plugins.image2 = {
		/**
   * Checks whether the current image ratio matches the natural one
   * by comparing dimensions.
   *
   * @param {CKEDITOR.dom.element} image
   * @return {Boolean}
   */
		checkHasNaturalRatio: function checkHasNaturalRatio(image) {
			var $ = image.$;

			var natural = this.getNatural(image);

			// The reason for two alternative comparisons is that the rounding can come from
			// both dimensions, e.g. there are two cases:
			// 	1. height is computed as a rounded relation of the real height and the value of width,
			//	2. width is computed as a rounded relation of the real width and the value of heigh.
			return Math.round($.clientWidth / natural.width * natural.height) == $.clientHeight || Math.round($.clientHeight / natural.height * natural.width) == $.clientWidth;
		},


		/**
   * Returns natural dimensions of the image. For modern browsers
   * it uses natural(Width|Height). For old ones (IE8) it creates
   * a new image and reads the dimensions.
   *
   * @param {CKEDITOR.dom.element} image
   * @return {Object}
   */
		getNatural: function getNatural(image) {
			var dimensions = void 0;

			if (image.$.naturalWidth) {
				dimensions = {
					height: image.$.naturalHeigh,
					width: image.$.naturalWidth
				};
			} else {
				var img = new Image();

				img.src = image.getAttribute('src');

				dimensions = {
					height: img.heigh,
					width: img.width
				};
			}

			return dimensions;
		}
	};

	// Returns a function that creates widgets from all <img> and
	// <figure class="{config.image2_captionedClass}"> elements.
	//
	// @param {CKEDITOR.editor} editor
	// @returns {Function}
	function upcastWidgetElement(editor) {
		var isCenterWrapper = centerWrapperChecker(editor);

		var captionedClass = editor.config.image2_captionedClass;

		// @param {CKEDITOR.htmlParser.element} el
		// @param {Object} data
		return function (el, data) {
			var dimensions = {
				height: 1,
				width: 1
			};

			var name = el.name;

			var image = void 0;

			// #11110 Don't initialize on pasted fake objects.
			if (el.attributes['data-cke-realelement']) {
				return;
			}

			// If a center wrapper is found, there are 3 possible cases:
			//
			// 1. <div style="text-align:center"><figure>...</figure></div>.
			//    In this case centering is done with a class set on widget.wrapper.
			//    Simply replace centering wrapper with figure (it's no longer necessary).
			//
			// 2. <p style="text-align:center"><img/></p>.
			//    Nothing to do here: <p> remains for styling purposes.
			//
			// 3. <div style="text-align:center"><img/></div>.
			//    Nothing to do here (2.) but that case is only possible in enterMode different
			//    than ENTER_P.
			if (isCenterWrapper(el)) {
				if (name == 'div') {
					var figure = el.getFirst('figure');

					// Case #1.
					if (figure) {
						el.replaceWith(figure);
						el = figure;
					}
				}
				// Cases #2 and #3 (handled transparently)

				// If there's a centering wrapper, save it in data.
				data.align = 'center';

				// Image can be wrapped in link <a><img/></a>.
				image = el.getFirst('img') || el.getFirst('a').getFirst('img');
			}

			// No center wrapper has been found.
			else if (name == 'figure' && el.hasClass(captionedClass)) {
					image = el.getFirst('img') || el.getFirst('a').getFirst('img');

					// Upcast linked image like <a><img/></a>.
				} else if (isLinkedOrStandaloneImage(el)) {
					image = el.name == 'a' ? el.children[0] : el;
				}

			if (!image) {
				return;
			}

			// If there's an image, then cool, we got a widget.
			// Now just remove dimension attributes expressed with %.
			for (var d in dimensions) {
				if (Object.prototype.hasOwnProperty.call(dimensions, d)) {
					var dimension = image.attributes[d];

					if (dimension && dimension.match(regexPercent)) {
						delete image.attributes[d];
					}
				}
			}

			return el;
		};
	}

	// Returns a function which transforms the widget to the external format
	// according to the current configuration.
	//
	// @param {CKEDITOR.editor}
	function downcastWidgetElement(editor) {
		var alignClasses = editor.config.image2_alignClasses;

		// @param {CKEDITOR.htmlParser.element} el
		return function (el) {
			// In case of <a><img/></a>, <img/> is the element to hold
			// inline styles or classes (image2_alignClasses).
			var attrsHolder = el.name == 'a' ? el.getFirst() : el;

			delete attrsHolder.attributes.contenteditable;

			var attrs = attrsHolder.attributes;

			var align = this.data.align;

			// De-wrap the image from resize handle wrapper.
			// Only block widgets have one.
			if (!this.inline) {
				var resizeWrapper = el.getFirst('span');

				if (resizeWrapper) {
					resizeWrapper.replaceWith(resizeWrapper.getFirst({
						a: 1,
						img: 1
					}));
				}
			}

			if (align && align != 'none') {
				var styles = CKEDITOR.tools.parseCssText(attrs.style || '');

				// When the widget is captioned (<figure>) and internally centering is done
				// with widget's wrapper style/class, in the external data representation,
				// <figure> must be wrapped with an element holding an style/class:
				//
				// 	<div style="text-align:center">
				// 		<figure class="image" style="display:inline-block">...</figure>
				// 	</div>
				// or
				// 	<div class="some-center-class">
				// 		<figure class="image">...</figure>
				// 	</div>
				//
				if (align == 'center' && el.name == 'figure') {
					el = el.wrapWith(new CKEDITOR.htmlParser.element('div', alignClasses ? {
						class: alignClasses[1]
					} : {
						style: 'text-align:center'
					}));
				}

				// If left/right, add float style to the downcasted element.
				else if (align in {
						left: 1,
						right: 1
					}) {
						if (alignClasses) {
							attrsHolder.addClass(alignClasses[alignmentsObj[align]]);
						} else {
							styles['float'] = align;
						}
					}

				// Update element styles.
				if (!alignClasses && !CKEDITOR.tools.isEmpty(styles)) {
					attrs.style = CKEDITOR.tools.writeCssText(styles);
				}
			}

			return el;
		};
	}

	// Returns a function that checks if an element is a centering wrapper.
	//
	// @param {CKEDITOR.editor} editor
	// @returns {Function}
	function centerWrapperChecker(editor) {
		var captionedClass = editor.config.image2_captionedClass;

		var alignClasses = editor.config.image2_alignClasses;

		var validChildren = {
			a: 1,
			figure: 1,
			img: 1
		};

		return function (el) {
			// Wrapper must be either <div> or <p>.
			if (!(el.name in {
				div: 1,
				p: 1
			})) {
				return false;
			}

			var children = el.children;

			// Centering wrapper can have only one child.
			if (children.length !== 1) {
				return false;
			}

			var child = children[0];

			// Only <figure> or <img /> can be first (only) child of centering wrapper,
			// regardless of its type.
			if (!(child.name in validChildren)) {
				return false;
			}

			// If centering wrapper is <p>, only <img /> can be the child.
			//   <p style="text-align:center"><img /></p>
			if (el.name == 'p') {
				if (!isLinkedOrStandaloneImage(child)) {
					return false;
				}
			}
			// Centering <div> can hold <img/> or <figure>, depending on enterMode.
			else {
					// If a <figure> is the first (only) child, it must have a class.
					//   <div style="text-align:center"><figure>...</figure><div>
					if (child.name == 'figure') {
						if (!child.hasClass(captionedClass)) {
							return false;
						}
					} else {
						// Centering <div> can hold <img/> or <a><img/></a> only when enterMode
						// is ENTER_(BR|DIV).
						//   <div style="text-align:center"><img /></div>
						//   <div style="text-align:center"><a><img /></a></div>
						if (editor.enterMode == CKEDITOR.ENTER_P) {
							return false;
						}

						// Regardless of enterMode, a child which is not <figure> must be
						// either <img/> or <a><img/></a>.
						if (!isLinkedOrStandaloneImage(child)) {
							return false;
						}
					}
				}

			// Centering wrapper got to be... centering. If image2_alignClasses are defined,
			// check for centering class. Otherwise, check the style.
			if (alignClasses ? el.hasClass(alignClasses[1]) : CKEDITOR.tools.parseCssText(el.attributes.style || '', true)['text-align'] == 'center') {
				return true;
			}

			return false;
		};
	}

	// Checks whether element is <img/> or <a><img/></a>.
	//
	// @param {CKEDITOR.htmlParser.element}
	function isLinkedOrStandaloneImage(el) {
		if (el.name == 'img') {
			return true;
		} else if (el.name == 'a') {
			return el.children.length == 1 && el.getFirst('img');
		}

		return false;
	}

	// Sets width and height of the widget image according to current widget data.
	//
	// @param {CKEDITOR.plugins.widget} widget
	function setDimensions(widget) {
		var data = widget.data;

		var dimensions = {
			height: data.height,
			width: data.width
		};

		var image = widget.parts.image;

		for (var d in dimensions) {
			if (dimensions[d]) {
				image.setAttribute(d, dimensions[d]);
			} else {
				image.removeAttribute(d);
			}
		}
	}

	// Defines all features related to drag-driven image resizing.
	//
	// @param {CKEDITOR.plugins.widget} widget
	function setupResizer(widget) {
		var editor = widget.editor;

		var editable = editor.editable();

		var doc = editor.document;

		// Store the resizer in a widget for testing (#11004).
		var resizer = widget.resizer = doc.createElement('span');

		resizer.addClass('cke_image_resizer');
		resizer.addClass('cke_image_resizer_' + cursor[editor.config.imageScaleResize]);
		resizer.append(new CKEDITOR.dom.text('\u200B', doc));

		// Inline widgets don't need a resizer wrapper as an image spans the entire widget.
		if (!widget.inline) {
			var imageOrLink = widget.parts.link || widget.parts.image;

			var oldResizeWrapper = imageOrLink.getParent();

			var resizeWrapper = doc.createElement('span');

			resizeWrapper.addClass('cke_image_resizer_wrapper');
			resizeWrapper.append(imageOrLink);
			resizeWrapper.append(resizer);
			widget.element.append(resizeWrapper, true);

			// Remove the old wrapper which could came from e.g. pasted HTML
			// and which could be corrupted (e.g. resizer span has been lost).
			if (oldResizeWrapper.is('span')) {
				oldResizeWrapper.remove();
			}
		} else {
			widget.wrapper.append(resizer);
		}

		// Calculate values of size variables and mouse offsets.
		resizer.on('mousedown', function (evt) {
			var image = widget.parts.image;

			// "factor" can be either 1 or -1. I.e.: For right-aligned images, we need to
			// subtract the difference to get proper width, etc. Without "factor",
			// resizer starts working the opposite way.
			var factor = widget.data.align == 'right' ? -1 : 1;

			// The x-coordinate of the mouse relative to the screen
			// when button gets pressed.
			var startX = evt.data.$.screenX;

			var startY = evt.data.$.screenY;

			// The initial dimensions and aspect ratio of the image.
			var startWidth = image.$.clientWidth;

			var startHeight = image.$.clientHeight;

			var listeners = [];

			// A class applied to editable during resizing.
			var cursorClass = 'cke_image_s' + (!~factor ? 'w' : 'e');

			var nativeEvt = void 0;
			var newWidth = void 0;
			var newHeight = void 0;
			var updateData = void 0;

			var moveDiffX = void 0;
			var moveDiffY = void 0;

			// Save the undo snapshot first: before resizing.
			editor.fire('saveSnapshot');

			// Mousemove listeners are removed on mouseup.
			attachToDocuments('mousemove', onMouseMove, listeners);

			// Clean up the mousemove listener. Update widget data if valid.
			attachToDocuments('mouseup', onMouseUp, listeners);

			// The entire editable will have the special cursor while resizing goes on.
			editable.addClass(cursorClass);

			// This is to always keep the resizer element visible while resizing.
			resizer.addClass('cke_image_resizing');

			// Attaches an event to a global document if inline editor.
			// Additionally, if classic (`iframe`-based) editor, also attaches the same event to `iframe`'s document.
			function attachToDocuments(name, callback, collection) {
				var globalDoc = CKEDITOR.document;

				var listeners = [];

				if (!doc.equals(globalDoc)) {
					listeners.push(globalDoc.on(name, callback));
				}

				listeners.push(doc.on(name, callback));

				if (collection) {
					for (var i = listeners.length; i--;) {
						collection.push(listeners.pop());
					}
				}
			}

			// This is how variables refer to the geometry.
			// Note: x corresponds to moveOffset, this is the position of mouse
			// Note: o corresponds to [startX, startY].
			//
			// 	+--------------+--------------+
			// 	|              |              |
			// 	|      I       |      II      |
			// 	|              |              |
			// 	+------------- o -------------+ _ _ _
			// 	|              |              |      ^

			// 	|      VI      |     III      |      | moveDiffY
			// 	|              |         x _ _ _ _ _ v
			// 	+--------------+---------|----+
			// 	               |         |
			// 	                <------->
			// 	                moveDiffX
			function onMouseMove(evt) {
				var imageScaleResize = editor.config.imageScaleResize;

				nativeEvt = evt.data.$;

				// This is how far the mouse is from the point the button was pressed.
				moveDiffX = nativeEvt.screenX - startX;
				moveDiffY = startY - nativeEvt.screenY;

				if (imageScaleResize === 'width' || imageScaleResize === 'both' || imageScaleResize === 'scale') {
					newWidth = startWidth + factor * moveDiffX;
				}

				if (imageScaleResize === 'height' || imageScaleResize === 'both') {
					newHeight = startHeight - moveDiffY;
				}

				if (imageScaleResize === 'scale') {
					newHeight = 'auto';
				}

				newWidth = newWidth || startWidth;
				newHeight = newHeight || startHeight;

				// Don't update attributes if less than 10.
				// This is to prevent images to visually disappear.
				if (newWidth >= 15 && (newHeight >= 15 || newHeight === 'auto')) {
					image.$.style.width = newWidth + 'px';
					image.$.style.height = newHeight + 'px';

					updateData = true;
				} else {
					updateData = false;
				}
			}

			function onMouseUp() {
				var l = void 0;

				while (l = listeners.pop()) {
					l.removeListener();
				}

				// Restore default cursor by removing special class.
				editable.removeClass(cursorClass);

				// This is to bring back the regular behaviour of the resizer.
				resizer.removeClass('cke_image_resizing');

				if (updateData) {
					widget.setData({
						height: newHeight,
						width: newWidth
					});

					// Save another undo snapshot: after resizing.
					editor.fire('saveSnapshot');
				}

				// Don't update data twice or more.
				updateData = false;
			}
		});

		// Change the position of the widget resizer when data changes.
		widget.on('data', function () {
			resizer[widget.data.align == 'right' ? 'addClass' : 'removeClass']('cke_image_resizer_left');
		});

		widget.parts.image.on('click', function () {
			var selection = editor.getSelection();

			if (selection) {
				var element = selection.getStartElement();

				if (element) {
					var widgetElement = element.findOne('img');

					if (widgetElement) {
						var region = element.getClientRect();

						var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();
						region.left -= scrollPosition.x;
						region.top += scrollPosition.y;

						region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;

						editor.fire('editorInteraction', {
							nativeEvent: event,
							selectionData: {
								element: widgetElement,
								region: region
							}
						});
					}
				}
			}
		});
	}

	// Returns a set of widget allowedContent rules, depending
	// on configurations like config#image2_alignClasses or
	// config#image2_captionedClass.
	//
	// @param {CKEDITOR.editor}
	// @returns {Object}
	function getWidgetAllowedContent(editor) {
		var rules = {
			figcaption: true,
			figure: {
				classes: '!' + editor.config.image2_captionedClass
			},
			img: {
				attributes: '!src,alt,width,height'
			}
		};

		return rules;
	}

	// Returns a set of widget feature rules, depending
	// on editor configuration. Note that the following may not cover
	// all the possible cases since requiredContent supports a single
	// tag only.
	//
	// @param {CKEDITOR.editor}
	// @returns {Object}
	function getWidgetFeatures(editor) {
		var alignClasses = editor.config.image2_alignClasses;

		var features = {
			align: {
				requiredContent: 'img' + (alignClasses ? '(' + alignClasses[0] + ')' : '{float}')
			},
			caption: {
				requiredContent: 'figcaption'
			},
			dimension: {
				requiredContent: 'img[width,height]'
			}
		};

		return features;
	}

	// Returns element which is styled, considering current
	// state of the widget.
	//
	// @see CKEDITOR.plugins.widget#applyStyle
	// @param {CKEDITOR.plugins.widget} widget
	// @returns {CKEDITOR.dom.element}
	function getStyleableElement(widget) {
		return widget.data.hasCaption ? widget.element : widget.parts.image;
	}
}

CKEDITOR.config.image2_captionedClass = 'image';

/***/ }),

/***/ "./src/plugins/dragresize_ie11.js":
/*!****************************************!*\
  !*** ./src/plugins/dragresize_ie11.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

(function () {
	if (CKEDITOR.plugins.get('ae_dragresize_ie11')) {
		return;
	}

	var template = '<img alt="" src="" />';

	var templateBlock = new CKEDITOR.template('<figure class="{captionedClass}">' + template + '<figcaption>{captionPlaceholder}</figcaption>' + '</figure>');

	var alignmentsObj = { left: 0, center: 1, right: 2 };

	var regexPercent = /^\s*(\d+%)\s*$/i;

	CKEDITOR.plugins.add('ae_dragresize_ie11', {
		requires: 'widget',
		onLoad: function onLoad() {
			CKEDITOR.addCss('.cke_image_nocaption{' +
			// This is to remove unwanted space so resize
			// wrapper is displayed property.
			'line-height:0' + '}' + '.cke_editable.cke_image_ne, .cke_editable.cke_image_ne *{cursor:ne-resize !important}' + '.cke_editable.cke_image_nw, .cke_editable.cke_image_nw *{cursor:nw-resize !important}' + '.cke_editable.cke_image_sw, .cke_editable.cke_image_sw *{cursor:sw-resize !important}' + '.cke_editable.cke_image_se, .cke_editable.cke_image_se *{cursor:se-resize !important}' + '.cke_image_resizer{' + 'display:none;' + 'position:absolute;' + 'width:10px;' + 'height:10px;' + 'background:#000;' + 'outline:1px solid #fff;' +
			// Prevent drag handler from being misplaced (#11207).
			'line-height:0;' + 'cursor:se-resize;' + '}' + '.cke_image_resizer_wrapper{' + 'position:relative;' + 'display:inline-block;' + 'line-height:0;' + '}' +
			// Top-right corner style of the resizer.
			'.cke_image_resizer.cke_image_resizer_ne{' + 'cursor:ne-resize;' + 'left:auto;' + 'right:-5px;' + 'top:-5px;' + '}' +
			// Top-left corner style of the resizer.
			'.cke_image_resizer.cke_image_resizer_nw{' + 'cursor:nw-resize;' + 'left:-5px;' + 'right:auto;' + 'top:-5px;' + '}' +
			// Bottom-right corner style of the resizer.
			'.cke_image_resizer.cke_image_resizer_se{' + 'bottom:-5px;' + 'cursor:se-resize;' + 'left:auto;' + 'right:-5px;' + '}' +
			// Bottom-left corner style of the resizer.
			'.cke_image_resizer.cke_image_resizer_sw{' + 'bottom:-5px;' + 'cursor:sw-resize;' + 'left:-5px;' + 'right:auto;' + '}' + '.cke_widget_wrapper:hover .cke_image_resizer,' + '.cke_image_resizing>.cke_image_resizer{' + 'display:block' + '}' +
			// Expand widget wrapper when linked inline image.
			'.cke_widget_wrapper>a{' + 'display:inline-block' + '}');
		},
		init: function init(editor) {
			// Adapts configuration from original image plugin. Should be removed
			// when we'll rename ae_dragresize_ie11 to image.

			var image = widgetDef(editor);

			// Register the widget.
			editor.widgets.add('image', image);

			// Add a listener to handle selection change events and properly detect editor
			// interactions on the widgets without messing with widget native selection
			editor.on('selectionChange', function (_event) {
				var selection = editor.getSelection();

				if (selection) {
					var element = selection.getSelectedElement();

					if (element) {
						var widgetElement = element.findOne('img');

						if (widgetElement) {
							var region = element.getClientRect();

							var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();
							region.left -= scrollPosition.x;
							region.top += scrollPosition.y;

							region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;

							editor.fire('editorInteraction', {
								nativeEvent: {},
								selectionData: {
									element: widgetElement,
									region: region
								}
							});
						}
					}
				}
			});
		},
		afterInit: function afterInit(editor) {
			// Integrate with align commands (justify plugin).
			var align = { left: 1, right: 1, center: 1, block: 1 };

			var integrate = alignCommandIntegrator(editor);

			for (var value in align) {
				if (Object.prototype.hasOwnProperty.call(align, value)) {
					integrate(value);
				}
			}
		}
	});

	// Widget states (forms) depending on alignment and configuration.
	//
	// Non-captioned widget (inline styles)
	// 		ââââââââ¬ââââââââââââââââââââââââââââââââ¬ââââââââââââââââââââââââââââââ
	// 		âAlign âInternal form                  âData                         â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		ânone  â<wrapper>                      â<img />                      â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âleft  â<wrapper style=âfloat:leftâ>   â<img style=âfloat:leftâ />   â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âcenterâ<wrapper>                      â<p style=âtext-align:centerâ>â
	// 		â      â <p style=âtext-align:centerâ> â  <img />                    â
	// 		â      â   <img />                     â</p>                         â
	// 		â      â </p>                          â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âright â<wrapper style=âfloat:rightâ>  â<img style=âfloat:rightâ />  â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ´ââââââââââââââââââââââââââââââââ´ââââââââââââââââââââââââââââââ
	//
	// Non-captioned widget (config.ae_dragresize_ie11_alignClasses defined)
	// 		ââââââââ¬ââââââââââââââââââââââââââââââââ¬ââââââââââââââââââââââââââââââ
	// 		âAlign âInternal form                  âData                         â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		ânone  â<wrapper>                      â<img />                      â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âleft  â<wrapper class=âleftâ>         â<img class=âleftâ />         â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âcenterâ<wrapper>                      â<p class=âcenterâ>           â
	// 		â      â <p class=âcenterâ>            â <img />                     â
	// 		â      â   <img />                     â</p>                         â
	// 		â      â </p>                          â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âright â<wrapper class=ârightâ>        â<img class=ârightâ />        â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ´ââââââââââââââââââââââââââââââââ´ââââââââââââââââââââââââââââââ
	//
	// Captioned widget (inline styles)
	// 		ââââââââ¬âââââââââââââââââââââââââââââââââââââââââ¬âââââââââââââââââââââââââââââââââââââââââ
	// 		âAlign âInternal form                           âData                                    â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		ânone  â<wrapper>                               â<figure />                              â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âleft  â<wrapper style=âfloat:leftâ>            â<figure style=âfloat:leftâ />           â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âcenterâ<wrapper style=âtext-align:centerâ>     â<div style=âtext-align:centerâ>         â
	// 		â      â <figure style=âdisplay:inline-blockâ />â <figure style=âdisplay:inline-blockâ />â
	// 		â      â</wrapper>                              â</p>                                    â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âright â<wrapper style=âfloat:rightâ>           â<figure style=âfloat:rightâ />          â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ´âââââââââââââââââââââââââââââââââââââââââ´âââââââââââââââââââââââââââââââââââââââââ
	//
	// Captioned widget (config.ae_dragresize_ie11_alignClasses defined)
	// 		ââââââââ¬âââââââââââââââââââââââââââââââââââââââââ¬âââââââââââââââââââââââââââââââââââââââââ
	// 		âAlign âInternal form                           âData                                    â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		ânone  â<wrapper>                               â<figure />                              â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âleft  â<wrapper class=âleftâ>                  â<figure class=âleftâ />                 â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âcenterâ<wrapper class=âcenterâ>                â<div class=âcenterâ>                    â
	// 		â      â <figure />                             â <figure />                             â
	// 		â      â</wrapper>                              â</p>                                    â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âright â<wrapper class=ârightâ>                 â<figure class=ârightâ />                â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ´âââââââââââââââââââââââââââââââââââââââââ´âââââââââââââââââââââââââââââââââââââââââ
	//
	// @param {CKEDITOR.editor}
	// @returns {Object}
	function widgetDef(editor) {
		var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

		var captionedClass = editor.config.ae_dragresize_ie11_captionedClass;

		function deflate() {
			if (this.deflated) return;

			// Remember whether widget was focused before destroyed.
			if (editor.widgets.focused == this.widget) this.focused = true;

			editor.widgets.destroy(this.widget);

			// Mark widget was destroyed.
			this.deflated = true;
		}

		function inflate() {
			var editable = editor.editable();

			var doc = editor.document;

			// Create a new widget. This widget will be either captioned
			// non-captioned, block or inline according to what is the
			// new state of the widget.
			if (this.deflated) {
				this.widget = editor.widgets.initOn(this.element, 'image', this.widget.data);

				// Once widget was re-created, it may become an inline element without
				// block wrapper (i.e. when unaligned, end not captioned). Let's do some
				// sort of autoparagraphing here (#10853).
				if (this.widget.inline && !new CKEDITOR.dom.elementPath(this.widget.wrapper, editable).block) {
					var block = doc.createElement(editor.activeEnterMode == CKEDITOR.ENTER_P ? 'p' : 'div');
					block.replace(this.widget.wrapper);
					this.widget.wrapper.move(block);
				}

				// The focus must be transferred from the old one (destroyed)
				// to the new one (just created).
				if (this.focused) {
					this.widget.focus();
					delete this.focused;
				}

				delete this.deflated;
			}

			// If now widget was destroyed just update wrapper's alignment.
			// According to the new state.
			else {
					setWrapperAlign(this.widget, alignClasses);
				}
		}

		return {
			allowedContent: getWidgetAllowedContent(editor),

			requiredContent: 'img[src,alt]',

			features: getWidgetFeatures(editor),

			styleableElements: 'img figure',

			// This widget converts style-driven dimensions to attributes.
			contentTransformations: [['img[width]: sizeToAttribute']],

			// This widget has an editable caption.
			editables: {
				caption: {
					selector: 'figcaption',
					allowedContent: 'br em strong sub sup u s; a[!href,target]'
				}
			},

			parts: {
				image: 'img',
				caption: 'figcaption'
				// parts#link defined in widget#init
			},

			// Template of the widget: plain image.
			template: template,

			data: function data() {
				var features = this.features;

				// Image can't be captioned when figcaption is disallowed (#11004).
				if (this.data.hasCaption && !editor.filter.checkFeature(features.caption)) this.data.hasCaption = false;

				// Image can't be aligned when floating is disallowed (#11004).
				if (this.data.align != 'none' && !editor.filter.checkFeature(features.align)) this.data.align = 'none';

				// Convert the internal form of the widget from the old state to the new one.
				this.shiftState({
					widget: this,
					element: this.element,
					oldData: this.oldData,
					newData: this.data,
					deflate: deflate,
					inflate: inflate
				});

				// Update widget.parts.link since it will not auto-update unless widget
				// is destroyed and re-inited.
				if (!this.data.link) {
					if (this.parts.link) delete this.parts.link;
				} else {
					if (!this.parts.link) this.parts.link = this.parts.image.getParent();
				}

				this.parts.image.setAttributes({
					src: this.data.src,

					// This internal is required by the editor.
					'data-cke-saved-src': this.data.src,

					alt: this.data.alt
				});

				// If shifting non-captioned -> captioned, remove classes
				// related to styles from <img/>.
				if (this.oldData && !this.oldData.hasCaption && this.data.hasCaption) {
					for (var c in this.data.classes) {
						if (Object.prototype.hasOwnProperty.call(this.data.classes, c)) {
							this.parts.image.removeClass(c);
						}
					}
				}

				// Set dimensions of the image according to gathered data.
				// Do it only when the attributes are allowed (#11004).
				if (editor.filter.checkFeature(features.dimension)) setDimensions(this);

				// Cache current data.
				this.oldData = CKEDITOR.tools.extend({}, this.data);
			},
			init: function init() {
				var helpers = CKEDITOR.plugins.ae_dragresize_ie11;

				var image = this.parts.image;

				var data = {
					hasCaption: !!this.parts.caption,
					src: image.getAttribute('src'),
					alt: image.getAttribute('alt') || '',
					width: image.getAttribute('width') || '',
					height: image.getAttribute('height') || '',

					// Lock ratio is on by default (#10833).
					lock: this.ready ? helpers.checkHasNaturalRatio(image) : true
				};

				// If we used 'a' in widget#parts definition, it could happen that
				// selected element is a child of widget.parts#caption. Since there's no clever
				// way to solve it with CSS selectors, it's done like that. (#11783).
				var link = image.getAscendant('a');

				if (link && this.wrapper.contains(link)) this.parts.link = link;

				// Depending on configuration, read style/class from element and
				// then remove it. Removed style/class will be set on wrapper in #data listener.
				// Note: Center alignment is detected during upcast, so only left/right cases
				// are checked below.
				if (!data.align) {
					var alignElement = data.hasCaption ? this.element : image;

					// Read the initial left/right alignment from the class set on element.
					if (alignClasses) {
						if (alignElement.hasClass(alignClasses[0])) {
							data.align = 'left';
						} else if (alignElement.hasClass(alignClasses[2])) {
							data.align = 'right';
						}

						if (data.align) {
							alignElement.removeClass(alignClasses[alignmentsObj[data.align]]);
						} else {
							data.align = 'none';
						}
					}
					// Read initial float style from figure/image and then remove it.
					else {
							data.align = alignElement.getStyle('float') || 'none';
							alignElement.removeStyle('float');
						}
				}

				// Update data.link object with attributes if the link has been discovered.
				if (editor.plugins.link && this.parts.link) {
					data.link = helpers.getLinkAttributesParser()(editor, this.parts.link);

					// Get rid of cke_widget_* classes in data. Otherwise
					// they might appear in link dialog.
					var advanced = data.link.advanced;
					if (advanced && advanced.advCSSClasses) {
						advanced.advCSSClasses = CKEDITOR.tools.trim(advanced.advCSSClasses.replace(/cke_\S+/, ''));
					}
				}

				// Get rid of extra vertical space when there's no caption.
				// It will improve the look of the resizer.
				this.wrapper[(data.hasCaption ? 'remove' : 'add') + 'Class']('cke_image_nocaption');

				this.setData(data);

				// Setup dynamic image resizing with mouse.
				// Don't initialize resizer when dimensions are disallowed (#11004).
				if (editor.filter.checkFeature(this.features.dimension) && editor.config.ae_dragresize_ie11_disableResizer !== true) setupResizer(this);

				var dragHandlerStyle = this.dragHandlerContainer.$.style;
				dragHandlerStyle.setAttribute('backgroundColor', 'rgba(255, 255, 255, 1');
				dragHandlerStyle.setAttribute('opacity', '1');

				this.shiftState = helpers.stateShifter(this.editor);

				// Add widget editing option to its context menu.
				this.on('contextMenu', function (evt) {
					evt.data.image = CKEDITOR.TRISTATE_OFF;

					// Integrate context menu items for link.
					// Note that widget may be wrapped in a link, which
					// does not belong to that widget (#11814).
					if (this.parts.link || this.wrapper.getAscendant('a')) evt.data.link = evt.data.unlink = CKEDITOR.TRISTATE_OFF;
				});
			},


			// Overrides default method to handle internal mutability of ae_dragresize_ie11.
			// @see CKEDITOR.plugins.widget#addClass
			addClass: function addClass(className) {
				getStyleableElement(this).addClass(className);
			},


			// Overrides default method to handle internal mutability of ae_dragresize_ie11.
			// @see CKEDITOR.plugins.widget#hasClass
			hasClass: function hasClass(className) {
				return getStyleableElement(this).hasClass(className);
			},


			// Overrides default method to handle internal mutability of ae_dragresize_ie11.
			// @see CKEDITOR.plugins.widget#removeClass
			removeClass: function removeClass(className) {
				getStyleableElement(this).removeClass(className);
			},


			// Overrides default method to handle internal mutability of ae_dragresize_ie11.
			// @see CKEDITOR.plugins.widget#getClasses
			getClasses: function () {
				var classRegex = new RegExp('^(' + [].concat(captionedClass, alignClasses).join('|') + ')$');

				return function () {
					var classes = this.repository.parseElementClasses(getStyleableElement(this).getAttribute('class'));

					// Neither config.ae_dragresize_ie11_captionedClass nor config.ae_dragresize_ie11_alignClasses
					// do not belong to style classes.
					for (var c in classes) {
						if (classRegex.test(c)) delete classes[c];
					}

					return classes;
				};
			}(),

			upcast: upcastWidgetElement(editor),
			downcast: downcastWidgetElement(editor),

			getLabel: function getLabel() {
				var label = (this.data.alt || '') + ' ' + this.pathName;

				return this.editor.lang.widget.label.replace(/%1/, label);
			}
		};
	}

	/**
  * A set of Enhanced Image (ae_dragresize_ie11) plugin helpers.
  *
  * @class
  * @singleton
  */
	CKEDITOR.plugins.ae_dragresize_ie11 = {
		stateShifter: function stateShifter(editor) {
			// Tag name used for centering non-captioned widgets.
			var doc = editor.document;

			var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

			var captionedClass = editor.config.ae_dragresize_ie11_captionedClass;

			var editable = editor.editable();

			// The order that stateActions get executed. It matters!

			var shiftables = ['hasCaption', 'align', 'link'];

			// Atomic procedures, one per state variable.
			var stateActions = {
				align: function align(shift, oldValue, newValue) {
					var el = shift.element;

					// Alignment changed.
					if (shift.changed.align || el.$.style.marginLeft === 'auto' && el.$.style.marginRight === 'auto') {
						// No caption in the new state.
						if (!shift.newData.hasCaption) {
							// Changed to "center" (non-captioned).
							if (newValue == 'center' || el.$.style.marginLeft === 'auto' && el.$.style.marginRight === 'auto') {
								shift.deflate();
								shift.element = wrapInCentering(editor, el);
							}

							// Changed to "non-center" from "center" while caption removed.
							if (!shift.changed.hasCaption && oldValue == 'center' && newValue != 'center') {
								shift.deflate();
								shift.element = unwrapFromCentering(el);
							}
						}
					}

					// Alignment remains and "center" removed caption.
					else if (newValue == 'center' && shift.changed.hasCaption && !shift.newData.hasCaption) {
							shift.deflate();
							shift.element = wrapInCentering(editor, el);
						}

					// Finally set display for figure.
					if (!alignClasses && el.is('figure')) {
						if (newValue == 'center') el.setStyle('display', 'inline-block');else el.removeStyle('display');
					}
				},
				hasCaption: function hasCaption(shift, oldValue, newValue) {
					// This action is for real state change only.
					if (!shift.changed.hasCaption) return;

					// Get <img/> or <a><img/></a> from widget. Note that widget element might itself
					// be what we're looking for. Also element can be <p style="text-align:center"><a>...</a></p>.
					var imageOrLink = void 0;
					if (shift.element.is({ img: 1, a: 1 })) imageOrLink = shift.element;else imageOrLink = shift.element.findOne('a,img');

					// Switching hasCaption always destroys the widget.
					shift.deflate();

					// There was no caption, but the caption is to be added.
					if (newValue) {
						// Create new <figure> from widget template.
						var figure = CKEDITOR.dom.element.createFromHtml(templateBlock.output({
							captionedClass: captionedClass,
							captionPlaceholder: editor.lang.ae_dragresize_ie11.captionPlaceholder
						}), doc);

						// Replace element with <figure>.
						replaceSafely(figure, shift.element);

						// Use old <img/> or <a><img/></a> instead of the one from the template,
						// so we won't lose additional attributes.
						imageOrLink.replace(figure.findOne('img'));

						// Update widget's element.
						shift.element = figure;
					}

					// The caption was present, but now it's to be removed.
					else {
							// Unwrap <img/> or <a><img/></a> from figure.
							imageOrLink.replace(shift.element);

							// Update widget's element.
							shift.element = imageOrLink;
						}
				},
				link: function link(shift, oldValue, newValue) {
					if (shift.changed.link) {
						var img = shift.element.is('img') ? shift.element : shift.element.findOne('img');

						var link = shift.element.is('a') ? shift.element : shift.element.findOne('a');

						// Why deflate:
						// If element is <img/>, it will be wrapped into <a>,
						// which becomes a new widget.element.
						// If element is <a><img/></a>, it will be unlinked
						// so <img/> becomes a new widget.element.

						var needsDeflate = shift.element.is('a') && !newValue || shift.element.is('img') && newValue;

						var newEl = void 0;

						if (needsDeflate) shift.deflate();

						// If unlinked the image, returned element is <img>.
						if (!newValue) newEl = unwrapFromLink(link);else {
							// If linked the image, returned element is <a>.
							if (!oldValue) newEl = wrapInLink(img, shift.newData.link);

							// Set and remove all attributes associated with this state.
							var attributes = CKEDITOR.plugins.ae_dragresize_ie11.getLinkAttributesGetter()(editor, newValue);

							if (!CKEDITOR.tools.isEmpty(attributes.set)) (newEl || link).setAttributes(attributes.set);

							if (attributes.removed.length) (newEl || link).removeAttributes(attributes.removed);
						}

						if (needsDeflate) shift.element = newEl;
					}
				}
			};

			function wrapInCentering(editor, element) {
				var attribsAndStyles = {};

				if (alignClasses) attribsAndStyles.attributes = { class: alignClasses[1] };else attribsAndStyles.styles = { 'text-align': 'center' };

				// There's no gentle way to center inline element with CSS, so create p/div
				// that wraps widget contents and does the trick either with style or class.
				var center = doc.createElement(editor.activeEnterMode == CKEDITOR.ENTER_P ? 'p' : 'div', attribsAndStyles);

				// Replace element with centering wrapper.
				replaceSafely(center, element);
				element.move(center);

				return center;
			}

			function unwrapFromCentering(element) {
				var imageOrLink = element.findOne('a,img');

				imageOrLink.replace(element);

				return imageOrLink;
			}

			// Wraps <img/> -> <a><img/></a>.
			// Returns reference to <a>.
			//
			// @param {CKEDITOR.dom.element} img
			// @param {Object} linkData
			// @returns {CKEDITOR.dom.element}
			function wrapInLink(img, linkData) {
				var link = doc.createElement('a', {
					attributes: {
						href: linkData.url
					}
				});

				link.replace(img);
				img.move(link);

				return link;
			}

			// De-wraps <a><img/></a> -> <img/>.
			// Returns the reference to <img/>
			//
			// @param {CKEDITOR.dom.element} link
			// @returns {CKEDITOR.dom.element}
			function unwrapFromLink(link) {
				var img = link.findOne('img');

				img.replace(link);

				return img;
			}

			function replaceSafely(replacing, replaced) {
				if (replaced.getParent()) {
					var range = editor.createRange();

					range.moveToPosition(replaced, CKEDITOR.POSITION_BEFORE_START);

					// Remove old element. Do it before insertion to avoid a case when
					// element is moved from 'replaced' element before it, what creates
					// a tricky case which insertElementIntorRange does not handle.
					replaced.remove();

					editable.insertElementIntoRange(replacing, range);
				} else {
					replacing.replace(replaced);
				}
			}

			return function (shift) {
				var name = void 0;
				var i = void 0;

				shift.changed = {};

				for (i = 0; i < shiftables.length; i++) {
					name = shiftables[i];

					shift.changed[name] = shift.oldData ? shift.oldData[name] !== shift.newData[name] : false;
				}

				// Iterate over possible state variables.
				for (i = 0; i < shiftables.length; i++) {
					name = shiftables[i];

					stateActions[name](shift, shift.oldData ? shift.oldData[name] : null, shift.newData[name]);
				}

				shift.inflate();
			};
		},


		/**
   * Checks whether the current image ratio matches the natural one
   * by comparing dimensions.
   *
   * @param {CKEDITOR.dom.element} image
   * @return {Boolean}
   */
		checkHasNaturalRatio: function checkHasNaturalRatio(image) {
			var $ = image.$;

			var natural = this.getNatural(image);

			// The reason for two alternative comparisons is that the rounding can come from
			// both dimensions, e.g. there are two cases:
			// 	1. height is computed as a rounded relation of the real height and the value of width,
			//	2. width is computed as a rounded relation of the real width and the value of heigh.
			return Math.round($.clientWidth / natural.width * natural.height) == $.clientHeight || Math.round($.clientHeight / natural.height * natural.width) == $.clientWidth;
		},


		/**
   * Returns natural dimensions of the image. For modern browsers
   * it uses natural(Width|Height). For old ones (IE8) it creates
   * a new image and reads the dimensions.
   *
   * @param {CKEDITOR.dom.element} image
   * @return {Object}
   */
		getNatural: function getNatural(image) {
			var dimensions = void 0;

			if (image.$.naturalWidth) {
				dimensions = {
					width: image.$.naturalWidth,
					height: image.$.naturalHeight
				};
			} else {
				var img = new Image();
				img.src = image.getAttribute('src');

				dimensions = {
					width: img.width,
					height: img.height
				};
			}

			return dimensions;
		},


		/**
   * Returns an attribute getter function. Default getter comes from the Link plugin
   * and is documented by {@link CKEDITOR.plugins.link#getLinkAttributes}.
   *
   * **Note:** It is possible to override this method and use a custom getter e.g.
   * in the absence of the Link plugin.
   *
   * **Note:** If a custom getter is used, a data model format it produces
   * must be compatible with {@link CKEDITOR.plugins.link#getLinkAttributes}.
   *
   * **Note:** A custom getter must understand the data model format produced by
   * {@link #getLinkAttributesParser} to work correctly.
   *
   * @return {Function} A function that gets (composes) link attributes.
   * @since 4.5.5
   */
		getLinkAttributesGetter: function getLinkAttributesGetter() {
			// #13885
			return CKEDITOR.plugins.link.getLinkAttributes;
		},


		/**
   * Returns an attribute parser function. Default parser comes from the Link plugin
   * and is documented by {@link CKEDITOR.plugins.link#parseLinkAttributes}.
   *
   * **Note:** It is possible to override this method and use a custom parser e.g.
   * in the absence of the Link plugin.
   *
   * **Note:** If a custom parser is used, a data model format produced by the parser
   * must be compatible with {@link #getLinkAttributesGetter}.
   *
   * **Note:** If a custom parser is used, it should be compatible with the
   * {@link CKEDITOR.plugins.link#parseLinkAttributes} data model format. Otherwise the
   * Link plugin dialog may not be populated correctly with parsed data. However
   * as long as Enhanced Image is **not** used with the Link plugin dialog, any custom data model
   * will work, being stored as an internal property of Enhanced Image widget's data only.
   *
   * @return {Function} A function that parses attributes.
   * @since 4.5.5
   */
		getLinkAttributesParser: function getLinkAttributesParser() {
			// #13885
			return CKEDITOR.plugins.link.parseLinkAttributes;
		}
	};

	function setWrapperAlign(widget, alignClasses) {
		var wrapper = widget.wrapper;

		var align = widget.data.align;

		var hasCaption = widget.data.hasCaption;

		if (alignClasses) {
			// Remove all align classes first.
			for (var i = 3; i--;) {
				wrapper.removeClass(alignClasses[i]);
			}if (align == 'center') {
				// Avoid touching non-captioned, centered widgets because
				// they have the class set on the element instead of wrapper:
				//
				// 	<div class="cke_widget_wrapper">
				// 		<p class="center-class">
				// 			<img />
				// 		</p>
				// 	</div>
				if (hasCaption) {
					wrapper.addClass(alignClasses[1]);
				}
			} else if (align != 'none') {
				wrapper.addClass(alignClasses[alignmentsObj[align]]);
			}
		} else {
			if (align == 'center') {
				if (hasCaption) wrapper.setStyle('text-align', 'center');else wrapper.removeStyle('text-align');

				wrapper.removeStyle('float');
			} else {
				if (align == 'none') wrapper.removeStyle('float');else wrapper.setStyle('float', align);

				wrapper.removeStyle('text-align');
			}

			var image = wrapper.$.querySelector('img');

			var imageStyles = image.getAttribute('style');

			if (imageStyles) {
				var styles = '';

				var heightStyles = /(height:.+?;)/.exec(imageStyles);
				if (heightStyles) {
					styles += heightStyles[0];
				}

				var widthStyles = /(width:.+?;)/.exec(imageStyles);
				if (widthStyles) {
					styles += widthStyles[0];
				}

				image.setAttribute('style', styles);
			}
		}
	}

	// Returns a function that creates widgets from all <img> and
	// <figure class="{config.ae_dragresize_ie11_captionedClass}"> elements.
	//
	// @param {CKEDITOR.editor} editor
	// @returns {Function}
	function upcastWidgetElement(editor) {
		var isCenterWrapper = centerWrapperChecker(editor);

		var captionedClass = editor.config.ae_dragresize_ie11_captionedClass;

		// @param {CKEDITOR.htmlParser.element} el
		// @param {Object} data
		return function (el, data) {
			var dimensions = { width: 1, height: 1 };

			var name = el.name;

			var image = void 0;

			// #11110 Don't initialize on pasted fake objects.
			if (el.attributes['data-cke-realelement']) return;

			// If a center wrapper is found, there are 3 possible cases:
			//
			// 1. <div style="text-align:center"><figure>...</figure></div>.
			//    In this case centering is done with a class set on widget.wrapper.
			//    Simply replace centering wrapper with figure (it's no longer necessary).
			//
			// 2. <p style="text-align:center"><img/></p>.
			//    Nothing to do here: <p> remains for styling purposes.
			//
			// 3. <div style="text-align:center"><img/></div>.
			//    Nothing to do here (2.) but that case is only possible in enterMode different
			//    than ENTER_P.
			if (isCenterWrapper(el)) {
				if (name == 'div') {
					var figure = el.getFirst('figure');

					// Case #1.
					if (figure) {
						el.replaceWith(figure);
						el = figure;
					}
				}
				// Cases #2 and #3 (handled transparently)

				// If there's a centering wrapper, save it in data.
				data.align = 'center';

				// Image can be wrapped in link <a><img/></a>.
				image = el.getFirst('img') || el.getFirst('a').getFirst('img');
			}

			// No center wrapper has been found.
			else if (name == 'figure' && el.hasClass(captionedClass)) {
					image = el.getFirst('img') || el.getFirst('a').getFirst('img');

					// Upcast linked image like <a><img/></a>.
				} else if (isLinkedOrStandaloneImage(el)) {
					image = el.name == 'a' ? el.children[0] : el;
				}

			if (!image) return;

			// If there's an image, then cool, we got a widget.
			// Now just remove dimension attributes expressed with %.
			for (var d in dimensions) {
				if (Object.prototype.hasOwnProperty.call(dimensions, d)) {
					var dimension = image.attributes[d];
					if (dimension && dimension.match(regexPercent)) delete image.attributes[d];
				}
			}

			return el;
		};
	}

	// Returns a function which transforms the widget to the external format
	// according to the current configuration.
	//
	// @param {CKEDITOR.editor}
	function downcastWidgetElement(editor) {
		var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

		// @param {CKEDITOR.htmlParser.element} el
		return function (el) {
			// In case of <a><img/></a>, <img/> is the element to hold
			// inline styles or classes (ae_dragresize_ie11_alignClasses).
			var attrsHolder = el.name == 'a' ? el.getFirst() : el;

			var attrs = attrsHolder.attributes;

			var align = this.data.align;

			// De-wrap the image from resize handle wrapper.
			// Only block widgets have one.
			if (!this.inline) {
				var resizeWrapper = el.getFirst('span');

				if (resizeWrapper) resizeWrapper.replaceWith(resizeWrapper.getFirst({ img: 1, a: 1 }));
			}

			if (align && align != 'none') {
				var styles = CKEDITOR.tools.parseCssText(attrs.style || '');

				// When the widget is captioned (<figure>) and internally centering is done
				// with widget's wrapper style/class, in the external data representation,
				// <figure> must be wrapped with an element holding an style/class:
				//
				// 	<div style="text-align:center">
				// 		<figure class="image" style="display:inline-block">...</figure>
				// 	</div>
				// or
				// 	<div class="some-center-class">
				// 		<figure class="image">...</figure>
				// 	</div>
				//
				if (align == 'center' && el.name == 'figure') {
					el = el.wrapWith(new CKEDITOR.htmlParser.element('div', alignClasses ? { class: alignClasses[1] } : { style: 'text-align:center' }));
				}

				// If left/right, add float style to the downcasted element.
				else if (align in { left: 1, right: 1 }) {
						if (alignClasses) attrsHolder.addClass(alignClasses[alignmentsObj[align]]);else styles['float'] = align;
					}

				// Update element styles.
				if (!alignClasses && !CKEDITOR.tools.isEmpty(styles)) attrs.style = CKEDITOR.tools.writeCssText(styles) + ';';
			}

			return el;
		};
	}

	// Returns a function that checks if an element is a centering wrapper.
	//
	// @param {CKEDITOR.editor} editor
	// @returns {Function}
	function centerWrapperChecker(editor) {
		var captionedClass = editor.config.ae_dragresize_ie11_captionedClass;

		var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

		var validChildren = { figure: 1, a: 1, img: 1 };

		return function (el) {
			// Wrapper must be either <div> or <p>.
			if (!(el.name in { div: 1, p: 1 })) return false;

			var children = el.children;

			// Centering wrapper can have only one child.
			if (children.length !== 1) return false;

			var child = children[0];

			// Only <figure> or <img /> can be first (only) child of centering wrapper,
			// regardless of its type.
			if (!(child.name in validChildren)) return false;

			// If centering wrapper is <p>, only <img /> can be the child.
			//   <p style="text-align:center"><img /></p>
			if (el.name == 'p') {
				if (!isLinkedOrStandaloneImage(child)) return false;
			}
			// Centering <div> can hold <img/> or <figure>, depending on enterMode.
			else {
					// If a <figure> is the first (only) child, it must have a class.
					//   <div style="text-align:center"><figure>...</figure><div>
					if (child.name == 'figure') {
						if (!child.hasClass(captionedClass)) return false;
					} else {
						// Centering <div> can hold <img/> or <a><img/></a> only when enterMode
						// is ENTER_(BR|DIV).
						//   <div style="text-align:center"><img /></div>
						//   <div style="text-align:center"><a><img /></a></div>
						if (editor.enterMode == CKEDITOR.ENTER_P) return false;

						// Regardless of enterMode, a child which is not <figure> must be
						// either <img/> or <a><img/></a>.
						if (!isLinkedOrStandaloneImage(child)) return false;
					}
				}

			// Centering wrapper got to be... centering. If ae_dragresize_ie11_alignClasses are defined,
			// check for centering class. Otherwise, check the style.
			if (alignClasses ? el.hasClass(alignClasses[1]) : CKEDITOR.tools.parseCssText(el.attributes.style || '', true)['text-align'] == 'center') return true;

			return false;
		};
	}

	// Checks whether element is <img/> or <a><img/></a>.
	//
	// @param {CKEDITOR.htmlParser.element}
	function isLinkedOrStandaloneImage(el) {
		if (el.name == 'img') return true;else if (el.name == 'a') return el.children.length == 1 && el.getFirst('img');

		return false;
	}

	// Sets width and height of the widget image according to current widget data.
	//
	// @param {CKEDITOR.plugins.widget} widget
	function setDimensions(widget) {
		var data = widget.data;

		var dimensions = { width: data.width, height: data.height };

		var image = widget.parts.image;

		for (var d in dimensions) {
			if (dimensions[d]) image.setAttribute(d, dimensions[d]);else image.removeAttribute(d);
		}
	}

	// Defines all features related to drag-driven image resizing.
	//
	// @param {CKEDITOR.plugins.widget} widget
	function setupResizer(widget) {
		var editor = widget.editor;

		var editable = editor.editable();

		var doc = editor.document;

		// Store the resizer in a widget for testing (#11004).

		var resizer = widget.resizer = doc.createElement('span');

		// Create resizer for each corner (NE, NW, SE, SW)

		var resizerNE = doc.createElement('span');

		var resizerNW = doc.createElement('span');

		var resizerSE = doc.createElement('span');

		var resizerSW = doc.createElement('span');

		resizerNE.addClass('cke_image_resizer');
		resizerNE.addClass('cke_image_resizer_ne');

		resizerNW.addClass('cke_image_resizer');
		resizerNW.addClass('cke_image_resizer_nw');

		resizerSE.addClass('cke_image_resizer');
		resizerSE.addClass('cke_image_resizer_se');

		resizerSW.addClass('cke_image_resizer');
		resizerSW.addClass('cke_image_resizer_sw');

		// Add each directional resizer as a child of resizer
		resizer.append(resizerNE);
		resizer.append(resizerNW);
		resizer.append(resizerSE);
		resizer.append(resizerSW);

		// resizer.setAttribute( 'title', editor.lang.ae_dragresize_ie11.resizer );
		resizer.append(new CKEDITOR.dom.text('\u200B', doc));

		// Inline widgets don't need a resizer wrapper as an image spans the entire widget.
		if (!widget.inline) {
			var imageOrLink = widget.parts.link || widget.parts.image;

			var oldResizeWrapper = imageOrLink.getParent();

			var resizeWrapper = doc.createElement('span');

			resizeWrapper.addClass('cke_image_resizer_wrapper');
			resizeWrapper.append(imageOrLink);
			resizeWrapper.append(resizer);
			widget.element.append(resizeWrapper, true);

			// Remove the old wrapper which could came from e.g. pasted HTML
			// and which could be corrupted (e.g. resizer span has been lost).
			if (oldResizeWrapper.is('span')) oldResizeWrapper.remove();
		} else {
			widget.wrapper.append(resizer);
		}

		// Calculate values of size variables and mouse offsets.
		resizer.on('mousedown', function (evt) {
			var image = widget.parts.image;

			// The x-coordinate of the mouse relative to the screen
			// when button gets pressed.

			var startX = evt.data.$.screenX;

			var startY = evt.data.$.screenY;

			// The initial dimensions and aspect ratio of the image.

			var startWidth = image.$.clientWidth;

			var startHeight = image.$.clientHeight;

			var ratio = startWidth / startHeight;

			var listeners = [];

			var target = evt.data.getTarget();

			var factorX = void 0;

			var factorY = void 0;

			var moveDiffX = void 0;

			var moveDiffY = void 0;

			var nativeEvt = void 0;

			var newHeight = void 0;

			var newWidth = void 0;

			var updateData = void 0;

			// "factorX" and "factorY" can be either 1 or -1. I.e.: We need to
			// add/subtract the difference to get proper width, etc. Without "factorX"
			// and "factorY", resizer starts working the opposite way.
			if (target.hasClass('cke_image_resizer_ne')) {
				factorX = 1;
				factorY = 1;
			} else if (target.hasClass('cke_image_resizer_nw')) {
				factorX = -1;
				factorY = 1;
			} else if (target.hasClass('cke_image_resizer_se')) {
				factorX = 1;
				factorY = -1;
			} else if (target.hasClass('cke_image_resizer_sw')) {
				factorX = -1;
				factorY = -1;
			}

			// A class applied to editable during resizing.
			var cursorClass = 'cke_image_' + (!~factorY ? 's' : 'n') + (!~factorX ? 'w' : 'e');

			// Save the undo snapshot first: before resizing.
			editor.fire('saveSnapshot');

			// Mousemove listeners are removed on mouseup.
			attachToDocuments('mousemove', onMouseMove, listeners);

			// Clean up the mousemove listener. Update widget data if valid.
			attachToDocuments('mouseup', onMouseUp, listeners);

			// The entire editable will have the special cursor while resizing goes on.
			editable.addClass(cursorClass);

			// This is to always keep the resizer element visible while resizing.
			resizer.addClass('cke_image_resizing');

			// Attaches an event to a global document if inline editor.
			// Additionally, if classic (`iframe`-based) editor, also attaches the same event to `iframe`'s document.
			function attachToDocuments(name, callback, collection) {
				var globalDoc = CKEDITOR.document;

				var listeners = [];

				if (!doc.equals(globalDoc)) listeners.push(globalDoc.on(name, callback));

				listeners.push(doc.on(name, callback));

				if (collection) {
					for (var i = listeners.length; i--;) {
						collection.push(listeners.pop());
					}
				}
			}

			// Calculate width first, and then adjust height, preserving ratio.
			function adjustToX() {
				newWidth = startWidth + factorX * moveDiffX;
				newHeight = Math.round(newWidth / ratio);
			}

			// Calculate height first, and then adjust width, preserving ratio.
			function adjustToY() {
				newHeight = startHeight + factorY * moveDiffY;
				newWidth = Math.round(newHeight * ratio);
			}

			// This is how variables refer to the geometry.
			// Note: x corresponds to moveOffset, this is the position of mouse
			// Note: o corresponds to [startX, startY].
			//
			// 	+--------------+--------------+
			// 	|              |              |
			// 	|      I       |      II      |
			// 	|              |              |
			// 	+------------- o -------------+ _ _ _
			// 	|              |              |      ^
			// 	|      VI      |     III      |      | moveDiffY
			// 	|              |         x _ _ _ _ _ v
			// 	+--------------+---------|----+
			// 	               |         |
			// 	                <------->
			// 	                moveDiffX
			function onMouseMove(evt) {
				nativeEvt = evt.data.$;

				// This is how far the mouse is from the point the button was pressed.
				moveDiffX = nativeEvt.screenX - startX;
				moveDiffY = startY - nativeEvt.screenY;

				// Resize with NE, SE drag handles
				if (factorX == 1) {
					if (moveDiffX <= 0) {
						adjustToY();
					} else {
						adjustToX();
					}
				}
				// Resize with NW, SW drag handles
				else {
						if (moveDiffX <= 0) {
							adjustToX();
						} else {
							adjustToY();
						}
					}

				// Don't update attributes if less than 10.
				// This is to prevent images to visually disappear.
				if (newWidth >= 15 && newHeight >= 15) {
					image.$.style.width = newWidth + 'px';
					image.$.style.height = newHeight + 'px';

					updateData = true;
				} else {
					updateData = false;
				}
			}

			function onMouseUp() {
				var l = void 0;

				while (l = listeners.pop()) {
					l.removeListener();
				} // Restore default cursor by removing special class.
				editable.removeClass(cursorClass);

				// This is to bring back the regular behaviour of the resizer.
				resizer.removeClass('cke_image_resizing');

				if (updateData) {
					widget.setData({
						height: newHeight,
						width: newWidth
					});

					// Save another undo snapshot: after resizing.
					editor.fire('saveSnapshot');
				}

				// Don't update data twice or more.
				updateData = false;
			}
		});
	}

	/**
  * Removes the alignment value of an image
  *
  * @param {CKEDITOR.dom.element} image The image element
  * @param {String} imageAlignment The image alignment value to be removed
  */
	var removeWidgetAlignment = function removeWidgetAlignment(widget, imageAlignment) {
		if (imageAlignment === 'left' || imageAlignment === 'right') {
			widget.wrapper.removeStyle('float');
		} else if (imageAlignment === 'center') {
			widget.editor.execCommand('justifyleft');
			widget.editor.execCommand('justifyleft');
		}
	};

	// Integrates widget alignment setting with justify
	// plugin's commands (execution and refreshment).
	// @param {CKEDITOR.editor} editor
	// @param {String} value 'left', 'right', 'center' or 'block'
	function alignCommandIntegrator(editor) {
		var execCallbacks = [];

		var enabled = void 0;

		return function (value) {
			var command = editor.getCommand('justify' + value);

			// Most likely, the justify plugin isn't loaded.
			if (!command) return;

			// This command will be manually refreshed along with
			// other commands after exec.
			execCallbacks.push(function () {
				command.refresh(editor, editor.elementPath());
			});

			if (value in { right: 1, left: 1, center: 1 }) {
				command.on('exec', function (evt) {
					var widget = getFocusedWidget(editor);

					if (widget) {
						if (widget.data.align === value) {
							removeWidgetAlignment(widget, value);

							delete widget.data.align;
						} else {
							widget.setData('align', value);
						}

						// Once the widget changed its align, all the align commands
						// must be refreshed: the event is to be cancelled.
						for (var i = execCallbacks.length; i--;) {
							execCallbacks[i]();
						}evt.cancel();
					}
				});
			}

			command.on('refresh', function (evt) {
				var widget = getFocusedWidget(editor);

				var allowed = { right: 1, left: 1, center: 1 };

				if (!widget) return;

				// Cache "enabled" on first use. This is because filter#checkFeature may
				// not be available during plugin's afterInit in the future â a moment when
				// alignCommandIntegrator is called.
				if (enabled === undefined) enabled = editor.filter.checkFeature(editor.widgets.registered.image.features.align);

				// Don't allow justify commands when widget alignment is disabled (#11004).
				if (!enabled) this.setState(CKEDITOR.TRISTATE_DISABLED);else {
					this.setState(widget.data.align == value ? CKEDITOR.TRISTATE_ON : value in allowed ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED);
				}

				evt.cancel();
			});
		};
	}

	// Returns the focused widget, if of the type specific for this plugin.
	// If no widget is focused, `null` is returned.
	//
	// @param {CKEDITOR.editor}
	// @returns {CKEDITOR.plugins.widget}
	function getFocusedWidget(editor) {
		var widget = editor.widgets.focused;

		if (widget && widget.name == 'image') return widget;

		return null;
	}

	// Returns a set of widget allowedContent rules, depending
	// on configurations like config#ae_dragresize_ie11_alignClasses or
	// config#ae_dragresize_ie11_captionedClass.
	//
	// @param {CKEDITOR.editor}
	// @returns {Object}
	function getWidgetAllowedContent(editor) {
		var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

		var rules = {
			// Widget may need <div> or <p> centering wrapper.
			div: {
				match: centerWrapperChecker(editor)
			},
			p: {
				match: centerWrapperChecker(editor)
			},
			img: {
				attributes: '!src,alt,width,height'
			},
			figure: {
				classes: '!' + editor.config.ae_dragresize_ie11_captionedClass
			},
			figcaption: true
		};

		if (alignClasses) {
			// Centering class from the config.
			rules.div.classes = alignClasses[1];
			rules.p.classes = rules.div.classes;

			// Left/right classes from the config.
			rules.img.classes = alignClasses[0] + ',' + alignClasses[2];
			rules.figure.classes += ',' + rules.img.classes;
		} else {
			// Centering with text-align.
			rules.div.styles = 'text-align';
			rules.p.styles = 'text-align';

			rules.img.styles = 'float';
			rules.figure.styles = 'float,display';
		}

		return rules;
	}

	// Returns a set of widget feature rules, depending
	// on editor configuration. Note that the following may not cover
	// all the possible cases since requiredContent supports a single
	// tag only.
	//
	// @param {CKEDITOR.editor}
	// @returns {Object}
	function getWidgetFeatures(editor) {
		var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

		var features = {
			dimension: {
				requiredContent: 'img[width,height]'
			},
			align: {
				requiredContent: 'img' + (alignClasses ? '(' + alignClasses[0] + ')' : '{float}')
			},
			caption: {
				requiredContent: 'figcaption'
			}
		};

		return features;
	}

	// Returns element which is styled, considering current
	// state of the widget.
	//
	// @see CKEDITOR.plugins.widget#applyStyle
	// @param {CKEDITOR.plugins.widget} widget
	// @returns {CKEDITOR.dom.element}
	function getStyleableElement(widget) {
		return widget.data.hasCaption ? widget.element : widget.parts.image;
	}
})();

/**
 * A CSS class applied to the `<figure>` element of a captioned image.
 *
 * Read more in the [documentation](#!/guide/dev_captionedimage) and see the
 * [SDK sample](http://sdk.ckeditor.com/samples/captionedimage.html).
 *
 *		// Changes the class to "captionedImage".
 *		config.ae_dragresize_ie11_captionedClass = 'captionedImage';
 *
 * @cfg {String} [ae_dragresize_ie11_captionedClass='image']
 * @member CKEDITOR.config
 */
CKEDITOR.config.ae_dragresize_ie11_captionedClass = 'image';

/***/ }),

/***/ "./src/plugins/embed.js":
/*!******************************!*\
  !*** ./src/plugins/embed.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _priorities = __webpack_require__(/*! ./priorities */ "./src/plugins/priorities.js");

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_embed')) {
	var REGEX_HTTP = /^https?/;

	var REGEX_DEFAULT_LINK = /<a href=/;

	CKEDITOR.DEFAULT_AE_EMBED_URL_TPL = 'http://alloy.iframe.ly/api/oembed?url={url}&callback={callback}';
	CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL = '<div data-ae-embed-url="{url}"></div>';
	CKEDITOR.DEFAULT_AE_EMBED_DEFAULT_LINK_TPL = '<a href="{url}">{url}</a>';
	/**
  * CKEditor plugin which adds the infrastructure to embed urls as media objects using an oembed
  * service. By default, and for demoing purposes only, the oembed service is hosted in iframe.ly
  * at //alloy.iframe.ly/api/oembed?url={url}&callback={callback}. Note this should be changed to
  * a self-hosted or paid service in production environments. Access to the alloy.iframe.ly endpoint
  * may be restricted per domain due to significant traffic.
  *
  * This plugin adds an `embedUrl` command that can be used to easily embed a URL and transform it
  * to an embedded content.
  *
  * @class CKEDITOR.plugins.ae_embed
  */
	CKEDITOR.plugins.add('ae_embed', {
		requires: 'widget',
		init: function init(editor) {
			var AE_EMBED_URL_TPL = new CKEDITOR.template(editor.config.embedUrlTemplate || CKEDITOR.DEFAULT_AE_EMBED_URL_TPL);
			var AE_EMBED_WIDGET_TPL = new CKEDITOR.template(editor.config.embedWidgetTpl || CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL);
			var AE_EMBED_DEFAULT_LINK_TPL = new CKEDITOR.template(editor.config.embedLinkDefaultTpl || CKEDITOR.DEFAULT_AE_EMBED_DEFAULT_LINK_TPL);

			// Default function to upcast DOM elements to embed widgets.
			// It matches CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL
			var defaultEmbedWidgetUpcastFn = function defaultEmbedWidgetUpcastFn(element, data) {
				if (element.name === 'div' && element.attributes['data-ae-embed-url']) {
					data.url = element.attributes['data-ae-embed-url'];

					return true;
				}
			};

			// Create a embedUrl command that can be invoked to easily embed media URLs
			editor.addCommand('embedUrl', {
				exec: function exec(editor, data) {
					editor.insertHtml(AE_EMBED_WIDGET_TPL.output({
						url: data.url
					}));
				}
			});

			// Create a widget to properly handle embed operations
			editor.widgets.add('ae_embed', {
				mask: true,
				requiredContent: 'div[data-ae-embed-url]',

				/**
     * Listener to be executed every time the widget's data changes. It takes care of
     * requesting the embed object to the configured oembed service and render it in
     * the editor
     *
     * @method data
     * @param {event} event Data change event
     */
				data: function data(event) {
					var widget = this;

					var url = event.data.url;

					if (url) {
						CKEDITOR.tools.jsonp(AE_EMBED_URL_TPL, {
							url: encodeURIComponent(url)
						}, function (response) {
							if (response.html) {
								if (REGEX_DEFAULT_LINK.test(response.html)) {
									widget.createATag(url);
								} else {
									widget.element.setHtml(response.html);
								}
							} else {
								widget.createATag(url);
							}
						}, function (_msg) {
							widget.createATag(url);
						});
					}
				},
				createATag: function createATag(url) {
					this.editor.execCommand('undo');

					var aTagHtml = AE_EMBED_DEFAULT_LINK_TPL.output({
						url: url
					});

					this.editor.insertHtml(aTagHtml);
					this.editor.fire('actionPerformed', this);
				},


				/**
     * Function used to upcast an element to ae_embed widgets.
     *
     * @method upcast
     * @param {CKEDITOR.htmlParser.element} element The element to be checked
     * @param {Object} data The object that will be passed to the widget
     */
				upcast: function upcast(element, data) {
					var embedWidgetUpcastFn = editor.config.embedWidgetUpcastFn || defaultEmbedWidgetUpcastFn;

					return embedWidgetUpcastFn(element, data);
				}
			});

			// Add a listener to handle paste events and turn links into embed objects
			editor.once('contentDom', function () {
				editor.on('paste', function (event) {
					var link = event.data.dataValue;

					if (REGEX_HTTP.test(link)) {
						event.stop();

						editor.execCommand('embedUrl', {
							url: event.data.dataValue
						});
					}
				}, null, null,
				// Make sure we run before autolink's paste handler,
				// otherwise the link will be turned into an anchor and our
				// REGEX_HTTP test will fail.
				_priorities.HIGH_PRIORITY);
			});

			// Add a listener to handle selection change events and properly detect editor
			// interactions on the widgets without messing with widget native selection
			editor.on('selectionChange', function (_event) {
				var selection = editor.getSelection();

				if (selection) {
					var element = selection.getSelectedElement();

					if (element) {
						var widgetElement = element.findOne('[data-widget="ae_embed"]');

						if (widgetElement) {
							var region = element.getClientRect();

							var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();
							region.left -= scrollPosition.x;
							region.top += scrollPosition.y;

							region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;

							editor.fire('editorInteraction', {
								nativeEvent: {},
								selectionData: {
									element: widgetElement,
									region: region
								}
							});
						}
					}
				}
			});

			// Add a filter to skip filtering widget elements
			editor.filter.addElementCallback(function (element) {
				if ('data-ae-embed-url' in element.attributes) {
					return CKEDITOR.FILTER_SKIP_TREE;
				}
			});
		}
	});
} /**
   * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
   * SPDX-License-Identifier: LGPL-3.0-or-later
   */

/***/ }),

/***/ "./src/plugins/embedurl.js":
/*!*********************************!*\
  !*** ./src/plugins/embedurl.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Resizer = __webpack_require__(/*! ./Resizer.es */ "./src/plugins/Resizer.es.js");

var _Resizer2 = _interopRequireDefault(_Resizer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (!CKEDITOR.plugins.get('embedurl')) {
	var REGEX_HTTP = /^https?/;

	CKEDITOR.DEFAULT_LFR_EMBED_WIDGET_TPL = '<div data-embed-url="{url}" class="embed-responsive embed-responsive-16by9">{content}<div class="embed-help-message">{helpMessageIcon}<span> {helpMessage}</span></div></div><br>';

	/**
  * Enum for supported embed alignments
  * @type {Object}
  */

	var EMBED_ALIGNMENT = {
		CENTER: 'center',
		LEFT: 'left',
		RIGHT: 'right'
	};

	/**
  * Enum values for supported embed alignments
  * @type {Array}
  */

	var ALIGN_VALUES = [EMBED_ALIGNMENT.CENTER, EMBED_ALIGNMENT.LEFT, EMBED_ALIGNMENT.RIGHT];

	/**
  * Necessary styles for the center alignment
  * @type {Array.<Object>}
  */

	var CENTERED_EMBED_STYLE = [{
		name: 'display',
		value: 'block'
	}, {
		name: 'margin-left',
		value: 'auto'
	}, {
		name: 'margin-right',
		value: 'auto'
	}];

	/**
  * Retrieves the alignment value of an embed element.
  *
  * @param {CKEDITOR.dom.element} embed The embed element
  * @return {String} The alignment value
  */

	var getEmbedAlignment = function getEmbedAlignment(embed) {
		var embedAlignment = embed.getStyle('float');

		if (!embedAlignment || embedAlignment === 'inherit' || embedAlignment === 'none') {
			embedAlignment = embed.getAttribute('align');
		}

		if (!embedAlignment) {
			var centeredEmbed = CENTERED_EMBED_STYLE.every(function (style) {
				var styleCheck = embed.getStyle(style.name) === style.value;

				if (!styleCheck && style.vendorPrefixes) {
					styleCheck = style.vendorPrefixes.some(function (vendorPrefix) {
						return embed.getStyle(vendorPrefix + style.name) === style.value;
					});
				}

				return styleCheck;
			});

			embedAlignment = centeredEmbed ? EMBED_ALIGNMENT.CENTER : null;
		}

		return embedAlignment;
	};

	/**
  * Removes the alignment value of an embed
  *
  * @param {CKEDITOR.dom.element} embed The embed element
  * @param {String} embedAlignment The embed alignment value to be removed
  */

	var removeEmbedAlignment = function removeEmbedAlignment(embed, embedAlignment) {
		if (embedAlignment === EMBED_ALIGNMENT.LEFT || embedAlignment === EMBED_ALIGNMENT.RIGHT) {
			embed.removeStyle('float');

			if (embedAlignment === getEmbedAlignment(embed)) {
				embed.removeAttribute('align');
			}
		} else if (embedAlignment === EMBED_ALIGNMENT.CENTER) {
			CENTERED_EMBED_STYLE.forEach(function (style) {
				embed.removeStyle(style.name);

				if (style.vendorPrefixes) {
					style.vendorPrefixes.forEach(function (vendorPrefix) {
						return embed.removeStyle(vendorPrefix + style.name);
					});
				}
			});
		}
	};

	/**
  * Sets the alignment value of an embed
  *
  * @param {CKEDITOR.dom.element} embed The embed element
  * @param {String} embedAlignment The embed alignment value to be set
  */

	var setEmbedAlignment = function setEmbedAlignment(embed, embedAlignment) {
		removeEmbedAlignment(embed, getEmbedAlignment(embed));

		if (embedAlignment === EMBED_ALIGNMENT.LEFT || embedAlignment === EMBED_ALIGNMENT.RIGHT) {
			embed.setStyle('float', embedAlignment);
		} else if (embedAlignment === EMBED_ALIGNMENT.CENTER) {
			CENTERED_EMBED_STYLE.forEach(function (style) {
				embed.setStyle(style.name, style.value);

				if (style.vendorPrefixes) {
					style.vendorPrefixes.forEach(function (vendorPrefix) {
						return embed.setStyle(vendorPrefix + style.name, style.value);
					});
				}
			});
		}
	};

	var getSelectedElement = function getSelectedElement(editor) {
		var result = {
			alignment: null,
			element: null
		};

		var selection = editor.getSelection();

		if (selection) {
			var selectedElement = selection.getSelectedElement();

			if (selectedElement && selectedElement.getAttribute('data-cke-widget-wrapper')) {
				result.alignment = getEmbedAlignment(selectedElement);
				result.element = selectedElement;
			}
		}

		return result;
	};

	var resizeElement = function resizeElement(el, width, height) {
		var wrapperElement = el.parentElement;

		if (wrapperElement && width > 0 && height > 0) {
			var rect = wrapperElement.getBoundingClientRect();

			var pwidth = width >= rect.width ? 100 : Math.floor(width / rect.width * 100);
			var style = 'width:' + pwidth + '%;';

			wrapperElement.setAttribute('style', style);

			var widgetElement = wrapperElement.querySelector('[data-widget="embedurl"]');

			if (widgetElement) {
				var styles = JSON.parse(widgetElement.getAttribute('data-styles')) || {};

				styles.width = width + 'px';
				styles.height = height + 'px';

				widgetElement.setAttribute('data-styles', JSON.stringify(styles));

				var iframeElement = widgetElement.querySelector('iframe');

				if (iframeElement) {
					iframeElement.setAttribute('width', width);
					iframeElement.setAttribute('height', height);
				}
			}
		}
	};

	var selectWidget = function selectWidget(editor) {
		setTimeout(function () {
			var selection = editor.getSelection();

			if (selection) {
				var wrapperElement = selection.root.find('[data-cke-widget-wrapper]');

				if (wrapperElement) {
					var elementList = wrapperElement.$;
					if (elementList.length > 0) {
						var lastElement = new CKEDITOR.dom.element(elementList[elementList.length - 1]);

						var imageElement = lastElement.findOne('img');
						var widgetElement = lastElement.findOne('[data-widget="embedurl"]');

						if (imageElement && widgetElement) {
							var range = editor.createRange();

							range.setStart(widgetElement, 0);
							range.setEnd(imageElement, 1);

							selection.selectRanges([range]);
							selection.selectElement(lastElement);
						}
					}
				}
			}
		}, 0);
	};

	var currentAlignment = null;
	var currentElement = null;
	var resizer = null;

	/**
  * CKEditor plugin which adds the infrastructure to embed urls as media objects
  *
  * This plugin adds an `embedUrl` command that can be used to easily embed a URL and transform it
  * to an embedded content.
  *
  * @class CKEDITOR.plugins.embedurl
  */

	CKEDITOR.plugins.add('embedurl', {
		requires: 'widget',

		init: function init(editor) {
			var LFR_EMBED_WIDGET_TPL = new CKEDITOR.template(editor.config.embedWidgetTpl || CKEDITOR.DEFAULT_LFR_EMBED_WIDGET_TPL);

			var providers = editor.config.embedProviders || [];

			providers = providers.map(function (provider) {
				return {
					id: provider.id,
					tpl: new CKEDITOR.template('<div data-embed-id="{embedId}">' + provider.tpl + '</div>'),
					type: provider.type,
					urlSchemes: provider.urlSchemes.map(function (scheme) {
						return new RegExp(scheme);
					})
				};
			});

			var generateEmbedContent = function generateEmbedContent(url, content) {
				return LFR_EMBED_WIDGET_TPL.output({
					content: content,
					helpMessage: AlloyEditor.Strings.videoPlaybackDisabled,
					helpMessageIcon: Liferay.Util.getLexiconIconTpl('info-circle'),
					url: url
				});
			};

			var defaultEmbedWidgetUpcastFn = function defaultEmbedWidgetUpcastFn(element, data) {
				var upcastWidget = false;

				if (element.name === 'div' && element.attributes['data-embed-url']) {
					data.url = element.attributes['data-embed-url'];

					upcastWidget = true;
				} else if (element.name === 'div' && element.attributes['data-embed-id']) {
					var iframe = element.children[0];

					data.url = iframe.attributes.src;

					delete element.attributes.style;

					var embedContent = generateEmbedContent(data.url, element.getOuterHtml());

					var widgetFragment = new CKEDITOR.htmlParser.fragment.fromHtml(embedContent);

					upcastWidget = widgetFragment.children[0];

					upcastWidget.attributes['data-styles'] = element.attributes['data-styles'];
					upcastWidget.removeClass('embed-responsive');
					upcastWidget.removeClass('embed-responsive-16by9');

					element.replaceWith(upcastWidget);
				}

				return upcastWidget;
			};

			var showError = function showError(errorMsg) {
				editor.fire('error', errorMsg);

				setTimeout(function () {
					editor.getSelection().removeAllRanges();

					editor.focus();

					resizer.hide();
				}, 0);
			};

			editor.addCommand('embedUrl', {
				exec: function exec(editor, data) {
					var type = data.type;
					var url = data.url;
					var content = void 0;

					if (REGEX_HTTP.test(url)) {
						var validProvider = providers.filter(function (provider) {
							return type ? provider.type === type : true;
						}).some(function (provider) {
							var scheme = provider.urlSchemes.find(function (scheme) {
								return scheme.test(url);
							});

							if (scheme) {
								var embedId = scheme.exec(url)[1];

								content = provider.tpl.output({
									embedId: embedId
								});
							}

							return scheme;
						});

						if (validProvider) {
							editor._selectEmbedWidget = url;

							var embedContent = generateEmbedContent(url, content);

							editor.insertHtml(embedContent);
						} else {
							showError(AlloyEditor.Strings.platformNotSupported);
						}
					} else {
						showError(AlloyEditor.Strings.enterValidUrl);
					}
				}
			});

			editor.widgets.add('embedurl', {
				draggable: false,
				mask: true,
				requiredContent: 'div[data-embed-url]',

				data: function data(event) {
					var instance = this;

					// Sync dimensions and alignment with editor wrapper

					var styles = null;

					var stylesJSON = instance.element.getAttribute('data-styles');

					if (stylesJSON) {
						try {
							styles = JSON.parse(stylesJSON);
						} catch (_error) {
							styles = null;
						}
					}

					if (!styles) {
						var iframe = instance.wrapper.findOne('iframe');

						var bounds = instance.wrapper.$.getBoundingClientRect();
						var width = iframe.getAttribute('width');

						var pwidth = width >= bounds.width ? 100 : Math.round(width / bounds.width * 100);

						styles = {
							width: pwidth + '%'
						};
					}

					instance.wrapper.setAttribute('style', CKEDITOR.tools.writeCssText(styles));

					if (editor._selectEmbedWidget === event.data.url) {
						selectWidget(editor);
					}
				},
				downcast: function downcast(widget) {
					var embedContent = widget.children[0];

					embedContent.attributes.class = 'embed-responsive embed-responsive-16by9';

					embedContent.attributes['data-styles'] = JSON.stringify(CKEDITOR.tools.parseCssText(widget.parent.attributes.style));

					embedContent.attributes.style = widget.parent.attributes.style;

					return embedContent;
				},
				upcast: function upcast(element, data) {
					var embedWidgetUpcastFn = editor.config.embedWidgetUpcastFn || defaultEmbedWidgetUpcastFn;

					return embedWidgetUpcastFn(element, data);
				}
			});

			window.addEventListener('resize', function () {
				resizer.hide();
				selectWidget(editor);
			}, false);

			editor.on('selectionChange', function (_event) {
				var selection = editor.getSelection();

				if (selection) {
					var element = selection.getSelectedElement();

					if (element) {
						var widgetElement = element.findOne('[data-widget="embedurl"]');

						if (widgetElement) {
							var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();

							var region = element.getClientRect();

							region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
							region.left -= scrollPosition.x;
							region.top += scrollPosition.y;

							editor.fire('editorInteraction', {
								nativeEvent: {},
								selectionData: {
									element: widgetElement,
									region: region
								}
							});
						}

						var imageElement = element.findOne('img.cke_widget_mask');

						if (imageElement) {
							resizer.show(imageElement.$);
						}
					} else {
						resizer.hide();
					}
				}
			});

			editor.on('destroy', function () {
				var resizeElement = document.getElementById('ckimgrsz');

				if (resizeElement) {
					resizeElement.remove();
				}

				document.removeEventListener('mousedown', mouseDownListener);
			});

			editor.on('blur', function () {
				resizer.hide();
			});

			editor.filter.addElementCallback(function (element) {
				if ('data-embed-url' in element.attributes) {
					return CKEDITOR.FILTER_SKIP_TREE;
				}
			});

			var mouseDownListener = function mouseDownListener(event) {
				var result = getSelectedElement(editor);

				currentAlignment = result.alignment;
				currentElement = result.element;

				if (resizer.isHandle(event.target)) {
					resizer.initDrag(event);
				}
			};

			resizer = new _Resizer2.default(editor, {
				onComplete: function onComplete(element, width, height) {
					resizeElement(element, width, height);

					if (currentAlignment && currentElement) {
						setEmbedAlignment(currentElement, currentAlignment);
					}
					selectWidget(editor);
				}
			});

			document.addEventListener('mousedown', mouseDownListener, false);
		},

		afterInit: function afterInit(editor) {
			ALIGN_VALUES.forEach(function (alignValue) {
				var command = editor.getCommand('justify' + alignValue);

				if (command) {
					command.on('exec', function (event) {
						var selectedElement = editor.getSelection().getSelectedElement();

						if (selectedElement && selectedElement.getAttribute('data-cke-widget-wrapper')) {
							var selectedEmbed = selectedElement.findOne('[data-widget="embedurl"] [data-embed-id]');

							if (selectedEmbed) {
								var embedAlignment = getEmbedAlignment(selectedElement);

								if (embedAlignment === alignValue) {
									removeEmbedAlignment(selectedElement, alignValue);
								} else {
									setEmbedAlignment(selectedElement, alignValue);
								}

								currentElement = selectedElement;
								currentAlignment = getEmbedAlignment(selectedElement);

								var imageElement = selectedElement.findOne('img');

								if (imageElement) {
									resizer.show(imageElement.$);
								}

								event.cancel();

								var elementPath = new CKEDITOR.dom.elementPath(selectedElement);

								ALIGN_VALUES.forEach(function (alignValue) {
									var command = editor.getCommand('justify' + alignValue);

									if (command) {
										command.refresh(editor, elementPath);
									}
								});
							}
						}
					});

					command.on('refresh', function (event) {
						var lastElement = event.data.path.lastElement;

						if (lastElement && lastElement.getAttribute('data-cke-widget-wrapper') && lastElement.findOne('[data-widget] [data-embed-id]')) {
							var embedAlignment = getEmbedAlignment(lastElement);

							event.sender.setState(embedAlignment === alignValue ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF);

							event.cancel();
						}
					});
				}
			});
		}
	});
} /**
   * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
   * SPDX-License-Identifier: LGPL-3.0-or-later
   */

exports.default = CKEDITOR.plugins.get('embedurl');

/***/ }),

/***/ "./src/plugins/imagealignment.js":
/*!***************************************!*\
  !*** ./src/plugins/imagealignment.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _selectionTest = __webpack_require__(/*! ../selections/selection-test */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /**
                                                                                                                                                                                                                   * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                   * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                   */

if (!CKEDITOR.plugins.get('ae_imagealignment')) {
	var _IMAGE_STYLE_ALIGNMEN;

	/**
  * Enum for supported image alignments
  * @type {Object}
  */
	var IMAGE_ALIGNMENT = {
		CENTER: 'center',
		LEFT: 'left',
		RIGHT: 'right'
	};

	/**
  * Enum values for supported image alignments
  * @type {Array}
  */
	var ALIGN_VALUES = [IMAGE_ALIGNMENT.LEFT, IMAGE_ALIGNMENT.RIGHT, IMAGE_ALIGNMENT.CENTER];

	/**
  * Necessary styles for the left|center|right alignment
  * @type {Array.<Object>}
  */
	var IMAGE_STYLE_ALIGNMENT = (_IMAGE_STYLE_ALIGNMEN = {}, _defineProperty(_IMAGE_STYLE_ALIGNMEN, IMAGE_ALIGNMENT.LEFT, [{
		name: 'display',
		value: 'inline-block'
	}, {
		name: 'float',
		value: 'left'
	}, {
		name: 'margin-right',
		value: '1.2rem'
	}]), _defineProperty(_IMAGE_STYLE_ALIGNMEN, IMAGE_ALIGNMENT.CENTER, [{
		name: 'display',
		value: 'block'
	}, {
		name: 'margin-left',
		value: 'auto'
	}, {
		name: 'margin-right',
		value: 'auto'
	}]), _defineProperty(_IMAGE_STYLE_ALIGNMEN, IMAGE_ALIGNMENT.RIGHT, [{
		name: 'display',
		value: 'inline-block'
	}, {
		name: 'float',
		value: 'right'
	}, {
		name: 'margin-left',
		value: '1.2rem'
	}]), _IMAGE_STYLE_ALIGNMEN);

	/**
  * Retrieves the alignment value of an image.
  *
  * @param {CKEDITOR.dom.element} image The image element
  * @return {String} The alignment value
  */
	var getImageAlignment = function getImageAlignment(image) {
		var imageAlignment = image.getStyle('float');

		if (!imageAlignment || imageAlignment === 'inherit' || imageAlignment === 'none') {
			imageAlignment = image.getAttribute('align');
		}

		if (!imageAlignment) {
			var centeredImage = IMAGE_STYLE_ALIGNMENT[IMAGE_ALIGNMENT.CENTER].every(function (style) {
				var styleCheck = image.getStyle(style.name) === style.value;

				if (!styleCheck && style.vendorPrefixes) {
					styleCheck = style.vendorPrefixes.some(function (vendorPrefix) {
						return image.getStyle(vendorPrefix + style.name) === style.value;
					});
				}

				return styleCheck;
			});

			if (!imageAlignment) {
				var imageContainer = image.$.parentNode;

				if (imageContainer.style.textAlign == IMAGE_ALIGNMENT.CENTER) {
					IMAGE_STYLE_ALIGNMENT[IMAGE_ALIGNMENT.CENTER].forEach(function (style) {
						image.setStyle(style.name, style.value);

						if (style.vendorPrefixes) {
							style.vendorPrefixes.forEach(function (vendorPrefix) {
								image.setStyle(vendorPrefix + style.name, style.value);
							});
						}
					});
					centeredImage = true;
					imageContainer.style.textAlign = '';
				}
			}

			imageAlignment = centeredImage ? IMAGE_ALIGNMENT.CENTER : null;
		}

		if (!CKEDITOR.env.edge && CKEDITOR.env.ie) {
			var p = image.findOne('p');
			if (p) {
				imageAlignment = p.getStyle('text-align');
			}
		}

		return imageAlignment;
	};

	/**
  * Removes the alignment value of an image
  *
  * @param {CKEDITOR.dom.element} image The image element
  * @param {String} imageAlignment The image alignment value to be removed
  */
	var removeImageAlignment = function removeImageAlignment(image, imageAlignment) {
		if (imageAlignment === IMAGE_ALIGNMENT.LEFT || imageAlignment === IMAGE_ALIGNMENT.RIGHT) {
			if (imageAlignment === getImageAlignment(image)) {
				image.removeAttribute('align');
			}
		} else if (imageAlignment === IMAGE_ALIGNMENT.CENTER) {
			var imageContainer = image.$.parentNode;

			if (imageContainer.style.textAlign == IMAGE_ALIGNMENT.CENTER) {
				imageContainer.style.textAlign = '';
			}
		}

		var styles = IMAGE_STYLE_ALIGNMENT[imageAlignment];

		if (styles) {
			styles.forEach(function (style) {
				image.removeStyle(style.name);

				if (style.vendorPrefixes) {
					style.vendorPrefixes.forEach(function (vendorPrefix) {
						image.removeStyle(vendorPrefix + style.name);
					});
				}
			});
		}
	};

	/**
  * Sets the alignment value of an image
  *
  * @param {CKEDITOR.dom.element} image The image element
  * @param {String} imageAlignment The image alignment value to be set
  */
	var setImageAlignment = function setImageAlignment(image, imageAlignment) {
		removeImageAlignment(image, getImageAlignment(image));

		var styles = IMAGE_STYLE_ALIGNMENT[imageAlignment];

		if (styles) {
			styles.forEach(function (style) {
				image.setStyle(style.name, style.value);

				if (style.vendorPrefixes) {
					style.vendorPrefixes.forEach(function (vendorPrefix) {
						image.setStyle(vendorPrefix + style.name, style.value);
					});
				}
			});
		}
	};

	/**
  * CKEditor plugin which modifies the justify commands to properly align images. This
  * plugin is an excerpt of CKEditor's original image one that can be found at
  * https://github.com/ckeditor/ckeditor-dev/blob/master/plugins/image/plugin.js
  *
  * @class CKEDITOR.plugins.ae_imagealignment
  */
	CKEDITOR.plugins.add('ae_imagealignment', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function registers a 'paste' event on the editing area.
   *
   * @method afterInit
   * @param {Object} editor The current editor instance
   */
		afterInit: function afterInit(editor) {
			var self = this;

			ALIGN_VALUES.forEach(function (value) {
				var command = editor.getCommand('justify' + value);

				if (command) {
					command.on('exec', function (event) {
						var selectionData = editor.getSelectionData();

						if (selectionData && _selectionTest2.default.image({
							data: { selectionData: selectionData }
						})) {
							var image = selectionData.element;

							var imageAlignment = getImageAlignment(image);

							if (imageAlignment === value) {
								removeImageAlignment(image, value);
							} else {
								setImageAlignment(image, value);
							}

							event.cancel();

							self.refreshCommands(editor, new CKEDITOR.dom.elementPath(image));
						}
					});

					command.on('refresh', function (event) {
						var selectionData = {
							element: event.data.path.lastElement
						};

						if (_selectionTest2.default.image({
							data: { selectionData: selectionData }
						})) {
							var imageAlignment = getImageAlignment(selectionData.element);

							this.setState(imageAlignment === value ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF);

							event.cancel();
						}
					});
				}
			});
		},


		/**
   * Forces a refresh of the modified justify commands. This is needed because the applied changes
   * do not modify the selection, so the refresh is never triggered and the UI does not update
   * properly until the next selectionChange event.
   *
   * @param {CKEDITOR.editor} editor The editor instance
   * @param {CKEDITOR.dom.elementPath} elementPath The path of the selected image
   */
		refreshCommands: function refreshCommands(editor, elementPath) {
			ALIGN_VALUES.forEach(function (value) {
				var command = editor.getCommand('justify' + value);

				if (command) {
					command.refresh(editor, elementPath);
				}
			});
		}
	});
}

/***/ }),

/***/ "./src/plugins/index.js":
/*!******************************!*\
  !*** ./src/plugins/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.embedurl = undefined;

__webpack_require__(/*! ./addimages */ "./src/plugins/addimages.js");

__webpack_require__(/*! ./autolink */ "./src/plugins/autolink.js");

__webpack_require__(/*! ./autolist */ "./src/plugins/autolist.js");

__webpack_require__(/*! ./dragresize */ "./src/plugins/dragresize.js");

__webpack_require__(/*! ./dragresize_ie */ "./src/plugins/dragresize_ie.js");

__webpack_require__(/*! ./dragresize_ie11 */ "./src/plugins/dragresize_ie11.js");

__webpack_require__(/*! ./embed */ "./src/plugins/embed.js");

var _embedurl = __webpack_require__(/*! ./embedurl */ "./src/plugins/embedurl.js");

var _embedurl2 = _interopRequireDefault(_embedurl);

__webpack_require__(/*! ./imagealignment */ "./src/plugins/imagealignment.js");

__webpack_require__(/*! ./pasteimages */ "./src/plugins/pasteimages.js");

__webpack_require__(/*! ./placeholder */ "./src/plugins/placeholder.js");

__webpack_require__(/*! ./selectionkeystrokes */ "./src/plugins/selectionkeystrokes.js");

__webpack_require__(/*! ./tableresize */ "./src/plugins/tableresize.js");

__webpack_require__(/*! ./tabletools */ "./src/plugins/tabletools.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

exports.embedurl = _embedurl2.default;

/***/ }),

/***/ "./src/plugins/pasteimages.js":
/*!************************************!*\
  !*** ./src/plugins/pasteimages.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

if (!CKEDITOR.plugins.get('ae_pasteimages')) {
	/**
  * CKEditor plugin which allows pasting images directly into the editable area. The image will be encoded
  * as Data URI. An event `beforeImageAdd` will be fired with the list of pasted images. If any of the listeners
  * returns `false` or cancels the event, the images won't be added to the content. Otherwise,
  * an event `imageAdd` will be fired with the inserted element into the editable area.
  *
  * @class CKEDITOR.plugins.ae_pasteimages
  */

	/**
  * Fired before adding images to the editor.
  * @event beforeImageAdd
  * @param {Array} imageFiles Array of image files
  */

	/**
  * Fired when an image is being added to the editor successfully.
  *
  * @event imageAdd
  * @param {CKEDITOR.dom.element} el The created image with src as Data URI
  * @param {File} file The image file
  */

	CKEDITOR.plugins.add('ae_pasteimages', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function registers a 'paste' event on the editing area.
   *
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			var _this = this;

			editor.once('contentDom', function () {
				var editable = editor.editable();

				editable.attachListener(editable, 'paste', _this._onPaste, _this, {
					editor: editor
				});
			});
		},


		/**
   * The function creates an img element with src the image data as Data URI.
   * Then, it fires an 'imageAdd' event via CKEditor's event system. The passed
   * params will be:
   * - `el` - the created img element
   * - `file` - the original pasted data
   *
   * @method _onPaste
   * @protected
   * @param {CKEDITOR.dom.event} event A `paste` event, as received natively from CKEditor
   */
		_onPaste: function _onPaste(event) {
			if (event.data.$.clipboardData) {
				var pastedData = event.data.$.clipboardData.items[0];
				var editor = event.listenerData.editor;

				if (pastedData.type.indexOf('image') === 0) {
					var reader = new FileReader();
					var imageFile = pastedData.getAsFile();

					reader.onload = function (event) {
						var result = editor.fire('beforeImageAdd', {
							imageFiles: imageFile
						});

						if (result) {
							var el = CKEDITOR.dom.element.createFromHtml('<img src="' + event.target.result + '">');

							editor.insertElement(el);

							var imageData = {
								el: el,
								file: imageFile
							};

							editor.fire('imageAdd', imageData);
						}
					};

					reader.readAsDataURL(imageFile);
				}
			}
		}
	});
}

/***/ }),

/***/ "./src/plugins/placeholder.js":
/*!************************************!*\
  !*** ./src/plugins/placeholder.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

if (!CKEDITOR.plugins.get('ae_placeholder')) {
	/**
  * CKEDITOR enterMode config set the behavior of paragraphs
  * When the content is empty CKEDITOR keeps the enterMode string
  * into the content
  * @property
  * @type {string}
  */
	var brFiller = CKEDITOR.env.needsBrFiller ? '<br>' : '';

	var enterModeEmptyValue = {
		1: ['<p>' + brFiller + '</p>'],
		2: ['', ' ', brFiller],
		3: ['<div>' + brFiller + '</div>']
	};

	/**
  * CKEditor plugin which allows adding a placeholder to the editor. In this case, if there
  * is no content to the editor, there will be hint to the user.
  *
  * @class CKEDITOR.plugins.ae_placeholder
  */

	/**
  * Specifies the placeholder class which have to be aded to editor when editor is not focused.
  *
  * @attribute placeholderClass
  * @default ae_placeholder
  * @type String
  */

	CKEDITOR.plugins.add('ae_placeholder', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function registers a 'blur' and 'contentDom' event listeners.
   *
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			editor.on('blur', this._checkEmptyData, this);
			editor.on('change', this._checkEmptyData, this);
			editor.on('focus', this._removePlaceholderClass, this);
			editor.once('contentDom', this._checkEmptyData, this);
		},


		/**
   * Removes any data from the content and adds a class,
   * specified by the "placeholderClass" config attribute.
   *
   * @protected
   * @method _checkEmptyData
   * @param {CKEDITOR.dom.event} editor event, fired from CKEditor
   */
		_checkEmptyData: function _checkEmptyData(event) {
			var editor = event.editor;

			var editableNode = editor.editable();

			var innerHtml = editableNode.$.innerHTML.trim();

			var isEmpty = enterModeEmptyValue[editor.config.enterMode].some(function (element) {
				return innerHtml === element;
			});

			if (isEmpty) {
				editableNode.addClass(editor.config.placeholderClass);
			} else {
				editableNode.removeClass(editor.config.placeholderClass);
			}
		},


		/**
             * Remove placeholder class when input is focused
             *
             * @protected
             * @method _removePlaceholderClass
             + @param {CKEDITOR.dom.event} editor event, fired from CKEditor
             */
		_removePlaceholderClass: function _removePlaceholderClass(event) {
			var editor = event.editor;

			var editorNode = new CKEDITOR.dom.element(editor.element.$);

			editorNode.removeClass(editor.config.placeholderClass);
		}
	});
}

/***/ }),

/***/ "./src/plugins/priorities.js":
/*!***********************************!*\
  !*** ./src/plugins/priorities.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * Priorities that can be used to control the order in which event handlers run.
 *
 * @see https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_event.html#method-on
 */
var DEFAULT_PRIORITY = exports.DEFAULT_PRIORITY = 10;
var HIGH_PRIORITY = exports.HIGH_PRIORITY = 5;

/***/ }),

/***/ "./src/plugins/selectionkeystrokes.js":
/*!********************************************!*\
  !*** ./src/plugins/selectionkeystrokes.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

if (!CKEDITOR.plugins.get('ae_selectionkeystrokes')) {
	/**
  * CKEditor plugin that simulates editor interaction events based on manual keystrokes. This
  * can be used to trigger different reactions in the editor.
  *
  * @class CKEDITOR.plugins.ae_selectionkeystrokes
  */
	CKEDITOR.plugins.add('ae_selectionkeystrokes', {
		requires: 'ae_selectionregion',

		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function adds a command to the editor for every defined selectionKeystroke
   * in the configuration and maps it to the specified keystroke.
   *
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			if (editor.config.selectionKeystrokes) {
				editor.config.selectionKeystrokes.forEach(function (selectionKeystroke) {
					var command = new CKEDITOR.command(editor, {
						exec: function exec(editor) {
							editor.fire('editorInteraction', {
								manualSelection: selectionKeystroke.selection,
								nativeEvent: {},
								selectionData: editor.getSelectionData()
							});
						}
					});

					var commandName = 'selectionKeystroke' + selectionKeystroke.selection;

					editor.addCommand(commandName, command);
					editor.setKeystroke(selectionKeystroke.keys, commandName);
				});
			}
		}
	});
}

/***/ }),

/***/ "./src/plugins/tableresize.js":
/*!************************************!*\
  !*** ./src/plugins/tableresize.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

if (!CKEDITOR.plugins.get('ae_tableresize')) {
	var pxUnit = CKEDITOR.tools.cssLength;

	function getWidth(el) {
		return CKEDITOR.env.ie ? el.$.clientWidth : parseInt(el.getComputedStyle('width'), 10);
	}

	function getBorderWidth(element, side) {
		var computed = element.getComputedStyle('border-' + side + '-width');

		var borderMap = {
			thin: '0px',
			medium: '1px',
			thick: '2px'
		};

		if (computed.indexOf('px') < 0) {
			// look up keywords
			if (computed in borderMap && element.getComputedStyle('border-style') != 'none') {
				computed = borderMap[computed];
			} else {
				computed = 0;
			}
		}

		return parseInt(computed, 10);
	}

	// Gets the table row that contains the most columns.
	function getMasterPillarRow(table) {
		var $rows = table.$.rows;

		var maxCells = 0;

		var cellsCount = void 0;

		var $elected = void 0;

		var $tr = void 0;

		for (var i = 0, len = $rows.length; i < len; i++) {
			$tr = $rows[i];
			cellsCount = $tr.cells.length;

			if (cellsCount > maxCells) {
				maxCells = cellsCount;
				$elected = $tr;
			}
		}

		return $elected;
	}

	function buildTableColumnPillars(table) {
		var pillars = [];

		var pillarIndex = -1;

		var rtl = table.getComputedStyle('direction') === 'rtl';

		// Get the raw row element that cointains the most columns.
		var $tr = getMasterPillarRow(table);

		// Get the tbody element and position, which will be used to set the
		// top and bottom boundaries.
		var tbody = new CKEDITOR.dom.element(table.$.tBodies[0]);

		var tbodyPosition = tbody.getDocumentPosition();

		// Loop thorugh all cells, building pillars after each one of them.
		for (var i = 0, len = $tr.cells.length; i < len; i++) {
			// Both the current cell and the successive one will be used in the
			// pillar size calculation.
			var td = new CKEDITOR.dom.element($tr.cells[i]);

			var nextTd = $tr.cells[i + 1] && new CKEDITOR.dom.element($tr.cells[i + 1]);

			pillarIndex += td.$.colSpan || 1;

			// Calculate the pillar boundary positions.
			var pillarLeft = void 0;
			var pillarRight = void 0;

			var x = td.getDocumentPosition().x;

			// Calculate positions based on the current cell.
			if (rtl) {
				pillarRight = x + getBorderWidth(td, 'left');
			} else {
				pillarLeft = x + td.$.offsetWidth - getBorderWidth(td, 'right');
			}

			// Calculate positions based on the next cell, if available.
			if (nextTd) {
				x = nextTd.getDocumentPosition().x;

				if (rtl) {
					pillarLeft = x + nextTd.$.offsetWidth - getBorderWidth(nextTd, 'right');
				} else {
					pillarRight = x + getBorderWidth(nextTd, 'left');
				}
			}
			// Otherwise calculate positions based on the table (for last cell).
			else {
					x = table.getDocumentPosition().x;

					if (rtl) {
						pillarLeft = x;
					} else {
						pillarRight = x + table.$.offsetWidth;
					}
				}

			var pillarWidth = Math.max(pillarRight - pillarLeft, 4);

			// The pillar should reflects exactly the shape of the hovered
			// column border line.
			pillars.push({
				table: table,
				index: pillarIndex,
				x: pillarLeft,
				y: tbodyPosition.y,
				width: pillarWidth,
				height: tbody.$.offsetHeight,
				rtl: rtl
			});
		}

		return pillars;
	}

	function getPillarAtPosition(pillars, positionX) {
		for (var i = 0, len = pillars.length; i < len; i++) {
			var pillar = pillars[i];

			if (positionX >= pillar.x && positionX <= pillar.x + pillar.width) {
				return pillar;
			}
		}

		return null;
	}

	function cancel(evt) {
		(evt.data || evt).preventDefault();
	}

	function ColumnResizer(editor, pillar) {
		var currentShift = void 0;
		var leftShiftBoundary = void 0;
		var leftSideCells = void 0;
		var resizing = void 0;
		var rightShiftBoundary = void 0;
		var rightSideCells = void 0;
		var startOffset = void 0;

		var document = editor.document;

		var resizer = CKEDITOR.dom.element.createFromHtml('<div data-cke-temp=1 contenteditable=false unselectable=on ' + 'style="position:absolute;cursor:col-resize;filter:alpha(opacity=0);opacity:0;' + 'padding:0;background-color:#004;background-image:none;border:0px none;z-index:10"></div>', document);

		var isResizing = this.isResizing = function () {
			return resizing;
		};

		var move = this.move = function (posX) {
			var resizerNewPosition = posX - Math.round(resizer.$.offsetWidth / 2);

			if (isResizing) {
				if (resizerNewPosition === leftShiftBoundary || resizerNewPosition === rightShiftBoundary) {
					return;
				}

				resizerNewPosition = Math.max(resizerNewPosition, leftShiftBoundary);
				resizerNewPosition = Math.min(resizerNewPosition, rightShiftBoundary);

				currentShift = resizerNewPosition - startOffset;
			}

			resizer.setStyle('left', pxUnit(resizerNewPosition));
		};

		function detach() {
			resizer.removeListener('mouseup', onMouseUp);
			resizer.removeListener('mousedown', onMouseDown);
			resizer.removeListener('mousemove', onMouseMove);
		}

		function resizeStart() {
			// Before starting to resize, figure out which cells to change
			// and the boundaries of this resizing shift.

			var columnIndex = pillar.index;

			var map = CKEDITOR.tools.buildTableMap(pillar.table);

			var leftColumnCells = [];

			var rightColumnCells = [];

			var leftMinSize = Number.MAX_VALUE;

			var rightMinSize = leftMinSize;

			var rtl = pillar.rtl;

			for (var i = 0, len = map.length; i < len; i++) {
				var row = map[i];

				var leftCell = row[columnIndex + (rtl ? 1 : 0)];

				var rightCell = row[columnIndex + (rtl ? 0 : 1)];

				leftCell = leftCell && new CKEDITOR.dom.element(leftCell);
				rightCell = rightCell && new CKEDITOR.dom.element(rightCell);

				if (!leftCell || !rightCell || !leftCell.equals(rightCell)) {
					if (leftCell) {
						leftMinSize = Math.min(leftMinSize, getWidth(leftCell));
					}
					if (rightCell) {
						rightMinSize = Math.min(rightMinSize, getWidth(rightCell));
					}

					leftColumnCells.push(leftCell);
					rightColumnCells.push(rightCell);
				}
			}

			// Cache the list of cells to be resized.
			leftSideCells = leftColumnCells;
			rightSideCells = rightColumnCells;

			// Cache the resize limit boundaries.
			leftShiftBoundary = pillar.x - leftMinSize;
			rightShiftBoundary = pillar.x + rightMinSize;

			resizer.setOpacity(0.5);
			startOffset = parseInt(resizer.getStyle('left'), 10);
			currentShift = 0;
			resizing = 1;

			resizer.on('mousemove', onMouseMove);

			// Prevent the native drag behavior otherwise 'mousemove' won't fire.
			document.on('dragstart', cancel);
		}

		function resizeEnd() {
			resizing = 0;

			resizer.setOpacity(0);

			if (currentShift) {
				resizeColumn();
			}

			var table = pillar.table;
			setTimeout(function () {
				table.removeCustomData('_cke_table_pillars');
			}, 0);

			document.removeListener('dragstart', cancel);
		}

		function resizeColumn() {
			var _this = this;

			var rtl = pillar.rtl;

			var cellsCount = rtl ? rightSideCells.length : leftSideCells.length;

			// Perform the actual resize to table cells, only for those by side of the pillar.

			var _loop = function _loop(i) {
				var leftCell = leftSideCells[i];

				var rightCell = rightSideCells[i];

				var table = pillar.table;

				// Defer the resizing to avoid any interference among cells.
				CKEDITOR.tools.setTimeout(function (leftCell, leftOldWidth, rightCell, rightOldWidth, tableWidth, sizeShift) {
					// 1px is the minimum valid width (#11626).
					if (leftCell) {
						leftCell.setStyle('width', pxUnit(Math.max(leftOldWidth + sizeShift, 1)));
					}
					if (rightCell) {
						rightCell.setStyle('width', pxUnit(Math.max(rightOldWidth - sizeShift, 1)));
					}

					// If we're in the last cell, we need to resize the table as well
					if (tableWidth) {
						table.setStyle('width', pxUnit(tableWidth + sizeShift * (rtl ? -1 : 1)));
					}
				}, 0, _this, [leftCell, leftCell && getWidth(leftCell), rightCell, rightCell && getWidth(rightCell), (!leftCell || !rightCell) && getWidth(table) + getBorderWidth(table, 'left') + getBorderWidth(table, 'right'), currentShift]);
			};

			for (var i = 0; i < cellsCount; i++) {
				_loop(i);
			}
		}

		function onMouseDown(evt) {
			cancel(evt);

			resizeStart();

			document.on('mouseup', onMouseUp, this);
		}

		function onMouseUp(evt) {
			evt.removeListener();

			resizeEnd();
		}

		function onMouseMove(evt) {
			move(evt.data.getPageOffset().x);
		}

		// Clean DOM when editor is destroyed.
		editor.on('destroy', function () {
			detach();

			resizer.remove();
		});

		// Place the resizer after body to prevent it
		// from being editable.
		document.getDocumentElement().append(resizer);

		resizer.setStyles({
			width: pxUnit(pillar.width),
			height: pxUnit(pillar.height),
			left: pxUnit(pillar.x),
			top: pxUnit(pillar.y)
		});

		resizer.on('mousedown', onMouseDown, this);

		document.getBody().setStyle('cursor', 'col-resize');

		// Display the resizer to receive events but don't show it,
		// only change the cursor to resizable shape.
		resizer.show();

		this.destroy = function () {
			detach();

			document.getBody().setStyle('cursor', 'auto');

			resizer.remove();
		};
	}

	function clearPillarsCache(evt) {
		var target = evt.data.getTarget();

		if (evt.name === 'mouseout') {
			// Bypass interal mouse move.
			if (!target.is('table')) {
				return;
			}

			var dest = new CKEDITOR.dom.element(evt.data.$.relatedTarget || evt.data.$.toElement);
			while (dest && dest.$ && !dest.equals(target) && !dest.is('body')) {
				dest = dest.getParent();
			}
			if (!dest || dest.equals(target)) {
				return;
			}
		}

		target.getAscendant('table', 1).removeCustomData('_cke_table_pillars');
		evt.removeListener();
	}

	CKEDITOR.plugins.add('ae_tableresize', {
		requires: 'ae_tabletools',

		init: function init(editor) {
			editor.on('contentDom', function () {
				var resizer = void 0;

				var editable = editor.editable();

				// In Classic editor it is better to use document
				// instead of editable so event will work below body.
				editable.attachListener(editable.isInline() ? editable : editor.document, 'mousemove', function (evt) {
					evt = evt.data;

					var target = evt.getTarget();

					// FF may return document and IE8 some UFO (object with no nodeType property...)
					// instead of an element (#11823).
					if (target.type !== CKEDITOR.NODE_ELEMENT) {
						return;
					}

					var pageX = evt.getPageOffset().x;

					// If we're already attached to a pillar, simply move the
					// resizer.
					if (resizer) {
						if (resizer.isResizing()) {
							resizer.move(pageX);

							cancel(evt);

							return;
						} else {
							resizer.destroy();

							resizer = null;
						}
					}

					// Considering table, tr, td, tbody but nothing else.
					var pillars = void 0;

					if (!target.is('table') && !target.getAscendant('tbody', 1)) {
						return;
					}

					var table = target.getAscendant('table', 1);

					// Make sure the table we found is inside the container
					// (eg. we should not use tables the editor is embedded within)
					if (!editor.editable().contains(table)) {
						return;
					}

					if (!(pillars = table.getCustomData('_cke_table_pillars'))) {
						// Cache table pillars calculation result.
						table.setCustomData('_cke_table_pillars', pillars = buildTableColumnPillars(table));
						table.on('mouseout', clearPillarsCache);
						table.on('mousedown', clearPillarsCache);
					}

					var pillar = getPillarAtPosition(pillars, pageX);

					if (pillar) {
						resizer = new ColumnResizer(editor, pillar);
					}
				});
			});
		}
	});
}

/***/ }),

/***/ "./src/plugins/tabletools.js":
/*!***********************************!*\
  !*** ./src/plugins/tabletools.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

if (!CKEDITOR.plugins.get('ae_tabletools')) {
	var cellNodeRegex = /^(?:td|th)$/;

	function getSelectedCells(selection) {
		var ranges = selection.getRanges();
		var retval = [];
		var database = {};

		function moveOutOfCellGuard(node) {
			// Apply to the first cell only.
			if (retval.length > 0) return;

			// If we are exiting from the first </td>, then the td should definitely be
			// included.
			if (node.type == CKEDITOR.NODE_ELEMENT && cellNodeRegex.test(node.getName()) && !node.getCustomData('selected_cell')) {
				CKEDITOR.dom.element.setMarker(database, node, 'selected_cell', true);
				retval.push(node);
			}
		}

		for (var i = 0; i < ranges.length; i++) {
			var range = ranges[i];

			if (range.collapsed) {
				// Walker does not handle collapsed ranges yet - fall back to old API.
				var startNode = range.getCommonAncestor();
				var nearestCell = startNode.getAscendant('td', true) || startNode.getAscendant('th', true);
				if (nearestCell) retval.push(nearestCell);
			} else {
				var walker = new CKEDITOR.dom.walker(range);
				var node = void 0;
				walker.guard = moveOutOfCellGuard;

				while (node = walker.next()) {
					// If may be possible for us to have a range like this:
					// <td>^1</td><td>^2</td>
					// The 2nd td shouldn't be included.
					//
					// So we have to take care to include a td we've entered only when we've
					// walked into its children.

					if (node.type != CKEDITOR.NODE_ELEMENT || !node.is(CKEDITOR.dtd.table)) {
						var parent = node.getAscendant('td', true) || node.getAscendant('th', true);
						if (parent && !parent.getCustomData('selected_cell')) {
							CKEDITOR.dom.element.setMarker(database, parent, 'selected_cell', true);
							retval.push(parent);
						}
					}
				}
			}
		}

		CKEDITOR.dom.element.clearAllMarkers(database);

		return retval;
	}

	function getFocusElementAfterDelCells(cellsToDelete) {
		var i = 0;

		var last = cellsToDelete.length - 1;

		var database = {};

		var cell = void 0;

		var focusedCell = void 0;

		var tr = void 0;

		while (cell = cellsToDelete[i++]) {
			CKEDITOR.dom.element.setMarker(database, cell, 'delete_cell', true);
		} // 1.first we check left or right side focusable cell row by row;
		i = 0;
		while (cell = cellsToDelete[i++]) {
			if ((focusedCell = cell.getPrevious()) && !focusedCell.getCustomData('delete_cell') || (focusedCell = cell.getNext()) && !focusedCell.getCustomData('delete_cell')) {
				CKEDITOR.dom.element.clearAllMarkers(database);
				return focusedCell;
			}
		}

		CKEDITOR.dom.element.clearAllMarkers(database);

		// 2. then we check the toppest row (outside the selection area square) focusable cell
		tr = cellsToDelete[0].getParent();
		if (tr = tr.getPrevious()) return tr.getLast();

		// 3. last we check the lowerest  row focusable cell
		tr = cellsToDelete[last].getParent();
		if (tr = tr.getNext()) return tr.getChild(0);

		return null;
	}

	function insertRow(editor, insertBefore) {
		var selection = editor.getSelection();

		var cells = getSelectedCells(selection);

		var firstCell = cells[0];

		var table = firstCell.getAscendant('table');

		var doc = firstCell.getDocument();

		var startRow = cells[0].getParent();

		var startRowIndex = startRow.$.rowIndex;

		var lastCell = cells[cells.length - 1];

		var endRowIndex = lastCell.getParent().$.rowIndex + lastCell.$.rowSpan - 1;

		var endRow = new CKEDITOR.dom.element(table.$.rows[endRowIndex]);

		var rowIndex = insertBefore ? startRowIndex : endRowIndex;

		var row = insertBefore ? startRow : endRow;

		var map = CKEDITOR.tools.buildTableMap(table);

		var cloneRow = map[rowIndex];

		var nextRow = insertBefore ? map[rowIndex - 1] : map[rowIndex + 1];

		var width = map[0].length;

		var newRow = doc.createElement('tr');
		for (var i = 0; cloneRow[i] && i < width; i++) {
			var _cell = void 0;
			// Check whether there's a spanning row here, do not break it.
			if (cloneRow[i].rowSpan > 1 && nextRow && cloneRow[i] == nextRow[i]) {
				_cell = cloneRow[i];
				_cell.rowSpan += 1;
			} else {
				_cell = new CKEDITOR.dom.element(cloneRow[i]).clone();
				_cell.removeAttribute('rowSpan');
				_cell.appendBogus();
				newRow.append(_cell);
				_cell = _cell.$;
			}

			i += _cell.colSpan - 1;
		}

		if (insertBefore) {
			newRow.insertBefore(row);
		} else {
			newRow.insertAfter(row);
		}

		var cell = new CKEDITOR.dom.element(newRow.$).getChild(cells[0] ? cells[0].$.cellIndex : 0);
		selectElement(editor, cell);
	}

	function deleteRows(selectionOrRow) {
		if (selectionOrRow instanceof CKEDITOR.dom.selection) {
			var cells = getSelectedCells(selectionOrRow);

			var firstCell = cells[0];

			var table = firstCell.getAscendant('table');

			var map = CKEDITOR.tools.buildTableMap(table);

			var startRow = cells[0].getParent();

			var startRowIndex = startRow.$.rowIndex;

			var lastCell = cells[cells.length - 1];

			var endRowIndex = lastCell.getParent().$.rowIndex + lastCell.$.rowSpan - 1;

			var rowsToDelete = [];

			// Delete cell or reduce cell spans by checking through the table map.
			for (var i = startRowIndex; i <= endRowIndex; i++) {
				var mapRow = map[i];

				var row = new CKEDITOR.dom.element(table.$.rows[i]);

				for (var j = 0; j < mapRow.length; j++) {
					var cell = new CKEDITOR.dom.element(mapRow[j]);

					var cellRowIndex = cell.getParent().$.rowIndex;

					if (cell.$.rowSpan == 1) cell.remove();
					// Row spanned cell.
					else {
							// Span row of the cell, reduce spanning.
							cell.$.rowSpan -= 1;
							// Root row of the cell, root cell to next row.
							if (cellRowIndex == i) {
								var nextMapRow = map[i + 1];
								if (nextMapRow[j - 1]) {
									cell.insertAfter(new CKEDITOR.dom.element(nextMapRow[j - 1]));
								} else {
									new CKEDITOR.dom.element(table.$.rows[i + 1]).append(cell, 1);
								}
							}
						}

					j += cell.$.colSpan - 1;
				}

				rowsToDelete.push(row);
			}

			var rows = table.$.rows;

			// Where to put the cursor after rows been deleted?
			// 1. Into next sibling row if any;
			// 2. Into previous sibling row if any;
			// 3. Into table's parent element if it's the very last row.
			var cursorPosition = new CKEDITOR.dom.element(rows[endRowIndex + 1] || (startRowIndex > 0 ? rows[startRowIndex - 1] : null) || table.$.parentNode);

			for (var _i = rowsToDelete.length; _i >= 0; _i--) {
				deleteRows(rowsToDelete[_i]);
			}return cursorPosition;
		} else if (selectionOrRow instanceof CKEDITOR.dom.element) {
			var _table = selectionOrRow.getAscendant('table');

			if (_table.$.rows.length == 1) _table.remove();else selectionOrRow.remove();
		}

		return null;
	}

	function getCellColIndex(cell, isStart) {
		var row = cell.getParent();

		var rowCells = row.$.cells;

		var colIndex = 0;
		for (var i = 0; i < rowCells.length; i++) {
			var mapCell = rowCells[i];
			colIndex += isStart ? 1 : mapCell.colSpan;
			if (mapCell == cell.$) break;
		}

		return colIndex - 1;
	}

	function getColumnsIndices(cells, isStart) {
		var retval = isStart ? Infinity : 0;
		for (var i = 0; i < cells.length; i++) {
			var colIndex = getCellColIndex(cells[i], isStart);
			if (isStart ? colIndex < retval : colIndex > retval) retval = colIndex;
		}
		return retval;
	}

	function insertColumn(editor, insertBefore) {
		var selection = editor.getSelection();

		var cells = getSelectedCells(selection);

		var firstCell = cells[0];

		var table = firstCell.getAscendant('table');

		var startCol = getColumnsIndices(cells, 1);

		var lastCol = getColumnsIndices(cells);

		var colIndex = insertBefore ? startCol : lastCol;

		var map = CKEDITOR.tools.buildTableMap(table);

		var cloneCol = [];

		var nextCol = [];

		var height = map.length;

		for (var i = 0; i < height; i++) {
			cloneCol.push(map[i][colIndex]);
			var nextCell = insertBefore ? map[i][colIndex - 1] : map[i][colIndex + 1];
			nextCol.push(nextCell);
		}

		var insertedCells = [];
		for (var _i2 = 0; _i2 < height; _i2++) {
			var _cell2 = void 0;

			if (!cloneCol[_i2]) continue;

			// Check whether there's a spanning column here, do not break it.
			if (cloneCol[_i2].colSpan > 1 && nextCol[_i2] == cloneCol[_i2]) {
				_cell2 = cloneCol[_i2];
				_cell2.colSpan += 1;
			} else {
				_cell2 = new CKEDITOR.dom.element(cloneCol[_i2]).clone();
				_cell2.removeAttribute('colSpan');
				_cell2.appendBogus();
				_cell2[insertBefore ? 'insertBefore' : 'insertAfter'].call(_cell2, new CKEDITOR.dom.element(cloneCol[_i2]));
				_cell2 = _cell2.$;
			}

			insertedCells[_i2] = _cell2;

			_i2 += _cell2.rowSpan - 1;
		}

		var cell = new CKEDITOR.dom.element(insertedCells[firstCell.getParent().$.rowIndex]);
		selectElement(editor, cell);
	}

	function selectElement(editor, element) {
		var range = editor.createRange();

		range.moveToPosition(element, CKEDITOR.POSITION_AFTER_START);
		editor.getSelection().selectRanges([range]);
	}

	function deleteColumns(selectionOrCell) {
		var cells = getSelectedCells(selectionOrCell);

		var firstCell = cells[0];

		var lastCell = cells[cells.length - 1];

		var table = firstCell.getAscendant('table');

		var map = CKEDITOR.tools.buildTableMap(table);

		var startColIndex = void 0;

		var endColIndex = void 0;

		var rowsToDelete = [];

		var rows = void 0;

		// Figure out selected cells' column indices.
		for (var i = 0, _rows = map.length; i < _rows; i++) {
			// eslint-disable-next-line sort-vars
			for (var j = 0, cols = map[i].length; j < cols; j++) {
				if (map[i][j] == firstCell.$) startColIndex = j;
				if (map[i][j] == lastCell.$) endColIndex = j;
			}
		}

		// Delete cell or reduce cell spans by checking through the table map.
		for (var _i3 = startColIndex; _i3 <= endColIndex; _i3++) {
			for (var _j = 0; _j < map.length; _j++) {
				var mapRow = map[_j];

				var row = new CKEDITOR.dom.element(table.$.rows[_j]);

				var cell = new CKEDITOR.dom.element(mapRow[_i3]);

				if (cell.$) {
					if (cell.$.colSpan == 1) cell.remove();
					// Reduce the col spans.
					else cell.$.colSpan -= 1;

					_j += cell.$.rowSpan - 1;

					if (!row.$.cells.length) rowsToDelete.push(row);
				}
			}
		}

		var firstRowCells = table.$.rows[0] && table.$.rows[0].cells;

		// Where to put the cursor after columns been deleted?
		// 1. Into next cell of the first row if any;
		// 2. Into previous cell of the first row if any;
		// 3. Into table's parent element;
		var cursorPosition = new CKEDITOR.dom.element(firstRowCells[startColIndex] || (startColIndex ? firstRowCells[startColIndex - 1] : table.$.parentNode));

		// Delete table rows only if all columns are gone (do not remove empty row).
		if (rowsToDelete.length == rows) table.remove();

		return cursorPosition;
	}

	function insertCell(selection, insertBefore) {
		var startElement = selection.getStartElement();
		var cell = startElement.getAscendant('td', 1) || startElement.getAscendant('th', 1);

		if (!cell) return;

		// Create the new cell element to be added.
		var newCell = cell.clone();
		newCell.appendBogus();

		if (insertBefore) newCell.insertBefore(cell);else newCell.insertAfter(cell);
	}

	function deleteCells(selectionOrCell) {
		if (selectionOrCell instanceof CKEDITOR.dom.selection) {
			var cellsToDelete = getSelectedCells(selectionOrCell);
			var table = cellsToDelete[0] && cellsToDelete[0].getAscendant('table');
			var cellToFocus = getFocusElementAfterDelCells(cellsToDelete);

			for (var i = cellsToDelete.length - 1; i >= 0; i--) {
				deleteCells(cellsToDelete[i]);
			}if (cellToFocus) placeCursorInCell(cellToFocus, true);else if (table) table.remove();
		} else if (selectionOrCell instanceof CKEDITOR.dom.element) {
			var tr = selectionOrCell.getParent();
			if (tr.getChildCount() == 1) tr.remove();else selectionOrCell.remove();
		}
	}

	// Remove filler at end and empty spaces around the cell content.
	function trimCell(cell) {
		var bogus = cell.getBogus();
		if (bogus) {
			bogus.remove();
		}
		cell.trim();
	}

	function placeCursorInCell(cell, placeAtEnd) {
		var docInner = cell.getDocument();

		var docOuter = CKEDITOR.document;

		// Fixing "Unspecified error" thrown in IE10 by resetting
		// selection the dirty and shameful way (#10308).
		// We can not apply this hack to IE8 because
		// it causes error (#11058).
		if (CKEDITOR.env.ie && CKEDITOR.env.version == 10) {
			docOuter.focus();
			docInner.focus();
		}

		var range = new CKEDITOR.dom.range(docInner);
		if (!range['moveToElementEdit' + (placeAtEnd ? 'End' : 'Start')](cell)) {
			range.selectNodeContents(cell);
			range.collapse(placeAtEnd ? false : true);
		}
		range.select(true);
	}

	function cellInRow(tableMap, rowIndex, cell) {
		var oRow = tableMap[rowIndex];
		if (typeof cell == 'undefined') return oRow;

		for (var c = 0; oRow && c < oRow.length; c++) {
			if (cell.is && oRow[c] == cell.$) return c;else if (c == cell) return new CKEDITOR.dom.element(oRow[c]);
		}
		return cell.is ? -1 : null;
	}

	function cellInCol(tableMap, colIndex) {
		var oCol = [];
		for (var r = 0; r < tableMap.length; r++) {
			var row = tableMap[r];
			oCol.push(row[colIndex]);

			// Avoid adding duplicate cells.
			if (row[colIndex].rowSpan > 1) r += row[colIndex].rowSpan - 1;
		}
		return oCol;
	}

	function mergeCells(selection, mergeDirection, isDetect) {
		var cells = getSelectedCells(selection);

		// Invalid merge request if:
		// 1. In batch mode despite that less than two selected.
		// 2. In solo mode while not exactly only one selected.
		// 3. Cells distributed in different table groups (e.g. from both thead and tbody).
		var commonAncestor = void 0;
		if ((mergeDirection ? cells.length != 1 : cells.length < 2) || (commonAncestor = selection.getCommonAncestor()) && commonAncestor.type == CKEDITOR.NODE_ELEMENT && commonAncestor.is('table')) return false;

		var cell = void 0;

		var firstCell = cells[0];

		var table = firstCell.getAscendant('table');

		var map = CKEDITOR.tools.buildTableMap(table);

		var mapHeight = map.length;

		var mapWidth = map[0].length;

		var startRow = firstCell.getParent().$.rowIndex;

		var startColumn = cellInRow(map, startRow, firstCell);

		if (mergeDirection) {
			var targetCell = void 0;
			try {
				var rowspan = parseInt(firstCell.getAttribute('rowspan'), 10) || 1;
				var colspan = parseInt(firstCell.getAttribute('colspan'), 10) || 1;

				targetCell = map[mergeDirection == 'up' ? startRow - rowspan : mergeDirection == 'down' ? startRow + rowspan : startRow][mergeDirection == 'left' ? startColumn - colspan : mergeDirection == 'right' ? startColumn + colspan : startColumn];
			} catch (er) {
				return false;
			}

			// 1. No cell could be merged.
			// 2. Same cell actually.
			if (!targetCell || firstCell.$ == targetCell) return false;

			// Sort in map order regardless of the DOM sequence.
			cells[mergeDirection == 'up' || mergeDirection == 'left' ? 'unshift' : 'push'](new CKEDITOR.dom.element(targetCell));
		}

		// Start from here are merging way ignorance (merge up/right, batch merge).
		var doc = firstCell.getDocument();

		var lastRowIndex = startRow;

		var totalRowSpan = 0;

		var totalColSpan = 0;

		// Use a documentFragment as buffer when appending cell contents.

		var frag = !isDetect && new CKEDITOR.dom.documentFragment(doc);

		var dimension = 0;

		for (var i = 0; i < cells.length; i++) {
			cell = cells[i];

			var tr = cell.getParent();

			var cellFirstChild = cell.getFirst();

			var colSpan = cell.$.colSpan;

			var rowSpan = cell.$.rowSpan;

			var rowIndex = tr.$.rowIndex;

			var colIndex = cellInRow(map, rowIndex, cell);

			// Accumulated the actual places taken by all selected cells.
			dimension += colSpan * rowSpan;
			// Accumulated the maximum virtual spans from column and row.
			totalColSpan = Math.max(totalColSpan, colIndex - startColumn + colSpan);
			totalRowSpan = Math.max(totalRowSpan, rowIndex - startRow + rowSpan);

			if (!isDetect) {
				// Trim all cell fillers and check to remove empty cells.
				if (trimCell(cell), cell.getChildren().count()) {
					// Merge vertically cells as two separated paragraphs.
					if (rowIndex != lastRowIndex && cellFirstChild && !(cellFirstChild.isBlockBoundary && cellFirstChild.isBlockBoundary({ br: 1 }))) {
						var last = frag.getLast(CKEDITOR.dom.walker.whitespaces(true));
						if (last && !(last.is && last.is('br'))) frag.append('br');
					}

					cell.moveChildren(frag);
				}
				if (i) {
					cell.remove();
				} else {
					cell.setHtml('');
				}
			}
			lastRowIndex = rowIndex;
		}

		if (!isDetect) {
			frag.moveChildren(firstCell);

			firstCell.appendBogus();

			if (totalColSpan >= mapWidth) firstCell.removeAttribute('rowSpan');else firstCell.$.rowSpan = totalRowSpan;

			if (totalRowSpan >= mapHeight) firstCell.removeAttribute('colSpan');else firstCell.$.colSpan = totalColSpan;

			// Swip empty <tr> left at the end of table due to the merging.
			var trs = new CKEDITOR.dom.nodeList(table.$.rows);

			var count = trs.count();

			for (var _i4 = count - 1; _i4 >= 0; _i4--) {
				var tailTr = trs.getItem(_i4);
				if (!tailTr.$.cells.length) {
					tailTr.remove();
					count++;
					continue;
				}
			}

			return firstCell;
		}
		// Be able to merge cells only if actual dimension of selected
		// cells equals to the caculated rectangle.
		else {
				return totalRowSpan * totalColSpan == dimension;
			}
	}

	function verticalSplitCell(selection, isDetect) {
		var cells = getSelectedCells(selection);
		if (cells.length > 1) return false;else if (isDetect) return true;

		var cell = cells[0];

		var tr = cell.getParent();

		var table = tr.getAscendant('table');

		var map = CKEDITOR.tools.buildTableMap(table);

		var rowIndex = tr.$.rowIndex;

		var colIndex = cellInRow(map, rowIndex, cell);

		var rowSpan = cell.$.rowSpan;

		var newCell = void 0;

		var newRowSpan = void 0;

		var newCellRowSpan = void 0;

		var newRowIndex = void 0;

		if (rowSpan > 1) {
			newRowSpan = Math.ceil(rowSpan / 2);
			newCellRowSpan = Math.floor(rowSpan / 2);
			newRowIndex = rowIndex + newRowSpan;
			var newCellTr = new CKEDITOR.dom.element(table.$.rows[newRowIndex]);

			var newCellRow = cellInRow(map, newRowIndex);

			var candidateCell = void 0;

			newCell = cell.clone();

			// Figure out where to insert the new cell by checking the vitual row.
			for (var c = 0; c < newCellRow.length; c++) {
				candidateCell = newCellRow[c];
				// Catch first cell actually following the column.
				if (candidateCell.parentNode == newCellTr.$ && c > colIndex) {
					newCell.insertBefore(new CKEDITOR.dom.element(candidateCell));
					break;
				} else {
					candidateCell = null;
				}
			}

			// The destination row is empty, append at will.
			if (!candidateCell) newCellTr.append(newCell);
		} else {
			newCellRowSpan = newRowSpan = 1;

			var _newCellTr = tr.clone();
			_newCellTr.insertAfter(tr);
			_newCellTr.append(newCell = cell.clone());

			var cellsInSameRow = cellInRow(map, rowIndex);
			for (var i = 0; i < cellsInSameRow.length; i++) {
				cellsInSameRow[i].rowSpan++;
			}
		}

		newCell.appendBogus();

		cell.$.rowSpan = newRowSpan;
		newCell.$.rowSpan = newCellRowSpan;
		if (newRowSpan == 1) cell.removeAttribute('rowSpan');
		if (newCellRowSpan == 1) newCell.removeAttribute('rowSpan');

		return newCell;
	}

	function horizontalSplitCell(selection, isDetect) {
		var cells = getSelectedCells(selection);
		if (cells.length > 1) return false;else if (isDetect) return true;

		var cell = cells[0];

		var tr = cell.getParent();

		var table = tr.getAscendant('table');

		var map = CKEDITOR.tools.buildTableMap(table);

		var rowIndex = tr.$.rowIndex;

		var colIndex = cellInRow(map, rowIndex, cell);

		var colSpan = cell.$.colSpan;

		var newColSpan = void 0;

		var newCellColSpan = void 0;

		if (colSpan > 1) {
			newColSpan = Math.ceil(colSpan / 2);
			newCellColSpan = Math.floor(colSpan / 2);
		} else {
			newCellColSpan = newColSpan = 1;
			var cellsInSameCol = cellInCol(map, colIndex);
			for (var i = 0; i < cellsInSameCol.length; i++) {
				cellsInSameCol[i].colSpan++;
			}
		}
		var newCell = cell.clone();
		newCell.insertAfter(cell);
		newCell.appendBogus();

		cell.$.colSpan = newColSpan;
		newCell.$.colSpan = newCellColSpan;
		if (newColSpan == 1) cell.removeAttribute('colSpan');
		if (newCellColSpan == 1) newCell.removeAttribute('colSpan');

		return newCell;
	}

	CKEDITOR.plugins.add('ae_tabletools', {
		init: function init(editor) {
			function createDef(def) {
				return CKEDITOR.tools.extend(def || {}, {
					contextSensitive: 1,
					refresh: function refresh(editor, path) {
						this.setState(path.contains({ td: 1, th: 1 }, 1) ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED);
					}
				});
			}
			function addCmd(name, def) {
				var cmd = editor.getCommand(name);

				if (cmd) {
					return;
				}

				cmd = editor.addCommand(name, def);
				editor.addFeature(cmd);
			}

			addCmd('rowDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					placeCursorInCell(deleteRows(selection));
				}
			}));

			addCmd('rowInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					insertRow(editor, true);
				}
			}));

			addCmd('rowInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					insertRow(editor);
				}
			}));

			addCmd('columnDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					var element = deleteColumns(selection);
					if (element) {
						placeCursorInCell(element, true);
					}
				}
			}));

			addCmd('columnInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					insertColumn(editor, true);
				}
			}));

			addCmd('columnInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					insertColumn(editor);
				}
			}));

			addCmd('cellDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					deleteCells(selection);
				}
			}));

			addCmd('cellMerge', createDef({
				allowedContent: 'td[colspan,rowspan]',
				requiredContent: 'td[colspan,rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection()), true);
				}
			}));

			addCmd('cellMergeRight', createDef({
				allowedContent: 'td[colspan]',
				requiredContent: 'td[colspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection(), 'right'), true);
				}
			}));

			addCmd('cellMergeDown', createDef({
				allowedContent: 'td[rowspan]',
				requiredContent: 'td[rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection(), 'down'), true);
				}
			}));

			addCmd('cellVerticalSplit', createDef({
				allowedContent: 'td[rowspan]',
				requiredContent: 'td[rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(verticalSplitCell(editor.getSelection()));
				}
			}));

			addCmd('cellHorizontalSplit', createDef({
				allowedContent: 'td[colspan]',
				requiredContent: 'td[colspan]',
				exec: function exec(editor) {
					placeCursorInCell(horizontalSplitCell(editor.getSelection()));
				}
			}));

			addCmd('cellInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertCell(selection, true);
				}
			}));

			addCmd('cellInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertCell(selection);
				}
			}));
		},


		getSelectedCells: getSelectedCells
	});
}

/**
 * Create a two-dimension array that reflects the actual layout of table cells,
 * with cell spans, with mappings to the original td elements.
 *
 * @param {CKEDITOR.dom.element} table
 * @member CKEDITOR.tools
 */
CKEDITOR.tools.buildTableMap = function (table) {
	var aRows = table.$.rows;

	// Row and Column counters.
	var r = -1;

	var aMap = [];

	for (var i = 0; i < aRows.length; i++) {
		r++;
		if (!aMap[r]) {
			aMap[r] = [];
		}

		var c = -1;

		for (var j = 0; j < aRows[i].cells.length; j++) {
			var oCell = aRows[i].cells[j];

			c++;
			while (aMap[r][c]) {
				c++;
			}var iColSpan = isNaN(oCell.colSpan) ? 1 : oCell.colSpan;
			var iRowSpan = isNaN(oCell.rowSpan) ? 1 : oCell.rowSpan;

			for (var rs = 0; rs < iRowSpan; rs++) {
				if (!aMap[r + rs]) aMap[r + rs] = [];

				for (var cs = 0; cs < iColSpan; cs++) {
					aMap[r + rs][c + cs] = aRows[i].cells[j];
				}
			}

			c += iColSpan - 1;
		}
	}
	return aMap;
};

/***/ }),

/***/ "./src/selections/selection-arrowbox.js":
/*!**********************************************!*\
  !*** ./src/selections/selection-arrowbox.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var tableSelectionGetArrowBoxClasses = function tableSelectionGetArrowBoxClasses() {
  return 'ae-arrow-box ae-arrow-box-bottom';
};

var SelectionGetArrowBoxClasses = {
  table: tableSelectionGetArrowBoxClasses
};

exports.default = SelectionGetArrowBoxClasses;

/***/ }),

/***/ "./src/selections/selection-position.js":
/*!**********************************************!*\
  !*** ./src/selections/selection-position.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Default gutter value for toolbar positioning
var DEFAULT_GUTTER = {
	left: 0,
	top: 0
};

/**
 * Centers a Toolbar according to given rectangle
 *
 * @method centerToolbar
 * @param {Object} toolbar The toolbar to be centered
 * @param {Object} rect The rectangle according to which the Toolbar will be centered
 */
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var centerToolbar = function centerToolbar(toolbar, rect) {
	var toolbarNode = _reactDom2.default.findDOMNode(toolbar);

	var nativeEditor = toolbar.context.editor.get('nativeEditor');
	var uiNode = nativeEditor.config.uiNode || document.body;
	var uiNodeStyle = getComputedStyle(uiNode);
	var uiNodeMarginLeft = parseInt(uiNodeStyle.getPropertyValue('margin-left'), 10);
	var uiNodeMarginRight = parseInt(uiNodeStyle.getPropertyValue('margin-right'), 10);
	var totalWidth = uiNodeMarginLeft + uiNode.clientWidth + uiNodeMarginRight;

	var halfNodeWidth = toolbarNode.offsetWidth / 2;
	var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();

	var gutter = toolbar.props.gutter || DEFAULT_GUTTER;

	var widgetXY = toolbar.getWidgetXYPoint(rect.left + rect.width / 2 - scrollPosition.x, rect.top + scrollPosition.y, CKEDITOR.SELECTION_BOTTOM_TO_TOP);

	var caretPosition = nativeEditor.getSelection();
	var ranges = caretPosition.getRanges();
	var offsetHeight = 0;

	if (ranges && ranges.length === 1) {
		var startContainer = ranges[0].startContainer;
		if (startContainer.$.nodeType !== Node.ELEMENT_NODE) {
			startContainer = startContainer.getParent();
		}
		if (startContainer) {
			var startContainerClientRect = startContainer.getClientRect();
			offsetHeight = startContainerClientRect.y - rect.top;
		}
	}

	var endPosition = [rect.left + rect.width / 2 - halfNodeWidth - scrollPosition.x, rect.top + offsetHeight - toolbarNode.offsetHeight + scrollPosition.y - gutter.top];

	if (endPosition[0] < 0) {
		endPosition[0] = 0;
	} else if (endPosition[0] > totalWidth - toolbarNode.offsetWidth) {
		endPosition[0] = totalWidth - toolbarNode.offsetWidth;
	}

	toolbar.moveToPoint(widgetXY, endPosition);
};

/**
 * Sets the position of a toolbar according to the position of the selected image
 *
 * @method imageSelectionSetPosition
 * @param {Object} payload Payload, should contain the selection data for retrieving the
 * client rectangle of the selected image
 * @return {Boolean} True, in all cases
 */
var imageSelectionSetPosition = function imageSelectionSetPosition(payload) {
	var selectionData = payload.selectionData ? payload.selectionData : payload.editorEvent ? payload.editorEvent.data.selectionData : null;

	if (selectionData && selectionData.element) {
		var nativeEditor = payload.editor.get('nativeEditor');
		var uiNode = nativeEditor.config.uiNode;

		var scrollTop = uiNode ? uiNode.scrollTop : 0;

		var rect = selectionData.element.getClientRect();
		rect.top += scrollTop;

		centerToolbar(this, rect);

		return true;
	}
};

/**
 * Sets the position of a toolbar according to the position of the selected image
 *
 * @method tableSelectionSetPosition
 * @param {Object} payload Object, which contains the selection data for retrieving the
 * client rectangle of the selected table
 * @return {Boolean} True, in all cases
 */
var tableSelectionSetPosition = function tableSelectionSetPosition(payload) {
	var nativeEditor = payload.editor.get('nativeEditor');
	var uiNode = nativeEditor.config.uiNode;

	var scrollTop = uiNode ? uiNode.scrollTop : 0;

	var table = new CKEDITOR.Table(nativeEditor).getFromSelection();
	var rect = table.getClientRect();
	rect.top += scrollTop;

	centerToolbar(this, rect);

	return true;
};

var SelectionSetPosition = {
	image: imageSelectionSetPosition,
	table: tableSelectionSetPosition
};

exports.default = SelectionSetPosition;

/***/ }),

/***/ "./src/selections/selection-test.js":
/*!******************************************!*\
  !*** ./src/selections/selection-test.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var _isRangeAtElementEnd = function _isRangeAtElementEnd(range, element) {
	// Finding if a range is at the end of an element is somewhat tricky
	// due to how CKEditor handles ranges. It might depend on whether a
	// source node inside the element is selected or not. For now, we
	// need to cover the following cases:
	//
	// - The text length of the element is the same as the endOffset of
	//   the range.
	// - Both start and end containers match the element and the start
	//   and end offsets are 1.

	return element.getText().length === range.endOffset || element.equals(range.startContainer) && element.equals(range.endContainer) && range.startOffset === range.endOffset && range.endOffset === 1;
};

var embedSelectionTest = function embedSelectionTest(payload) {
	var selectionData = payload.data.selectionData;

	return !!(selectionData.element && selectionData.element.getAttribute('data-widget') === 'ae_embed');
};

var embedUrlSelectionTest = function embedUrlSelectionTest(payload) {
	var selectionData = payload.data.selectionData;

	return !!(selectionData.element && selectionData.element.getAttribute('data-widget') === 'embedurl');
};

var headingTextSelectionTest = function headingTextSelectionTest(payload) {
	var headings = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
	var nativeEditor = payload.editor.get('nativeEditor');
	var selectionData = payload.data.selectionData;
	var selectionEmpty = nativeEditor.isSelectionEmpty();

	return !!(!selectionData.element && selectionData.region && !selectionEmpty && !nativeEditor.getSelection().getCommonAncestor().isReadOnly() && nativeEditor.elementPath().contains(headings));
};

var linkSelectionTest = function linkSelectionTest(payload) {
	var nativeEditor = payload.editor.get('nativeEditor');
	var range = nativeEditor.getSelection().getRanges()[0];
	var selectionData = payload.data.selectionData;

	var element = new CKEDITOR.Link(nativeEditor).getFromSelection();
	var isSelectionEmpty = nativeEditor.isSelectionEmpty();
	var elementIsNotImage = selectionData.element ? selectionData.element.getName() !== 'img' : true;

	return !!(isSelectionEmpty && elementIsNotImage && element && element.getText().length !== range.endOffset && element && !element.isReadOnly() && !_isRangeAtElementEnd(range, element));
};

var imageSelectionTest = function imageSelectionTest(payload) {
	var selectionData = payload.data.selectionData;
	var element = selectionData.element;
	var hasImage = !!element && !!element.findOne('img');
	var isImage = !!element && element.getName() === 'img';

	return !!(element && (hasImage || isImage));
};

var textSelectionTest = function textSelectionTest(payload) {
	var nativeEditor = payload.editor.get('nativeEditor');

	var selectionEmpty = nativeEditor.isSelectionEmpty();

	var selectionData = payload.data.selectionData;

	return !!(!selectionData.element && selectionData.region && !selectionEmpty && !nativeEditor.getSelection().getCommonAncestor().isReadOnly());
};

var tableSelectionTest = function tableSelectionTest(payload) {
	var nativeEditor = payload.editor.get('nativeEditor');

	var table = new CKEDITOR.Table(nativeEditor);
	var element = table.getFromSelection();

	return !!(element && table.isEditable(element));
};

var SelectionTest = {
	embed: embedSelectionTest,
	embedUrl: embedUrlSelectionTest,
	header: headingTextSelectionTest,
	image: imageSelectionTest,
	link: linkSelectionTest,
	table: tableSelectionTest,
	text: textSelectionTest
};

exports.default = SelectionTest;

/***/ }),

/***/ "./src/selections/selections.js":
/*!**************************************!*\
  !*** ./src/selections/selections.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _selectionArrowbox = __webpack_require__(/*! ./selection-arrowbox */ "./src/selections/selection-arrowbox.js");

var _selectionArrowbox2 = _interopRequireDefault(_selectionArrowbox);

var _selectionPosition = __webpack_require__(/*! ./selection-position */ "./src/selections/selection-position.js");

var _selectionPosition2 = _interopRequireDefault(_selectionPosition);

var _selectionTest = __webpack_require__(/*! ./selection-test */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Selections = [{
	name: 'embed',
	buttons: ['embedRemove', 'embedEdit'],
	test: _selectionTest2.default.embed
}, {
	name: 'embedUrl',
	buttons: ['embedVideo', 'embedVideoEdit'],
	test: _selectionTest2.default.embedUrl
}, {
	name: 'link',
	buttons: ['linkEdit'],
	test: _selectionTest2.default.link
}, {
	name: 'image',
	buttons: ['imageLeft', 'imageCenter', 'imageRight', 'removeImage'],
	setPosition: _selectionPosition2.default.image,
	test: _selectionTest2.default.image
}, {
	name: 'text',
	buttons: {
		full: [['Font', 'FontSize', 'separator', 'bold', 'italic', 'underline', 'strike', 'separator', 'link'], ['paragraphAlign', 'separator', 'ul', 'ol', 'separator', 'h1', 'h2', 'separator', 'indentBlock', 'outdentBlock', 'separator', 'TextColor', 'BGColor', 'separator', 'code', 'quote', 'separator', 'removeFormat']],

		simple: ['styles', 'bold', 'italic', 'underline', 'link']
	},
	test: _selectionTest2.default.text
}, {
	name: 'table',
	buttons: ['tableHeading', 'tableRow', 'tableColumn', 'tableCell', 'tableRemove'],
	getArrowBoxClasses: _selectionArrowbox2.default.table,
	setPosition: _selectionPosition2.default.table,
	test: _selectionTest2.default.table
}]; /**
     * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
     * SPDX-License-Identifier: LGPL-3.0-or-later
     */

exports.default = Selections;

/***/ }),

/***/ "react":
/*!****************************************************************************************************!*\
  !*** external {"amd":"react","commonjs":"react","commonjs2":"react","root":"React","umd":"react"} ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window[undefined]; }());

/***/ }),

/***/ "react-dom":
/*!***********************************************************************************************************************!*\
  !*** external {"amd":"react-dom","commonjs":"react-dom","commonjs2":"react-dom","root":"ReactDOM","umd":"react-dom"} ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window[undefined]; }());

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BbGxveUVkaXRvci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9hZGFwdGVyL2NvcmUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvYWRhcHRlci9lZGl0b3ItY29udGV4dC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9hZGFwdGVyL21haW4uanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tbWFuZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tbWFuZHMvcmVtb3ZlLWltYWdlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tYWN0aW9uLXN0eWxlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2J1dHRvbi1jb21tYW5kLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24ta2V5c3Ryb2tlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tcHJvcHMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tc3R5bGUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS90b29sYmFyLWJ1dHRvbnMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL3dpZGdldC1kcm9wZG93bi5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2Jhc2Uvd2lkZ2V0LWV4Y2x1c2l2ZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1hY2Nlc3NpYmlsaXR5LWltYWdlLWFsdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1iYWNrZ3JvdW5kLWNvbG9yLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWJvbGQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tY2FtZXJhLWltYWdlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWNhbWVyYS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1jb2RlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWNvbG9yLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWNvbW1hbmQtbGlzdC1pdGVtLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWNvbW1hbmRzLWxpc3QuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tZHJvcGRvd24uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tZW1iZWQtZWRpdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1lbWJlZC12aWRlby1lZGl0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWVtYmVkLXZpZGVvLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWVtYmVkLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWgxLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWgyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWhsaW5lLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWljb24uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taW1hZ2UtYWxpZ24tY2VudGVyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWltYWdlLWFsaWduLWxlZnQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taW1hZ2UtYWxpZ24tcmlnaHQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taW1hZ2UuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taW5kZW50LWJsb2NrLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWl0YWxpYy5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1pdGVtLXNlbGVjdG9yLWF1ZGlvLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWl0ZW0tc2VsZWN0b3ItaW1hZ2UuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taXRlbS1zZWxlY3Rvci12aWRlby5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1saW5rLWF1dG9jb21wbGV0ZS1saXN0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWxpbmstYnJvd3NlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWxpbmstZWRpdC1icm93c2UuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tbGluay1lZGl0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWxpbmstdGFyZ2V0LWVkaXQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tbGluay5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1vbC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1vdXRkZW50LWJsb2NrLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXBhcmFncmFwaC1hbGlnbi1sZWZ0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXBhcmFncmFwaC1hbGlnbi1yaWdodC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1wYXJhZ3JhcGgtYWxpZ24uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcGFyYWdyYXBoLWNlbnRlci5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1wYXJhZ3JhcGgtanVzdGlmeS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1xdW90ZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1yZW1vdmUtZm9ybWF0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXJlbW92ZS1pbWFnZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1zZXBhcmF0b3IuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3BhY2luZy5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1zdHJpa2UuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3R5bGVzLWxpc3QtaGVhZGVyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0tcmVtb3ZlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3R5bGVzLWxpc3QuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3R5bGVzLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN1YnNjcmlwdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1zdXBlcnNjcmlwdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS1jZWxsLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXRhYmxlLWNvbHVtbi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS1lZGl0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXRhYmxlLWhlYWRpbmcuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tdGFibGUtcmVtb3ZlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXRhYmxlLXJvdy5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YXJnZXQtbGlzdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10d2l0dGVyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXVsLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXVuZGVybGluZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvY29tcGF0L2J1dHRvbi1hY3Rpb24tc3R5bGUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9jb21wYXQvYnV0dG9uLWNvbW1hbmQtYWN0aXZlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvY29tcGF0L2J1dHRvbi1jb21tYW5kLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvY29tcGF0L2J1dHRvbi1rZXlzdHJva2UuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9jb21wYXQvYnV0dG9uLXByb3BzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvY29tcGF0L2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvY29tcGF0L2J1dHRvbi1zdHlsZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2NvbXBhdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2NvbXBhdC90b29sYmFyLWJ1dHRvbnMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9jb21wYXQvd2lkZ2V0LWFycm93LWJveC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2NvbXBhdC93aWRnZXQtZHJvcGRvd24uanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9jb21wYXQvd2lkZ2V0LWV4Y2x1c2l2ZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2NvbXBhdC93aWRnZXQtZm9jdXMtbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2NvbXBhdC93aWRnZXQtaW50ZXJhY3Rpb24tcG9pbnQuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9jb21wYXQvd2lkZ2V0LXBvc2l0aW9uLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvbWFpbi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy90b29sYmFycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3Rvb2xiYXJzL3Rvb2xiYXItYWRkLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3Rvb2xiYXJzL3Rvb2xiYXItc3R5bGVzLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3VpYnJpZGdlL2J1dHRvbi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy91aWJyaWRnZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3VpYnJpZGdlL21lbnUtYnV0dG9uLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3VpYnJpZGdlL21lbnUuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvdWlicmlkZ2UvcGFuZWwtbWVudS1idXR0b24uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvdWlicmlkZ2UvcmljaGNvbWJvLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3VpYnJpZGdlL3VpYnJpZGdlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb3JlL2xpbmsuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS9wbHVnaW5zLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvc2VsZWN0aW9uLXJlZ2lvbi5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb3JlL3RhYmxlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvdG9vbHMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS91aWNvcmUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvb29wL2F0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9vb3AvYmFzZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9vb3AvbGFuZy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9vb3Avb29wLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvRHJhZ0V2ZW50LmVzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvUmVzaXplci5lcy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2FkZGltYWdlcy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2F1dG9saW5rLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvYXV0b2xpc3QuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9kcmFncmVzaXplLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvZHJhZ3Jlc2l6ZV9pZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2RyYWdyZXNpemVfaWUxMS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2VtYmVkLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvZW1iZWR1cmwuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9pbWFnZWFsaWdubWVudC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvcGFzdGVpbWFnZXMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9wbGFjZWhvbGRlci5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL3ByaW9yaXRpZXMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9zZWxlY3Rpb25rZXlzdHJva2VzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvdGFibGVyZXNpemUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy90YWJsZXRvb2xzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3NlbGVjdGlvbnMvc2VsZWN0aW9uLWFycm93Ym94LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3NlbGVjdGlvbnMvc2VsZWN0aW9uLXBvc2l0aW9uLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3NlbGVjdGlvbnMvc2VsZWN0aW9uLXRlc3QuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvc2VsZWN0aW9ucy9zZWxlY3Rpb25zLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yL2V4dGVybmFsIHtcImFtZFwiOlwicmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiY29tbW9uanMyXCI6XCJyZWFjdFwiLFwicm9vdFwiOlwiUmVhY3RcIixcInVtZFwiOlwicmVhY3RcIn0iLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvZXh0ZXJuYWwge1wiYW1kXCI6XCJyZWFjdC1kb21cIixcImNvbW1vbmpzXCI6XCJyZWFjdC1kb21cIixcImNvbW1vbmpzMlwiOlwicmVhY3QtZG9tXCIsXCJyb290XCI6XCJSZWFjdERPTVwiLFwidW1kXCI6XCJyZWFjdC1kb21cIn0iXSwibmFtZXMiOlsiRU1CRURfVklERU9fV0lEVEgiLCJFTUJFRF9WSURFT19IRUlHSFQiLCJDb3JlIiwiY29uZmlnIiwic3VwZXJjbGFzcyIsImNvbnN0cnVjdG9yIiwiY2FsbCIsIkJhc2UiLCJpbml0aWFsaXplciIsIm5vZGUiLCJnZXQiLCJzZXRBdHRyaWJ1dGUiLCJlZGl0b3IiLCJDS0VESVRPUiIsImlubGluZSIsImFsbG93ZWRDb250ZW50IiwidG9vbGJhcnMiLCJyZW1vdmVQbHVnaW5zIiwiZXh0cmFQbHVnaW5zIiwiZW1iZWRQcm92aWRlcnMiLCJwbGFjZWhvbGRlckNsYXNzIiwicGFzdGVGcm9tV29yZFJlbW92ZVN0eWxlcyIsInBhc3RlRnJvbVdvcmRSZW1vdmVGb250U3R5bGVzIiwic2VsZWN0aW9uS2V5c3Ryb2tlcyIsInNwcml0ZW1hcCIsIkxhbmciLCJtaXgiLCJlbnYiLCJpZSIsImVkZ2UiLCJwbHVnaW4iLCJ2ZXJzaW9uIiwicmVwbGFjZSIsIm9uY2UiLCJfYWRkUmVhZE9ubHlMaW5rQ2xpY2tMaXN0ZW5lciIsImVkaXRhYmxlIiwiZXh0cmFDb21tYW5kcyIsImV4dHJhQ29tbWFuZEtleXMiLCJPYmplY3QiLCJrZXlzIiwiaSIsImxlbmd0aCIsImNvbW1hbmROYW1lIiwiY29tbWFuZHMiLCJhZGRDb21tYW5kIiwiYWRkQ2xhc3MiLCJfZWRpdG9yIiwiQWxsb3lFZGl0b3IiLCJsb2FkTGFuZ3VhZ2VSZXNvdXJjZXMiLCJfcmVuZGVyVUkiLCJiaW5kIiwiZGVzdHJ1Y3RvciIsIl9kZXN0cm95ZWQiLCJfZWRpdG9yVUlFbGVtZW50IiwiUmVhY3RET00iLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwibmF0aXZlRWRpdG9yIiwicmVtb3ZlQ2xhc3MiLCJfY2xlYXJTZWxlY3Rpb25zIiwiZGVzdHJveSIsImlzTVNTZWxlY3Rpb24iLCJ3aW5kb3ciLCJnZXRTZWxlY3Rpb24iLCJkb2N1bWVudCIsIiQiLCJzZWxlY3Rpb24iLCJlbXB0eSIsImdldFdpbmRvdyIsInJlbW92ZUFsbFJhbmdlcyIsIm9uIiwiX2RlZmF1bHRSZWFkT25seUNsaWNrRm4iLCJldmVudCIsIm1vdXNlRXZlbnQiLCJkYXRhIiwiaGFzQ3RybEtleSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hvdWxkT3BlbiIsInJlYWRPbmx5IiwicHJldmVudERlZmF1bHQiLCJsaXN0ZW5lckRhdGEiLCJmaXJlIiwiY2tFbGVtZW50IiwiZG9tIiwiZWxlbWVudFBhdGgiLCJnZXRUYXJnZXQiLCJsaW5rIiwibGFzdEVsZW1lbnQiLCJocmVmIiwiYXR0cmlidXRlcyIsInZhbHVlIiwidGFyZ2V0IiwiX3JlZGlyZWN0TGluayIsIl9nZXROYXRpdmVFZGl0b3IiLCJvcGVuIiwibG9jYXRpb24iLCJlZGl0b3JVSUVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwidWlOb2RlIiwiYm9keSIsImFwcGVuZENoaWxkIiwiY2FsbGJhY2tSZWYiLCJfbWFpblVJIiwiZWxlbWVudCIsInJlbmRlciIsIl90b0VsZW1lbnQiLCJpc1N0cmluZyIsImdldEVsZW1lbnRCeUlkIiwiX3ZhbGlkYXRlQWxsb3dlZENvbnRlbnQiLCJpc09iamVjdCIsImlzQm9vbGVhbiIsIl92YWxpZGF0ZVRvb2xiYXJzIiwiaXNOdWxsIiwiQVRUUlMiLCJ2YWxpZGF0b3IiLCJ3cml0ZU9uY2UiLCJkb2N1bWVudEJyb3dzZUxpbmtDYWxsYmFjayIsImlzRnVuY3Rpb24iLCJ1bmRlZmluZWQiLCJkb2N1bWVudEJyb3dzZUxpbmtVcmwiLCJpc0FycmF5IiwiaWQiLCJ0cGwiLCJ0eXBlIiwidXJsU2NoZW1lcyIsImVuYWJsZUNvbnRlbnRFZGl0YWJsZSIsImV2ZW50c0RlbGF5IiwiaXNOdW1iZXIiLCJyZW1vdmVJbWFnZSIsInJlbW92ZUltYWdlQ29tbWFuZCIsIm1vZGUiLCJnZXR0ZXIiLCJDVFJMIiwiU0hJRlQiLCJzcmNOb2RlIiwic2V0dGVyIiwiYWRkIiwiYnV0dG9ucyIsInRhYkluZGV4Iiwic3R5bGVzIiwic2VsZWN0aW9ucyIsIlNlbGVjdGlvbnMiLCJpbXBsZW1lbnRPbiIsIkVkaXRvckNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ0b1Byb3BzIiwiZm9yd2FyZGluZ0NvbXBvbmVudCIsImZvcndhcmRSZWYiLCJwcm9wcyIsInJlZiIsImNvbnRleHQiLCJrZXkiLCJDb21wb25lbnQiLCJDb21wYXQiLCJCUklER0VfQlVUVE9OUyIsImltcGxlbWVudEV2ZW50VGFyZ2V0IiwiZ2V0QmFzZVBhdGgiLCJwYXRoIiwiQUxMT1lFRElUT1JfQkFTRVBBVEgiLCJzY3JpcHRzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJtYXRjaCIsInNyYyIsInJlZ2V4QmFzZVBhdGgiLCJpbmRleE9mIiwic2xpY2UiLCJFcnJvciIsImNhbGxiYWNrIiwiU3RyaW5ncyIsInNldFRpbWVvdXQiLCJfbGFuZ1Jlc291cmNlUmVxdWVzdGVkIiwibGFuZ3VhZ2VzIiwidXNlckxhbmd1YWdlIiwibmF2aWdhdG9yIiwibGFuZ3VhZ2UiLCJwYXJ0cyIsInRvTG93ZXJDYXNlIiwibGFuZyIsImxvY2FsZSIsInNjcmlwdExvYWRlciIsImxvYWQiLCJnZXRVcmwiLCJsb2FkZWQiLCJyZXNvdXJjZSIsImJhc2VQYXRoIiwidGltZXN0YW1wIiwiY2hhckF0IiwidGVzdCIsImdldEJ1dHRvbnMiLCJyZWR1Y2UiLCJhY2MiLCJ2YWwiLCJjb25jYXQiLCJyZWdpc3RlckJyaWRnZUJ1dHRvbiIsImJ1dHRvbk5hbWUiLCJwbHVnaW5OYW1lIiwicHVzaCIsIk9PUCIsImV4dGVuZCIsIkF0dHJpYnV0ZSIsIkJ1dHRvbnMiLCJTZWxlY3Rpb25HZXRBcnJvd0JveENsYXNzZXMiLCJTZWxlY3Rpb25TZXRQb3NpdGlvbiIsIlNlbGVjdGlvblRlc3QiLCJUb29sYmFycyIsImV4ZWMiLCJyYW5nZXMiLCJnZXRSYW5nZXMiLCJzdGFydENvbnRhaW5lciIsIm5leHRSYW5nZSIsInJhbmdlIiwic2V0U3RhcnQiLCJzZXRFbmQiLCJzZWxlY3RlZEVsZW1lbnQiLCJnZXRTZWxlY3RlZEVsZW1lbnQiLCJnZXROYW1lIiwibmF0aXZlIiwiZ2V0TmF0aXZlIiwic2VsZWN0UmFuZ2VzIiwicmVtb3ZlIiwiYXBwbHlTdHlsZSIsImlzQWN0aXZlIiwiZ2V0U3R5bGUiLCJsb2NrIiwicmVtb3ZlU3R5bGUiLCJ1bmxvY2siLCJXcmFwcGVkQ29tcG9uZW50IiwiY29udGV4dFR5cGUiLCJjb21tYW5kIiwiZ2V0Q29tbWFuZCIsInN0YXRlIiwiVFJJU1RBVEVfT04iLCJleGVjQ29tbWFuZCIsImtleXN0cm9rZSIsIm5hbWUiLCJrZXlzdHJva2VGbiIsImZuIiwiX2RlZmF1bHRLZXlzdHJva2VDb21tYW5kIiwia2V5c3Ryb2tlSGFuZGxlciIsImtleXN0cm9rZXMiLCJzZXRLZXlzdHJva2UiLCJidXR0b25DZmciLCJ0b29scyIsIm1lcmdlIiwic3RhdGVDbGFzc2VzIiwic3R5bGUiLCJzcGxpdCIsImN1cnJlbnRNZW1iZXIiLCJwcm9wZXJ0eSIsInNoaWZ0IiwiX3N0eWxlIiwiY2hlY2tBY3RpdmUiLCJkZWZhdWx0IiwiX2FuaW1hdGlvbkZyYW1lSWQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImFycm93Qm94Q2xhc3NlcyIsImdldEludGVyYWN0aW9uUG9pbnQiLCJkaXJlY3Rpb24iLCJTRUxFQ1RJT05fVE9QX1RPX0JPVFRPTSIsImF0dHJzIiwidmlld1BhbmVTaXplIiwiZ2V0Vmlld1BhbmVTaXplIiwieCIsImxlZnQiLCJ5IiwidG9wIiwid2lkdGgiLCJldmVudFBheWxvYWQiLCJlZGl0b3JFdmVudCIsInNlbGVjdGlvbkRhdGEiLCJuYXRpdmVFdmVudCIsInBvcyIsInBhZ2VYIiwicmVnaW9uIiwiZW5kUmVjdCIsInN0YXJ0UmVjdCIsIlNFTEVDVElPTl9CT1RUT01fVE9fVE9QIiwiX2dldFhQb2ludCIsIk1hdGgiLCJtaW4iLCJtYXgiLCJfZ2V0WVBvaW50IiwiZXZlbnRYIiwicmlnaHQiLCJsZWZ0RGlzdCIsImFicyIsInJpZ2h0RGlzdCIsImVsZW1lbnRUYXJnZXQiLCJvZmZzZXRUb3AiLCJvZmZzZXRIZWlnaHQiLCJib3R0b20iLCJkb21Ob2RlIiwiZmluZERPTU5vZGUiLCJndXR0ZXIiLCJvZmZzZXRXaWR0aCIsIlNFTEVDVElPTl9MRUZUX1RPX1JJR0hUIiwiU0VMRUNUSU9OX1JJR0hUX1RPX0xFRlQiLCJkb21FbGVtZW50IiwiaGFzQ2xhc3MiLCJzdGFydFBvaW50IiwiZW5kUG9pbnQiLCJzZXRTdHlsZXMiLCJvcGFjaXR5IiwicG9pbnRlckV2ZW50cyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNjcm9sbFRvcCIsImlzVmlzaWJsZSIsImludGVyYWN0aW9uUG9pbnQiLCJmaW5hbFgiLCJmaW5hbFkiLCJpbml0aWFsWCIsImluaXRpYWxZIiwicGFyc2VGbG9hdCIsImNvbnN0cmFpblRvVmlld3BvcnQiLCJyZXMiLCJnZXRDb25zdHJhaW5lZFBvc2l0aW9uIiwiaGVpZ2h0IiwibW92ZVRvUG9pbnQiLCJ1aU5vZGVTdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJ1aU5vZGVNYXJnaW5MZWZ0IiwicGFyc2VJbnQiLCJnZXRQcm9wZXJ0eVZhbHVlIiwidWlOb2RlTWFyZ2luUmlnaHQiLCJ0b3RhbFdpZHRoIiwiY2xpZW50V2lkdGgiLCJ0YWdOYW1lIiwieHkiLCJnZXRXaWRnZXRYWVBvaW50IiwiYWRkaXRpb25hbFByb3BzIiwibGlzdCIsImJ1dHRvbiIsIkFycmF5IiwiZ2V0VG9vbGJhckJ1dHRvbnMiLCJidXR0b25Qcm9wcyIsInRvb2xiYXJCdXR0b25zIiwiZmlsdGVyRXhjbHVzaXZlIiwiZmlsdGVyIiwibWFwIiwiY2ZnIiwiaW5kZXgiLCJtZXJnZUV4Y2x1c2l2ZVByb3BzIiwidGFiS2V5IiwidHJpZ2dlciIsIm1lcmdlRHJvcGRvd25Qcm9wcyIsImRlZmF1bHRQcm9wcyIsIm9iaiIsIml0ZW1LZXkiLCJleHBhbmRlZCIsIml0ZW1Ecm9wZG93biIsImRyb3Bkb3duVHJpZ2dlciIsInRvZ2dsZURyb3Bkb3duIiwidG9nZ2xlRGlyZWN0aW9uIiwic2V0U3RhdGUiLCJtb3ZlRm9jdXMiLCJmb2N1cyIsIm5leHRQcm9wcyIsInJlcXVlc3RFeGNsdXNpdmUiLCJpdGVtRXhjbHVzaXZlIiwiaXRlbXMiLCJpdGVtIiwiY2FuY2VsRXhjbHVzaXZlIiwicmVuZGVyRXhjbHVzaXZlIiwiRElSRUNUSU9OX05PTkUiLCJESVJFQ1RJT05fTkVYVCIsIkRJUkVDVElPTl9QUkVWIiwiQUNUSU9OX05PTkUiLCJBQ1RJT05fTU9WRV9GT0NVUyIsIkFDVElPTl9ESVNNSVNTX0ZPQ1VTIiwiX2lzVmFsaWRUYXJnZXQiLCJfZGVzY2VuZGFudHMiLCJhY3RpdmVEZXNjZW5kYW50RWwiLCJfYWN0aXZlRGVzY2VuZGFudCIsImFjdGl2ZUVsZW1lbnQiLCJmb2N1c0ZpcnN0Q2hpbGQiLCJzdG9wUHJvcGFnYXRpb24iLCJoYW5kbGVLZXkiLCJhY3Rpb24iLCJfZ2V0Rm9jdXNBY3Rpb24iLCJfbW92ZUZvY3VzIiwib25EaXNtaXNzIiwiX3JlZnJlc2giLCJfZ2V0Rm9jdXNNb3ZlRGlyZWN0aW9uIiwiZGlzbWlzc0FjdGlvbiIsIl9nZXRGb2N1c0Rpc21pc3NBY3Rpb24iLCJkaXNtaXNzIiwiZm9jdXNNb3ZlRGlyZWN0aW9uIiwiX2lzVmFsaWRLZXkiLCJrZXlDb2RlIiwiZGlzbWlzc05leHQiLCJkaXNtaXNzUHJldiIsImNpcmN1bGFyIiwibmV4dCIsInByZXYiLCJzaGlmS2V5IiwibnVtRGVzY2VuZGFudHMiLCJkZXNjZW5kYW50IiwiZGVzY2VuZGFudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwicHJpb3JpdHlEZXNjZW5kYW50cyIsInByb3RvdHlwZSIsImZvckVhY2giLCJkYXRhVGFiSW5kZXgiLCJnZXRBdHRyaWJ1dGUiLCJzb3J0IiwiYSIsImIiLCJ0b0ludCIsInNvbWUiLCJCdXR0b25BY2Nlc3NpYmlsaXR5SW1hZ2VBbHQiLCJnZXRTdGFydEVsZW1lbnQiLCJfZWxlbWVudCIsImltYWdlRWxlbWVudCIsImZpbmRPbmUiLCJpbWFnZUFsdCIsIl9oYW5kbGVBbHRDaGFuZ2UiLCJfaGFuZGxlS2V5RG93biIsImNvbmZpcm0iLCJfdXBkYXRlSW1hZ2VBbHQiLCJfcmVxdWVzdEV4Y2x1c2l2ZSIsImluc3RhbmNlIiwiZm9jdXNBbHRFbCIsInJlZnMiLCJyZWZBbHRJbnB1dCIsIl9mb2N1c0FsdElucHV0IiwiaW1hZ2UiLCJCdXR0b25CYWNrZ3JvdW5kQ29sb3IiLCJhY3RpdmVDb2xvciIsIm5vcm1hbCIsImFjdGl2ZUNvbG9yQ2xhc3MiLCJjb2xvcnMiLCJfZ2V0Q29sb3JzIiwiaXRlbVN0eWxlIiwiY2xhc3MiLCJzdHlsZUNsYXNzIiwiX2NoZWNrQWN0aXZlIiwiYnV0dG9uU3R5bGVzUHJvcHMiLCJhY3RpdmVTdHlsZSIsInNob3dSZW1vdmVTdHlsZXNJdGVtIiwic3R5bGVDb25maWciLCJzdHlsZUZuIiwiX2FwcGx5U3R5bGUiLCJwcmltYXJ5IiwiZGlzYWJsZWQiLCJzdWNjZXNzIiwiZGFuZ2VyIiwid2FybmluZyIsImluZm8iLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJib29sIiwibGFiZWwiLCJzdHJpbmciLCJhcnJheU9mIiwib2JqZWN0IiwibnVtYmVyIiwiZnVuYyIsIkJ1dHRvbkJvbGQiLCJjc3NDbGFzcyIsImdldFN0YXRlQ2xhc3NlcyIsImJvbGQiLCJCdXR0b25DYW1lcmFJbWFnZSIsInRha2VQaG90byIsInZpZGVvRWwiLCJfdmlkZW9Db250YWluZXJSZWYiLCJjdXJyZW50IiwiY2FudmFzRWwiLCJfY2FudmFzQ29udGFpbmVyUmVmIiwiZ2V0Q29udGV4dCIsIl92aWRlb0hlaWdodCIsInZpZGVvV2lkdGgiLCJkcmF3SW1hZ2UiLCJpbWdVUkwiLCJ0b0RhdGFVUkwiLCJlbCIsImNyZWF0ZUZyb21IdG1sIiwiaW5zZXJ0RWxlbWVudCIsIl9oYW5kbGVTdHJlYW1FcnJvciIsImFsZXJ0IiwiZXJyb3IiLCJfaGFuZGxlU3RyZWFtU3VjY2VzcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJ2aWRlb0hlaWdodCIsImlzTmFOIiwiX3N0cmVhbSIsInN0cmVhbSIsIm1vekdldFVzZXJNZWRpYSIsIm1velNyY09iamVjdCIsInNyY09iamVjdCIsInBsYXkiLCJfYnV0dG9uVGFrZVBob3RvUmVmIiwiY3JlYXRlUmVmIiwic3RvcCIsImdldFZpZGVvVHJhY2tzIiwidHJhY2siLCJnZXRVc2VyTWVkaWEiLCJ3ZWJraXRHZXRVc2VyTWVkaWEiLCJtc0dldFVzZXJNZWRpYSIsInZpZGVvIiwiYXVkaW8iLCJCdXR0b25DYW1lcmEiLCJwcm90b2NvbCIsImNhbWVyYURpc2FibGVkIiwiY2FtZXJhIiwiQnV0dG9uQ29kZSIsImNvZGUiLCJCdXR0b25Db2xvciIsImRhcmsiLCJkYXJrR3JheSIsInNlY29uZGFyeSIsImxpZ2h0IiwibGlnaHRlciIsIndoaXRlIiwiQnV0dG9uQ29tbWFuZExpc3RJdGVtIiwiZGVzY3JpcHRpb24iLCJfZ2V0Q2xhc3NOYW1lIiwiQnV0dG9uQ29tbWFuZHNMaXN0IiwiX3JlZiIsImxpc3RJZCIsIl9yZW5kZXJBY3Rpb25zIiwiaWNvbiIsIkJ1dHRvbkRyb3Bkb3duIiwiY2hpbGRyZW4iLCJLRVlfRU5URVIiLCJLRVlfRVNDIiwiQnV0dG9uRW1iZWRFZGl0IiwiX2NsZWFyTGluayIsImxpbmtIcmVmIiwiX2VtYmVkTGluayIsInVybCIsIl9mb2N1c0xpbmtJbnB1dCIsImxpbmtJbnB1dCIsIl9oYW5kbGVMaW5rSHJlZkNoYW5nZSIsIl9yZW1vdmVFbWJlZCIsImVtYmVkV3JhcHBlciIsImdldEFzY2VuZGFudCIsImdldEluaXRpYWxTdGF0ZSIsIm1hbnVhbFNlbGVjdGlvbiIsImVtYmVkIiwiaW5pdGlhbExpbmsiLCJjbGVhckxpbmtTdHlsZSIsImRlbGV0ZUVtYmVkIiwiZWRpdExpbmsiLCJjbGVhcklucHV0IiwiY2xlYXIiLCJfaXNWYWxpZFN0YXRlIiwidmFsaWRTdGF0ZSIsIkJ1dHRvbkVtYmVkVmlkZW9FZGl0IiwiX2VtYmVkVmlkZW9VUkwiLCJ2aWRlb1VSTCIsIl9mb2N1c1ZpZGVvVXJsSW5wdXQiLCJfaGFuZGxlVmlkZW9VUkxDaGFuZ2UiLCJuZXdTdGF0ZSIsImFsbCIsIm5ldyIsIm9sZCIsImluaXRpYWxFbWJlZCIsImlucHV0UGxhY2Vob2xkZXIiLCJwYXN0ZVZpZGVvTGluayIsImNsZWFyVmlkZW9VUkxTdHlsZSIsIkJ1dHRvbkVtYmVkVmlkZW8iLCJCdXR0b25FbWJlZCIsIkJ1dHRvbkgxIiwiaDEiLCJCdXR0b25IMiIsImgyIiwiQnV0dG9uSGxpbmUiLCJob3Jpem9udGFscnVsZSIsIkJ1dHRvbkljb24iLCJzeW1ib2wiLCJjbGFzc05hbWVQcmVmaXgiLCJjb21iaW5lZENsYXNzTmFtZSIsIkJ1dHRvbkltYWdlQWxpZ25DZW50ZXIiLCJhbGlnbkNlbnRlciIsIkJ1dHRvbkltYWdlQWxpZ25MZWZ0IiwiYWxpZ25MZWZ0IiwiQnV0dG9uSW1hZ2VBbGlnblJpZ2h0IiwiYWxpZ25SaWdodCIsIkJ1dHRvbkltYWdlIiwiaGFuZGxlQ2xpY2siLCJmaWxlSW5wdXQiLCJjbGljayIsIl9vbklucHV0Q2hhbmdlIiwiaW5wdXRFbCIsImZpbGVzIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsImZpbGUiLCJvbmxvYWQiLCJyZXN1bHQiLCJpbWFnZUZpbGVzIiwiaW1hZ2VEYXRhIiwicmVhZEFzRGF0YVVSTCIsImlucHV0U3lsZSIsImRpc3BsYXkiLCJCdXR0b25JbmRlbnRCbG9jayIsImluZGVudCIsIkJ1dHRvbkl0YWxpYyIsIml0YWxpYyIsIkJ1dHRvbkl0ZW1TZWxlY3RvckF1ZGlvIiwiX2hhbmRsZUNsaWNrIiwiQnV0dG9uSXRlbVNlbGVjdG9ySW1hZ2UiLCJCdXR0b25JdGVtU2VsZWN0b3JWaWRlbyIsIkJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0IiwidGVybSIsImNsZWFyVGltZW91dCIsIl90aW1lb3V0IiwiX3VwZGF0ZUl0ZW1zIiwiZGVsYXkiLCJhdXRvY29tcGxldGVTZWxlY3RlZCIsInNldEF1dG9jb21wbGV0ZVN0YXRlIiwic2VsZWN0ZWQiLCJfcmVuZGVyQXV0b2NvbXBsZXRlSXRlbXMiLCJuZXh0U3RhdGUiLCJoYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2siLCJ0aXRsZSIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJCdXR0b25MaW5rQnJvd3NlIiwibWVyZ2VCdXR0b25DZmdQcm9wcyIsIkJ1dHRvbkxpbmtFZGl0QnJvd3NlIiwiX2Jyb3dzZUNsaWNrIiwiYnJvd3NlTGlua0NhbGxiYWNrIiwibGlua1RhcmdldCIsImxpbmtFZGl0QnV0dG9uUmVmIiwiY2hhbmdlTGlua0NhbGxiYWNrIiwiX3VwZGF0ZUxpbmsiLCJzZWxlY3RlZEl0ZW0iLCJhcHBseSIsImxpbmtUaXRsZSIsImxpbmtVdGlscyIsIkxpbmsiLCJhcHBlbmRQcm90b2NvbCIsImxpbmtBdHRycyIsIm1vZGlmeVNlbGVjdGlvbiIsImFkdmFuY2UiLCJwbHVnaW5zIiwiY3Jlb2xlIiwib3JpZ2luIiwidXBkYXRlIiwiY3JlYXRlIiwiZ2V0RnJvbVNlbGVjdGlvbiIsIkJ1dHRvbkxpbmtFZGl0IiwiYWR2YW5jZVNlbGVjdGlvbiIsIl9oYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlIiwiX3JlbW92ZUxpbmsiLCJib29rbWFya3MiLCJjcmVhdGVCb29rbWFya3MiLCJzZWxlY3RCb29rbWFya3MiLCJfZ2V0SW5pdGlhbFN0YXRlIiwidGFyZ2V0U2VsZWN0b3IiLCJhbGxvd2VkVGFyZ2V0cyIsImhhbmRsZUxpbmtUYXJnZXRDaGFuZ2UiLCJzZWxlY3RlZFRhcmdldCIsImxpbmtUYXJnZXREZWZhdWx0IiwiQnV0dG9uTGlua1RhcmdldEVkaXQiLCJhdXRvY29tcGxldGVEcm9wZG93biIsImRhdGFGbiIsImF1dG9jb21wbGV0ZURyb3Bkb3duUHJvcHMiLCJfaGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrIiwiX3NldEF1dG9jb21wbGV0ZVN0YXRlIiwiYnV0dG9uQ2xlYXJMaW5rIiwicGxhY2Vob2xkZXJQcm9wIiwicGxhY2Vob2xkZXIiLCJyZW1vdmVMaW5rIiwic2hvd1RhcmdldFNlbGVjdG9yIiwiZGVmYXVsdExpbmtUYXJnZXQiLCJmb2N1c0xpbmtFbCIsImF1dG9jb21wbGV0ZVVybCIsImN1c3RvbUluZGV4U3RhcnQiLCJhbGxvd2VkTGlua1RhcmdldHMiLCJCdXR0b25MaW5rIiwiQnV0dG9uT3JkZXJlZExpc3QiLCJudW1iZXJlZGxpc3QiLCJCdXR0b25PdXRkZW50QmxvY2siLCJvdXRkZW50IiwiQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0IiwiQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodCIsIkJ1dHRvblBhcmFncmFwaEFsaWduIiwiYnV0dG9uQ29tbWFuZHNMaXN0IiwiYnV0dG9uQ29tbWFuZHNMaXN0SWQiLCJfZ2V0Q29tbWFuZHMiLCJhY3RpdmVDb21tYW5kIiwiYWxpZ25tZW50IiwicG9wIiwiaWNvbkNsYXNzTmFtZSIsInJvdyIsImFsaWduSnVzdGlmeSIsIkJ1dHRvblBhcmFncmFwaENlbnRlciIsIkJ1dHRvblBhcmFncmFwaEp1c3RpZnkiLCJCdXR0b25RdW90ZSIsInF1b3RlIiwiQnV0dG9uUmVtb3ZlRm9ybWF0IiwicmVtb3ZlZm9ybWF0IiwiQnV0dG9uUmVtb3ZlSW1hZ2UiLCJCdXR0b25TZXBhcmF0b3IiLCJfcHJvcHMiLCJCdXR0b25TcGFjaW5nIiwiYWN0aXZlU3BhY2luZyIsInNwYWNpbmdzIiwiX2dldFNwYWNpbmdzIiwiYWN0aXZlIiwiQnV0dG9uU3RyaWtlIiwic3RyaWtlIiwiQnV0dG9uc1N0eWxlc0xpc3RIZWFkZXIiLCJCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZSIsIl9yZW1vdmVTdHlsZXMiLCJyZW1vdmVCbG9ja3MiLCJibG9ja1N0eWxlIiwiYmxvY2tJdGVtIiwiQnV0dG9uU3R5bGVzTGlzdEl0ZW0iLCJfb25DbGljayIsInN0eWxlQ2ZnIiwibWFyZ2luIiwiX3ByZXZpZXciLCJidWlsZFByZXZpZXciLCJfX2h0bWwiLCJCdXR0b25TdHlsZXNMaXN0IiwiYmxvY2tTdHlsZXMiLCJpbmxpbmVTdHlsZXMiLCJvYmplY3RTdHlsZXMiLCJTVFlMRV9CTE9DSyIsIlNUWUxFX0lOTElORSIsIlNUWUxFX09CSkVDVCIsIl9ibG9ja1N0eWxlcyIsIl9pbmxpbmVTdHlsZXMiLCJfb2JqZWN0U3R5bGVzIiwicmVtb3ZlU3R5bGVzSXRlbSIsIl9yZW5kZXJTdHlsZXNJdGVtcyIsIkJ1dHRvblN0eWxlcyIsIl9nZXRTdHlsZXMiLCJidXR0b25TdHlsZXNMaXN0IiwiZm9ybWF0dGVkIiwiY2l0ZSIsIkJ1dHRvblN1YnNjcmlwdCIsInN1YnNjcmlwdCIsIkJ1dHRvblN1cGVyc2NyaXB0Iiwic3VwZXJzY3JpcHQiLCJCdXR0b25UYWJsZUNlbGwiLCJjZWxsIiwiY2VsbEluc2VydEJlZm9yZSIsImNlbGxJbnNlcnRBZnRlciIsImNlbGxEZWxldGUiLCJjZWxsTWVyZ2UiLCJjZWxsTWVyZ2VEb3duIiwiY2VsbE1lcmdlUmlnaHQiLCJjZWxsU3BsaXRIb3Jpem9udGFsIiwiY2VsbFNwbGl0VmVydGljYWwiLCJCdXR0b25UYWJsZUNvbHVtbiIsImNvbHVtbiIsImNvbHVtbkluc2VydEJlZm9yZSIsImNvbHVtbkluc2VydEFmdGVyIiwiY29sdW1uRGVsZXRlIiwiSU5QVVRfTkFNRVMiLCJDT0xTIiwiUk9XUyIsIk1JTklNVU1fR1JJRF9WQUxVRSIsIkJ1dHRvblRhYmxlRWRpdCIsIl9jcmVhdGVUYWJsZSIsInRhYmxlVXRpbHMiLCJUYWJsZSIsInRhYmxlQXR0cmlidXRlcyIsImNvbHMiLCJyb3dzIiwiX2hhbmRsZUNoYW5nZSIsImlucHV0TmFtZSIsInJvd3NSZWYiLCJjb2xzUmVmIiwidGltZSIsIkRhdGUiLCJub3ciLCJyb3dzSWQiLCJjb2xzSWQiLCJjb2x1bW5zIiwiYm9yZGVyIiwiY2VsbFBhZGRpbmciLCJjZWxsU3BhY2luZyIsIkJ1dHRvblRhYmxlSGVhZGluZyIsImFjdGl2ZUhlYWRpbmciLCJnZXRIZWFkaW5nIiwiYWN0aXZlSGVhZGluZ0ludHJvIiwiaGVhZGVycyIsImFjdGl2ZUhlYWRpbmdMYWJlbCIsImhlYWRlcnNOb25lIiwiaGVhZGVyc1JvdyIsImhlYWRlcnNDb2x1bW4iLCJoZWFkZXJzQm90aCIsIkJ1dHRvblRhYmxlUmVtb3ZlIiwiX3JlbW92ZVRhYmxlIiwiZGVsZXRlVGFibGUiLCJCdXR0b25UYWJsZVJvdyIsInJvd0luc2VydEJlZm9yZSIsInJvd0luc2VydEFmdGVyIiwicm93RGVsZXRlIiwiQnV0dG9uVGFibGUiLCJ0YWJsZSIsIkJ1dHRvblRhcmdldExpc3QiLCJsaXN0VGFyZ2V0cyIsIl9yZW5kZXJMaXN0VGFyZ2V0cyIsImxpbmtUYXJnZXRTZWxmIiwibGlua1RhcmdldEJsYW5rIiwibGlua1RhcmdldFBhcmVudCIsImxpbmtUYXJnZXRUb3AiLCJ0YXJnZXRzIiwiX2dldEFsbG93ZWRUYXJnZXRJdGVtcyIsIk1BWF9UV0VFVF9MRU5HVEgiLCJCdXR0b25Ud2l0dGVyIiwiX2dldEhyZWYiLCJ0d2l0dGVyIiwic2VsZWN0ZWRUZXh0IiwiZ2V0U2VsZWN0ZWRUZXh0Iiwic3Vic3RyaW5nIiwidmlhIiwidHdpdHRlckhyZWYiLCJCdXR0b25Vbm9yZGVyZWRsaXN0IiwiYnVsbGV0ZWRsaXN0IiwiQnV0dG9uVW5kZXJsaW5lIiwidW5kZXJsaW5lIiwiQnV0dG9uT2wiLCJCdXR0b25TdHlsZXNMaXN0SGVhZGVyIiwiQnV0dG9uVWwiLCJCdXR0b25BY3Rpb25TdHlsZSIsIkJ1dHRvbkNvbW1hbmRBY3RpdmUiLCJCdXR0b25Db21tYW5kIiwiaXNSZXF1aXJlZCIsIm1vZGlmaWVzU2VsZWN0aW9uIiwic2VsZWN0aW9uQ2hhbmdlIiwiQnV0dG9uS2V5c3Ryb2tlIiwiY29tcG9uZW50V2lsbE1vdW50IiwicmFuZG9tIiwidG9TdHJpbmciLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIkJ1dHRvblByb3BzIiwiQnV0dG9uU3RhdGVDbGFzc2VzIiwiaXNEaXNhYmxlZCIsIkJ1dHRvblN0eWxlIiwib25lT2ZUeXBlIiwiVG9vbGJhckJ1dHRvbnMiLCJnZXRUb29sYmFyQnV0dG9uR3JvdXBzIiwiV2lkZ2V0QXJyb3dCb3giLCJnZXRBcnJvd0JveENsYXNzZXMiLCJXaWRnZXREcm9wZG93biIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJfbmV4dFByb3BzIiwiV2lkZ2V0RXhjbHVzaXZlIiwiV2lkZ2V0Rm9jdXNNYW5hZ2VyIiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJXaWRnZXRJbnRlcmFjdGlvblBvaW50IiwiV2lkZ2V0UG9zaXRpb24iLCJtaXhpbnMiLCJnZXREZWZhdWx0UHJvcHMiLCJjYW5jZWxBbmltYXRpb24iLCJoYWxmV2lkdGgiLCJfYW5pbWF0ZSIsInNob3ciLCJ1cGRhdGVQb3NpdGlvbiIsIlVJIiwiX29uRGlzbWlzc1Rvb2xiYXJGb2N1cyIsImhpZGRlbiIsIl9vbkVkaXRvckludGVyYWN0aW9uIiwiX29uQWN0aW9uUGVyZm9ybWVkIiwiX29uRWRpdG9yS2V5IiwiX21vdXNlZG93bkxpc3RlbmVyIiwiX3NldFVJSGlkZGVuIiwiX2tleURvd25MaXN0ZW5lciIsImRlYm91bmNlIiwicHJldlByb3BzIiwicHJldlN0YXRlIiwibWVzc2FnZSIsIl9nZXRBdmFpbGFibGVUb29sYmFyc01lc3NhZ2UiLCJhcmlhVXBkYXRlIiwiX2FyaWFVcGRhdGVUZW1wbGF0ZXMiLCJ0ZW1wbGF0ZSIsIl9nZXRBcmlhVXBkYXRlcyIsImFyaWFVcGRhdGVzIiwibm9Ub29sYmFyIiwiYXJpYVVwZGF0ZU5vVG9vbGJhciIsIm9uZVRvb2xiYXIiLCJhcmlhVXBkYXRlT25lVG9vbGJhciIsIm1hbnlUb29sYmFycyIsImFyaWFVcGRhdGVNYW55VG9vbGJhcnMiLCJ0b29sYmFyc05vZGVMaXN0IiwidG9vbGJhck5hbWVzIiwidG9vbGJhciIsIl9nZXRBcmlhVXBkYXRlVGVtcGxhdGUiLCJvdXRwdXQiLCJqb2luIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRldGFjaCIsIl9ldmVudCIsImdldFNlbGVjdGlvbkRhdGEiLCJkb21FdmVudCIsImFsdEtleSIsInRhcmdldE5vZGUiLCJjb250YWlucyIsIlRvb2xiYXJBZGQiLCJUb29sYmFyU3R5bGVzIiwiUE9TSVRJT05fTEVGVCIsIlBPU0lUSU9OX1JJR0hUIiwiX3VwZGF0ZVBvc2l0aW9uIiwiX3ByZXZQcm9wcyIsIl9wcmV2U3RhdGUiLCJpc0NvbnRlbnRFZGl0YWJsZSIsIl9nZXRCdXR0b25zIiwiX2dldFRvb2xiYXJDbGFzc05hbWUiLCJjbGllbnRSZWN0IiwiZ2V0Q2xpZW50UmVjdCIsIm9mZnNldExlZnQiLCJwb3NpdGlvbiIsImd1dHRlckV4Y2x1c2l2ZSIsImZsb29yIiwiY3VycmVudFNlbGVjdGlvbiIsIl9nZXRDdXJyZW50U2VsZWN0aW9uIiwiZ2V0QXJyb3dCb3hDbGFzc2VzRm4iLCJfZ2V0U2VsZWN0aW9uRnVuY3Rpb24iLCJjc3NDbGFzc2VzIiwiYnV0dG9uc0dyb3VwIiwic2VsZWN0aW9uVHlwZSIsImhhc0dyb3VwcyIsInNlbGVjdGlvbkZuIiwic2VsZWN0aW9uRnVuY3Rpb24iLCJ0ZXN0Rm4iLCJzZXRQb3NpdGlvbkZuIiwic2V0UG9zaXRpb24iLCJCVVRUT05fREVGUyIsImdlbmVyYXRlQnV0dG9uQnJpZGdlIiwiYnV0dG9uRGVmaW5pdGlvbiIsIkJ1dHRvbkJyaWRnZSIsImJ1dHRvbkNvbW1hbmQiLCJidXR0b25PbkNsaWNrIiwib25DbGljayIsImJ1dHRvbkNsYXNzTmFtZSIsImJ1dHRvbkRpc3BsYXlOYW1lIiwiYnV0dG9uTGFiZWwiLCJidXR0b25UeXBlIiwiaWNvblN0eWxlIiwiY3NzU3R5bGUiLCJza2luIiwiZ2V0SWNvblN0eWxlIiwiY3NzU3R5bGVQYXJ0cyIsImJhY2tncm91bmRJbWFnZSIsImJhY2tncm91bmRQb3NpdGlvbiIsImJhY2tncm91bmRTaXplIiwiZGlzcGxheU5hbWUiLCJVSV9CVVRUT04iLCJyZXF1aXJlcyIsImJlZm9yZUluaXQiLCJ1aSIsImFkZEJ1dHRvbiIsImFkZEhhbmRsZXIiLCJNRU5VQlVUVE9OX0RFRlMiLCJnZW5lcmF0ZU1lbnVCdXR0b25CcmlkZ2UiLCJtZW51QnV0dG9uTmFtZSIsIm1lbnVCdXR0b25EZWZpbml0aW9uIiwiTWVudUJ1dHRvbkJyaWRnZSIsInBhbmVsTWVudUJ1dHRvbkRpc3BsYXlOYW1lIiwiX2dldE1lbnVJdGVtcyIsIm9uTWVudSIsIm1lbnVJdGVtcyIsIm1lbnVJdGVtIiwiZ2V0TWVudUl0ZW0iLCJtZW51SXRlbURlZmluaXRpb24iLCJkZWZpbml0aW9uIiwibWVudUl0ZW1TdGF0ZSIsIlRSSVNUQVRFX0RJU0FCTEVEIiwiVUlfTUVOVV9CVVRUT04iLCJhZGRNZW51QnV0dG9uIiwiVUlfTUVOVUJVVFRPTiIsImdyb3VwcyIsImdyb3Vwc09yZGVyIiwiXyIsIm1lbnVHcm91cHMiLCJhZGRNZW51R3JvdXAiLCJvcmRlciIsImFkZE1lbnVJdGVtIiwiZ3JvdXAiLCJhZGRNZW51SXRlbXMiLCJkZWZpbml0aW9ucyIsIml0ZW1OYW1lIiwiaGFzT3duUHJvcGVydHkiLCJyZW1vdmVNZW51SXRlbSIsIlBBTkVMX01FTlVfREVGUyIsImdlbmVyYXRlUGFuZWxNZW51QnV0dG9uQnJpZGdlIiwicGFuZWxNZW51QnV0dG9uTmFtZSIsInBhbmVsTWVudUJ1dHRvbkRlZmluaXRpb24iLCJQYW5lbE1lbnVCdXR0b25CcmlkZ2UiLCJwYW5lbCIsIl9nZXRQYW5lbCIsInBhbmVsTWVudUJ1dHRvbk9uQmxvY2siLCJvbkJsb2NrIiwiaGlkZSIsImJsb2NrRWxlbWVudCIsImJsb2NrIiwiZ2V0SHRtbCIsIlVJX1BBTkVMQlVUVE9OIiwiYWRkUGFuZWxNZW51QnV0dG9uIiwiUklDSF9DT01CT19ERUZTIiwiZ2VuZXJhdGVSaWNoQ29tYm9CcmlkZ2UiLCJyaWNoQ29tYm9OYW1lIiwicmljaENvbWJvRGVmaW5pdGlvbiIsIlJpY2hDb21ib0JyaWRnZSIsImN1cnJlbnRWYWx1ZSIsImVkaXRvckNvbWJvIiwibmV3VmFsdWUiLCJjdXJyZW50VGFyZ2V0IiwicHJldmlldyIsIl9pdGVtcyIsInNldFZhbHVlIiwiX3NldFZhbHVlIiwiaW5pdCIsIm9uUmVuZGVyIiwiX2NhY2hlVmFsdWUiLCJyaWNoQ29tYm9MYWJlbCIsIl9nZXRJdGVtcyIsInJpY2hDb21ibyIsIlVJX1JJQ0hDT01CTyIsImFkZFJpY2hDb21ibyIsIm9yaWdpbmFsVUlBZGRGbiIsInR5cGVIYW5kbGVyIiwiaGFuZGxlcnMiLCJfX3Byb2Nlc3NpbmdQbHVnaW5fXyIsInRpbWVvdXQiLCJhcmdzIiwiZGVib3VuY2VIYW5kbGUiLCJjYWxsRm4iLCJjYWxsQXJncyIsImNhbGxDb250ZXh0IiwiUkVHRVhfQk9PS01BUktfU0NIRU1FIiwiUkVHRVhfRU1BSUxfU0NIRU1FIiwiUkVHRVhfVVJJX1NDSEVNRSIsIm1vdmVUb0VsZW1lbnRFZGl0RW5kIiwibmV4dE5vZGUiLCJnZXROZXh0RWRpdGFibGVOb2RlIiwiZXF1YWxzIiwiZ2V0Q29tbW9uQW5jZXN0b3IiLCJ3aGl0ZXNwYWNlIiwiZ2V0VGV4dCIsIm9mZnNldCIsIlVSSSIsImNvbGxhcHNlZCIsInRleHQiLCJpbnNlcnROb2RlIiwic2VsZWN0Tm9kZUNvbnRlbnRzIiwiX2dldENvbXBsZXRlVVJJIiwiYXBwbHlUb1JhbmdlIiwic2VsZWN0IiwiaXMiLCJnZXRDaGlsZHJlbiIsImNvdW50IiwiZ2V0SXRlbSIsInNocmluayIsIlNIUklOS19URVhUIiwiYWx3YXlzUmVtb3ZlRWxlbWVudCIsInNlbGVjdEVsZW1lbnQiLCJ1cmkiLCJzZXRBdHRyaWJ1dGVzIiwicmVtb3ZlQXR0cnMiLCJzZXRBdHRycyIsInJlbW92ZUF0dHJpYnV0ZXMiLCJ3cmFwUGx1Z2luTGlmZWN5Y2xlIiwibWV0aG9kcyIsIm1ldGhvZE5hbWUiLCJvdmVycmlkZSIsInBheWxvYWQiLCJwaGFzZSIsIm9yaWdpbmFsUGx1Z2luTWV0aG9kIiwiZmlsdGVyVW53YW50ZWREZXBlbmRlbmNpZXMiLCJyZXF1aXJlIiwibmFtZXMiLCJzY29wZSIsInBsdWdpbnNMb2FkIiwiU2VsZWN0aW9uUmVnaW9uIiwiY3JlYXRlU2VsZWN0aW9uRnJvbVBvaW50IiwiY3JlYXRlU2VsZWN0aW9uRnJvbVJhbmdlIiwic3RhcnRYIiwic3RhcnRZIiwiZW5kWCIsImVuZFkiLCJlbmQiLCJlbmRDb250YWluZXIiLCJlbmRPZmZzZXQiLCJzdGFydCIsInN0YXJ0T2Zmc2V0IiwiY2FyZXRQb3NpdGlvbkZyb21Qb2ludCIsIm9mZnNldE5vZGUiLCJjcmVhdGVSYW5nZSIsImNhcmV0UmFuZ2VGcm9tUG9pbnQiLCJjcmVhdGVUZXh0UmFuZ2UiLCJlbmRSYW5nZSIsImR1cGxpY2F0ZSIsInNldEVuZFBvaW50IiwiZ2V0Q2FyZXRSZWdpb24iLCJib29rbWFya05vZGVFbCIsInN0YXJ0Tm9kZSIsInNjcm9sbFBvcyIsImdldFNjcm9sbFBvc2l0aW9uIiwiZ2V0U2VsZWN0aW9uUmVnaW9uIiwiZ2V0Q2xpZW50UmVjdHNSZWdpb24iLCJnZXRTZWxlY3Rpb25EaXJlY3Rpb24iLCJpc1NlbGVjdGlvbkVtcHR5IiwiZ2V0VHlwZSIsIlNFTEVDVElPTl9OT05FIiwibmF0aXZlU2VsZWN0aW9uIiwiZGVmYXVsdFJlY3QiLCJjbGllbnRSZWN0cyIsIkluZmluaXR5IiwiZ2V0Q2xpZW50UmVjdHMiLCJyYW5nZUNvdW50IiwiZ2V0UmFuZ2VBdCIsImFuY2hvck5vZGUiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsImZvY3VzTm9kZSIsImFuY2hvck9mZnNldCIsImZvY3VzT2Zmc2V0IiwiTm9kZSIsIkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyIsImF0dHIiLCJJRV9OT05fRElSRUNUTFlfRURJVEFCTEVfRUxFTUVOVCIsImNvbCIsImNvbGdyb3VwIiwidGJvZHkiLCJ0ZCIsInRmb290IiwidGgiLCJ0aGVhZCIsInRyIiwiSEVBRElOR19CT1RIIiwiSEVBRElOR19DT0wiLCJIRUFESU5HX05PTkUiLCJIRUFESU5HX1JPVyIsIl9jcmVhdGVFbGVtZW50IiwiYXBwZW5kIiwiaiIsImFwcGVuZEJvZ3VzIiwic2V0SGVhZGluZyIsImhlYWRpbmciLCJmaXJzdENlbGwiLCJjZWxscyIsIm1vdmVUb1Bvc2l0aW9uIiwiUE9TSVRJT05fQUZURVJfU1RBUlQiLCJ3ZWJraXQiLCJOT0RFX0VMRU1FTlQiLCJpc0VkaXRhYmxlIiwiaXNSZWFkT25seSIsImhhc0F0dHJpYnV0ZSIsImdldFBhcmVudCIsInJvd0hlYWRpbmdTZXR0aW5ncyIsInRIZWFkIiwiY29sSGVhZGluZ1NldHRpbmdzIiwibm9kZU5hbWUiLCJoZWFkaW5nU2V0dGluZ3MiLCJwYXJlbnQiLCJnZXRDaGlsZENvdW50IiwiUE9TSVRJT05fQkVGT1JFX1NUQVJUIiwibmV3Q2VsbCIsInRhYmxlSGVhZCIsInRhYmxlQm9keSIsImdldEVsZW1lbnRzQnlUYWciLCJ0YWJsZUhlYWRpbmciLCJoYWRDb2xIZWFkaW5nIiwibmVlZENvbEhlYWRpbmciLCJuZWVkUm93SGVhZGluZyIsInRhYmxlRmlyc3RSb3ciLCJ0YWJsZUZpcnN0Um93Q2hpbGRDb3VudCIsImdldENoaWxkIiwicmVuYW1lTm9kZSIsImNyZWF0ZVRIZWFkIiwicHJldmlvdXNGaXJzdFJvdyIsImdldEZpcnN0IiwibmV3Rmlyc3RSb3ciLCJuZXdGaXJzdFJvd0NoaWxkQ291bnQiLCJyZW1vdmVBdHRyaWJ1dGUiLCJpbnNlcnRCZWZvcmUiLCJoYXNDb2xIZWFkaW5nIiwiaGVhZGluZ0NvbW1hbmRzIiwianNvbnAiLCJ1cmxUZW1wbGF0ZSIsInVybFBhcmFtcyIsImVycm9yQ2FsbGJhY2siLCJjYWxsYmFja0tleSIsImdldE5leHROdW1iZXIiLCJqc29ucENhbGxiYWNrcyIsInJlc3BvbnNlIiwiY2xlYW5VcCIsInNjcmlwdEVsZW1lbnQiLCJnZXRCb2R5IiwiY2FuY2VsIiwic2ltdWxhdGUiLCJldmVudEluc3RhbmNlIiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiYXJpYVN0YXRlIiwiYXJpYUVsZW1lbnQiLCJfY3JlYXRlQXJpYUVsZW1lbnQiLCJ1aVRhc2tzVGltZW91dCIsInVpY29yZSIsImhhbmRsZVVJIiwiYWxsb3dFc2MiLCJoYW5kbGVBcmlhIiwiaW5uZXJIVE1MIiwiaGFuZGxlTW91c2VMZWF2ZSIsImFlVUlOb2RlcyIsImZvdW5kIiwicmVsYXRlZFRhcmdldCIsImZvY3VzSGFuZGxlciIsImF0dGFjaExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJzdGF0dXNFbGVtZW50IiwiX19jb25maWdfXyIsIl9fQVRUUlNfXyIsImN1cnJlbnRBdHRyIiwiX2lzSW5pdGlhbGl6ZWQiLCJfaW5pdCIsImN1clZhbHVlIiwiX2NhbGxTdHJpbmdPckZ1bmN0aW9uIiwic2V0Iiwic3RyaW5nT3JGdW5jdGlvbiIsImhhc0RlZmF1bHRWYWx1ZSIsImhhc1Bhc3NlZFZhbHVlVmlhQ29uZmlnIiwidmFsdWVGbiIsIl9jYWxsQ2hhaW4iLCJ3YXQiLCJhcnIiLCJjdG9yIiwicmV2ZXJzZSIsImlzRmluaXRlIiwidmFsdWVUeXBlIiwicmVjZWl2ZXIiLCJzdXBwbGllciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInN1cHBsaWVyUHJvdG8iLCJyZWNlaXZlclByb3RvIiwiRHJhZ0V2ZW50IiwiZXZlbnRzIiwia2V5ZG93biIsIm1vdXNlbW92ZSIsIm1vdXNldXAiLCJzdGFydFBvcyIsImNsaWVudFgiLCJjbGllbnRZIiwiY2xhc3NMaXN0Iiwib25TdGFydCIsImN1cnJlbnRQb3MiLCJkZWx0YSIsImFsdCIsImN0cmwiLCJzaGlmdEtleSIsIm9uRHJhZyIsIndoaWNoIiwicmVsZWFzZSIsIm9uQ29tcGxldGUiLCJvblJlbGVhc2UiLCJJTUFHRV9IQU5ETEVTIiwiUE9TSVRJT05fRUxFTUVOVF9GTiIsImJsIiwiaGFuZGxlIiwiYm94IiwicG9zaXRpb25FbGVtZW50IiwiYnIiLCJybSIsInJvdW5kIiwidGwiLCJfYm94IiwiZ2V0Qm91bmRpbmdCb3giLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsIlJlc2l6ZXIiLCJjb250YWluZXIiLCJoYW5kbGVzIiwicHJldmlld0JveCIsImhhbmRsZU5hbWUiLCJjcmVhdGVIYW5kbGUiLCJzaG93SGFuZGxlcyIsImVsZW1lbnRzIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImhpZGVIYW5kbGVzIiwiZHJhZyIsInNob3dQcmV2aWV3IiwiaXNEcmFnZ2luZyIsImNhbGN1bGF0ZVNpemUiLCJlZGl0b3JCb3VuZHMiLCJ1cGRhdGVQcmV2aWV3IiwidXBkYXRlSGFuZGxlcyIsImhpZGVQcmV2aWV3IiwicmVzaXplQ29tcGxldGUiLCJyYXRpbyIsImlzSUUiLCJfb25EcmFnRW50ZXIiLCJfb25EcmFnT3ZlciIsIl9vbkRyYWdEcm9wIiwiX29uUGFzdGUiLCJfaGFuZGxlRmlsZXMiLCJfcHJvY2Vzc0ZpbGUiLCJ0cmFuc2ZlckZpbGVzIiwiZGF0YVRyYW5zZmVyIiwiX3ByZXZlbnRFdmVudCIsImNsaXBib2FyZERhdGEiLCJwYXN0ZWREYXRhIiwiaW1hZ2VGaWxlIiwiZ2V0QXNGaWxlIiwiYmluIiwidXNlckFnZW50IiwiS0VZX0JBQ0siLCJLRVlfQ09NTUEiLCJLRVlfU0VNSUNPTE9OIiwiS0VZX1NQQUNFIiwiREVMSU1JVEVSUyIsIlJFR0VYX0xBU1RfV09SRCIsIlJFR0VYX1VSTCIsIlJFR0VYX0VNQUlMIiwiX29uS2V5VXAiLCJtZXRob2QiLCJkYXRhVmFsdWUiLCJSZWdFeHAiLCJfaXNWYWxpZFVSTCIsIl9pc1ZhbGlkRW1haWwiLCJfZ2V0TGFzdFdvcmQiLCJwcmV2aW91c1RleHQiLCJfY3VycmVudEtleUNvZGUiLCJwcmV2aW91c05vZGUiLCJnZXRQcmV2aW91cyIsImxhc3RDaGlsZCIsImdldExhc3QiLCJfc3RhcnRDb250YWluZXIiLCJfb2Zmc2V0IiwibGFzdFdvcmQiLCJlbWFpbCIsIl9vbktleURvd24iLCJfY2tMaW5rIiwiX3JlcGxhY2VDb250ZW50QnlMaW5rIiwiY29udGVudCIsImNrTGluayIsImxpbmtOb2RlIiwiX3N1YnNjcmliZVRvS2V5RXZlbnQiLCJuZXh0RWRpdGFibGVOb2RlIiwiZW5jbG9zZWROb2RlIiwiZ2V0RW5jbG9zZWROb2RlIiwiY2FyZXRPZmZzZXQiLCJnZXROZXh0IiwibmV3UmFuZ2UiLCJzZXRFbmRBZnRlciIsIkRFRkFVTFRfQ09ORklHIiwicmVnZXgiLCJfY2hlY2tGb3JCYWNrc3BhY2VBbmRVbmRvIiwiaW5zZXJ0SHRtbCIsImJ1bGxldCIsIl9nZXRMaXN0Q29uZmlnIiwiY29uZmlnUmVnZXgiLCJhdXRvbGlzdCIsInRleHRDb250YWluZXIiLCJyZWdleExlbiIsImF1dG9saXN0Q2ZnIiwicmVnZXhJdGVtIiwiX2NyZWF0ZUxpc3QiLCJsaXN0Q29uZmlnIiwic2V0VGV4dCIsImJvdGgiLCJzY2FsZSIsImJtIiwibG0iLCJ0bSIsIklNQUdFX1NOQVBfVE9fU0laRSIsImlzRmlyZWZveCIsImRvY3VtZW50RWxlbWVudCIsImlzV2ViS2l0IiwiZW5hYmxlUGx1Z2luIiwiYWRkQ3NzIiwib25Mb2FkIiwic25hcFRvU2l6ZSIsImltYWdlU2NhbGVSZXNpemUiLCJyZXNpemVyIiwibW91c2VEb3duTGlzdGVuZXIiLCJlIiwiaXNIYW5kbGUiLCJpbml0RHJhZyIsImh0bWwiLCJzZWxmIiwicmVzaXplRWxlbWVudCIsInJlc2l6ZVRpbWVvdXQiLCJuIiwib3RoZXJJbWFnZXMiLCJ0b0FycmF5Iiwic3BsaWNlIiwib3RoZXJzIiwib3RoZXIiLCJsZW4iLCJjdHgiLCJTdHJpbmciLCJhbGlnbm1lbnRzT2JqIiwiY2VudGVyIiwiY3Vyc29yIiwicmVnZXhQZXJjZW50IiwiaGlkcGkiLCJpY29ucyIsIndpZGdldERlZiIsIndpZGdldHMiLCJpbml0T24iLCJhbGlnbkNsYXNzZXMiLCJpbWFnZTJfYWxpZ25DbGFzc2VzIiwiY2FwdGlvbmVkQ2xhc3MiLCJpbWFnZTJfY2FwdGlvbmVkQ2xhc3MiLCJoZWxwZXJzIiwiaW1hZ2UyIiwiaGFzQ2FwdGlvbiIsImNhcHRpb24iLCJyZWFkeSIsImNoZWNrSGFzTmF0dXJhbFJhdGlvIiwid3JhcHBlciIsImFsaWduIiwiYWxpZ25FbGVtZW50Iiwic2V0RGF0YSIsImltYWdlMl9kaXNhYmxlUmVzaXplciIsInNldHVwUmVzaXplciIsImdldFN0eWxlYWJsZUVsZW1lbnQiLCJnZXRXaWRnZXRBbGxvd2VkQ29udGVudCIsImNvbnRlbnRUcmFuc2Zvcm1hdGlvbnMiLCJmZWF0dXJlcyIsImNoZWNrRmVhdHVyZSIsImNvbnRlbnRlZGl0YWJsZSIsIm9sZERhdGEiLCJjIiwiY2xhc3NlcyIsImRpbWVuc2lvbiIsInNldERpbWVuc2lvbnMiLCJkb3duY2FzdCIsImRvd25jYXN0V2lkZ2V0RWxlbWVudCIsImRyYWdnYWJsZSIsImVkaXRhYmxlcyIsInNlbGVjdG9yIiwiZ2V0V2lkZ2V0RmVhdHVyZXMiLCJnZXRDbGFzc2VzIiwiY2xhc3NSZWdleCIsInJlcG9zaXRvcnkiLCJwYXJzZUVsZW1lbnRDbGFzc2VzIiwiZ2V0TGFiZWwiLCJwYXRoTmFtZSIsInJlcXVpcmVkQ29udGVudCIsInN0eWxlYWJsZUVsZW1lbnRzIiwidXBjYXN0IiwidXBjYXN0V2lkZ2V0RWxlbWVudCIsIm5hdHVyYWwiLCJnZXROYXR1cmFsIiwiY2xpZW50SGVpZ2h0IiwiZGltZW5zaW9ucyIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaCIsImltZyIsIkltYWdlIiwiaGVpZ2giLCJpc0NlbnRlcldyYXBwZXIiLCJjZW50ZXJXcmFwcGVyQ2hlY2tlciIsImZpZ3VyZSIsInJlcGxhY2VXaXRoIiwiaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZSIsImQiLCJhdHRyc0hvbGRlciIsInJlc2l6ZVdyYXBwZXIiLCJwYXJzZUNzc1RleHQiLCJ3cmFwV2l0aCIsImh0bWxQYXJzZXIiLCJpc0VtcHR5Iiwid3JpdGVDc3NUZXh0IiwidmFsaWRDaGlsZHJlbiIsImRpdiIsInAiLCJjaGlsZCIsImVudGVyTW9kZSIsIkVOVEVSX1AiLCJ3aWRnZXQiLCJkb2MiLCJpbWFnZU9yTGluayIsIm9sZFJlc2l6ZVdyYXBwZXIiLCJmYWN0b3IiLCJldnQiLCJzY3JlZW5YIiwic2NyZWVuWSIsInN0YXJ0V2lkdGgiLCJzdGFydEhlaWdodCIsImxpc3RlbmVycyIsImN1cnNvckNsYXNzIiwibmF0aXZlRXZ0IiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJ1cGRhdGVEYXRhIiwibW92ZURpZmZYIiwibW92ZURpZmZZIiwiYXR0YWNoVG9Eb2N1bWVudHMiLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VVcCIsImNvbGxlY3Rpb24iLCJnbG9iYWxEb2MiLCJsIiwid2lkZ2V0RWxlbWVudCIsInNjcm9sbFBvc2l0aW9uIiwicnVsZXMiLCJmaWdjYXB0aW9uIiwidGVtcGxhdGVCbG9jayIsImFmdGVySW5pdCIsImludGVncmF0ZSIsImFsaWduQ29tbWFuZEludGVncmF0b3IiLCJhZV9kcmFncmVzaXplX2llMTFfYWxpZ25DbGFzc2VzIiwiYWVfZHJhZ3Jlc2l6ZV9pZTExX2NhcHRpb25lZENsYXNzIiwiZGVmbGF0ZSIsImRlZmxhdGVkIiwiZm9jdXNlZCIsImluZmxhdGUiLCJhY3RpdmVFbnRlck1vZGUiLCJtb3ZlIiwic2V0V3JhcHBlckFsaWduIiwic2hpZnRTdGF0ZSIsIm5ld0RhdGEiLCJhZV9kcmFncmVzaXplX2llMTEiLCJnZXRMaW5rQXR0cmlidXRlc1BhcnNlciIsImFkdmFuY2VkIiwiYWR2Q1NTQ2xhc3NlcyIsInRyaW0iLCJhZV9kcmFncmVzaXplX2llMTFfZGlzYWJsZVJlc2l6ZXIiLCJkcmFnSGFuZGxlclN0eWxlIiwiZHJhZ0hhbmRsZXJDb250YWluZXIiLCJzdGF0ZVNoaWZ0ZXIiLCJUUklTVEFURV9PRkYiLCJ1bmxpbmsiLCJzaGlmdGFibGVzIiwic3RhdGVBY3Rpb25zIiwib2xkVmFsdWUiLCJjaGFuZ2VkIiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0Iiwid3JhcEluQ2VudGVyaW5nIiwidW53cmFwRnJvbUNlbnRlcmluZyIsInNldFN0eWxlIiwiY2FwdGlvblBsYWNlaG9sZGVyIiwicmVwbGFjZVNhZmVseSIsIm5lZWRzRGVmbGF0ZSIsIm5ld0VsIiwidW53cmFwRnJvbUxpbmsiLCJ3cmFwSW5MaW5rIiwiZ2V0TGlua0F0dHJpYnV0ZXNHZXR0ZXIiLCJyZW1vdmVkIiwiYXR0cmlic0FuZFN0eWxlcyIsImxpbmtEYXRhIiwicmVwbGFjaW5nIiwicmVwbGFjZWQiLCJpbnNlcnRFbGVtZW50SW50b1JhbmdlIiwibmF0dXJhbEhlaWdodCIsImdldExpbmtBdHRyaWJ1dGVzIiwicGFyc2VMaW5rQXR0cmlidXRlcyIsInF1ZXJ5U2VsZWN0b3IiLCJpbWFnZVN0eWxlcyIsImhlaWdodFN0eWxlcyIsIndpZHRoU3R5bGVzIiwicmVzaXplck5FIiwicmVzaXplck5XIiwicmVzaXplclNFIiwicmVzaXplclNXIiwiZmFjdG9yWCIsImZhY3RvclkiLCJhZGp1c3RUb1giLCJhZGp1c3RUb1kiLCJyZW1vdmVXaWRnZXRBbGlnbm1lbnQiLCJpbWFnZUFsaWdubWVudCIsImV4ZWNDYWxsYmFja3MiLCJlbmFibGVkIiwicmVmcmVzaCIsImdldEZvY3VzZWRXaWRnZXQiLCJhbGxvd2VkIiwicmVnaXN0ZXJlZCIsIlJFR0VYX0hUVFAiLCJSRUdFWF9ERUZBVUxUX0xJTksiLCJERUZBVUxUX0FFX0VNQkVEX1VSTF9UUEwiLCJERUZBVUxUX0FFX0VNQkVEX1dJREdFVF9UUEwiLCJERUZBVUxUX0FFX0VNQkVEX0RFRkFVTFRfTElOS19UUEwiLCJBRV9FTUJFRF9VUkxfVFBMIiwiZW1iZWRVcmxUZW1wbGF0ZSIsIkFFX0VNQkVEX1dJREdFVF9UUEwiLCJlbWJlZFdpZGdldFRwbCIsIkFFX0VNQkVEX0RFRkFVTFRfTElOS19UUEwiLCJlbWJlZExpbmtEZWZhdWx0VHBsIiwiZGVmYXVsdEVtYmVkV2lkZ2V0VXBjYXN0Rm4iLCJtYXNrIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiY3JlYXRlQVRhZyIsInNldEh0bWwiLCJhVGFnSHRtbCIsImVtYmVkV2lkZ2V0VXBjYXN0Rm4iLCJISUdIX1BSSU9SSVRZIiwiYWRkRWxlbWVudENhbGxiYWNrIiwiRklMVEVSX1NLSVBfVFJFRSIsIkRFRkFVTFRfTEZSX0VNQkVEX1dJREdFVF9UUEwiLCJFTUJFRF9BTElHTk1FTlQiLCJDRU5URVIiLCJMRUZUIiwiUklHSFQiLCJBTElHTl9WQUxVRVMiLCJDRU5URVJFRF9FTUJFRF9TVFlMRSIsImdldEVtYmVkQWxpZ25tZW50IiwiZW1iZWRBbGlnbm1lbnQiLCJjZW50ZXJlZEVtYmVkIiwiZXZlcnkiLCJzdHlsZUNoZWNrIiwidmVuZG9yUHJlZml4ZXMiLCJ2ZW5kb3JQcmVmaXgiLCJyZW1vdmVFbWJlZEFsaWdubWVudCIsInNldEVtYmVkQWxpZ25tZW50Iiwid3JhcHBlckVsZW1lbnQiLCJwYXJlbnRFbGVtZW50IiwicHdpZHRoIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiaWZyYW1lRWxlbWVudCIsInNlbGVjdFdpZGdldCIsInJvb3QiLCJmaW5kIiwiZWxlbWVudExpc3QiLCJjdXJyZW50QWxpZ25tZW50IiwiY3VycmVudEVsZW1lbnQiLCJMRlJfRU1CRURfV0lER0VUX1RQTCIsInByb3ZpZGVycyIsInByb3ZpZGVyIiwic2NoZW1lIiwiZ2VuZXJhdGVFbWJlZENvbnRlbnQiLCJoZWxwTWVzc2FnZSIsInZpZGVvUGxheWJhY2tEaXNhYmxlZCIsImhlbHBNZXNzYWdlSWNvbiIsIkxpZmVyYXkiLCJVdGlsIiwiZ2V0TGV4aWNvbkljb25UcGwiLCJ1cGNhc3RXaWRnZXQiLCJpZnJhbWUiLCJlbWJlZENvbnRlbnQiLCJnZXRPdXRlckh0bWwiLCJ3aWRnZXRGcmFnbWVudCIsImZyYWdtZW50IiwiZnJvbUh0bWwiLCJzaG93RXJyb3IiLCJlcnJvck1zZyIsInZhbGlkUHJvdmlkZXIiLCJlbWJlZElkIiwiX3NlbGVjdEVtYmVkV2lkZ2V0IiwicGxhdGZvcm1Ob3RTdXBwb3J0ZWQiLCJlbnRlclZhbGlkVXJsIiwic3R5bGVzSlNPTiIsIl9lcnJvciIsImJvdW5kcyIsImFsaWduVmFsdWUiLCJzZWxlY3RlZEVtYmVkIiwic2VuZGVyIiwiSU1BR0VfQUxJR05NRU5UIiwiSU1BR0VfU1RZTEVfQUxJR05NRU5UIiwiZ2V0SW1hZ2VBbGlnbm1lbnQiLCJjZW50ZXJlZEltYWdlIiwiaW1hZ2VDb250YWluZXIiLCJ0ZXh0QWxpZ24iLCJyZW1vdmVJbWFnZUFsaWdubWVudCIsInNldEltYWdlQWxpZ25tZW50IiwicmVmcmVzaENvbW1hbmRzIiwiZW1iZWR1cmwiLCJickZpbGxlciIsIm5lZWRzQnJGaWxsZXIiLCJlbnRlck1vZGVFbXB0eVZhbHVlIiwiX2NoZWNrRW1wdHlEYXRhIiwiX3JlbW92ZVBsYWNlaG9sZGVyQ2xhc3MiLCJlZGl0YWJsZU5vZGUiLCJpbm5lckh0bWwiLCJlZGl0b3JOb2RlIiwiREVGQVVMVF9QUklPUklUWSIsInNlbGVjdGlvbktleXN0cm9rZSIsInB4VW5pdCIsImNzc0xlbmd0aCIsImdldFdpZHRoIiwiZ2V0Qm9yZGVyV2lkdGgiLCJzaWRlIiwiY29tcHV0ZWQiLCJib3JkZXJNYXAiLCJ0aGluIiwibWVkaXVtIiwidGhpY2siLCJnZXRNYXN0ZXJQaWxsYXJSb3ciLCIkcm93cyIsIm1heENlbGxzIiwiY2VsbHNDb3VudCIsIiRlbGVjdGVkIiwiJHRyIiwiYnVpbGRUYWJsZUNvbHVtblBpbGxhcnMiLCJwaWxsYXJzIiwicGlsbGFySW5kZXgiLCJydGwiLCJ0Qm9kaWVzIiwidGJvZHlQb3NpdGlvbiIsImdldERvY3VtZW50UG9zaXRpb24iLCJuZXh0VGQiLCJjb2xTcGFuIiwicGlsbGFyTGVmdCIsInBpbGxhclJpZ2h0IiwicGlsbGFyV2lkdGgiLCJnZXRQaWxsYXJBdFBvc2l0aW9uIiwicG9zaXRpb25YIiwicGlsbGFyIiwiQ29sdW1uUmVzaXplciIsImN1cnJlbnRTaGlmdCIsImxlZnRTaGlmdEJvdW5kYXJ5IiwibGVmdFNpZGVDZWxscyIsInJlc2l6aW5nIiwicmlnaHRTaGlmdEJvdW5kYXJ5IiwicmlnaHRTaWRlQ2VsbHMiLCJpc1Jlc2l6aW5nIiwicG9zWCIsInJlc2l6ZXJOZXdQb3NpdGlvbiIsIm9uTW91c2VEb3duIiwicmVzaXplU3RhcnQiLCJjb2x1bW5JbmRleCIsImJ1aWxkVGFibGVNYXAiLCJsZWZ0Q29sdW1uQ2VsbHMiLCJyaWdodENvbHVtbkNlbGxzIiwibGVmdE1pblNpemUiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJyaWdodE1pblNpemUiLCJsZWZ0Q2VsbCIsInJpZ2h0Q2VsbCIsInNldE9wYWNpdHkiLCJyZXNpemVFbmQiLCJyZXNpemVDb2x1bW4iLCJyZW1vdmVDdXN0b21EYXRhIiwibGVmdE9sZFdpZHRoIiwicmlnaHRPbGRXaWR0aCIsInRhYmxlV2lkdGgiLCJzaXplU2hpZnQiLCJnZXRQYWdlT2Zmc2V0IiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiY2xlYXJQaWxsYXJzQ2FjaGUiLCJkZXN0IiwidG9FbGVtZW50IiwiaXNJbmxpbmUiLCJnZXRDdXN0b21EYXRhIiwic2V0Q3VzdG9tRGF0YSIsImNlbGxOb2RlUmVnZXgiLCJnZXRTZWxlY3RlZENlbGxzIiwicmV0dmFsIiwiZGF0YWJhc2UiLCJtb3ZlT3V0T2ZDZWxsR3VhcmQiLCJzZXRNYXJrZXIiLCJuZWFyZXN0Q2VsbCIsIndhbGtlciIsImd1YXJkIiwiZHRkIiwiY2xlYXJBbGxNYXJrZXJzIiwiZ2V0Rm9jdXNFbGVtZW50QWZ0ZXJEZWxDZWxscyIsImNlbGxzVG9EZWxldGUiLCJsYXN0IiwiZm9jdXNlZENlbGwiLCJpbnNlcnRSb3ciLCJnZXREb2N1bWVudCIsInN0YXJ0Um93Iiwic3RhcnRSb3dJbmRleCIsInJvd0luZGV4IiwibGFzdENlbGwiLCJlbmRSb3dJbmRleCIsInJvd1NwYW4iLCJlbmRSb3ciLCJjbG9uZVJvdyIsIm5leHRSb3ciLCJuZXdSb3ciLCJjbG9uZSIsImluc2VydEFmdGVyIiwiY2VsbEluZGV4IiwiZGVsZXRlUm93cyIsInNlbGVjdGlvbk9yUm93Iiwicm93c1RvRGVsZXRlIiwibWFwUm93IiwiY2VsbFJvd0luZGV4IiwibmV4dE1hcFJvdyIsImN1cnNvclBvc2l0aW9uIiwiZ2V0Q2VsbENvbEluZGV4IiwiaXNTdGFydCIsInJvd0NlbGxzIiwiY29sSW5kZXgiLCJtYXBDZWxsIiwiZ2V0Q29sdW1uc0luZGljZXMiLCJpbnNlcnRDb2x1bW4iLCJzdGFydENvbCIsImxhc3RDb2wiLCJjbG9uZUNvbCIsIm5leHRDb2wiLCJuZXh0Q2VsbCIsImluc2VydGVkQ2VsbHMiLCJkZWxldGVDb2x1bW5zIiwic2VsZWN0aW9uT3JDZWxsIiwic3RhcnRDb2xJbmRleCIsImVuZENvbEluZGV4IiwiZmlyc3RSb3dDZWxscyIsImluc2VydENlbGwiLCJzdGFydEVsZW1lbnQiLCJkZWxldGVDZWxscyIsImNlbGxUb0ZvY3VzIiwicGxhY2VDdXJzb3JJbkNlbGwiLCJ0cmltQ2VsbCIsImJvZ3VzIiwiZ2V0Qm9ndXMiLCJwbGFjZUF0RW5kIiwiZG9jSW5uZXIiLCJkb2NPdXRlciIsImNvbGxhcHNlIiwiY2VsbEluUm93IiwidGFibGVNYXAiLCJvUm93IiwiY2VsbEluQ29sIiwib0NvbCIsInIiLCJtZXJnZUNlbGxzIiwibWVyZ2VEaXJlY3Rpb24iLCJpc0RldGVjdCIsImNvbW1vbkFuY2VzdG9yIiwibWFwSGVpZ2h0IiwibWFwV2lkdGgiLCJzdGFydENvbHVtbiIsInRhcmdldENlbGwiLCJyb3dzcGFuIiwiY29sc3BhbiIsImVyIiwibGFzdFJvd0luZGV4IiwidG90YWxSb3dTcGFuIiwidG90YWxDb2xTcGFuIiwiZnJhZyIsImRvY3VtZW50RnJhZ21lbnQiLCJjZWxsRmlyc3RDaGlsZCIsImlzQmxvY2tCb3VuZGFyeSIsIndoaXRlc3BhY2VzIiwibW92ZUNoaWxkcmVuIiwidHJzIiwibm9kZUxpc3QiLCJ0YWlsVHIiLCJ2ZXJ0aWNhbFNwbGl0Q2VsbCIsIm5ld1Jvd1NwYW4iLCJuZXdDZWxsUm93U3BhbiIsIm5ld1Jvd0luZGV4IiwiY2VpbCIsIm5ld0NlbGxUciIsIm5ld0NlbGxSb3ciLCJjYW5kaWRhdGVDZWxsIiwiY2VsbHNJblNhbWVSb3ciLCJob3Jpem9udGFsU3BsaXRDZWxsIiwibmV3Q29sU3BhbiIsIm5ld0NlbGxDb2xTcGFuIiwiY2VsbHNJblNhbWVDb2wiLCJjcmVhdGVEZWYiLCJkZWYiLCJjb250ZXh0U2Vuc2l0aXZlIiwiYWRkQ21kIiwiY21kIiwiYWRkRmVhdHVyZSIsImFSb3dzIiwiYU1hcCIsIm9DZWxsIiwiaUNvbFNwYW4iLCJpUm93U3BhbiIsInJzIiwiY3MiLCJ0YWJsZVNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcyIsIkRFRkFVTFRfR1VUVEVSIiwiY2VudGVyVG9vbGJhciIsInRvb2xiYXJOb2RlIiwiaGFsZk5vZGVXaWR0aCIsIndpZGdldFhZIiwiY2FyZXRQb3NpdGlvbiIsIm5vZGVUeXBlIiwiRUxFTUVOVF9OT0RFIiwic3RhcnRDb250YWluZXJDbGllbnRSZWN0IiwiZW5kUG9zaXRpb24iLCJpbWFnZVNlbGVjdGlvblNldFBvc2l0aW9uIiwidGFibGVTZWxlY3Rpb25TZXRQb3NpdGlvbiIsIl9pc1JhbmdlQXRFbGVtZW50RW5kIiwiZW1iZWRTZWxlY3Rpb25UZXN0IiwiZW1iZWRVcmxTZWxlY3Rpb25UZXN0IiwiaGVhZGluZ1RleHRTZWxlY3Rpb25UZXN0IiwiaGVhZGluZ3MiLCJzZWxlY3Rpb25FbXB0eSIsImxpbmtTZWxlY3Rpb25UZXN0IiwiZWxlbWVudElzTm90SW1hZ2UiLCJpbWFnZVNlbGVjdGlvblRlc3QiLCJoYXNJbWFnZSIsImlzSW1hZ2UiLCJ0ZXh0U2VsZWN0aW9uVGVzdCIsInRhYmxlU2VsZWN0aW9uVGVzdCIsImVtYmVkVXJsIiwiaGVhZGVyIiwiZnVsbCIsInNpbXBsZSJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHNCQUFzQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDLDZCQUE2QixtQkFBTyxDQUFDLHlGQUE0QjtBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsa0RBQVU7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLDREQUFlOztBQUVwQywyQkFBMkIsbUJBQU8sQ0FBQyx5RkFBNEI7QUFDL0QscUJBQXFCLG1CQUFPLENBQUMscUVBQWtCOztBQUUvQztBQUNBOztBQUVBLElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkJBQTZCO0FBQzdCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVLEtBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFC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Qyx1RkFBMkI7QUFDdEQsQ0FBQyxNQUFNLEVBSU47Ozs7Ozs7Ozs7Ozs7QUNsQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7OztBQUliLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYzs7QUFFNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNGQUFzRixhQUFhO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixlQUFlO0FBQzNHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7QUNsT2E7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsMEZBQStCO0FBQzFEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDREE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFDQTs7OztBQUVBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBcEJBOzs7OztBQXNCQSxJQUFNQSxvQkFBb0IsR0FBMUI7QUFDQSxJQUFNQyxxQkFBcUIsR0FBM0I7O0FBRUE7Ozs7Ozs7O0FBUUEsU0FBU0MsSUFBVCxDQUFjQyxNQUFkLEVBQXNCO0FBQ3JCRCxNQUFLRSxVQUFMLENBQWdCQyxXQUFoQixDQUE0QkMsSUFBNUIsQ0FBaUMsSUFBakMsRUFBdUNILE1BQXZDO0FBQ0E7O0FBRUQsbUJBQ0NELElBREQsRUFFQ0ssY0FGRCxFQUdDO0FBQ0M7Ozs7Ozs7Ozs7QUFVQUMsWUFYRCx1QkFXYUwsTUFYYixFQVdxQjtBQUFBOztBQUNuQixNQUFNTSxPQUFPLEtBQUtDLEdBQUwsQ0FBUyxTQUFULENBQWI7O0FBRUEsTUFBSSxLQUFLQSxHQUFMLENBQVMsdUJBQVQsQ0FBSixFQUF1QztBQUN0Q0QsUUFBS0UsWUFBTCxDQUFrQixpQkFBbEIsRUFBcUMsTUFBckM7QUFDQTs7QUFFRCxNQUFNQyxTQUFTQyxTQUFTQyxNQUFULENBQWdCTCxJQUFoQixDQUFmOztBQUVBRyxTQUFPVCxNQUFQLENBQWNZLGNBQWQsR0FBK0IsS0FBS0wsR0FBTCxDQUFTLGdCQUFULENBQS9COztBQUVBRSxTQUFPVCxNQUFQLENBQWNhLFFBQWQsR0FBeUIsS0FBS04sR0FBTCxDQUFTLFVBQVQsQ0FBekI7O0FBRUFFLFNBQU9ULE1BQVAsQ0FBY2MsYUFBZCxHQUE4QixLQUFLUCxHQUFMLENBQVMsZUFBVCxDQUE5Qjs7QUFFQUUsU0FBT1QsTUFBUCxDQUFjZSxZQUFkLEdBQTZCLEtBQUtSLEdBQUwsQ0FBUyxjQUFULENBQTdCOztBQUVBRSxTQUFPVCxNQUFQLENBQWNnQixjQUFkLEdBQStCLEtBQUtULEdBQUwsQ0FBUyxnQkFBVCxDQUEvQjs7QUFFQUUsU0FBT1QsTUFBUCxDQUFjaUIsZ0JBQWQsR0FBaUMsS0FBS1YsR0FBTCxDQUFTLGtCQUFULENBQWpDOztBQUVBRSxTQUFPVCxNQUFQLENBQWNrQix5QkFBZCxHQUEwQyxLQUExQztBQUNBVCxTQUFPVCxNQUFQLENBQWNtQiw2QkFBZCxHQUE4QyxLQUE5Qzs7QUFFQVYsU0FBT1QsTUFBUCxDQUFjb0IsbUJBQWQsR0FBb0MsS0FBS2IsR0FBTCxDQUFTLHFCQUFULENBQXBDOztBQUVBRSxTQUFPVCxNQUFQLENBQWNxQixTQUFkLEdBQTBCLEtBQUtkLEdBQUwsQ0FBUyxXQUFULENBQTFCOztBQUVBZSxpQkFBS0MsR0FBTCxDQUFTZCxPQUFPVCxNQUFoQixFQUF3QkEsTUFBeEI7O0FBRUEsTUFBSVUsU0FBU2MsR0FBVCxDQUFhQyxFQUFiLElBQW1CLENBQUNmLFNBQVNjLEdBQVQsQ0FBYUUsSUFBckMsRUFBMkM7QUFDMUMsT0FBTUMsU0FDTGpCLFNBQVNjLEdBQVQsQ0FBYUksT0FBYixLQUF5QixFQUF6QixHQUNHLG9CQURILEdBRUcsa0JBSEo7O0FBS0FuQixVQUFPVCxNQUFQLENBQWNlLFlBQWQsR0FBNkJOLE9BQU9ULE1BQVAsQ0FBY2UsWUFBZCxDQUEyQmMsT0FBM0IsQ0FDNUIsZUFENEIsRUFFNUJGLE1BRjRCLENBQTdCO0FBSUFsQixVQUFPVCxNQUFQLENBQWNjLGFBQWQsR0FBOEJMLE9BQU9ULE1BQVAsQ0FBY2MsYUFBZCxDQUE0QmUsT0FBNUIsQ0FDN0IsZUFENkIsRUFFN0JGLE1BRjZCLENBQTlCO0FBSUE7O0FBRURsQixTQUFPcUIsSUFBUCxDQUFZLFlBQVosRUFBMEIsWUFBTTtBQUMvQixTQUFLQyw2QkFBTCxDQUFtQ3RCLE1BQW5DOztBQUVBLE9BQU11QixXQUFXdkIsT0FBT3VCLFFBQVAsRUFBakI7O0FBRUEsT0FBTUMsZ0JBQWdCLE1BQUsxQixHQUFMLENBQVMsZUFBVCxDQUF0Qjs7QUFFQSxPQUFNMkIsbUJBQW1CQyxPQUFPQyxJQUFQLENBQVlILGFBQVosQ0FBekI7QUFDQSxRQUFLLElBQUlJLElBQUksQ0FBYixFQUFnQkEsSUFBSUgsaUJBQWlCSSxNQUFyQyxFQUE2Q0QsR0FBN0MsRUFBa0Q7QUFDakQsUUFBTUUsY0FBY0wsaUJBQWlCRyxDQUFqQixDQUFwQjs7QUFFQSxRQUFJNUIsT0FBTytCLFFBQVAsQ0FBZ0JELFdBQWhCLENBQUosRUFBa0M7QUFDakM7QUFDQTs7QUFFRDlCLFdBQU9nQyxVQUFQLENBQWtCRixXQUFsQixFQUErQk4sY0FBY00sV0FBZCxDQUEvQjtBQUNBOztBQUVEUCxZQUFTVSxRQUFULENBQWtCLGFBQWxCO0FBQ0EsR0FuQkQ7O0FBcUJBLE9BQUtDLE9BQUwsR0FBZWxDLE1BQWY7O0FBRUFtQyxjQUFZQyxxQkFBWixDQUFrQyxLQUFLQyxTQUFMLENBQWVDLElBQWYsQ0FBb0IsSUFBcEIsQ0FBbEM7QUFDQSxFQWpGRjs7O0FBbUZDOzs7Ozs7Ozs7QUFTQUMsV0E1RkQsd0JBNEZjO0FBQ1osT0FBS0MsVUFBTCxHQUFrQixJQUFsQjs7QUFFQSxNQUFJLEtBQUtDLGdCQUFULEVBQTJCO0FBQzFCQyxzQkFBU0Msc0JBQVQsQ0FBZ0MsS0FBS0YsZ0JBQXJDO0FBQ0EsUUFBS0EsZ0JBQUwsQ0FBc0JHLFVBQXRCLENBQWlDQyxXQUFqQyxDQUNDLEtBQUtKLGdCQUROO0FBR0E7O0FBRUQsTUFBTUssZUFBZSxLQUFLaEQsR0FBTCxDQUFTLGNBQVQsQ0FBckI7O0FBRUEsTUFBSWdELFlBQUosRUFBa0I7QUFDakIsT0FBTXZCLFdBQVd1QixhQUFhdkIsUUFBYixFQUFqQjs7QUFFQSxPQUFJQSxRQUFKLEVBQWM7QUFDYkEsYUFBU3dCLFdBQVQsQ0FBcUIsYUFBckI7O0FBRUEsUUFBSSxLQUFLakQsR0FBTCxDQUFTLHVCQUFULENBQUosRUFBdUM7QUFDdEMsVUFBS0EsR0FBTCxDQUFTLFNBQVQsRUFBb0JDLFlBQXBCLENBQ0MsaUJBREQsRUFFQyxPQUZEO0FBSUE7QUFDRDs7QUFFRCxRQUFLaUQsZ0JBQUw7O0FBRUFGLGdCQUFhRyxPQUFiO0FBQ0E7QUFDRCxFQTFIRjs7O0FBNEhDOzs7Ozs7OztBQVFBRCxpQkFwSUQsOEJBb0lvQjtBQUNsQixNQUFNRixlQUFlLEtBQUtoRCxHQUFMLENBQVMsY0FBVCxDQUFyQjtBQUNBLE1BQU1vRCxnQkFBZ0IsT0FBT0MsT0FBT0MsWUFBZCxJQUE4QixVQUFwRDs7QUFFQSxNQUFJRixhQUFKLEVBQW1CO0FBQ2xCSixnQkFBYU8sUUFBYixDQUFzQkMsQ0FBdEIsQ0FBd0JDLFNBQXhCLENBQWtDQyxLQUFsQztBQUNBLEdBRkQsTUFFTztBQUNOVixnQkFBYU8sUUFBYixDQUNFSSxTQURGLEdBRUVILENBRkYsQ0FFSUYsWUFGSixHQUdFTSxlQUhGO0FBSUE7QUFDRCxFQWhKRjs7O0FBa0pDOzs7Ozs7Ozs7QUFTQXBDLDhCQTNKRCx5Q0EySitCdEIsTUEzSi9CLEVBMkp1QztBQUNyQ0EsU0FBT3VCLFFBQVAsR0FBa0JvQyxFQUFsQixDQUFxQixPQUFyQixFQUE4QixLQUFLQyx1QkFBbkMsRUFBNEQsSUFBNUQsRUFBa0U7QUFDakU1RDtBQURpRSxHQUFsRTtBQUdBLEVBL0pGOzs7QUFpS0M7Ozs7Ozs7Ozs7O0FBV0E0RCx3QkE1S0QsbUNBNEt5QkMsS0E1S3pCLEVBNEtnQztBQUM5QixNQUFNQyxhQUFhRCxNQUFNRSxJQUFOLENBQVdULENBQTlCO0FBQ0EsTUFBTVUsYUFBYUYsV0FBV0csT0FBWCxJQUFzQkgsV0FBV0ksT0FBcEQ7QUFDQSxNQUFNQyxhQUFhLEtBQUtqQyxPQUFMLENBQWEzQyxNQUFiLENBQW9CNkUsUUFBcEIsSUFBZ0NKLFVBQW5EOztBQUVBRixhQUFXTyxjQUFYOztBQUVBLE1BQUksQ0FBQ0YsVUFBTCxFQUFpQjtBQUNoQjtBQUNBOztBQUVELE1BQ0NOLE1BQU1TLFlBQU4sQ0FBbUJ0RSxNQUFuQixDQUNFdUIsUUFERixHQUVFdkIsTUFGRixDQUVTdUUsSUFGVCxDQUVjLGVBRmQsRUFFK0JWLE1BQU1FLElBRnJDLE1BRStDLEtBSGhELEVBSUU7QUFDRCxPQUFNUyxZQUFZLElBQUl2RSxTQUFTd0UsR0FBVCxDQUFhQyxXQUFqQixDQUNqQmIsTUFBTUUsSUFBTixDQUFXWSxTQUFYLEVBRGlCLEVBRWpCLElBRmlCLENBQWxCO0FBSUEsT0FBTUMsT0FBT0osVUFBVUssV0FBdkI7O0FBRUEsT0FBSUQsSUFBSixFQUFVO0FBQ1QsUUFBTUUsT0FBT0YsS0FBS3RCLENBQUwsQ0FBT3lCLFVBQVAsQ0FBa0JELElBQWxCLEdBQ1ZGLEtBQUt0QixDQUFMLENBQU95QixVQUFQLENBQWtCRCxJQUFsQixDQUF1QkUsS0FEYixHQUVWLElBRkg7QUFHQSxRQUFNQyxTQUFTakIsYUFDWixRQURZLEdBRVpZLEtBQUt0QixDQUFMLENBQU95QixVQUFQLENBQWtCRSxNQUFsQixHQUNBTCxLQUFLdEIsQ0FBTCxDQUFPeUIsVUFBUCxDQUFrQkUsTUFBbEIsQ0FBeUJELEtBRHpCLEdBRUEsSUFKSDtBQUtBLFNBQUtFLGFBQUwsQ0FBbUJKLElBQW5CLEVBQXlCRyxNQUF6QjtBQUNBO0FBQ0Q7QUFDRCxFQTlNRjs7O0FBZ05DOzs7Ozs7Ozs7QUFTQUUsaUJBek5ELDhCQXlOb0I7QUFDbEIsU0FBTyxLQUFLakQsT0FBWjtBQUNBLEVBM05GOzs7QUE2TkM7Ozs7Ozs7Ozs7QUFVQWdELGNBdk9ELHlCQXVPZUosSUF2T2YsRUF1T3FCRyxNQXZPckIsRUF1TzZCO0FBQzNCLE1BQUlBLFVBQVVILElBQWQsRUFBb0I7QUFDbkIzQixVQUFPaUMsSUFBUCxDQUFZTixJQUFaLEVBQWtCRyxNQUFsQjtBQUNBLEdBRkQsTUFFTyxJQUFJSCxJQUFKLEVBQVU7QUFDaEIzQixVQUFPa0MsUUFBUCxDQUFnQlAsSUFBaEIsR0FBdUJBLElBQXZCO0FBQ0E7QUFDRCxFQTdPRjs7O0FBK09DOzs7Ozs7OztBQVFBekMsVUF2UEQsdUJBdVBhO0FBQUE7O0FBQ1gsTUFBSSxDQUFDLEtBQUtHLFVBQVYsRUFBc0I7QUFDckIsT0FBTThDLGtCQUFrQmpDLFNBQVNrQyxhQUFULENBQXVCLEtBQXZCLENBQXhCO0FBQ0FELG1CQUFnQkUsU0FBaEIsR0FBNEIsT0FBNUI7O0FBRUEsT0FBTUMsU0FBUyxLQUFLM0YsR0FBTCxDQUFTLFFBQVQsS0FBc0J1RCxTQUFTcUMsSUFBOUM7O0FBRUFELFVBQU9FLFdBQVAsQ0FBbUJMLGVBQW5COztBQUVBLE9BQU1NLGNBQWMsU0FBZEEsV0FBYyxVQUFXO0FBQzlCLFFBQUksQ0FBQyxPQUFLQyxPQUFOLElBQWlCQyxPQUFyQixFQUE4QjtBQUM3QixZQUFLRCxPQUFMLEdBQWVDLE9BQWY7QUFDQSxZQUFLaEcsR0FBTCxDQUFTLGNBQVQsRUFBeUJ5RSxJQUF6QixDQUE4QixTQUE5QjtBQUNBO0FBQ0QsSUFMRDs7QUFPQTdCLHNCQUFTcUQsTUFBVCxDQUNDO0FBQUMsMkJBQUQsQ0FBZSxRQUFmO0FBQUEsTUFBd0IsT0FBTyxFQUFDL0YsUUFBUSxJQUFULEVBQS9CO0FBQ0Msa0NBQUMsY0FBRDtBQUNDLGtCQUFhLEtBQUtGLEdBQUwsQ0FBUyxhQUFULENBRGQ7QUFFQyxVQUFLOEYsV0FGTjtBQUdDLGVBQVUsS0FBSzlGLEdBQUwsQ0FBUyxVQUFUO0FBSFg7QUFERCxJQURELEVBUUN3RixlQVJEOztBQVdBLFFBQUs3QyxnQkFBTCxHQUF3QjZDLGVBQXhCO0FBQ0E7QUFDRCxFQXBSRjs7O0FBc1JDOzs7Ozs7Ozs7Ozs7O0FBYUFVLFdBblNELHNCQW1TWWhCLEtBblNaLEVBbVNtQjtBQUNqQixNQUFJbkUsZUFBS29GLFFBQUwsQ0FBY2pCLEtBQWQsQ0FBSixFQUEwQjtBQUN6QkEsV0FBUTNCLFNBQVM2QyxjQUFULENBQXdCbEIsS0FBeEIsQ0FBUjtBQUNBOztBQUVELFNBQU9BLEtBQVA7QUFDQSxFQXpTRjs7O0FBMlNDOzs7Ozs7Ozs7Ozs7QUFZQW1CLHdCQXZURCxtQ0F1VHlCbkIsS0F2VHpCLEVBdVRnQztBQUM5QixTQUNDbkUsZUFBS29GLFFBQUwsQ0FBY2pCLEtBQWQsS0FDQW5FLGVBQUt1RixRQUFMLENBQWNwQixLQUFkLENBREEsSUFFQW5FLGVBQUt3RixTQUFMLENBQWVyQixLQUFmLENBSEQ7QUFLQSxFQTdURjs7O0FBK1RDOzs7Ozs7Ozs7O0FBVUFzQixrQkF6VUQsNkJBeVVtQnRCLEtBelVuQixFQXlVMEI7QUFDeEIsU0FBT25FLGVBQUt1RixRQUFMLENBQWNwQixLQUFkLEtBQXdCbkUsZUFBSzBGLE1BQUwsQ0FBWXZCLEtBQVosQ0FBL0I7QUFDQTtBQTNVRixDQUhELEVBZ1ZDO0FBQ0N3QixRQUFPO0FBQ047Ozs7Ozs7Ozs7OztBQVlBckcsa0JBQWdCO0FBQ2ZzRyxjQUFXLHlCQURJO0FBRWZ6QixVQUFPLElBRlE7QUFHZjBCLGNBQVc7QUFISSxHQWJWOztBQW1CTjs7Ozs7Ozs7Ozs7QUFXQUMsOEJBQTRCO0FBQzNCRixjQUFXNUYsZUFBSytGLFVBRFc7QUFFM0I1QixVQUFPNkI7QUFGb0IsR0E5QnRCOztBQW1DTjs7Ozs7Ozs7Ozs7QUFXQUMseUJBQXVCO0FBQ3RCTCxjQUFXNUYsZUFBS29GLFFBRE07QUFFdEJqQixVQUFPNkI7QUFGZSxHQTlDakI7O0FBbUROOzs7Ozs7Ozs7QUFTQXRHLGtCQUFnQjtBQUNma0csY0FBVzVGLGVBQUtrRyxPQUREO0FBRWYvQixVQUFPLENBQ047QUFDQ2dDLFFBQUksVUFETDtBQUVDQyx3SEFDaUM1SCxrQkFEakMsa0pBRzRCRCxpQkFINUIsZ0JBR3dEQyxrQkFIeEQsOEZBSW9ERCxpQkFKcEQsaUJBRkQ7QUFPQzhILFVBQU0sT0FQUDtBQVFDQyxnQkFBWSxDQUNYLCtEQURXO0FBUmIsSUFETSxFQWFOO0FBQ0NILFFBQUksUUFETDtBQUVDQywrRkFDaUI1SCxrQkFEakIsbUpBRytCRCxpQkFIL0IsZ0JBRkQ7QUFNQzhILFVBQU0sT0FOUDtBQU9DQyxnQkFBWSxDQUNYLHNEQURXO0FBUGIsSUFiTSxFQXdCTjtBQUNDSCxRQUFJLE9BREw7QUFFQ0MsOERBQXdENUgsa0JBQXhELDZKQUVzQ0QsaUJBRnRDLGdCQUZEO0FBS0M4SCxVQUFNLE9BTFA7QUFNQ0MsZ0JBQVksQ0FDWCxtRUFEVyxFQUVYLDhEQUZXLEVBR1gscUVBSFcsRUFJWCwrQ0FKVztBQU5iLElBeEJNLEVBcUNOO0FBQ0NILFFBQUksU0FETDtBQUVDQywwR0FDaUI1SCxrQkFEakIseUlBR2dCRCxpQkFIaEIsZ0JBRkQ7QUFNQzhILFVBQU0sT0FOUDtBQU9DQyxnQkFBWSxDQUNYLHlEQURXO0FBUGIsSUFyQ007QUFGUSxHQTVEVjs7QUFpSE47Ozs7Ozs7Ozs7O0FBV0FDLHlCQUF1QjtBQUN0QlgsY0FBVzVGLGVBQUt3RixTQURNO0FBRXRCckIsVUFBTyxJQUZlO0FBR3RCMEIsY0FBVztBQUhXLEdBNUhqQjs7QUFrSU47Ozs7Ozs7O0FBUUFXLGVBQWE7QUFDWlosY0FBVzVGLGVBQUt5RyxRQURKO0FBRVp0QyxVQUFPO0FBRkssR0ExSVA7O0FBK0lOOzs7Ozs7OztBQVFBeEQsaUJBQWU7QUFDZGlGLGNBQVc1RixlQUFLdUYsUUFERjtBQUVkcEIsVUFBTztBQUNOdUMsaUJBQWFDO0FBRFAsSUFGTztBQUtkZCxjQUFXO0FBTEcsR0F2SlQ7O0FBK0pOOzs7Ozs7Ozs7OztBQVdBcEcsZ0JBQWM7QUFDYm1HLGNBQVc1RixlQUFLb0YsUUFESDtBQUViakIsVUFDQyx1R0FDQSw4RUFEQSxHQUVBLDRIQUxZO0FBTWIwQixjQUFXO0FBTkUsR0ExS1I7O0FBbUxOOzs7Ozs7Ozs7QUFTQWUsUUFBTTtBQUNMaEIsY0FBVzVGLGVBQUtvRixRQURYO0FBRUxqQixVQUFPO0FBRkYsR0E1TEE7O0FBaU1OOzs7Ozs7Ozs7QUFTQWxDLGdCQUFjO0FBQ2I0RSxXQUFRLGtCQURLO0FBRWJ0RCxhQUFVO0FBRkcsR0ExTVI7O0FBK01OOzs7Ozs7Ozs7Ozs7QUFZQTVELG9CQUFrQjtBQUNqQmlHLGNBQVc1RixlQUFLb0YsUUFEQztBQUVqQmpCLFVBQU8sZ0JBRlU7QUFHakIwQixjQUFXO0FBSE0sR0EzTlo7O0FBaU9OOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkFyRyxpQkFBZTtBQUNkb0csY0FBVzVGLGVBQUtvRixRQURGO0FBRWRqQixVQUFPLHdEQUZPO0FBR2QwQixjQUFXO0FBSEcsR0FuUFQ7O0FBeVBOOzs7Ozs7Ozs7OztBQVdBL0YsdUJBQXFCO0FBQ3BCOEYsY0FBVzVGLGVBQUtrRyxPQURJO0FBRXBCL0IsVUFBTyxDQUNOO0FBQ0NyRCxVQUFNMUIsU0FBUzBILElBQVQsR0FBZ0IsRUFEdkIsQ0FDMEI7QUFEMUIsTUFFQ3BFLFdBQVc7QUFGWixJQURNLEVBS047QUFDQzVCLFVBQU0xQixTQUFTMEgsSUFBVCxHQUFnQjFILFNBQVMySCxLQUF6QixHQUFpQyxFQUR4QyxDQUMyQztBQUQzQyxNQUVDckUsV0FBVztBQUZaLElBTE07QUFGYSxHQXBRZjs7QUFrUk47Ozs7Ozs7OztBQVNBM0MsYUFBVztBQUNWNkYsY0FBVzVGLGVBQUtvRixRQUROO0FBRVZqQixVQUFPLHFDQUZHO0FBR1YwQixjQUFXO0FBSEQsR0EzUkw7O0FBaVNOOzs7Ozs7Ozs7QUFTQW1CLFdBQVM7QUFDUkMsV0FBUSxZQURBO0FBRVJwQixjQUFXO0FBRkgsR0ExU0g7O0FBK1NOOzs7Ozs7O0FBT0F0RyxZQUFVO0FBQ1RxRyxjQUFXLG1CQURGO0FBRVR6QixVQUFPO0FBQ04rQyxTQUFLO0FBQ0pDLGNBQVMsQ0FDUixlQURRLEVBRVIsT0FGUSxFQUdSLFFBSFEsRUFJUixPQUpRLEVBS1IsT0FMUSxDQURMO0FBUUpDLGVBQVU7QUFSTixLQURDO0FBV05DLFlBQVE7QUFDUEMsaUJBQVlDLG9CQURMO0FBRVBILGVBQVU7QUFGSDtBQVhGO0FBRkUsR0F0VEo7O0FBMFVOOzs7Ozs7Ozs7QUFTQXhDLFVBQVE7QUFDUHFDLFdBQVEsWUFERDtBQUVQcEIsY0FBVztBQUZKO0FBblZGO0FBRFIsQ0FoVkQ7O0FBNHFCQXpHLFNBQVM0RCxLQUFULENBQWV3RSxXQUFmLENBQTJCL0ksSUFBM0I7O2tCQUVlQSxJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7a1FDbnRCZjs7Ozs7QUFLQTs7Ozs7O0FBRUE7Ozs7QUFJQSxJQUFNZ0osZ0JBQWdCQyxnQkFBTUMsYUFBTixDQUFvQixFQUFwQixDQUF0Qjs7QUFFQTs7Ozs7Ozs7QUFRQUYsY0FBY0csT0FBZCxHQUF3QixxQkFBYTtBQUNwQyxNQUFNQyxzQkFBc0JILGdCQUFNSSxVQUFOLENBQWlCLFVBQUNDLEtBQUQsRUFBUUMsR0FBUjtBQUFBLFdBQzVDO0FBQUMsbUJBQUQsQ0FBZSxRQUFmO0FBQUE7QUFDRTtBQUFBLGVBQVcsOEJBQUMsU0FBRCxlQUFlRCxLQUFmLElBQXNCLFNBQVNFLE9BQS9CLEVBQXdDLEtBQUtELEdBQTdDLElBQVg7QUFBQTtBQURGLEtBRDRDO0FBQUEsR0FBakIsQ0FBNUI7QUFLQUgsc0JBQW9CSyxHQUFwQixHQUEwQkMsVUFBVUQsR0FBcEM7QUFDQSxTQUFPTCxtQkFBUDtBQUNBLENBUkQ7O2tCQVVlSixhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUJmOztJQUFZM0ksSTs7QUFDWjs7OztBQUNBOztJQUFZc0osTTs7QUFDWjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7Ozs7O0FBRUE7QUFDQSxJQUFNQyxpQkFBaUIsRUFBdkI7O0FBRUE7Ozs7Ozs7Ozs7QUF2QkE7Ozs7O0FBaUNBLElBQU0zSCxXQUFXLFNBQVhBLFFBQVcsQ0FBUzFCLElBQVQsRUFBZU4sTUFBZixFQUF1QjtBQUN2Q0EsVUFBU0EsVUFBVSxFQUFuQjtBQUNBQSxRQUFPc0ksT0FBUCxHQUFpQmhJLElBQWpCOztBQUVBc0MsYUFBWWdILG9CQUFaOztBQUVBLFFBQU8sSUFBSTdKLGNBQUosQ0FBU0MsTUFBVCxDQUFQO0FBQ0EsQ0FQRDs7QUFTQTs7Ozs7Ozs7Ozs7QUFXQSxJQUFNNkosY0FBYyxTQUFkQSxXQUFjLEdBQVc7QUFDOUI7QUFDQSxLQUFJQyxPQUFPbEcsT0FBT21HLG9CQUFQLElBQStCLEVBQTFDOztBQUVBLEtBQUksQ0FBQ0QsSUFBTCxFQUFXO0FBQ1YsTUFBTUUsVUFBVWxHLFNBQVNtRyxvQkFBVCxDQUE4QixRQUE5QixDQUFoQjs7QUFFQSxPQUFLLElBQUk1SCxJQUFJLENBQWIsRUFBZ0JBLElBQUkySCxRQUFRMUgsTUFBNUIsRUFBb0NELEdBQXBDLEVBQXlDO0FBQ3hDLE9BQU02SCxRQUFRRixRQUFRM0gsQ0FBUixFQUFXOEgsR0FBWCxDQUFlRCxLQUFmLENBQXFCdEgsWUFBWXdILGFBQWpDLENBQWQ7O0FBRUEsT0FBSUYsS0FBSixFQUFXO0FBQ1ZKLFdBQU9JLE1BQU0sQ0FBTixDQUFQO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLEtBQUlKLEtBQUtPLE9BQUwsQ0FBYSxJQUFiLE1BQXVCLENBQUMsQ0FBeEIsSUFBNkJQLEtBQUtRLEtBQUwsQ0FBVyxDQUFYLEVBQWMsQ0FBZCxNQUFxQixJQUF0RCxFQUE0RDtBQUMzRDtBQUNBLE1BQUlSLEtBQUtPLE9BQUwsQ0FBYSxHQUFiLE1BQXNCLENBQTFCLEVBQTZCO0FBQzVCUCxVQUFPaEUsU0FBU1AsSUFBVCxDQUFjMkUsS0FBZCxDQUFvQixnQkFBcEIsRUFBc0MsQ0FBdEMsSUFBMkNKLElBQWxEO0FBQ0E7QUFDRDtBQUhBLE9BSUs7QUFDSkEsV0FBT2hFLFNBQVNQLElBQVQsQ0FBYzJFLEtBQWQsQ0FBb0IsY0FBcEIsRUFBb0MsQ0FBcEMsSUFBeUNKLElBQWhEO0FBQ0E7QUFDRDs7QUFFRCxLQUFJLENBQUNBLElBQUwsRUFBVztBQUNWLFFBQU0sSUFBSVMsS0FBSixDQUNMLGdLQURLLENBQU47QUFHQTs7QUFFRCxRQUFPVCxJQUFQO0FBQ0EsQ0FyQ0Q7O0FBdUNBOzs7Ozs7Ozs7QUFTQSxJQUFNakgsd0JBQXdCLFNBQXhCQSxxQkFBd0IsQ0FBUzJILFFBQVQsRUFBbUI7QUFDaEQ1SCxhQUFZZ0gsb0JBQVo7O0FBRUEsS0FBSXRJLGVBQUsrRixVQUFMLENBQWdCbUQsUUFBaEIsQ0FBSixFQUErQjtBQUM5QixNQUFJNUgsWUFBWTZILE9BQWhCLEVBQXlCO0FBQ3hCQyxjQUFXRixRQUFYLEVBQXFCLENBQXJCO0FBQ0EsR0FGRCxNQUVPO0FBQ041SCxlQUFZZCxJQUFaLENBQWlCLHlCQUFqQixFQUE0QyxZQUFNO0FBQ2pENEksZUFBV0YsUUFBWCxFQUFxQixDQUFyQjtBQUNBLElBRkQ7QUFHQTtBQUNEOztBQUVELEtBQUksQ0FBQzVILFlBQVkrSCxzQkFBakIsRUFBeUM7QUFDeEMvSCxjQUFZK0gsc0JBQVosR0FBcUMsSUFBckM7O0FBRUEsTUFBTUMsWUFBWSxDQUNqQixJQURpQixFQUVqQixJQUZpQixFQUdqQixJQUhpQixFQUlqQixJQUppQixFQUtqQixJQUxpQixFQU1qQixJQU5pQixFQU9qQixJQVBpQixFQVFqQixJQVJpQixFQVNqQixJQVRpQixFQVVqQixJQVZpQixFQVdqQixJQVhpQixFQVlqQixPQVppQixFQWFqQixPQWJpQixFQWNqQixPQWRpQixFQWVqQixJQWZpQixFQWdCakIsSUFoQmlCLEVBaUJqQixJQWpCaUIsRUFrQmpCLElBbEJpQixFQW1CakIsSUFuQmlCLEVBb0JqQixJQXBCaUIsRUFxQmpCLElBckJpQixFQXNCakIsSUF0QmlCLEVBdUJqQixPQXZCaUIsRUF3QmpCLElBeEJpQixFQXlCakIsSUF6QmlCLEVBMEJqQixJQTFCaUIsRUEyQmpCLElBM0JpQixFQTRCakIsSUE1QmlCLEVBNkJqQixJQTdCaUIsRUE4QmpCLElBOUJpQixFQStCakIsSUEvQmlCLEVBZ0NqQixJQWhDaUIsRUFpQ2pCLElBakNpQixFQWtDakIsSUFsQ2lCLEVBbUNqQixJQW5DaUIsRUFvQ2pCLElBcENpQixFQXFDakIsSUFyQ2lCLEVBc0NqQixJQXRDaUIsRUF1Q2pCLElBdkNpQixFQXdDakIsSUF4Q2lCLEVBeUNqQixJQXpDaUIsRUEwQ2pCLElBMUNpQixFQTJDakIsSUEzQ2lCLEVBNENqQixJQTVDaUIsRUE2Q2pCLElBN0NpQixFQThDakIsSUE5Q2lCLEVBK0NqQixJQS9DaUIsRUFnRGpCLE9BaERpQixFQWlEakIsSUFqRGlCLEVBa0RqQixJQWxEaUIsRUFtRGpCLElBbkRpQixFQW9EakIsSUFwRGlCLEVBcURqQixJQXJEaUIsRUFzRGpCLElBdERpQixFQXVEakIsSUF2RGlCLEVBd0RqQixTQXhEaUIsRUF5RGpCLElBekRpQixFQTBEakIsSUExRGlCLEVBMkRqQixJQTNEaUIsRUE0RGpCLElBNURpQixFQTZEakIsSUE3RGlCLEVBOERqQixJQTlEaUIsRUErRGpCLElBL0RpQixFQWdFakIsSUFoRWlCLEVBaUVqQixPQWpFaUIsRUFrRWpCLElBbEVpQixDQUFsQjs7QUFxRUEsTUFBTUMsZUFDTEMsVUFBVUMsUUFBVixJQUFzQkQsVUFBVUQsWUFBaEMsSUFBZ0QsSUFEakQ7O0FBR0EsTUFBTUcsUUFBUUgsYUFDWkksV0FEWSxHQUVaZixLQUZZLENBRU4sd0JBRk0sQ0FBZDtBQUdBLE1BQUlnQixPQUFPRixNQUFNLENBQU4sQ0FBWDtBQUNBLE1BQU1HLFNBQVNILE1BQU0sQ0FBTixDQUFmOztBQUVBLE1BQUlKLFVBQVVQLE9BQVYsQ0FBa0JhLE9BQU8sR0FBUCxHQUFhQyxNQUEvQixLQUEwQyxDQUE5QyxFQUFpRDtBQUNoREQsVUFBT0EsT0FBTyxHQUFQLEdBQWFDLE1BQXBCO0FBQ0EsR0FGRCxNQUVPLElBQUlQLFVBQVVQLE9BQVYsQ0FBa0JhLElBQWxCLE1BQTRCLENBQUMsQ0FBakMsRUFBb0M7QUFDMUNBLFVBQU8sSUFBUDtBQUNBOztBQUVEeEssV0FBUzBLLFlBQVQsQ0FBc0JDLElBQXRCLENBQ0N6SSxZQUFZMEksTUFBWixDQUFtQix1QkFBdUJKLElBQXZCLEdBQThCLEtBQWpELENBREQsRUFFQyxrQkFBVTtBQUNULE9BQUlLLE1BQUosRUFBWTtBQUNYM0ksZ0JBQVlvQyxJQUFaLENBQWlCLHlCQUFqQjtBQUNBO0FBQ0QsR0FORjtBQU9DO0FBQ0EsTUFSRCxDQVFNO0FBQ0w7QUFURDtBQVdBO0FBQ0QsQ0FoSEQ7O0FBa0hBOzs7Ozs7Ozs7Ozs7QUFZQSxJQUFNc0csU0FBUyxTQUFUQSxNQUFTLENBQVNFLFFBQVQsRUFBbUI7QUFDakMsS0FBTUMsV0FBVzdJLFlBQVlpSCxXQUFaLEVBQWpCOztBQUVBO0FBQ0EsS0FBSTJCLFNBQVNuQixPQUFULENBQWlCLElBQWpCLE1BQTJCLENBQUMsQ0FBNUIsSUFBaUNtQixTQUFTbkIsT0FBVCxDQUFpQixHQUFqQixNQUEwQixDQUEvRCxFQUFrRTtBQUNqRW1CLGFBQVdDLFdBQVdELFFBQXRCO0FBQ0E7O0FBRUQ7QUFDQSxLQUNDOUssU0FBU2dMLFNBQVQsSUFDQUYsU0FBU0csTUFBVCxDQUFnQkgsU0FBU2xKLE1BQVQsR0FBa0IsQ0FBbEMsTUFBeUMsR0FEekMsSUFFQSxDQUFDLFNBQVNzSixJQUFULENBQWNKLFFBQWQsQ0FIRixFQUlFO0FBQ0RBLGNBQ0MsQ0FBQ0EsU0FBU25CLE9BQVQsQ0FBaUIsR0FBakIsS0FBeUIsQ0FBekIsR0FBNkIsR0FBN0IsR0FBbUMsR0FBcEMsSUFDQSxJQURBLEdBRUEzSixTQUFTZ0wsU0FIVjtBQUlBOztBQUVELFFBQU9GLFFBQVA7QUFDQSxDQXJCRDs7QUF1QkE7Ozs7Ozs7QUFPQSxJQUFNNUIsdUJBQXVCLFNBQXZCQSxvQkFBdUIsR0FBVztBQUN2QyxLQUFJLENBQUNoSCxZQUFZb0MsSUFBYixJQUFxQixDQUFDcEMsWUFBWXdCLEVBQXRDLEVBQTBDO0FBQ3pDMUQsV0FBUzRELEtBQVQsQ0FBZXdFLFdBQWYsQ0FBMkJsRyxXQUEzQjtBQUNBO0FBQ0QsQ0FKRDs7QUFNQTs7Ozs7Ozs7QUFRQSxJQUFNd0gsZ0JBQWdCLGtFQUF0Qjs7QUFFQTs7Ozs7OztBQU9BOzs7Ozs7Ozs7O0FBVUEsSUFBTXlCLGFBQWEsU0FBYkEsVUFBYSxDQUFTcEQsT0FBVCxFQUFrQjtBQUNwQyxRQUFPLFlBQVc7QUFDakIsU0FBT0EsUUFBUXFELE1BQVIsQ0FBZSxVQUFDQyxHQUFELEVBQU1DLEdBQU4sRUFBYztBQUNuQ0EsU0FBTXJDLGVBQWVxQyxHQUFmLEtBQXVCLENBQUNBLEdBQUQsQ0FBN0I7QUFDQSxVQUFPRCxJQUFJRSxNQUFKLENBQVdELEdBQVgsQ0FBUDtBQUNBLEdBSE0sRUFHSixFQUhJLENBQVA7QUFJQSxFQUxEO0FBTUEsQ0FQRDs7QUFTQTs7Ozs7Ozs7O0FBU0EsSUFBTUUsdUJBQXVCLFNBQXZCQSxvQkFBdUIsQ0FBU0MsVUFBVCxFQUFxQkMsVUFBckIsRUFBaUM7QUFDN0QsS0FBSSxDQUFDekMsZUFBZXlDLFVBQWYsQ0FBTCxFQUFpQztBQUNoQ3pDLGlCQUFleUMsVUFBZixJQUE2QixFQUE3QjtBQUNBOztBQUVEekMsZ0JBQWV5QyxVQUFmLEVBQTJCQyxJQUEzQixDQUFnQ0YsVUFBaEM7QUFDQSxDQU5EOztBQVFBOzs7O0FBSUEsSUFBTUcsTUFBTTtBQUNYQztBQURXLENBQVo7O1FBS0NDLFMsR0FBQUEsbUI7UUFDQXBNLEksR0FBQUEsSTtRQUNBcU0sTyxHQUFBQSxpQjtRQUNBL0MsTSxHQUFBQSxNO1FBQ0EzSixJLEdBQUFBLGM7UUFDQXVCLEksR0FBQUEsYztRQUNBZ0wsRyxHQUFBQSxHO1FBQ0FJLDJCLEdBQUFBLDJCO1FBQ0FDLG9CLEdBQUFBLDJCO1FBQ0FDLGEsR0FBQUEsdUI7UUFDQS9ELFUsR0FBQUEsb0I7UUFDQWdFLFEsR0FBQUEsa0I7UUFDQTdLLFEsR0FBQUEsUTtRQUNBNkgsVyxHQUFBQSxXO1FBQ0FnQyxVLEdBQUFBLFU7UUFDQVAsTSxHQUFBQSxNO1FBQ0ExQixvQixHQUFBQSxvQjtRQUNBL0cscUIsR0FBQUEscUI7UUFDQXVILGEsR0FBQUEsYTtRQUNBOEIsb0IsR0FBQUEsb0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuVkQ7Ozs7OztRQUVRakUsa0IsR0FBQUEscUIsRUFQUjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7QUFLQSxJQUFNQSxxQkFBcUI7QUFDMUI2RSxPQUFNLHNCQUFVO0FBQ2YsTUFBTTlJLFlBQVl2RCxPQUFPb0QsWUFBUCxFQUFsQjs7QUFFQSxNQUFJRyxTQUFKLEVBQWU7QUFDZCxPQUFNK0ksU0FBUy9JLFVBQVVnSixTQUFWLEVBQWY7QUFDQSxPQUFNQyxpQkFBaUJGLE9BQU8sQ0FBUCxFQUFVRSxjQUFqQzs7QUFFQSxPQUFNQyxZQUFZLElBQUl4TSxTQUFTd0UsR0FBVCxDQUFhaUksS0FBakIsQ0FBdUJGLGNBQXZCLENBQWxCO0FBQ0FDLGFBQVVFLFFBQVYsQ0FBbUJILGNBQW5CLEVBQW1DLENBQW5DO0FBQ0FDLGFBQVVHLE1BQVYsQ0FBaUJKLGNBQWpCLEVBQWlDLENBQWpDOztBQUVBLE9BQU1LLGtCQUFrQnRKLFVBQVV1SixrQkFBVixFQUF4Qjs7QUFFQSxPQUFJRCxtQkFBbUJBLGdCQUFnQkUsT0FBaEIsT0FBOEIsS0FBckQsRUFBNEQ7QUFDM0QsUUFBTUMsU0FBU3pKLFVBQVUwSixTQUFWLEVBQWY7QUFDQSxRQUFJRCxNQUFKLEVBQVk7QUFDWEEsWUFBT3RKLGVBQVA7QUFDQTs7QUFFREgsY0FBVTJKLFlBQVYsQ0FBdUIsQ0FBQ1QsU0FBRCxDQUF2Qjs7QUFFQUksb0JBQWdCTSxNQUFoQjtBQUNBO0FBQ0Q7QUFDRDtBQXpCeUIsQ0FBM0I7O2tCQTRCZTNGLGtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QmY7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFOQTs7Ozs7QUFRQTs7Ozs7Ozs7Ozs7a0JBV2U7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBLDJNQVdiNEYsVUFYYSxHQVdBLFlBQU07QUFDbEIsUUFDQ3ZNLGVBQUsrRixVQUFMLENBQWdCLE1BQUt5RyxRQUFyQixLQUNBeE0sZUFBSytGLFVBQUwsQ0FBZ0IsTUFBSzBHLFFBQXJCLENBRkQsRUFHRTtBQUNELFNBQU10TixTQUFTLE1BQUs4SSxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFmOztBQUVBRSxZQUFPb0QsWUFBUCxHQUFzQm1LLElBQXRCOztBQUVBLFNBQUksTUFBS0YsUUFBTCxFQUFKLEVBQXFCO0FBQ3BCck4sYUFBT3dOLFdBQVAsQ0FBbUIsTUFBS0YsUUFBTCxFQUFuQjtBQUNBLE1BRkQsTUFFTztBQUNOdE4sYUFBT29OLFVBQVAsQ0FBa0IsTUFBS0UsUUFBTCxFQUFsQjtBQUNBOztBQUVEdE4sWUFBT29ELFlBQVAsR0FBc0JxSyxNQUF0Qjs7QUFFQXpOLFlBQU91RSxJQUFQLENBQVksaUJBQVo7QUFDQTtBQUNELElBOUJZO0FBQUE7O0FBSWI7Ozs7Ozs7OztBQUphO0FBQUEsR0FDa0JtSixnQkFEbEIsVUFFTkMsV0FGTSxHQUVRckYsdUJBRlI7QUFBQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2RmOzs7Ozs7Ozs7OytlQUxBOzs7OztBQU9BOzs7Ozs7a0JBTWU7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOzs7QUFJYjs7Ozs7Ozs7QUFKYSw4QkFZRjtBQUNWLFFBQU10SSxTQUFTLEtBQUs4SSxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFmOztBQUVBLFFBQU04TixVQUFVNU4sT0FBTzZOLFVBQVAsQ0FBa0IsS0FBS2pGLEtBQUwsQ0FBV2dGLE9BQTdCLENBQWhCOztBQUVBLFdBQU9BLFVBQVVBLFFBQVFFLEtBQVIsS0FBa0I3TixTQUFTOE4sV0FBckMsR0FBbUQsS0FBMUQ7QUFDQTtBQWxCWTs7QUFBQTtBQUFBLEdBQ29CTCxnQkFEcEIsVUFFTkMsV0FGTSxHQUVRckYsdUJBRlI7QUFBQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSZjs7Ozs7Ozs7OzsrZUFMQTs7Ozs7QUFPQTs7Ozs7a0JBS2U7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBLG1NQVliMEYsV0FaYSxHQVlDLGdCQUFRO0FBQ3JCLFFBQU1oTyxTQUFTLE1BQUs4SSxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFmOztBQUVBRSxXQUFPZ08sV0FBUCxDQUFtQixNQUFLcEYsS0FBTCxDQUFXZ0YsT0FBOUIsRUFBdUM3SixJQUF2Qzs7QUFFQS9ELFdBQU91RSxJQUFQLENBQVksaUJBQVo7QUFDQSxJQWxCWTtBQUFBOztBQUliOzs7Ozs7Ozs7O0FBSmE7QUFBQSxHQUNjbUosZ0JBRGQsVUFFTkMsV0FGTSxHQUVRckYsdUJBRlI7QUFBQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUGY7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFOQTs7Ozs7QUFRQTs7Ozs7O2tCQU1lO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7O0FBSWI7Ozs7Ozs7QUFKYSx3Q0FXUTtBQUNwQixRQUFJekgsZUFBSytGLFVBQUwsMkhBQUosRUFBK0M7QUFDOUM7QUFDQTs7QUFFRCxRQUFNOUQsZUFBZSxLQUFLZ0csT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FBckI7QUFDQSxRQUFNbU8sWUFBWSxLQUFLckYsS0FBTCxDQUFXcUYsU0FBN0I7O0FBRUEsUUFBTW5NLDZCQUEyQm1NLFVBQVVDLElBQTNDOztBQUVBLFFBQUlOLFVBQVU5SyxhQUFhK0ssVUFBYixDQUF3Qi9MLFdBQXhCLENBQWQ7O0FBRUEsUUFBSSxDQUFDOEwsT0FBTCxFQUFjO0FBQ2JBLGVBQVUsSUFBSTNOLFNBQVMyTixPQUFiLENBQXFCOUssWUFBckIsRUFBbUM7QUFDNUN1SixZQUFNLFVBQVNyTSxNQUFULEVBQWlCO0FBQ3RCLFdBQU1tTyxjQUFjRixVQUFVRyxFQUE5Qjs7QUFFQSxXQUFJdk4sZUFBS29GLFFBQUwsQ0FBY2tJLFdBQWQsQ0FBSixFQUFnQztBQUMvQixhQUFLQSxXQUFMLEVBQWtCek8sSUFBbEIsQ0FBdUIsSUFBdkIsRUFBNkJNLE1BQTdCO0FBQ0EsUUFGRCxNQUVPLElBQUlhLGVBQUsrRixVQUFMLENBQWdCdUgsV0FBaEIsQ0FBSixFQUFrQztBQUN4Q0Esb0JBQVl6TyxJQUFaLENBQWlCLElBQWpCLEVBQXVCTSxNQUF2QjtBQUNBO0FBQ0QsT0FSSyxDQVFKc0MsSUFSSSxDQVFDLElBUkQ7QUFEc0MsTUFBbkMsQ0FBVjs7QUFZQVEsa0JBQWFkLFVBQWIsQ0FBd0JGLFdBQXhCLEVBQXFDOEwsT0FBckM7QUFDQTs7QUFFRCxTQUFLUyx3QkFBTCxHQUNDdkwsYUFBYXdMLGdCQUFiLENBQThCQyxVQUE5QixDQUF5Q04sVUFBVXRNLElBQW5ELENBREQ7O0FBR0FtQixpQkFBYTBMLFlBQWIsQ0FBMEJQLFVBQVV0TSxJQUFwQyxFQUEwQ0csV0FBMUM7QUFDQTs7QUFFRDs7Ozs7Ozs7QUE3Q2E7QUFBQTtBQUFBLDBDQW9EVTtBQUN0QixRQUFJakIsZUFBSytGLFVBQUwsNkhBQUosRUFBaUQ7QUFDaEQ7QUFDQTs7QUFFRCxTQUFLa0MsT0FBTCxDQUFhOUksTUFBYixDQUNFRixHQURGLENBQ00sY0FETixFQUVFME8sWUFGRixDQUdFLEtBQUs1RixLQUFMLENBQVdxRixTQUFYLENBQXFCdE0sSUFIdkIsRUFJRSxLQUFLME0sd0JBSlA7QUFNQTtBQS9EWTs7QUFBQTtBQUFBLEdBQ2dCWCxnQkFEaEIsVUFFTkMsV0FGTSxHQUVRckYsdUJBRlI7QUFBQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1RmOzs7Ozs7Ozs7OytlQUxBOzs7OztBQU9BOzs7Ozs7a0JBTWU7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOzs7QUFJYjs7Ozs7Ozs7Ozs7QUFKYSx5Q0FlMkI7QUFBQSxRQUFwQk0sS0FBb0IsdUVBQVosS0FBS0EsS0FBTzs7QUFDdkMsUUFBTTlGLGVBQWUsS0FBS2dHLE9BQUwsQ0FBYTlJLE1BQWIsQ0FBb0JGLEdBQXBCLENBQXdCLGNBQXhCLENBQXJCO0FBQ0EsUUFBTTJPLFlBQVkzTCxhQUFhdkQsTUFBYixDQUFvQmtQLFNBQXBCLElBQWlDLEVBQW5EO0FBQ0EsV0FBT3hPLFNBQVN5TyxLQUFULENBQWVDLEtBQWYsQ0FBcUIvRixLQUFyQixFQUE0QjZGLFVBQVUsVUFBVixDQUE1QixDQUFQO0FBQ0E7QUFuQlk7O0FBQUE7QUFBQSxHQUNZZixnQkFEWixVQUVOQyxXQUZNLEdBRVFyRix1QkFGUjtBQUFBLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUmY7Ozs7Ozs7Ozs7K2VBTEE7Ozs7O0FBT0E7Ozs7Ozs7OztrQkFTZTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBRWI7Ozs7Ozs7OztBQUZhLHFDQVdLO0FBQ2pCLFFBQUlzRyxlQUFlLEVBQW5COztBQUVBO0FBQ0EsUUFBSS9OLGVBQUsrRixVQUFMLENBQWdCLEtBQUt5RyxRQUFyQixLQUFrQyxLQUFLQSxRQUFMLEVBQXRDLEVBQXVEO0FBQ3REdUIscUJBQWdCLG1CQUFoQjtBQUNBOztBQUVELFdBQU9BLFlBQVA7QUFDQTtBQXBCWTs7QUFBQTtBQUFBLEdBQ21CbEIsZ0JBRG5CO0FBQUEsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1hmOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBTkE7Ozs7O0FBUUE7Ozs7OztrQkFNZTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7OztBQUliOzs7Ozs7O0FBSmEsd0NBV1E7QUFDcEIsUUFBSTdNLGVBQUsrRixVQUFMLG1IQUFKLEVBQStDO0FBQzlDO0FBQ0E7O0FBRUQsUUFBSWlJLFFBQVEsS0FBS2pHLEtBQUwsQ0FBV2lHLEtBQXZCOztBQUVBLFFBQUloTyxlQUFLb0YsUUFBTCxDQUFjNEksS0FBZCxDQUFKLEVBQTBCO0FBQ3pCLFNBQU10RSxRQUFRc0UsTUFBTUMsS0FBTixDQUFZLEdBQVosQ0FBZDtBQUNBLFNBQUlDLGdCQUFnQixLQUFLakcsT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsRUFDbEJQLE1BREY7QUFFQSxTQUFJeVAsV0FBV3pFLE1BQU0wRSxLQUFOLEVBQWY7O0FBRUEsWUFDQ0QsWUFDQW5PLGVBQUt1RixRQUFMLENBQWMySSxhQUFkLENBREEsSUFFQWxPLGVBQUt1RixRQUFMLENBQWMySSxjQUFjQyxRQUFkLENBQWQsQ0FIRCxFQUlFO0FBQ0RELHNCQUFnQkEsY0FBY0MsUUFBZCxDQUFoQjtBQUNBQSxpQkFBV3pFLE1BQU0wRSxLQUFOLEVBQVg7QUFDQTs7QUFFRCxTQUFJcE8sZUFBS3VGLFFBQUwsQ0FBYzJJLGFBQWQsQ0FBSixFQUFrQztBQUNqQ0YsY0FBUUUsYUFBUjtBQUNBO0FBQ0Q7O0FBRUQsU0FBS0csTUFBTCxHQUFjLElBQUlqUCxTQUFTNE8sS0FBYixDQUFtQkEsS0FBbkIsQ0FBZDtBQUNBOztBQUVEOzs7Ozs7OztBQXpDYTtBQUFBO0FBQUEsMENBZ0RVO0FBQ3RCLFFBQUloTyxlQUFLK0YsVUFBTCxxSEFBSixFQUFpRDtBQUNoRDtBQUNBOztBQUVELFNBQUtzSSxNQUFMLEdBQWMsSUFBZDtBQUNBOztBQUVEOzs7Ozs7Ozs7QUF4RGE7QUFBQTtBQUFBLDhCQWdFRjtBQUNWLFdBQU8sS0FBS0EsTUFBWjtBQUNBOztBQUVEOzs7Ozs7Ozs7QUFwRWE7QUFBQTtBQUFBLDhCQTRFRjtBQUNWLFFBQU1sUCxTQUFTLEtBQUs4SSxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFmO0FBQ0EsUUFBTTRFLGNBQWMxRSxPQUFPMEUsV0FBUCxFQUFwQjtBQUNBLFdBQU8sS0FBSzRJLFFBQUwsR0FBZ0I2QixXQUFoQixDQUE0QnpLLFdBQTVCLEVBQXlDMUUsTUFBekMsQ0FBUDtBQUNBO0FBaEZZOztBQUFBO0FBQUEsR0FDWTBOLGdCQURaLFVBRU5DLFdBRk0sR0FFUXJGLHVCQUZSO0FBQUEsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0RDVFA4RyxPOzs7Ozs7Ozs7d0RBQ0FBLE87Ozs7Ozs7OztrREFDQUEsTzs7Ozs7Ozs7O29EQUNBQSxPOzs7Ozs7Ozs7Z0RBQ0FBLE87Ozs7Ozs7Ozt1REFDQUEsTzs7Ozs7Ozs7O2dEQUNBQSxPOzs7Ozs7Ozs7bURBQ0FBLE87Ozs7Ozs7OzttREFDQUEsTzs7Ozs7Ozs7O29EQUNBQSxPOzs7Ozs7Ozs7dURBQ0FBLE87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVlI7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBVEE7Ozs7O0FBV0E7Ozs7OztrQkFNZTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7OztBQXFCYjs7Ozs7OztBQXJCYSxxQ0E0Qks7QUFDakIsUUFBSSxLQUFLQyxpQkFBVCxFQUE0QjtBQUMzQmxNLFlBQU9tTSxvQkFBUCxDQUE0QixLQUFLRCxpQkFBakM7QUFDQTtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7O0FBOUJBOzs7Ozs7Ozs7QUFKYTtBQUFBO0FBQUEsd0NBNkNRO0FBQ3BCLFFBQUlFLGtCQUFrQixjQUF0Qjs7QUFFQSxRQUNDLEtBQUtDLG1CQUFMLEdBQTJCQyxTQUEzQixLQUNBeFAsU0FBU3lQLHVCQUZWLEVBR0U7QUFDREgsd0JBQW1CLG1CQUFuQjtBQUNBLEtBTEQsTUFLTztBQUNOQSx3QkFBbUIsc0JBQW5CO0FBQ0E7O0FBRUQsV0FBT0EsZUFBUDtBQUNBOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE1RGE7QUFBQTtBQUFBLDBDQTZFVUksS0E3RVYsRUE2RWlCQyxZQTdFakIsRUE2RStCO0FBQzNDQSxtQkFDQ0EsZ0JBQ0EsSUFBSTNQLFNBQVN3RSxHQUFULENBQWF0QixNQUFqQixDQUF3QkEsTUFBeEIsRUFBZ0MwTSxlQUFoQyxFQUZEOztBQUlBLFFBQUlDLElBQUlILE1BQU1JLElBQWQ7QUFDQSxRQUFJQyxJQUFJTCxNQUFNTSxHQUFkOztBQUVBLFFBQUlOLE1BQU1JLElBQU4sR0FBYUosTUFBTU8sS0FBbkIsR0FBMkJOLGFBQWFNLEtBQTVDLEVBQW1EO0FBQ2xESixVQUFLSCxNQUFNSSxJQUFOLEdBQWFKLE1BQU1PLEtBQW5CLEdBQTJCTixhQUFhTSxLQUE3QztBQUNBOztBQUVELFFBQUlGLElBQUksQ0FBUixFQUFXO0FBQ1ZBLFNBQUksQ0FBSjtBQUNBOztBQUVELFdBQU87QUFDTkYsU0FETTtBQUVORTtBQUZNLEtBQVA7QUFJQTs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbkdhO0FBQUE7QUFBQSx5Q0FvSFM7QUFDckIsUUFBTUcsZUFBZSxLQUFLdkgsS0FBTCxDQUFXd0gsV0FBWCxHQUNsQixLQUFLeEgsS0FBTCxDQUFXd0gsV0FBWCxDQUF1QnJNLElBREwsR0FFbEIsSUFGSDs7QUFJQSxRQUFJLENBQUNvTSxZQUFMLEVBQW1CO0FBQ2xCO0FBQ0E7O0FBRUQsUUFBTUUsZ0JBQWdCRixhQUFhRSxhQUFuQzs7QUFFQSxRQUFNQyxjQUFjSCxhQUFhRyxXQUFqQzs7QUFFQSxRQUFNQyxNQUFNO0FBQ1hULFFBQUdLLGFBQWFHLFdBQWIsQ0FBeUJFLEtBRGpCO0FBRVhSLFFBQUdLLGNBQWNJLE1BQWQsQ0FBcUJSO0FBRmIsS0FBWjs7QUFLQSxRQUFJUixZQUFZWSxjQUFjSSxNQUFkLENBQXFCaEIsU0FBckM7O0FBRUEsUUFBTWlCLFVBQVVMLGNBQWNJLE1BQWQsQ0FBcUJDLE9BQXJDOztBQUVBLFFBQU1DLFlBQVlOLGNBQWNJLE1BQWQsQ0FBcUJFLFNBQXZDOztBQUVBLFFBQUlELFdBQVdDLFNBQVgsSUFBd0JBLFVBQVVWLEdBQVYsS0FBa0JTLFFBQVFULEdBQXRELEVBQTJEO0FBQzFEUixpQkFBWXhQLFNBQVMyUSx1QkFBckI7QUFDQTs7QUFFRCxRQUFJZCxVQUFKO0FBQ0EsUUFBSUUsVUFBSjs7QUFFQTtBQUNBOztBQUVBLFFBQUlPLElBQUlULENBQUosSUFBU1MsSUFBSVAsQ0FBakIsRUFBb0I7QUFDbkJGLFNBQUksS0FBS2UsVUFBTCxDQUFnQlIsYUFBaEIsRUFBK0JFLElBQUlULENBQW5DLENBQUo7O0FBRUEsU0FBSUwsY0FBY3hQLFNBQVMyUSx1QkFBM0IsRUFBb0Q7QUFDbkRaLFVBQUljLEtBQUtDLEdBQUwsQ0FBU1IsSUFBSVAsQ0FBYixFQUFnQkssY0FBY0ksTUFBZCxDQUFxQlIsR0FBckMsQ0FBSjtBQUNBLE1BRkQsTUFFTztBQUNORCxVQUFJYyxLQUFLRSxHQUFMLENBQ0hULElBQUlQLENBREQsRUFFSCxLQUFLaUIsVUFBTCxDQUFnQlosYUFBaEIsRUFBK0JDLFdBQS9CLENBRkcsQ0FBSjtBQUlBO0FBQ0QsS0FYRCxNQVdPO0FBQ05SLFNBQUlPLGNBQWNJLE1BQWQsQ0FBcUJWLElBQXJCLEdBQTRCTSxjQUFjSSxNQUFkLENBQXFCUCxLQUFyQixHQUE2QixDQUE3RDs7QUFFQSxTQUFJVCxjQUFjeFAsU0FBU3lQLHVCQUEzQixFQUFvRDtBQUNuRE0sVUFBSSxLQUFLaUIsVUFBTCxDQUFnQlosYUFBaEIsRUFBK0JDLFdBQS9CLENBQUo7QUFDQSxNQUZELE1BRU87QUFDTk4sVUFBSUssY0FBY0ksTUFBZCxDQUFxQlIsR0FBekI7QUFDQTtBQUNEOztBQUVELFdBQU87QUFDTlIseUJBRE07QUFFTkssU0FGTTtBQUdORTtBQUhNLEtBQVA7QUFLQTs7QUFFRDs7Ozs7Ozs7Ozs7QUFsTGE7QUFBQTtBQUFBLDhCQTRMRkssYUE1TEUsRUE0TGFhLE1BNUxiLEVBNExxQjtBQUNqQyxRQUFNVCxTQUFTSixjQUFjSSxNQUE3Qjs7QUFFQSxRQUFNVixPQUFPVSxPQUFPRSxTQUFQLEdBQW1CRixPQUFPRSxTQUFQLENBQWlCWixJQUFwQyxHQUEyQ1UsT0FBT1YsSUFBL0Q7QUFDQSxRQUFNb0IsUUFBUVYsT0FBT0MsT0FBUCxHQUFpQkQsT0FBT0MsT0FBUCxDQUFlUyxLQUFoQyxHQUF3Q1YsT0FBT1UsS0FBN0Q7O0FBRUEsUUFBSXJCLFVBQUo7O0FBRUEsUUFBSUMsT0FBT21CLE1BQVAsSUFBaUJDLFFBQVFELE1BQTdCLEVBQXFDO0FBQ3BDcEIsU0FBSW9CLE1BQUo7QUFDQSxLQUZELE1BRU87QUFDTixTQUFNRSxXQUFXTixLQUFLTyxHQUFMLENBQVN0QixPQUFPbUIsTUFBaEIsQ0FBakI7QUFDQSxTQUFNSSxZQUFZUixLQUFLTyxHQUFMLENBQVNGLFFBQVFELE1BQWpCLENBQWxCOztBQUVBLFNBQUlFLFdBQVdFLFNBQWYsRUFBMEI7QUFDekI7QUFDQXhCLFVBQUlDLElBQUo7QUFDQSxNQUhELE1BR087QUFDTkQsVUFBSXFCLEtBQUo7QUFDQTtBQUNEOztBQUVELFdBQU9yQixDQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7O0FBck5hO0FBQUE7QUFBQSw4QkErTkZPLGFBL05FLEVBK05hQyxXQS9OYixFQStOMEI7QUFDdEMsUUFBSU4sSUFBSSxDQUFSOztBQUVBLFFBQUlLLGlCQUFpQkMsV0FBckIsRUFBa0M7QUFDakMsU0FBTWlCLGdCQUFnQixJQUFJdFIsU0FBU3dFLEdBQVQsQ0FBYXFCLE9BQWpCLENBQ3JCd0ssWUFBWXJMLE1BRFMsQ0FBdEI7O0FBSUEsU0FDQ3NNLGNBQWNqTyxDQUFkLElBQ0FpTyxjQUFjakUsUUFBZCxDQUF1QixVQUF2QixNQUF1QyxNQUZ4QyxFQUdFO0FBQ0QwQyxVQUNDTSxZQUFZckwsTUFBWixDQUFtQnVNLFNBQW5CLEdBQ0FsQixZQUFZckwsTUFBWixDQUFtQndNLFlBRnBCO0FBR0EsTUFQRCxNQU9PO0FBQ056QixVQUFJSyxjQUFjSSxNQUFkLENBQXFCaUIsTUFBekI7QUFDQTtBQUNEOztBQUVELFdBQU8xQixDQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7OztBQXRQYTtBQUFBO0FBQUEsb0NBb1FJRCxJQXBRSixFQW9RVUUsR0FwUVYsRUFvUWVSLFNBcFFmLEVBb1EwQjtBQUN0QyxRQUFNa0MsVUFBVWpQLG1CQUFTa1AsV0FBVCxDQUFxQixJQUFyQixDQUFoQjs7QUFFQSxRQUFNQyxTQUFTLEtBQUtqSixLQUFMLENBQVdpSixNQUExQjs7QUFFQSxRQUNDcEMsY0FBY3hQLFNBQVN5UCx1QkFBdkIsSUFDQUQsY0FBY3hQLFNBQVMyUSx1QkFGeEIsRUFHRTtBQUNEYixZQUFPQSxPQUFPOEIsT0FBTzlCLElBQWQsR0FBcUI0QixRQUFRRyxXQUFSLEdBQXNCLENBQWxEOztBQUVBN0IsV0FDQ1IsY0FBY3hQLFNBQVN5UCx1QkFBdkIsR0FDR08sTUFBTTRCLE9BQU81QixHQURoQixHQUVHQSxNQUFNMEIsUUFBUUYsWUFBZCxHQUE2QkksT0FBTzVCLEdBSHhDO0FBSUEsS0FWRCxNQVVPLElBQ05SLGNBQWN4UCxTQUFTOFIsdUJBQXZCLElBQ0F0QyxjQUFjeFAsU0FBUytSLHVCQUZqQixFQUdMO0FBQ0RqQyxZQUNDTixjQUFjeFAsU0FBUzhSLHVCQUF2QixHQUNHaEMsT0FBTzhCLE9BQU85QixJQUFkLEdBQXFCNEIsUUFBUUYsWUFBUixHQUF1QixDQUQvQyxHQUVHMUIsT0FBUSxJQUFJNEIsUUFBUUYsWUFBYixHQUE2QixDQUFwQyxHQUF3Q0ksT0FBTzlCLElBSG5EOztBQUtBRSxXQUFNQSxNQUFNNEIsT0FBTzVCLEdBQWIsR0FBbUIwQixRQUFRRixZQUFSLEdBQXVCLENBQWhEO0FBQ0E7O0FBRUQsUUFBSTFCLE9BQU8sQ0FBWCxFQUFjO0FBQ2JBLFlBQU8sQ0FBUDtBQUNBOztBQUVELFFBQUlFLE1BQU0sQ0FBVixFQUFhO0FBQ1pBLFdBQU0sQ0FBTjtBQUNBOztBQUVELFdBQU8sQ0FBQ0YsSUFBRCxFQUFPRSxHQUFQLENBQVA7QUFDQTs7QUFFRDs7Ozs7Ozs7O0FBMVNhO0FBQUE7QUFBQSwrQkFrVEQ7QUFDWCxRQUFNMEIsVUFBVWpQLG1CQUFTa1AsV0FBVCxDQUFxQixJQUFyQixDQUFoQjs7QUFFQSxRQUFJRCxPQUFKLEVBQWE7QUFDWixTQUFNTSxhQUFhLElBQUloUyxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUI2TCxPQUF6QixDQUFuQjs7QUFFQSxZQUFPTSxXQUFXQyxRQUFYLENBQW9CLHNCQUFwQixDQUFQO0FBQ0E7O0FBRUQsV0FBTyxLQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7QUE5VGE7QUFBQTtBQUFBLCtCQXVVREMsVUF2VUMsRUF1VVdDLFFBdlVYLEVBdVVxQjtBQUNqQyxRQUFNSCxhQUFhLElBQUloUyxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FDbEJwRCxtQkFBU2tQLFdBQVQsQ0FBcUIsSUFBckIsQ0FEa0IsQ0FBbkI7O0FBSUFLLGVBQVdJLFNBQVgsQ0FBcUI7QUFDcEJ0QyxXQUFNb0MsV0FBVyxDQUFYLElBQWdCLElBREY7QUFFcEJsQyxVQUFLa0MsV0FBVyxDQUFYLElBQWdCLElBRkQ7QUFHcEJHLGNBQVMsQ0FIVztBQUlwQkMsb0JBQWU7QUFKSyxLQUFyQjs7QUFPQU4sZUFBV2xQLFdBQVgsQ0FBdUIsd0JBQXZCOztBQUVBLFNBQUtzTSxpQkFBTCxHQUF5QmxNLE9BQU9xUCxxQkFBUCxDQUE2QixZQUFNO0FBQzNEUCxnQkFBV2hRLFFBQVgsQ0FBb0IsdUJBQXBCO0FBQ0FnUSxnQkFBV2hRLFFBQVgsQ0FBb0Isc0JBQXBCO0FBQ0FnUSxnQkFBV0ksU0FBWCxDQUFxQjtBQUNwQnRDLFlBQU1xQyxTQUFTLENBQVQsSUFBYyxJQURBO0FBRXBCbkMsV0FBS21DLFNBQVMsQ0FBVCxJQUFjLElBRkM7QUFHcEJFLGVBQVM7QUFIVyxNQUFyQjs7QUFNQTtBQUNBckksZ0JBQVcsWUFBTTtBQUNoQmdJLGlCQUFXSSxTQUFYLENBQXFCO0FBQ3BCRSxzQkFBZTtBQURLLE9BQXJCO0FBR0EsTUFKRCxFQUlHLEdBSkg7QUFLQSxLQWZ3QixDQUF6QjtBQWdCQTs7QUFFRDs7Ozs7Ozs7QUF2V2E7QUFBQTtBQUFBLDBCQThXTjtBQUNOLFFBQU1aLFVBQVVqUCxtQkFBU2tQLFdBQVQsQ0FBcUIsSUFBckIsQ0FBaEI7QUFDQSxRQUFNbk0sU0FBUyxLQUFLcUQsT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsUUFBeEIsQ0FBZjs7QUFFQSxRQUFNMlMsWUFBWWhOLFNBQVNBLE9BQU9nTixTQUFoQixHQUE0QixDQUE5Qzs7QUFFQSxRQUFJLENBQUMsS0FBS0MsU0FBTCxFQUFELElBQXFCZixPQUF6QixFQUFrQztBQUNqQyxTQUFNZ0IsbUJBQW1CLEtBQUtuRCxtQkFBTCxFQUF6Qjs7QUFFQSxTQUFJbUQsZ0JBQUosRUFBc0I7QUFDckIsVUFBTVYsYUFBYSxJQUFJaFMsU0FBU3dFLEdBQVQsQ0FBYXFCLE9BQWpCLENBQXlCNkwsT0FBekIsQ0FBbkI7O0FBRUEsVUFBSWlCLGVBQUo7QUFDQSxVQUFJQyxlQUFKO0FBQ0EsVUFBSUMsaUJBQUo7QUFDQSxVQUFJQyxpQkFBSjs7QUFFQUgsZUFBU0UsV0FBV0UsV0FBV2YsV0FBVzNFLFFBQVgsQ0FBb0IsTUFBcEIsQ0FBWCxDQUFwQjtBQUNBdUYsZUFBU0UsV0FBV0MsV0FBV2YsV0FBVzNFLFFBQVgsQ0FBb0IsS0FBcEIsQ0FBWCxDQUFwQjs7QUFFQSxVQUFJLEtBQUsxRSxLQUFMLENBQVdxSyxtQkFBZixFQUFvQztBQUNuQyxXQUFNQyxNQUFNLEtBQUtDLHNCQUFMLENBQTRCO0FBQ3ZDQyxnQkFBUUosV0FBV3JCLFFBQVFGLFlBQW5CLENBRCtCO0FBRXZDMUIsY0FBTTZDLE1BRmlDO0FBR3ZDM0MsYUFBSzRDLE1BSGtDO0FBSXZDM0MsZUFBTzhDLFdBQVdyQixRQUFRRyxXQUFuQjtBQUpnQyxRQUE1QixDQUFaOztBQU9BYyxnQkFBU00sSUFBSXBELENBQWI7QUFDQStDLGdCQUFTSyxJQUFJbEQsQ0FBYjtBQUNBOztBQUVELFVBQ0MyQyxpQkFBaUJsRCxTQUFqQixLQUNBeFAsU0FBU3lQLHVCQUZWLEVBR0U7QUFDRHFELGtCQUNDLEtBQUtuSyxLQUFMLENBQVd5SCxhQUFYLENBQXlCSSxNQUF6QixDQUFnQ2lCLE1BQWhDLEdBQXlDZSxTQUQxQztBQUVBLE9BTkQsTUFNTztBQUNOTSxrQkFDQyxLQUFLbkssS0FBTCxDQUFXeUgsYUFBWCxDQUF5QkksTUFBekIsQ0FBZ0NSLEdBQWhDLEdBQXNDd0MsU0FEdkM7QUFFQTs7QUFFRCxXQUFLWSxXQUFMLENBQWlCLENBQUNQLFFBQUQsRUFBV0MsUUFBWCxDQUFqQixFQUF1QyxDQUFDSCxNQUFELEVBQVNDLE1BQVQsQ0FBdkM7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBOVphO0FBQUE7QUFBQSxvQ0FxYUk7QUFDaEIsUUFBTUYsbUJBQW1CLEtBQUtuRCxtQkFBTCxFQUF6Qjs7QUFFQSxRQUFNbUMsVUFBVWpQLG1CQUFTa1AsV0FBVCxDQUFxQixJQUFyQixDQUFoQjs7QUFFQSxRQUFJZSxvQkFBb0JoQixPQUF4QixFQUFpQztBQUNoQyxTQUFNbE0sU0FDTCxLQUFLcUQsT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsUUFBeEIsS0FBcUN1RCxTQUFTcUMsSUFEL0M7QUFFQSxTQUFNNE4sY0FBY0MsaUJBQWlCOU4sTUFBakIsQ0FBcEI7QUFDQSxTQUFNK04sbUJBQW1CQyxTQUN4QkgsWUFBWUksZ0JBQVosQ0FBNkIsYUFBN0IsQ0FEd0IsRUFFeEIsRUFGd0IsQ0FBekI7QUFJQSxTQUFNQyxvQkFBb0JGLFNBQ3pCSCxZQUFZSSxnQkFBWixDQUE2QixjQUE3QixDQUR5QixFQUV6QixFQUZ5QixDQUExQjtBQUlBLFNBQU1FLGFBQ0xKLG1CQUFtQi9OLE9BQU9vTyxXQUExQixHQUF3Q0YsaUJBRHpDOztBQUdBLFNBQU1sQixZQUNMaE4sT0FBT3FPLE9BQVAsS0FBbUIsTUFBbkIsR0FBNEJyTyxPQUFPZ04sU0FBbkMsR0FBK0MsQ0FEaEQ7O0FBR0EsU0FBTXNCLEtBQUssS0FBS0MsZ0JBQUwsQ0FDVnJCLGlCQUFpQjdDLENBRFAsRUFFVjZDLGlCQUFpQjNDLENBRlAsRUFHVjJDLGlCQUFpQmxELFNBSFAsQ0FBWDtBQUtBc0UsUUFBRyxDQUFILEtBQVN0QixTQUFUOztBQUVBLFNBQUlzQixHQUFHLENBQUgsSUFBUSxDQUFaLEVBQWU7QUFDZEEsU0FBRyxDQUFILElBQVEsQ0FBUjtBQUNBO0FBQ0QsU0FBSUEsR0FBRyxDQUFILElBQVFILGFBQWFqQyxRQUFRRyxXQUFqQyxFQUE4QztBQUM3Q2lDLFNBQUcsQ0FBSCxJQUFRSCxhQUFhakMsUUFBUUcsV0FBN0I7QUFDQTs7QUFFRCxTQUFJN1IsU0FBU3dFLEdBQVQsQ0FBYXFCLE9BQWpCLENBQXlCNkwsT0FBekIsRUFBa0NVLFNBQWxDLENBQTRDO0FBQzNDdEMsWUFBTWdFLEdBQUcsQ0FBSCxJQUFRLElBRDZCO0FBRTNDOUQsV0FBSzhELEdBQUcsQ0FBSCxJQUFRO0FBRjhCLE1BQTVDO0FBSUE7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQWpkYTtBQUFBO0FBQUEsMENBMGRVL0wsT0ExZFYsRUEwZG1CaU0sZUExZG5CLEVBMGRvQztBQUFBOztBQUNoRCxRQUFJcFQsZUFBSytGLFVBQUwsQ0FBZ0JvQixPQUFoQixDQUFKLEVBQThCO0FBQzdCQSxlQUFVQSxRQUFRdEksSUFBUixDQUFhLElBQWIsS0FBc0IsRUFBaEM7QUFDQTs7QUFFRCxXQUFPc0ksUUFBUXFELE1BQVIsQ0FBZSxVQUFDNkksSUFBRCxFQUFPQyxNQUFQLEVBQWtCO0FBQ3ZDLFNBQUlDLE1BQU1yTixPQUFOLENBQWNvTixNQUFkLENBQUosRUFBMkI7QUFDMUJELFdBQUt0SSxJQUFMLENBQVUsT0FBS3lJLGlCQUFMLENBQXVCRixNQUF2QixFQUErQkYsZUFBL0IsQ0FBVjtBQUNBLGFBQU9DLElBQVA7QUFDQSxNQUhELE1BR087QUFDTixhQUFPLE9BQUtHLGlCQUFMLENBQXVCck0sT0FBdkIsRUFBZ0NpTSxlQUFoQyxDQUFQO0FBQ0E7QUFDRCxLQVBNLEVBT0osRUFQSSxDQUFQO0FBUUE7O0FBRUQ7Ozs7Ozs7Ozs7OztBQXplYTtBQUFBO0FBQUEscUNBb2ZLak0sT0FwZkwsRUFvZmNpTSxlQXBmZCxFQW9mK0I7QUFDM0MsUUFBTUssY0FBYyxFQUFwQjs7QUFFQSxRQUFNeFIsZUFBZSxLQUFLZ0csT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FBckI7QUFDQSxRQUFNMk8sWUFBWTNMLGFBQWF2RCxNQUFiLENBQW9Ca1AsU0FBcEIsSUFBaUMsRUFBbkQ7O0FBRUEsUUFBSTVOLGVBQUsrRixVQUFMLENBQWdCb0IsT0FBaEIsQ0FBSixFQUE4QjtBQUM3QkEsZUFBVUEsUUFBUXRJLElBQVIsQ0FBYSxJQUFiLEtBQXNCLEVBQWhDO0FBQ0E7O0FBRUQsUUFBTTZVLGlCQUFpQixLQUFLQyxlQUFMLENBQ3RCeE0sUUFDRXlNLE1BREYsQ0FDUyxrQkFBVTtBQUNqQixZQUNDTixXQUNDaFMsWUFBWTZKLE9BQVosQ0FBb0JtSSxNQUFwQixLQUNBaFMsWUFBWTZKLE9BQVosQ0FBb0JtSSxPQUFPakcsSUFBM0IsQ0FGRCxDQUREO0FBS0EsS0FQRixFQVFFd0csR0FSRixDQVFNLGtCQUFVO0FBQ2QsU0FBSTdULGVBQUtvRixRQUFMLENBQWNrTyxNQUFkLENBQUosRUFBMkI7QUFDMUJHLGtCQUFZSCxNQUFaLElBQXNCMUYsVUFBVTBGLE1BQVYsQ0FBdEI7QUFDQUEsZUFBU2hTLFlBQVk2SixPQUFaLENBQW9CbUksTUFBcEIsQ0FBVDtBQUNBLE1BSEQsTUFHTyxJQUFJdFQsZUFBS29GLFFBQUwsQ0FBY2tPLE9BQU9qRyxJQUFyQixDQUFKLEVBQWdDO0FBQ3RDb0csa0JBQ0NuUyxZQUFZNkosT0FBWixDQUFvQm1JLE9BQU9qRyxJQUEzQixFQUFpQ25GLEdBRGxDLElBRUk5SSxTQUFTeU8sS0FBVCxDQUFlQyxLQUFmLENBQ0hGLFVBQVUwRixNQUFWLENBREcsRUFFSEEsT0FBT1EsR0FGSixDQUZKO0FBTUFSLGVBQVNoUyxZQUFZNkosT0FBWixDQUFvQm1JLE9BQU9qRyxJQUEzQixDQUFUO0FBQ0E7O0FBRUQsWUFBT2lHLE1BQVA7QUFDQSxLQXZCRixDQURzQixFQXlCckJPLEdBekJxQixDQXlCakIsVUFBU1AsTUFBVCxFQUFpQlMsS0FBakIsRUFBd0I7QUFDN0IsU0FBSWhNLFFBQVEsS0FBS2lNLG1CQUFMLENBQ1g7QUFDQzdVLGNBQVEsS0FBSzhJLE9BQUwsQ0FBYTlJLE1BRHRCO0FBRUMrSSxXQUNDb0wsT0FBT3BMLEdBQVAsS0FBZSxXQUFmLEdBQ0dvTCxPQUFPcEwsR0FEVixHQUVNb0wsT0FBT3BMLEdBRmIsU0FFb0I2TCxLQUx0QjtBQU1DRSxjQUFRWCxPQUFPcEwsR0FOaEI7QUFPQ2QsZ0JBQ0MsS0FBS1csS0FBTCxDQUFXbU0sT0FBWCxJQUNBLEtBQUtuTSxLQUFMLENBQVdtTSxPQUFYLENBQW1Cbk0sS0FBbkIsQ0FBeUJrTSxNQUF6QixLQUFvQ1gsT0FBT3BMLEdBRDNDLEdBRUcsQ0FGSCxHQUdHLENBQUMsQ0FYTjtBQVlDZ00sZUFBUyxLQUFLbk0sS0FBTCxDQUFXbU07QUFackIsTUFEVyxFQWVYWixPQUFPcEwsR0FmSSxDQUFaOztBQWtCQUgsYUFBUSxLQUFLb00sa0JBQUwsQ0FBd0JwTSxLQUF4QixFQUErQnVMLE9BQU9wTCxHQUF0QyxDQUFSOztBQUVBLFNBQUlrTCxlQUFKLEVBQXFCO0FBQ3BCckwsY0FBUTNJLFNBQVN5TyxLQUFULENBQWVDLEtBQWYsQ0FBcUIvRixLQUFyQixFQUE0QnFMLGVBQTVCLENBQVI7QUFDQTs7QUFFRHJMLGFBQVEzSSxTQUFTeU8sS0FBVCxDQUFlQyxLQUFmLENBQXFCL0YsS0FBckIsRUFBNEIwTCxZQUFZSCxPQUFPcEwsR0FBbkIsQ0FBNUIsQ0FBUjs7QUFFQSxZQUFPUixnQkFBTWhELGFBQU4sQ0FBb0I0TyxNQUFwQixFQUE0QnZMLEtBQTVCLENBQVA7QUFDQSxLQXJEc0IsRUFxRHBCLElBckRvQixDQUF2Qjs7QUF1REEsV0FBTzJMLGNBQVA7QUFDQTtBQXRqQlk7O0FBQUE7QUFBQSxHQUNlN0csZ0JBRGYsVUFFTkMsV0FGTSxHQUVRckYsdUJBRlIsU0FZTjJNLFlBWk0sZ0JBYVR2SCxpQkFBaUJ1SCxZQWJSO0FBY1pwRCxVQUFRO0FBQ1A5QixTQUFNLENBREM7QUFFUEUsUUFBSztBQUZFLEdBZEk7QUFrQlpnRCx1QkFBcUI7QUFsQlQ7QUFBQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaZjs7OztBQUVBOzs7Ozs7Ozs7OytlQVBBOzs7OztBQVNBOzs7OztrQkFLZTtBQUFBO0FBQUE7O0FBRWIsMEJBQVlySyxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsK0hBQ1pBLEtBRFk7O0FBQUEsU0EwQ25Cb00sa0JBMUNtQixHQTBDRSxVQUFDRSxHQUFELEVBQU1DLE9BQU4sRUFBa0I7QUFDdEMsV0FBT2xWLFNBQVN5TyxLQUFULENBQWVDLEtBQWYsQ0FBcUJ1RyxHQUFyQixFQUEwQjtBQUNoQ0UsZUFBVSxNQUFLdEgsS0FBTCxDQUFXdUgsWUFBWCxLQUE0QkYsT0FBNUIsR0FBc0MsSUFBdEMsR0FBNkMsS0FEdkI7QUFFaENsTixlQUFVLE1BQUs2RixLQUFMLENBQVd3SCxlQUFYLEtBQStCSCxPQUEvQixHQUF5QyxDQUF6QyxHQUE2QyxDQUFDLENBRnhCO0FBR2hDSSxxQkFBZ0IsTUFBS0EsY0FBTCxDQUFvQmpULElBQXBCLFFBQStCNlMsT0FBL0I7QUFIZ0IsS0FBMUIsQ0FBUDtBQUtBLElBaERrQjs7QUFBQSxTQTJEbkJJLGNBM0RtQixHQTJERixVQUFDRixZQUFELEVBQWVHLGVBQWYsRUFBbUM7QUFDbkQsVUFBS0MsUUFBTCxDQUNDO0FBQ0NILHNCQUFpQkQsWUFEbEI7QUFFQ0EsbUJBQ0NBLGlCQUFpQixNQUFLdkgsS0FBTCxDQUFXdUgsWUFBNUIsR0FDR0EsWUFESCxHQUVHO0FBTEwsS0FERCxFQVFDLFlBQU07QUFDTCxTQUFJLENBQUMsTUFBS3ZILEtBQUwsQ0FBV3VILFlBQWhCLEVBQThCO0FBQzdCLFVBQUksTUFBS0ssU0FBVCxFQUFvQjtBQUNuQixhQUFLQSxTQUFMLENBQWVGLGVBQWY7QUFDQSxPQUZELE1BRU87QUFDTjlTLDBCQUFTa1AsV0FBVCxRQUEyQitELEtBQTNCO0FBQ0E7QUFDRDtBQUNELEtBaEJGO0FBa0JBLElBOUVrQjs7QUFHbEIsU0FBSzdILEtBQUwsZ0JBQ0ksTUFBS0EsS0FEVDtBQUVDd0gscUJBQWlCLElBRmxCO0FBR0NELGtCQUFjO0FBSGY7QUFIa0I7QUFRbEI7O0FBRUQ7Ozs7Ozs7Ozs7QUFaYTtBQUFBO0FBQUEsNkNBb0JhTyxTQXBCYixFQW9Cd0I7QUFDcEMsUUFBSS9VLGVBQUsrRixVQUFMLGdJQUFKLEVBQXNEO0FBQ3JELCtJQUFnQ2dQLFNBQWhDO0FBQ0E7O0FBRUQsU0FBS0gsUUFBTCxDQUFjO0FBQ2JILHNCQUFpQixJQURKO0FBRWJELG1CQUFjO0FBRkQsS0FBZDtBQUlBOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7Ozs7Ozs7Ozs7QUFwRGE7O0FBQUE7QUFBQSxHQUNlM0gsZ0JBRGY7QUFBQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVGY7Ozs7Ozs7Ozs7K2VBTEE7Ozs7O0FBT0E7Ozs7Ozs7O2tCQVFlO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQSx1TUE0RmJtSSxnQkE1RmEsR0E0Rk0seUJBQWlCO0FBQ25DLFVBQUtKLFFBQUwsQ0FBYztBQUNiSztBQURhLEtBQWQ7QUFHQSxJQWhHWTtBQUFBOztBQUFBO0FBQUE7O0FBRWI7Ozs7Ozs7O0FBRmEsbUNBVUdBLGFBVkgsRUFVa0I7QUFDOUIsUUFBSSxLQUFLaEksS0FBTCxDQUFXZ0ksYUFBWCxLQUE2QkEsYUFBakMsRUFBZ0Q7QUFDL0MsVUFBS0wsUUFBTCxDQUFjO0FBQ2JLLHFCQUFlO0FBREYsTUFBZDtBQUdBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7O0FBbEJhO0FBQUE7QUFBQSw2Q0E0QmFGLFNBNUJiLEVBNEJ3QjtBQUNwQyxRQUFJL1UsZUFBSytGLFVBQUwsa0lBQUosRUFBc0Q7QUFDckQsaUpBQWdDZ1AsU0FBaEM7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxTQUFLSCxRQUFMLENBQWM7QUFDYkssb0JBQWU7QUFERixLQUFkO0FBR0E7O0FBRUQ7Ozs7Ozs7Ozs7QUF6Q2E7QUFBQTtBQUFBLG1DQWtER0MsS0FsREgsRUFrRFU7QUFBQTs7QUFDdEIsV0FBT0EsTUFBTXRCLE1BQU4sQ0FBYSxnQkFBUTtBQUMzQixTQUFJLE9BQUszRyxLQUFMLENBQVdnSSxhQUFmLEVBQThCO0FBQzdCLFVBQUksT0FBS2hJLEtBQUwsQ0FBV2dJLGFBQVgsS0FBNkJFLEtBQUtqTixHQUF0QyxFQUEyQztBQUMxQyxjQUFPaU4sSUFBUDtBQUNBO0FBQ0QsTUFKRCxNQUlPO0FBQ04sYUFBT0EsSUFBUDtBQUNBO0FBQ0QsS0FSTSxDQUFQO0FBU0E7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7OztBQTlEYTtBQUFBO0FBQUEsdUNBNEVPZCxHQTVFUCxFQTRFWUMsT0E1RVosRUE0RXFCO0FBQ2pDLFdBQU9sVixTQUFTeU8sS0FBVCxDQUFlQyxLQUFmLENBQXFCdUcsR0FBckIsRUFBMEI7QUFDaENlLHNCQUFpQixLQUFLQSxlQUFMLENBQXFCM1QsSUFBckIsQ0FBMEIsSUFBMUIsRUFBZ0M2UyxPQUFoQyxDQURlO0FBRWhDZSxzQkFBaUIsS0FBS3BJLEtBQUwsQ0FBV2dJLGFBQVgsS0FBNkJYLE9BRmQ7QUFHaENVLHVCQUFrQixLQUFLQSxnQkFBTCxDQUFzQnZULElBQXRCLENBQTJCLElBQTNCLEVBQWlDNlMsT0FBakM7QUFIYyxLQUExQixDQUFQO0FBS0E7O0FBRUQ7Ozs7Ozs7OztBQXBGYTs7QUFBQTtBQUFBLEdBQ2dCekgsZ0JBRGhCO0FBQUEsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1ZmOzs7O0FBRUE7Ozs7Ozs7Ozs7K2VBUEE7Ozs7O0FBU0EsSUFBTXlJLGlCQUFpQixDQUF2QjtBQUNBLElBQU1DLGlCQUFpQixDQUF2QjtBQUNBLElBQU1DLGlCQUFpQixDQUFDLENBQXhCOztBQUVBLElBQU1DLGNBQWMsQ0FBcEI7QUFDQSxJQUFNQyxvQkFBb0IsQ0FBMUI7QUFDQSxJQUFNQyx1QkFBdUIsQ0FBN0I7O0FBRUE7Ozs7Ozs7a0JBTWU7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBLDZNQTJDYmIsS0EzQ2EsR0EyQ0wsaUJBQVM7QUFDaEIsUUFBSSxDQUFDOVIsS0FBRCxJQUFVLE1BQUs0UyxjQUFMLENBQW9CNVMsTUFBTW9CLE1BQTFCLENBQWQsRUFBaUQ7QUFDaEQsU0FBSSxNQUFLeVIsWUFBTCxJQUFxQixNQUFLQSxZQUFMLENBQWtCN1UsTUFBM0MsRUFBbUQ7QUFDbEQsVUFBTThVLHFCQUFxQixNQUFLRCxZQUFMLENBQzFCLE1BQUtFLGlCQURxQixDQUEzQjtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFDQ3ZULFNBQVN3VCxhQUFULEtBQTJCRixrQkFBM0IsSUFDQSxDQUFDLE1BQUsvTixLQUFMLENBQVdrTyxlQUZiLEVBR0U7QUFDRCxXQUNDLE1BQUtKLFlBQUwsQ0FBa0I5TSxPQUFsQixDQUNDdkcsU0FBU3dULGFBRFYsTUFFTSxDQUFDLENBSFIsRUFJRTtBQUNERiwyQkFBbUJoQixLQUFuQjtBQUNBO0FBQ0Q7O0FBRUQsVUFBSTlSLEtBQUosRUFBVztBQUNWQSxhQUFNa1QsZUFBTjtBQUNBbFQsYUFBTVEsY0FBTjtBQUNBO0FBQ0Q7QUFDRDtBQUNELElBeEVZLFFBa0ZiMlMsU0FsRmEsR0FrRkQsaUJBQVM7QUFDcEIsUUFBSSxNQUFLUCxjQUFMLENBQW9CNVMsTUFBTW9CLE1BQTFCLEtBQXFDLE1BQUt5UixZQUE5QyxFQUE0RDtBQUMzRCxTQUFNTyxTQUFTLE1BQUtDLGVBQUwsQ0FBcUJyVCxLQUFyQixDQUFmOztBQUVBLFNBQUlvVCxPQUFPL1AsSUFBWCxFQUFpQjtBQUNoQnJELFlBQU1rVCxlQUFOO0FBQ0FsVCxZQUFNUSxjQUFOOztBQUVBLFVBQUk0UyxPQUFPL1AsSUFBUCxLQUFnQnFQLGlCQUFwQixFQUF1QztBQUN0QyxhQUFLWSxVQUFMLENBQWdCRixPQUFPeEgsU0FBdkI7QUFDQTs7QUFFRCxVQUFJd0gsT0FBTy9QLElBQVAsS0FBZ0JzUCxvQkFBcEIsRUFBMEM7QUFDekMsYUFBSzVOLEtBQUwsQ0FBV3dPLFNBQVgsQ0FBcUJILE9BQU94SCxTQUE1QjtBQUNBO0FBQ0Q7QUFDRDtBQUNELElBbkdZO0FBQUE7O0FBQUE7QUFBQTs7QUFFYjs7Ozs7OztBQUZhLHVDQVNPO0FBQ25CLFFBQUk1TyxlQUFLK0YsVUFBTCxnSUFBSixFQUE4QztBQUM3QztBQUNBOztBQUVELFNBQUt5USxRQUFMO0FBQ0E7O0FBRUQ7Ozs7Ozs7OztBQWpCYTtBQUFBO0FBQUEsd0NBeUJRO0FBQ3BCLFFBQUl4VyxlQUFLK0YsVUFBTCxpSUFBSixFQUErQztBQUM5QztBQUNBOztBQUVELFNBQUt5USxRQUFMO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7OztBQXlDQTs7Ozs7Ozs7O0FBMUVhO0FBQUE7OztBQXFHYjs7Ozs7Ozs7QUFyR2EsNkJBNkdINUgsU0E3R0csRUE2R1E7QUFDcEJBLGdCQUFZNU8sZUFBS3lHLFFBQUwsQ0FBY21JLFNBQWQsSUFBMkJBLFNBQTNCLEdBQXVDLENBQW5EOztBQUVBLFNBQUswSCxVQUFMLENBQWdCMUgsU0FBaEI7QUFDQTs7QUFFRDs7Ozs7Ozs7Ozs7O0FBbkhhO0FBQUE7QUFBQSxtQ0E4SEc1TCxLQTlISCxFQThIVTtBQUN0QixRQUFNb1QsU0FBUztBQUNkL1AsV0FBTW9QO0FBRFEsS0FBZjs7QUFJQSxRQUFJLEtBQUsxTixLQUFMLENBQVdqSCxJQUFmLEVBQXFCO0FBQ3BCLFNBQU04TixZQUFZLEtBQUs2SCxzQkFBTCxDQUE0QnpULEtBQTVCLENBQWxCOztBQUVBLFNBQUk0TCxTQUFKLEVBQWU7QUFDZHdILGFBQU94SCxTQUFQLEdBQW1CQSxTQUFuQjtBQUNBd0gsYUFBTy9QLElBQVAsR0FBY3FQLGlCQUFkO0FBQ0E7O0FBRUQsU0FBTWdCLGdCQUFnQixLQUFLQyxzQkFBTCxDQUNyQjNULEtBRHFCLEVBRXJCNEwsU0FGcUIsQ0FBdEI7O0FBS0EsU0FBSThILGNBQWNFLE9BQWxCLEVBQTJCO0FBQzFCUixhQUFPeEgsU0FBUCxHQUFtQjhILGNBQWM5SCxTQUFqQztBQUNBd0gsYUFBTy9QLElBQVAsR0FBY3NQLG9CQUFkO0FBQ0E7QUFDRDs7QUFFRCxXQUFPUyxNQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBekphO0FBQUE7QUFBQSwwQ0F5S1VwVCxLQXpLVixFQXlLaUI2VCxrQkF6S2pCLEVBeUtxQztBQUNqRCxRQUFNSCxnQkFBZ0I7QUFDckI5SCxnQkFBV2lJLGtCQURVO0FBRXJCRCxjQUFTO0FBRlksS0FBdEI7O0FBS0EsUUFBSSxLQUFLN08sS0FBTCxDQUFXd08sU0FBZixFQUEwQjtBQUN6QixTQUFJLEtBQUtPLFdBQUwsQ0FBaUI5VCxNQUFNK1QsT0FBdkIsRUFBZ0MsS0FBS2hQLEtBQUwsQ0FBV2pILElBQVgsQ0FBZ0I4VixPQUFoRCxDQUFKLEVBQThEO0FBQzdERixvQkFBY0UsT0FBZCxHQUF3QixJQUF4QjtBQUNBO0FBQ0QsU0FDQyxLQUFLRSxXQUFMLENBQWlCOVQsTUFBTStULE9BQXZCLEVBQWdDLEtBQUtoUCxLQUFMLENBQVdqSCxJQUFYLENBQWdCa1csV0FBaEQsQ0FERCxFQUVFO0FBQ0ROLG9CQUFjRSxPQUFkLEdBQXdCLElBQXhCO0FBQ0FGLG9CQUFjOUgsU0FBZCxHQUEwQjJHLGNBQTFCO0FBQ0E7QUFDRCxTQUNDLEtBQUt1QixXQUFMLENBQWlCOVQsTUFBTStULE9BQXZCLEVBQWdDLEtBQUtoUCxLQUFMLENBQVdqSCxJQUFYLENBQWdCbVcsV0FBaEQsQ0FERCxFQUVFO0FBQ0RQLG9CQUFjRSxPQUFkLEdBQXdCLElBQXhCO0FBQ0FGLG9CQUFjOUgsU0FBZCxHQUEwQjRHLGNBQTFCO0FBQ0E7O0FBRUQsU0FDQyxDQUFDa0IsY0FBY0UsT0FBZixJQUNBLENBQUMsS0FBSzdPLEtBQUwsQ0FBV21QLFFBRFosSUFFQUwsa0JBSEQsRUFJRTtBQUNESCxvQkFBY0UsT0FBZCxHQUNFQyx1QkFBdUJyQixjQUF2QixJQUNBLEtBQUtPLGlCQUFMLEtBQTJCLENBRDVCLElBRUNjLHVCQUF1QnRCLGNBQXZCLElBQ0EsS0FBS1EsaUJBQUwsS0FDQyxLQUFLRixZQUFMLENBQWtCN1UsTUFBbEIsR0FBMkIsQ0FMOUI7QUFNQTtBQUNEOztBQUVELFdBQU8wVixhQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7OztBQWpOYTtBQUFBO0FBQUEsMENBNE5VMVQsS0E1TlYsRUE0TmlCO0FBQzdCLFFBQUk0TCxZQUFZMEcsY0FBaEI7O0FBRUEsUUFBSSxLQUFLd0IsV0FBTCxDQUFpQjlULE1BQU0rVCxPQUF2QixFQUFnQyxLQUFLaFAsS0FBTCxDQUFXakgsSUFBWCxDQUFnQnFXLElBQWhELENBQUosRUFBMkQ7QUFDMUR2SSxpQkFBWTJHLGNBQVo7QUFDQTtBQUNELFFBQUksS0FBS3VCLFdBQUwsQ0FBaUI5VCxNQUFNK1QsT0FBdkIsRUFBZ0MsS0FBS2hQLEtBQUwsQ0FBV2pILElBQVgsQ0FBZ0JzVyxJQUFoRCxDQUFKLEVBQTJEO0FBQzFEeEksaUJBQVk0RyxjQUFaO0FBQ0E7O0FBRUQsUUFBSXhTLE1BQU1xVSxPQUFWLEVBQW1CO0FBQ2xCekksa0JBQWEsQ0FBQyxDQUFkO0FBQ0E7O0FBRUQsV0FBT0EsU0FBUDtBQUNBOztBQUVEOzs7Ozs7Ozs7Ozs7QUE3T2E7QUFBQTtBQUFBLCtCQXdQRG1JLE9BeFBDLEVBd1BRalcsSUF4UFIsRUF3UGM7QUFDMUIsV0FBT2QsZUFBS2tHLE9BQUwsQ0FBYXBGLElBQWIsSUFDSkEsS0FBS2lJLE9BQUwsQ0FBYWdPLE9BQWIsTUFBMEIsQ0FBQyxDQUR2QixHQUVKQSxZQUFZalcsSUFGZjtBQUdBOztBQUVEOzs7Ozs7Ozs7Ozs7QUE5UGE7QUFBQTtBQUFBLGtDQXlRRW1FLE9BelFGLEVBeVFXO0FBQ3ZCLFFBQU1nTyxVQUFVaE8sUUFBUWdPLE9BQVIsQ0FBZ0J0SixXQUFoQixFQUFoQjs7QUFFQSxXQUNDc0osWUFBWSxPQUFaLElBQ0FBLFlBQVksUUFEWixJQUVBQSxZQUFZLFVBSGI7QUFLQTs7QUFFRDs7Ozs7Ozs7OztBQW5SYTtBQUFBO0FBQUEsOEJBNFJGckUsU0E1UkUsRUE0UlM7QUFDckIsUUFBTTBJLGlCQUFpQixLQUFLekIsWUFBTCxDQUFrQjdVLE1BQXpDOztBQUVBLFFBQUl1VyxhQUFhLEtBQUsxQixZQUFMLENBQWtCLEtBQUtFLGlCQUF2QixDQUFqQjs7QUFFQXdCLGVBQVdyWSxZQUFYLENBQXdCLFVBQXhCLEVBQW9DLENBQUMsQ0FBckM7O0FBRUEsU0FBSzZXLGlCQUFMLElBQTBCbkgsU0FBMUI7O0FBRUEsUUFBSSxLQUFLN0csS0FBTCxDQUFXbVAsUUFBZixFQUF5QjtBQUN4QjtBQUNBO0FBQ0EsVUFBS25CLGlCQUFMLEdBQ0MsQ0FBRSxLQUFLQSxpQkFBTCxHQUF5QnVCLGNBQTFCLEdBQ0FBLGNBREQsSUFFQUEsY0FIRDtBQUlBLEtBUEQsTUFPTztBQUNOLFVBQUt2QixpQkFBTCxHQUF5QjlGLEtBQUtFLEdBQUwsQ0FDeEJGLEtBQUtDLEdBQUwsQ0FBUyxLQUFLNkYsaUJBQWQsRUFBaUN1QixpQkFBaUIsQ0FBbEQsQ0FEd0IsRUFFeEIsQ0FGd0IsQ0FBekI7QUFJQTs7QUFFREMsaUJBQWEsS0FBSzFCLFlBQUwsQ0FBa0IsS0FBS0UsaUJBQXZCLENBQWI7O0FBRUF3QixlQUFXclksWUFBWCxDQUF3QixVQUF4QixFQUFvQyxDQUFwQztBQUNBcVksZUFBV3pDLEtBQVg7QUFDQTs7QUFFRDs7Ozs7Ozs7O0FBelRhO0FBQUE7QUFBQSw4QkFpVUY7QUFBQTs7QUFDVixRQUFNaEUsVUFBVWpQLG1CQUFTa1AsV0FBVCxDQUFxQixJQUFyQixDQUFoQjs7QUFFQSxRQUFJRCxPQUFKLEVBQWE7QUFDWixTQUFNMEcsY0FBYzFHLFFBQVEyRyxnQkFBUixDQUNuQixLQUFLMVAsS0FBTCxDQUFXeVAsV0FEUSxDQUFwQjs7QUFJQSxTQUFJRSxzQkFBc0IsRUFBMUI7O0FBRUEsVUFBSzdCLFlBQUwsR0FBb0IsRUFBcEI7O0FBRUF0QyxXQUFNb0UsU0FBTixDQUFnQjNPLEtBQWhCLENBQXNCbkssSUFBdEIsQ0FBMkIyWSxXQUEzQixFQUF3Q0ksT0FBeEMsQ0FBZ0QsZ0JBQVE7QUFDdkQsVUFBTUMsZUFBZTFDLEtBQUsyQyxZQUFMLENBQWtCLGVBQWxCLENBQXJCOztBQUVBLFVBQUlELFlBQUosRUFBa0I7QUFDakJILDJCQUFvQjNNLElBQXBCLENBQXlCb0ssSUFBekI7QUFDQSxPQUZELE1BRU87QUFDTixjQUFLVSxZQUFMLENBQWtCOUssSUFBbEIsQ0FBdUJvSyxJQUF2QjtBQUNBO0FBQ0QsTUFSRDs7QUFVQXVDLDJCQUFzQkEsb0JBQW9CSyxJQUFwQixDQUF5QixVQUFDQyxDQUFELEVBQUlDLENBQUosRUFBVTtBQUN4RCxhQUNDalksZUFBS2tZLEtBQUwsQ0FBV0YsRUFBRUYsWUFBRixDQUFlLGVBQWYsQ0FBWCxJQUNBOVgsZUFBS2tZLEtBQUwsQ0FBV0QsRUFBRUgsWUFBRixDQUFlLGVBQWYsQ0FBWCxDQUZEO0FBSUEsTUFMcUIsQ0FBdEI7O0FBT0EsVUFBS2pDLFlBQUwsR0FBb0I2QixvQkFBb0IvTSxNQUFwQixDQUNuQixLQUFLa0wsWUFEYyxDQUFwQjs7QUFJQSxVQUFLRSxpQkFBTCxHQUF5QixDQUF6Qjs7QUFFQSxVQUFLRixZQUFMLENBQWtCc0MsSUFBbEIsQ0FBdUIsVUFBQ2hELElBQUQsRUFBT3BCLEtBQVAsRUFBaUI7QUFDdkMsVUFBSW9CLEtBQUsyQyxZQUFMLENBQWtCLFVBQWxCLE1BQWtDLEdBQXRDLEVBQTJDO0FBQzFDLGNBQUsvQixpQkFBTCxHQUF5QmhDLEtBQXpCO0FBQ0EsY0FBS2UsS0FBTDs7QUFFQSxjQUFPLElBQVA7QUFDQTtBQUNELE1BUEQ7QUFRQTtBQUNEO0FBN1dZOztBQUFBO0FBQUEsR0FDbUJqSSxnQkFEbkI7QUFBQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xCZjs7OztBQUNBOzs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFUQTs7Ozs7QUFXQTs7Ozs7O0lBTU11TCwyQjs7O0FBS0wsc0NBQVlyUSxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsd0pBQ1pBLEtBRFk7O0FBQUE7O0FBR2xCLE1BQU1yRixZQUFZcUYsTUFBTUUsT0FBTixDQUFjOUksTUFBZCxDQUNoQkYsR0FEZ0IsQ0FDWixjQURZLEVBRWhCc0QsWUFGZ0IsRUFBbEI7O0FBSUEsTUFBTTBDLFVBQ0x2QyxVQUFVdUosa0JBQVYsTUFBa0N2SixVQUFVMlYsZUFBVixFQURuQzs7QUFHQSxRQUFLQyxRQUFMLEdBQWdCclQsT0FBaEI7O0FBRUEsTUFBTXNULGVBQWUsTUFBS0QsUUFBTCxDQUFjRSxPQUFkLENBQXNCLEtBQXRCLENBQXJCOztBQUVBLE1BQU1DLFdBQVdGLGVBQ2RBLGFBQWFULFlBQWIsQ0FBMEIsS0FBMUIsQ0FEYyxHQUVkLE1BQUtRLFFBQUwsQ0FBY1IsWUFBZCxDQUEyQixLQUEzQixDQUZIOztBQUlBLFFBQUs3SyxLQUFMLEdBQWE7QUFDWndMO0FBRFksR0FBYjtBQWxCa0I7QUFxQmxCOztBQUVEOzs7Ozs7Ozs7OzJCQU1TO0FBQ1IsT0FBSSxLQUFLMVEsS0FBTCxDQUFXc04sZUFBZixFQUFnQztBQUMvQixXQUNDO0FBQUE7QUFBQSxPQUFLLFdBQVUsd0JBQWY7QUFDQztBQUFBO0FBQUEsUUFBSyxXQUFVLHdCQUFmO0FBQ0M7QUFDQyxxQkFBVyxLQURaO0FBRUMsa0JBQVUsVUFGWDtBQUdDLGlCQUFVLEtBQUtxRCxnQkFIaEI7QUFJQyxrQkFBVyxLQUFLQyxjQUpqQjtBQUtDLG9CQUFZLEtBTGI7QUFNQyxZQUFJLGFBTkw7QUFPQyxjQUFNLEtBUFA7QUFRQyxhQUFLLE1BUk47QUFTQyxjQUFPLEtBQUsxTCxLQUFMLENBQVd3TDtBQVRuQjtBQURELE1BREQ7QUFjQztBQUFBO0FBQUE7QUFDQyxxQkFBWW5YLFlBQVk2SCxPQUFaLENBQW9CeVAsT0FEakM7QUFFQyxrQkFBVSxXQUZYO0FBR0MsZ0JBQVMsS0FBS0MsZUFIZjtBQUlDLGNBQU92WCxZQUFZNkgsT0FBWixDQUFvQnlQLE9BSjVCO0FBS0Msb0NBQUMsb0JBQUQsSUFBWSxRQUFPLE9BQW5CO0FBTEQ7QUFkRCxLQUREO0FBd0JBLElBekJELE1BeUJPO0FBQ04sV0FDQztBQUFBO0FBQUE7QUFDQyxpQkFBVSxXQURYO0FBRUMsZUFBUyxLQUFLRSxpQkFGZjtBQUdDLGdCQUFVLEtBQUsvUSxLQUFMLENBQVdYLFFBSHRCO0FBSUM7QUFBQTtBQUFBLFFBQU8sV0FBVSxlQUFqQjtBQUFBO0FBQUE7QUFKRCxLQUREO0FBUUE7QUFDRDs7QUFFRDs7Ozs7Ozs7O21DQU1pQjtBQUNoQixPQUFNMlIsV0FBVyxJQUFqQjs7QUFFQSxPQUFNQyxhQUFhLFNBQWJBLFVBQWEsR0FBVztBQUM3Qm5YLHVCQUFTa1AsV0FBVCxDQUFxQmdJLFNBQVNFLElBQVQsQ0FBY0MsV0FBbkMsRUFBZ0RwRSxLQUFoRDtBQUNBLElBRkQ7O0FBSUEsT0FBSXhTLE9BQU9xUCxxQkFBWCxFQUFrQztBQUNqQ3JQLFdBQU9xUCxxQkFBUCxDQUE2QnFILFVBQTdCO0FBQ0EsSUFGRCxNQUVPO0FBQ041UCxlQUFXNFAsVUFBWCxFQUF1QixDQUF2QjtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQWVBOzs7Ozs7Ozs7O0FBZ0JBOzs7Ozs7OztBQVVBOzs7Ozs7Ozs7OztFQXJJeUN0UixnQkFBTVMsUzs7QUFBMUNpUSwyQixDQUNFdEwsVyxHQUFjckYsdUI7QUFEaEIyUSwyQixDQUdFbFEsRyxHQUFNLFU7Ozs7O01BZ0did1EsZ0IsR0FBbUIsaUJBQVM7QUFDM0IsU0FBSzlELFFBQUwsQ0FBYztBQUNiNkQsYUFBVXpWLE1BQU1vQixNQUFOLENBQWFEO0FBRFYsR0FBZDs7QUFJQSxTQUFLZ1YsY0FBTDtBQUNBLEU7O01BVURSLGMsR0FBaUIsaUJBQVM7QUFDekIsTUFBSTNWLE1BQU0rVCxPQUFOLEtBQWtCLEVBQXRCLEVBQTBCO0FBQ3pCL1QsU0FBTVEsY0FBTjs7QUFFQSxVQUFLcVYsZUFBTDtBQUNBO0FBQ0QsRTs7TUFRREMsaUIsR0FBb0IsWUFBTTtBQUN6QixTQUFLL1EsS0FBTCxDQUFXaU4sZ0JBQVgsQ0FBNEJvRCw0QkFBNEJsUSxHQUF4RDtBQUNBLEU7O01BU0QyUSxlLEdBQWtCLFlBQU07QUFDdkIsTUFBTTFaLFNBQVMsT0FBSzhJLE9BQUwsQ0FBYTlJLE1BQWIsQ0FBb0JGLEdBQXBCLENBQXdCLGNBQXhCLENBQWY7O0FBRUEsTUFBTXdaLFdBQVcsT0FBS1EsSUFBTCxDQUFVQyxXQUFWLENBQXNCL1UsS0FBdkM7O0FBRUEsU0FBS3lRLFFBQUwsQ0FBYztBQUNiNkQ7QUFEYSxHQUFkOztBQUlBLE1BQU1GLGVBQWUsT0FBS0QsUUFBTCxDQUFjRSxPQUFkLENBQXNCLEtBQXRCLENBQXJCO0FBQ0EsTUFBTVksUUFBUWIsZUFBZUEsWUFBZixHQUE4QixPQUFLRCxRQUFqRDs7QUFFQWMsUUFBTWxhLFlBQU4sQ0FBbUIsS0FBbkIsRUFBMEJ1WixRQUExQjs7QUFFQXRaLFNBQU91RSxJQUFQLENBQVksaUJBQVosRUFBK0IsTUFBL0I7O0FBRUE7QUFDQTtBQUNBLFNBQUtxRSxLQUFMLENBQVdxTixlQUFYO0FBQ0EsRTs7O2tCQUdhM04sd0JBQWNHLE9BQWQsQ0FBc0J3USwyQkFBdEIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5S2Y7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFWQTs7Ozs7SUFZTWlCLHFCOzs7Ozs7Ozs7Ozs7O0FBOERMOzs7Ozs7MkJBTVM7QUFBQTs7QUFDUixPQUFJQyxjQUFjaFksWUFBWTZILE9BQVosQ0FBb0JvUSxNQUF0Qzs7QUFFQSxPQUFJQyxtQkFBbUIsRUFBdkI7O0FBRUEsT0FBTUMsU0FBUyxLQUFLQyxVQUFMLEVBQWY7O0FBRUEsT0FBTUMsWUFBWTtBQUNqQjFVLGFBQVMsTUFEUTtBQUVqQmYsZ0JBQVk7QUFDWDBWLFlBQU87QUFESTtBQUZLLElBQWxCOztBQU9BSCxVQUFPN0IsT0FBUCxDQUFlLGdCQUFRO0FBQ3RCK0IsY0FBVXpWLFVBQVYsQ0FBcUIwVixLQUFyQixHQUE2QnpFLEtBQUswRSxVQUFsQzs7QUFFQSxRQUFJLE9BQUtDLFlBQUwsQ0FBa0JILFNBQWxCLENBQUosRUFBa0M7QUFDakNMLG1CQUFjbkUsS0FBSzlILElBQW5COztBQUVBbU0sd0JBQW1CckUsS0FBS25ILEtBQUwsQ0FBVzlKLFVBQVgsQ0FBc0IwVixLQUF6QztBQUNBO0FBQ0QsSUFSRDs7QUFkUSxnQkF3QnFDLEtBQUs3UixLQXhCMUM7QUFBQSxPQXdCRHdNLFFBeEJDLFVBd0JEQSxRQXhCQztBQUFBLE9Bd0JTbk4sUUF4QlQsVUF3QlNBLFFBeEJUO0FBQUEsT0F3Qm1Cc04sY0F4Qm5CLFVBd0JtQkEsY0F4Qm5COzs7QUEwQlIsT0FBTXFGLG9CQUFvQjtBQUN6QkMsaUJBQWFWLFdBRFk7QUFFekIvQyxlQUFXN0IsY0FGYztBQUd6QnVGLDBCQUFzQixLQUhHO0FBSXpCNVMsWUFBUW9TO0FBSmlCLElBQTFCOztBQU9BLFVBQ0M7QUFBQTtBQUFBLE1BQUssV0FBVSw4QkFBZjtBQUNDO0FBQUE7QUFBQTtBQUNDLHVCQUFlbEYsUUFEaEI7QUFFQyxpQkFBVSxvQkFGWDtBQUdDLGVBQVNHLGNBSFY7QUFJQyxZQUFLLFVBSk47QUFLQyxnQkFBVXROLFFBTFg7QUFNQztBQUFBO0FBQUEsUUFBTSxXQUFXb1MsZ0JBQWpCO0FBQ0Msb0NBQUMsb0JBQUQsSUFBWSxRQUFPLFNBQW5CO0FBREQ7QUFORCxLQUREO0FBV0VqRixnQkFBWSw4QkFBQywwQkFBRCxFQUFzQndGLGlCQUF0QjtBQVhkLElBREQ7QUFlQTs7OzhCQUVXcFYsUyxFQUFXO0FBQUE7O0FBQ3RCLE9BQU14RixTQUFTLEtBQUs4SSxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFmOztBQUVBLE9BQU1pYixjQUFjO0FBQ25CalYsYUFBUyxNQURVO0FBRW5CZixnQkFBWTtBQUNYMFYsWUFBT2pWO0FBREk7QUFGTyxJQUFwQjs7QUFPQXhGLFVBQU9vRCxZQUFQLEdBQXNCbUssSUFBdEI7O0FBRUEsUUFBS2dOLFVBQUwsR0FBa0I5QixPQUFsQixDQUEwQixnQkFBUTtBQUNqQ3NDLGdCQUFZaFcsVUFBWixDQUF1QjBWLEtBQXZCLEdBQStCekUsS0FBSzBFLFVBQXBDOztBQUVBLFFBQUksT0FBS0MsWUFBTCxDQUFrQkksV0FBbEIsQ0FBSixFQUFvQztBQUNuQy9hLFlBQU93TixXQUFQLENBQW1CLElBQUl2TixTQUFTNE8sS0FBYixDQUFtQmtNLFdBQW5CLENBQW5CO0FBQ0E7QUFDRCxJQU5EOztBQVFBQSxlQUFZaFcsVUFBWixDQUF1QjBWLEtBQXZCLEdBQStCalYsU0FBL0I7O0FBRUEsT0FBTXFKLFFBQVEsSUFBSTVPLFNBQVM0TyxLQUFiLENBQW1Ca00sV0FBbkIsQ0FBZDs7QUFFQS9hLFVBQU9vTixVQUFQLENBQWtCeUIsS0FBbEI7O0FBRUE3TyxVQUFPb0QsWUFBUCxHQUFzQnFLLE1BQXRCOztBQUVBek4sVUFBT3VFLElBQVAsQ0FBWSxpQkFBWixFQUErQixJQUEvQjtBQUNBOztBQUVEOzs7Ozs7Ozs7Ozs7OytCQVVhd1csVyxFQUFhO0FBQ3pCLE9BQU1qWSxlQUFlLEtBQUtnRyxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFyQjs7QUFFQTtBQUNBO0FBQ0FpYixpQkFBYzlhLFNBQVN5TyxLQUFULENBQWVDLEtBQWYsQ0FBcUIsRUFBQzdJLFNBQVMsTUFBVixFQUFyQixFQUF3Q2lWLFdBQXhDLENBQWQ7O0FBRUEsT0FBTWxNLFFBQVEsSUFBSTVPLFNBQVM0TyxLQUFiLENBQW1Ca00sV0FBbkIsQ0FBZDs7QUFFQSxVQUFPbE0sTUFBTU0sV0FBTixDQUFrQnJNLGFBQWE0QixXQUFiLEVBQWxCLEVBQThDNUIsWUFBOUMsQ0FBUDtBQUNBOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7K0JBWWE7QUFDWixVQUNDLEtBQUs4RixLQUFMLENBQVdWLE1BQVgsSUFBcUIsQ0FDcEI7QUFDQ2dHLFVBQU0vTCxZQUFZNkgsT0FBWixDQUFvQm9RLE1BRDNCO0FBRUN2TCxXQUFPO0FBQ04vSSxjQUFTLE1BREg7QUFFTmYsaUJBQVk7QUFDWDBWLGFBQU87QUFESTtBQUZOLEtBRlI7QUFRQ0MsZ0JBQVksRUFSYjtBQVNDTSxhQUFTLEtBQUtDLFdBQUwsQ0FBaUIzWSxJQUFqQixDQUFzQixJQUF0QixFQUE0QixFQUE1QjtBQVRWLElBRG9CLEVBWXBCO0FBQ0M0TCxVQUFNL0wsWUFBWTZILE9BQVosQ0FBb0JrUixPQUQzQjtBQUVDck0sV0FBTztBQUNOL0ksY0FBUyxNQURIO0FBRU5mLGlCQUFZO0FBQ1gwVixhQUFPO0FBREk7QUFGTixLQUZSO0FBUUNDLGdCQUFZLFlBUmI7QUFTQ00sYUFBUyxLQUFLQyxXQUFMLENBQWlCM1ksSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEIsWUFBNUI7QUFUVixJQVpvQixFQXVCcEI7QUFDQzRMLFVBQU0vTCxZQUFZNkgsT0FBWixDQUFvQm1SLFFBRDNCO0FBRUN0TSxXQUFPO0FBQ04vSSxjQUFTLE1BREg7QUFFTmYsaUJBQVk7QUFDWDBWLGFBQU87QUFESTtBQUZOLEtBRlI7QUFRQ0MsZ0JBQVksY0FSYjtBQVNDTSxhQUFTLEtBQUtDLFdBQUwsQ0FBaUIzWSxJQUFqQixDQUFzQixJQUF0QixFQUE0QixjQUE1QjtBQVRWLElBdkJvQixFQWtDcEI7QUFDQzRMLFVBQU0vTCxZQUFZNkgsT0FBWixDQUFvQm9SLE9BRDNCO0FBRUN2TSxXQUFPO0FBQ04vSSxjQUFTLE1BREg7QUFFTmYsaUJBQVk7QUFDWDBWLGFBQU87QUFESTtBQUZOLEtBRlI7QUFRQ0MsZ0JBQVksWUFSYjtBQVNDTSxhQUFTLEtBQUtDLFdBQUwsQ0FBaUIzWSxJQUFqQixDQUFzQixJQUF0QixFQUE0QixZQUE1QjtBQVRWLElBbENvQixFQTZDcEI7QUFDQzRMLFVBQU0vTCxZQUFZNkgsT0FBWixDQUFvQnFSLE1BRDNCO0FBRUN4TSxXQUFPO0FBQ04vSSxjQUFTLE1BREg7QUFFTmYsaUJBQVk7QUFDWDBWLGFBQU87QUFESTtBQUZOLEtBRlI7QUFRQ0MsZ0JBQVksV0FSYjtBQVNDTSxhQUFTLEtBQUtDLFdBQUwsQ0FBaUIzWSxJQUFqQixDQUFzQixJQUF0QixFQUE0QixXQUE1QjtBQVRWLElBN0NvQixFQXdEcEI7QUFDQzRMLFVBQU0vTCxZQUFZNkgsT0FBWixDQUFvQnNSLE9BRDNCO0FBRUN6TSxXQUFPO0FBQ04vSSxjQUFTLE1BREg7QUFFTmYsaUJBQVk7QUFDWDBWLGFBQU87QUFESTtBQUZOLEtBRlI7QUFRQ0MsZ0JBQVksWUFSYjtBQVNDTSxhQUFTLEtBQUtDLFdBQUwsQ0FBaUIzWSxJQUFqQixDQUFzQixJQUF0QixFQUE0QixZQUE1QjtBQVRWLElBeERvQixFQW1FcEI7QUFDQzRMLFVBQU0vTCxZQUFZNkgsT0FBWixDQUFvQnVSLElBRDNCO0FBRUMxTSxXQUFPO0FBQ04vSSxjQUFTLE1BREg7QUFFTmYsaUJBQVk7QUFDWDBWLGFBQU87QUFESTtBQUZOLEtBRlI7QUFRQ0MsZ0JBQVksU0FSYjtBQVNDTSxhQUFTLEtBQUtDLFdBQUwsQ0FBaUIzWSxJQUFqQixDQUFzQixJQUF0QixFQUE0QixTQUE1QjtBQVRWLElBbkVvQixDQUR0QjtBQWlGQTs7OztFQXpRa0NpRyxnQkFBTVMsUzs7QUFBcENrUixxQixDQUNFdk0sVyxHQUFjckYsdUI7QUFEaEI0UixxQixDQUdFblIsRyxHQUFNLGlCO0FBSFJtUixxQixDQUtFc0IsUyxHQUFZO0FBQ2xCOzs7Ozs7O0FBT0FwRyxXQUFVcUcsb0JBQVVDLElBUkY7O0FBVWxCOzs7Ozs7O0FBT0FDLFFBQU9GLG9CQUFVRyxNQWpCQzs7QUFtQmxCOzs7Ozs7O0FBT0FkLHVCQUFzQlcsb0JBQVVDLElBMUJkOztBQTRCbEI7Ozs7Ozs7QUFPQXhULFNBQVF1VCxvQkFBVUksT0FBVixDQUFrQkosb0JBQVVLLE1BQTVCLENBbkNVOztBQXFDbEI7Ozs7Ozs7O0FBUUE3VCxXQUFVd1Qsb0JBQVVNLE1BN0NGOztBQStDbEI7Ozs7Ozs7QUFPQXhHLGlCQUFnQmtHLG9CQUFVTztBQXREUixDO2tCQXVRTDlCLHFCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25SZjs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBWEE7Ozs7O0FBYUE7Ozs7Ozs7OztJQVNNK0IsVTs7Ozs7Ozs7Ozs7OztBQTZCTDs7Ozs7Ozs7O0FBNUJBOzs7Ozs7OzsyQkFvQ1M7QUFDUixPQUFNQywyQkFBeUIsS0FBS0MsZUFBTCxFQUEvQjs7QUFFQSxVQUNDO0FBQUE7QUFBQTtBQUNDLG1CQUFZaGEsWUFBWTZILE9BQVosQ0FBb0JvUyxJQURqQztBQUVDLHFCQUFjRixTQUFTdFMsT0FBVCxDQUFpQixTQUFqQixNQUFnQyxDQUFDLENBRmhEO0FBR0MsZ0JBQVdzUyxRQUhaO0FBSUMsa0JBQVUsYUFKWDtBQUtDLGNBQVMsS0FBS2xPLFdBTGY7QUFNQyxlQUFVLEtBQUtwRixLQUFMLENBQVdYLFFBTnRCO0FBT0MsWUFBTzlGLFlBQVk2SCxPQUFaLENBQW9Cb1MsSUFQNUI7QUFRQyxrQ0FBQyxvQkFBRCxJQUFZLFFBQU8sTUFBbkI7QUFSRCxJQUREO0FBWUE7O0FBakNEOzs7Ozs7Ozs7Ozs7RUFuQndCN1QsZ0JBQU1TLFM7O0FBQXpCaVQsVSxDQVNFaEgsWSxHQUFlO0FBQ3JCckgsVUFBUyxNQURZO0FBRXJCSyxZQUFXO0FBQ1ZHLE1BQUksYUFETTtBQUVWek0sUUFBTTFCLFNBQVMwSCxJQUFULEdBQWdCLEVBRlosQ0FFZTtBQUZmLElBR1Z1RyxNQUFNO0FBSEksRUFGVTtBQU9yQlcsUUFBTztBQVBjLEM7QUFUakJvTixVLENBMkJFbFQsRyxHQUFNLE07a0JBNEJDLDZCQUNkLCtCQUFnQixrQ0FBbUIsMkJBQVlrVCxVQUFaLENBQW5CLENBQWhCLENBRGMsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4RWY7Ozs7QUFFQTs7Ozs7Ozs7OzsrZUFQQTs7Ozs7QUFTQTs7Ozs7SUFLTUksaUI7OztBQUdMOzs7Ozs7QUFvQkEsNEJBQVl6VCxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsb0lBQ1pBLEtBRFk7O0FBQUEsUUE0Rm5CMFQsU0E1Rm1CLEdBNEZQLFlBQU07QUFDakIsT0FBTUMsVUFBVSxNQUFLQyxrQkFBTCxDQUF3QkMsT0FBeEM7QUFDQSxPQUFNQyxXQUFXLE1BQUtDLG1CQUFMLENBQXlCRixPQUExQzs7QUFFQSxPQUFNM1QsVUFBVTRULFNBQVNFLFVBQVQsQ0FBb0IsSUFBcEIsQ0FBaEI7O0FBRUEsT0FBTXhKLFNBQVMsTUFBS3lKLFlBQXBCO0FBQ0EsT0FBTTNNLFFBQVEsTUFBS3RILEtBQUwsQ0FBV2tVLFVBQXpCOztBQUVBLE9BQUk1TSxTQUFTa0QsTUFBYixFQUFxQjtBQUNwQnNKLGFBQVN4TSxLQUFULEdBQWlCQSxLQUFqQjtBQUNBd00sYUFBU3RKLE1BQVQsR0FBa0JBLE1BQWxCOztBQUVBdEssWUFBUWlVLFNBQVIsQ0FBa0JSLE9BQWxCLEVBQTJCLENBQTNCLEVBQThCLENBQTlCLEVBQWlDck0sS0FBakMsRUFBd0NrRCxNQUF4Qzs7QUFFQSxRQUFNNEosU0FBU04sU0FBU08sU0FBVCxDQUFtQixXQUFuQixDQUFmOztBQUVBLFFBQU1DLEtBQUtqZCxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBYixDQUFxQnFYLGNBQXJCLENBQ1YsZUFBZUgsTUFBZixHQUF3QixJQURkLENBQVg7O0FBSUEsUUFBTWhkLFNBQVMsTUFBSzhJLE9BQUwsQ0FBYTlJLE1BQWIsQ0FBb0JGLEdBQXBCLENBQXdCLGNBQXhCLENBQWY7O0FBRUFFLFdBQU9vZCxhQUFQLENBQXFCRixFQUFyQjs7QUFFQSxVQUFLdFUsS0FBTCxDQUFXcU4sZUFBWDs7QUFFQWpXLFdBQU91RSxJQUFQLENBQVksaUJBQVo7O0FBRUF2RSxXQUFPdUUsSUFBUCxDQUFZLGdCQUFaLEVBQThCMlksRUFBOUI7QUFDQTtBQUNELEdBM0hrQjs7QUFBQSxRQXNJbkJHLGtCQXRJbUIsR0FzSUUsaUJBQVM7QUFDN0JsYSxVQUFPbWEsS0FBUCxDQUFhLHdCQUF3QkMsS0FBckM7QUFDQSxHQXhJa0I7O0FBQUEsUUFvSm5CQyxvQkFwSm1CLEdBb0pJLGtCQUFVO0FBQ2hDLE9BQU1qQixVQUFVLE1BQUtDLGtCQUFMLENBQXdCQyxPQUF4QztBQUNBLE9BQU1DLFdBQVcsTUFBS0MsbUJBQUwsQ0FBeUJGLE9BQTFDOztBQUVBRixXQUFRa0IsZ0JBQVIsQ0FDQyxTQURELEVBRUMsWUFBTTtBQUNMLFFBQUlySyxTQUNIbUosUUFBUW1CLFdBQVIsSUFDQ25CLFFBQVFPLFVBQVIsR0FBcUIsTUFBS2xVLEtBQUwsQ0FBV2tVLFVBRGpDLENBREQ7O0FBSUEsUUFBSWEsTUFBTXZLLE1BQU4sQ0FBSixFQUFtQjtBQUNsQkEsY0FBUyxNQUFLeEssS0FBTCxDQUFXa1UsVUFBWCxJQUF5QixJQUFJLENBQTdCLENBQVQ7QUFDQTs7QUFFRFAsWUFBUXhjLFlBQVIsQ0FBcUIsT0FBckIsRUFBOEIsTUFBSzZJLEtBQUwsQ0FBV2tVLFVBQXpDO0FBQ0FQLFlBQVF4YyxZQUFSLENBQXFCLFFBQXJCLEVBQStCcVQsTUFBL0I7QUFDQXNKLGFBQVMzYyxZQUFULENBQXNCLE9BQXRCLEVBQStCLE1BQUs2SSxLQUFMLENBQVdrVSxVQUExQztBQUNBSixhQUFTM2MsWUFBVCxDQUFzQixRQUF0QixFQUFnQ3FULE1BQWhDOztBQUVBLFVBQUt5SixZQUFMLEdBQW9CekosTUFBcEI7QUFDQSxJQWpCRixFQWtCQyxLQWxCRDs7QUFxQkEsU0FBS3dLLE9BQUwsR0FBZUMsTUFBZjs7QUFFQSxPQUFJeFQsVUFBVXlULGVBQWQsRUFBK0I7QUFDOUJ2QixZQUFRd0IsWUFBUixHQUF1QkYsTUFBdkI7QUFDQSxJQUZELE1BRU87QUFDTnRCLFlBQVF5QixTQUFSLEdBQW9CSCxNQUFwQjtBQUNBOztBQUVEdEIsV0FBUTBCLElBQVI7O0FBRUEsU0FBS0MsbUJBQUwsQ0FBeUJ6QixPQUF6QixDQUFpQ3RCLFFBQWpDLEdBQTRDLEtBQTVDO0FBQ0EsR0F4TGtCOztBQUVsQixRQUFLK0MsbUJBQUwsR0FBMkIzVixnQkFBTTRWLFNBQU4sRUFBM0I7QUFDQSxRQUFLeEIsbUJBQUwsR0FBMkJwVSxnQkFBTTRWLFNBQU4sRUFBM0I7QUFDQSxRQUFLM0Isa0JBQUwsR0FBMEJqVSxnQkFBTTRWLFNBQU4sRUFBMUI7QUFKa0I7QUFLbEI7O0FBRUQ7Ozs7Ozs7Ozs7O0FBakJBOzs7Ozs7Ozs7Ozs7c0NBMEJvQjtBQUNuQixRQUFLRCxtQkFBTCxDQUF5QnpCLE9BQXpCLENBQWlDOUcsS0FBakM7QUFDQTs7QUFFRDs7Ozs7Ozs7Ozt5Q0FPdUI7QUFDdEIsT0FBSSxLQUFLaUksT0FBVCxFQUFrQjtBQUNqQixRQUFJLEtBQUtBLE9BQUwsQ0FBYVEsSUFBakIsRUFBdUI7QUFDdEIsVUFBS1IsT0FBTCxDQUFhUSxJQUFiO0FBQ0EsS0FGRCxNQUVPLElBQUksS0FBS1IsT0FBTCxDQUFhUyxjQUFqQixFQUFpQztBQUN2QyxVQUFLVCxPQUFMLENBQWFTLGNBQWIsR0FBOEI1RixPQUE5QixDQUFzQyxpQkFBUztBQUM5QzZGLFlBQU1GLElBQU47QUFDQSxNQUZEO0FBR0E7QUFDRCxTQUFLUixPQUFMLEdBQWUsSUFBZjtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUFrSkE7Ozs7Ozs7MkJBMUlTO0FBQ1IsT0FBTVcsZUFDTGxVLFVBQVVrVSxZQUFWLElBQ0FsVSxVQUFVbVUsa0JBRFYsSUFFQW5VLFVBQVV5VCxlQUZWLElBR0F6VCxVQUFVb1UsY0FKWDs7QUFNQUYsZ0JBQWE3ZSxJQUFiLENBQ0MySyxTQURELEVBRUM7QUFDQ3FVLFdBQU8sSUFEUjtBQUVDQyxXQUFPO0FBRlIsSUFGRCxFQU1DLEtBQUtuQixvQkFOTixFQU9DLEtBQUtILGtCQVBOOztBQVVBLFVBQ0M7QUFBQTtBQUFBLE1BQUssV0FBVSxXQUFmO0FBQ0M7QUFBQTtBQUFBLE9BQU8sS0FBSyxLQUFLYixrQkFBakI7QUFBQTtBQUFBLEtBREQ7QUFJQztBQUFBO0FBQUE7QUFDQyxpQkFBVSxpQkFEWDtBQUVDLGVBQVMsS0FBS0YsU0FGZjtBQUdDLFdBQUssS0FBSzRCLG1CQUhYO0FBQUE7QUFBQSxLQUpEO0FBVUM7QUFDQyxnQkFBVSxrQkFEWDtBQUVDLFVBQUssS0FBS3ZCO0FBRlg7QUFWRCxJQUREO0FBaUJBOztBQUVEOzs7Ozs7Ozs7O0FBeUNBOzs7Ozs7Ozs7OztBQWFBOzs7Ozs7Ozs7Ozs7OztFQWpLK0JwVSxnQkFBTVMsUzs7QUFBaENxVCxpQixDQUNFMU8sVyxHQUFjckYsdUI7QUFEaEIrVCxpQixDQVNFcEgsWSxHQUFlO0FBQ3JCNkgsYUFBWTtBQURTLEM7QUFUakJULGlCLENBcUJFdFQsRyxHQUFNLGE7a0JBcU1Dc1QsaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbk9mOzs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFSQTs7Ozs7QUFVQTs7Ozs7Ozs7SUFRTXVDLFk7Ozs7Ozs7Ozs7Ozs7QUFXTDs7Ozs7Ozs7MkJBUVM7QUFDUixPQUFJLEtBQUtoVyxLQUFMLENBQVdzTixlQUFmLEVBQWdDO0FBQy9CLFdBQU8sOEJBQUMsMkJBQUQsRUFBdUIsS0FBS3ROLEtBQTVCLENBQVA7QUFDQSxJQUZELE1BRU87QUFDTixRQUFNdVMsV0FBVyxFQUNoQjlRLFVBQVVrVSxZQUFWLElBQ0NsVSxVQUFVbVUsa0JBQVYsSUFDQW5aLFNBQVN3WixRQUFULEtBQXNCLE9BRnZCLElBR0F4VSxVQUFVeVQsZUFIVixJQUlBelQsVUFBVW9VLGNBTE0sQ0FBakI7O0FBUUEsUUFBTTlDLFFBQVFSLFdBQ1hoWixZQUFZNkgsT0FBWixDQUFvQjhVLGNBRFQsR0FFWDNjLFlBQVk2SCxPQUFaLENBQW9CK1UsTUFGdkI7O0FBSUEsV0FDQztBQUFBO0FBQUE7QUFDQyxvQkFBWXBELEtBRGI7QUFFQyxpQkFBVSxXQUZYO0FBR0MsbUJBQVUscUJBSFg7QUFJQyxnQkFBVVIsUUFKWDtBQUtDLGVBQVMsS0FBS3ZTLEtBQUwsQ0FBV2lOLGdCQUFYLENBQTRCdlQsSUFBNUIsQ0FBaUNzYyxhQUFhN1YsR0FBOUMsQ0FMVjtBQU1DLGdCQUFVLEtBQUtILEtBQUwsQ0FBV1gsUUFOdEI7QUFPQyxhQUFPMFQsS0FQUjtBQVFDLG1DQUFDLG9CQUFELElBQVksUUFBTyxRQUFuQjtBQVJELEtBREQ7QUFZQTtBQUNEO0FBL0NEOzs7Ozs7Ozs7Ozs7RUFEMEJwVCxnQkFBTVMsUzs7QUFBM0I0VixZLENBU0U3VixHLEdBQU0sUTtrQkEwQ0M2VixZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hFZjs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVZBOzs7OztBQVlBOzs7Ozs7OztJQVFNSSxVOzs7Ozs7Ozs7Ozs7O0FBd0JMOzs7Ozs7Ozs7QUF2QkE7Ozs7Ozs7MkJBK0JTO0FBQ1IsT0FBTTlDLDBCQUF3QixLQUFLQyxlQUFMLEVBQTlCOztBQUVBLFVBQ0M7QUFBQTtBQUFBO0FBQ0MsbUJBQVloYSxZQUFZNkgsT0FBWixDQUFvQmlWLElBRGpDO0FBRUMscUJBQWMvQyxTQUFTdFMsT0FBVCxDQUFpQixTQUFqQixNQUFnQyxDQUFDLENBRmhEO0FBR0MsZ0JBQVdzUyxRQUhaO0FBSUMsa0JBQVUsYUFKWDtBQUtDLGNBQVMsS0FBSzlPLFVBTGY7QUFNQyxlQUFVLEtBQUt4RSxLQUFMLENBQVdYLFFBTnRCO0FBT0MsWUFBTzlGLFlBQVk2SCxPQUFaLENBQW9CaVYsSUFQNUI7QUFRQyxrQ0FBQyxvQkFBRCxJQUFZLFFBQU8sTUFBbkI7QUFSRCxJQUREO0FBWUE7O0FBakNEOzs7Ozs7Ozs7Ozs7RUFkd0IxVyxnQkFBTVMsUzs7QUFBekJnVyxVLENBUUUvSixZLEdBQWU7QUFDckJwRyxRQUFPO0FBQ04vSSxXQUFTO0FBREg7QUFEYyxDO0FBUmpCa1osVSxDQXNCRWpXLEcsR0FBTSxNO2tCQTRCQyxpQ0FBa0Isa0NBQW1CLDJCQUFZaVcsVUFBWixDQUFuQixDQUFsQixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pFZjs7OztBQUNBOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVZBOzs7OztBQVlBOzs7Ozs7SUFNTUUsVzs7Ozs7Ozs7Ozs7OztBQThETDs7Ozs7OzJCQU1TO0FBQUE7O0FBQ1IsT0FBSS9FLGNBQWNoWSxZQUFZNkgsT0FBWixDQUFvQm9RLE1BQXRDOztBQUVBLE9BQU1FLFNBQVMsS0FBS0MsVUFBTCxFQUFmOztBQUVBRCxVQUFPdEIsSUFBUCxDQUFZLGdCQUFRO0FBQ25CLFFBQUksT0FBSzJCLFlBQUwsQ0FBa0IzRSxLQUFLbkgsS0FBdkIsQ0FBSixFQUFtQztBQUNsQ3NMLG1CQUFjbkUsS0FBSzlILElBQW5CO0FBQ0E7QUFDRCxJQUpEOztBQUxRLGdCQVdxQyxLQUFLdEYsS0FYMUM7QUFBQSxPQVdEd00sUUFYQyxVQVdEQSxRQVhDO0FBQUEsT0FXU25OLFFBWFQsVUFXU0EsUUFYVDtBQUFBLE9BV21Cc04sY0FYbkIsVUFXbUJBLGNBWG5COzs7QUFhUixPQUFNcUYsb0JBQW9CO0FBQ3pCQyxpQkFBYVYsV0FEWTtBQUV6Qi9DLGVBQVc3QixjQUZjO0FBR3pCdUYsMEJBQXNCLEtBSEc7QUFJekI1UyxZQUFRb1M7QUFKaUIsSUFBMUI7O0FBT0EsVUFDQztBQUFBO0FBQUEsTUFBSyxXQUFVLDhCQUFmO0FBQ0M7QUFBQTtBQUFBO0FBQ0MsdUJBQWVsRixRQURoQjtBQUVDLGlCQUFVLG9CQUZYO0FBR0MsZUFBU0csY0FIVjtBQUlDLFlBQUssVUFKTjtBQUtDLGdCQUFVdE4sUUFMWDtBQU1DO0FBQUE7QUFBQTtBQUNDLG9DQUFDLG9CQUFELElBQVksUUFBTyxjQUFuQjtBQUREO0FBTkQsS0FERDtBQVdFbU4sZ0JBQVksOEJBQUMsMEJBQUQsRUFBc0J3RixpQkFBdEI7QUFYZCxJQUREO0FBZUE7Ozs4QkFFV3BWLFMsRUFBVztBQUFBOztBQUN0QixPQUFNeEYsU0FBUyxLQUFLOEksT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FBZjs7QUFFQSxPQUFNaWIsY0FBYztBQUNuQmpWLGFBQVMsTUFEVTtBQUVuQmYsZ0JBQVk7QUFDWDBWLFlBQU9qVjtBQURJO0FBRk8sSUFBcEI7O0FBT0EsT0FBTXFKLFFBQVEsSUFBSTVPLFNBQVM0TyxLQUFiLENBQW1Ca00sV0FBbkIsQ0FBZDs7QUFFQS9hLFVBQU9vRCxZQUFQLEdBQXNCbUssSUFBdEI7O0FBRUEsUUFBS2dOLFVBQUwsR0FBa0I5QixPQUFsQixDQUEwQixnQkFBUTtBQUNqQyxRQUFJLE9BQUtrQyxZQUFMLENBQWtCM0UsS0FBS25ILEtBQXZCLENBQUosRUFBbUM7QUFDbEM3TyxZQUFPd04sV0FBUCxDQUFtQixJQUFJdk4sU0FBUzRPLEtBQWIsQ0FBbUJtSCxLQUFLbkgsS0FBeEIsQ0FBbkI7QUFDQTtBQUNELElBSkQ7O0FBTUE3TyxVQUFPb04sVUFBUCxDQUFrQnlCLEtBQWxCOztBQUVBN08sVUFBT29ELFlBQVAsR0FBc0JxSyxNQUF0Qjs7QUFFQXpOLFVBQU91RSxJQUFQLENBQVksaUJBQVosRUFBK0IsSUFBL0I7QUFDQTs7QUFFRDs7Ozs7Ozs7Ozs7OzsrQkFVYXdXLFcsRUFBYTtBQUN6QixPQUFNalksZUFBZSxLQUFLZ0csT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FBckI7O0FBRUE7QUFDQTtBQUNBaWIsaUJBQWM5YSxTQUFTeU8sS0FBVCxDQUFlQyxLQUFmLENBQXFCLEVBQUM3SSxTQUFTLE1BQVYsRUFBckIsRUFBd0NpVixXQUF4QyxDQUFkOztBQUVBLE9BQU1sTSxRQUFRLElBQUk1TyxTQUFTNE8sS0FBYixDQUFtQmtNLFdBQW5CLENBQWQ7O0FBRUEsVUFBT2xNLE1BQU1NLFdBQU4sQ0FBa0JyTSxhQUFhNEIsV0FBYixFQUFsQixFQUE4QzVCLFlBQTlDLENBQVA7QUFDQTs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7OzsrQkFhYTtBQUNaLFVBQ0MsS0FBSzhGLEtBQUwsQ0FBV1YsTUFBWCxJQUFxQixDQUNwQjtBQUNDZ0csVUFBTS9MLFlBQVk2SCxPQUFaLENBQW9Ca1IsT0FEM0I7QUFFQ3JNLFdBQU87QUFDTi9JLGNBQVMsTUFESDtBQUVOZixpQkFBWTtBQUNYMFYsYUFBTztBQURJO0FBRk4sS0FGUjtBQVFDTyxhQUFTLEtBQUtDLFdBQUwsQ0FBaUIzWSxJQUFqQixDQUFzQixJQUF0QixFQUE0QixjQUE1QjtBQVJWLElBRG9CLEVBV3BCO0FBQ0M0TCxVQUFNL0wsWUFBWTZILE9BQVosQ0FBb0JvUixPQUQzQjtBQUVDdk0sV0FBTztBQUNOL0ksY0FBUyxNQURIO0FBRU5mLGlCQUFZO0FBQ1gwVixhQUFPO0FBREk7QUFGTixLQUZSO0FBUUNPLGFBQVMsS0FBS0MsV0FBTCxDQUFpQjNZLElBQWpCLENBQXNCLElBQXRCLEVBQTRCLGNBQTVCO0FBUlYsSUFYb0IsRUFxQnBCO0FBQ0M0TCxVQUFNL0wsWUFBWTZILE9BQVosQ0FBb0JxUixNQUQzQjtBQUVDeE0sV0FBTztBQUNOL0ksY0FBUyxNQURIO0FBRU5mLGlCQUFZO0FBQ1gwVixhQUFPO0FBREk7QUFGTixLQUZSO0FBUUNPLGFBQVMsS0FBS0MsV0FBTCxDQUFpQjNZLElBQWpCLENBQXNCLElBQXRCLEVBQTRCLGFBQTVCO0FBUlYsSUFyQm9CLEVBK0JwQjtBQUNDNEwsVUFBTS9MLFlBQVk2SCxPQUFaLENBQW9Cc1IsT0FEM0I7QUFFQ3pNLFdBQU87QUFDTi9JLGNBQVMsTUFESDtBQUVOZixpQkFBWTtBQUNYMFYsYUFBTztBQURJO0FBRk4sS0FGUjtBQVFDTyxhQUFTLEtBQUtDLFdBQUwsQ0FBaUIzWSxJQUFqQixDQUFzQixJQUF0QixFQUE0QixjQUE1QjtBQVJWLElBL0JvQixFQXlDcEI7QUFDQzRMLFVBQU0vTCxZQUFZNkgsT0FBWixDQUFvQnVSLElBRDNCO0FBRUMxTSxXQUFPO0FBQ04vSSxjQUFTLE1BREg7QUFFTmYsaUJBQVk7QUFDWDBWLGFBQU87QUFESTtBQUZOLEtBRlI7QUFRQ08sYUFBUyxLQUFLQyxXQUFMLENBQWlCM1ksSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEIsV0FBNUI7QUFSVixJQXpDb0IsRUFtRHBCO0FBQ0M0TCxVQUFNL0wsWUFBWTZILE9BQVosQ0FBb0JtVixJQUQzQjtBQUVDdFEsV0FBTztBQUNOL0ksY0FBUyxNQURIO0FBRU5mLGlCQUFZO0FBQ1gwVixhQUFPO0FBREk7QUFGTixLQUZSO0FBUUNPLGFBQVMsS0FBS0MsV0FBTCxDQUFpQjNZLElBQWpCLENBQXNCLElBQXRCLEVBQTRCLFdBQTVCO0FBUlYsSUFuRG9CLEVBNkRwQjtBQUNDNEwsVUFBTS9MLFlBQVk2SCxPQUFaLENBQW9Cb1YsUUFEM0I7QUFFQ3ZRLFdBQU87QUFDTi9JLGNBQVMsTUFESDtBQUVOZixpQkFBWTtBQUNYMFYsYUFBTztBQURJO0FBRk4sS0FGUjtBQVFDTyxhQUFTLEtBQUtDLFdBQUwsQ0FBaUIzWSxJQUFqQixDQUFzQixJQUF0QixFQUE0QixnQkFBNUI7QUFSVixJQTdEb0IsRUF1RXBCO0FBQ0M0TCxVQUFNL0wsWUFBWTZILE9BQVosQ0FBb0JxVixTQUQzQjtBQUVDeFEsV0FBTztBQUNOL0ksY0FBUyxNQURIO0FBRU5mLGlCQUFZO0FBQ1gwVixhQUFPO0FBREk7QUFGTixLQUZSO0FBUUNPLGFBQVMsS0FBS0MsV0FBTCxDQUFpQjNZLElBQWpCLENBQXNCLElBQXRCLEVBQTRCLGdCQUE1QjtBQVJWLElBdkVvQixFQWlGcEI7QUFDQzRMLFVBQU0vTCxZQUFZNkgsT0FBWixDQUFvQnNWLEtBRDNCO0FBRUN6USxXQUFPO0FBQ04vSSxjQUFTLE1BREg7QUFFTmYsaUJBQVk7QUFDWDBWLGFBQU87QUFESTtBQUZOLEtBRlI7QUFRQ08sYUFBUyxLQUFLQyxXQUFMLENBQWlCM1ksSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEIsWUFBNUI7QUFSVixJQWpGb0IsRUEyRnBCO0FBQ0M0TCxVQUFNL0wsWUFBWTZILE9BQVosQ0FBb0J1VixPQUQzQjtBQUVDMVEsV0FBTztBQUNOL0ksY0FBUyxNQURIO0FBRU5mLGlCQUFZO0FBQ1gwVixhQUFPO0FBREk7QUFGTixLQUZSO0FBUUNPLGFBQVMsS0FBS0MsV0FBTCxDQUFpQjNZLElBQWpCLENBQXNCLElBQXRCLEVBQTRCLGNBQTVCO0FBUlYsSUEzRm9CLEVBcUdwQjtBQUNDNEwsVUFBTS9MLFlBQVk2SCxPQUFaLENBQW9Cd1YsS0FEM0I7QUFFQzNRLFdBQU87QUFDTi9JLGNBQVMsTUFESDtBQUVOZixpQkFBWTtBQUNYMFYsYUFBTztBQURJO0FBRk4sS0FGUjtBQVFDTyxhQUFTLEtBQUtDLFdBQUwsQ0FBaUIzWSxJQUFqQixDQUFzQixJQUF0QixFQUE0QixZQUE1QjtBQVJWLElBckdvQixDQUR0QjtBQWtIQTs7OztFQTFSd0JpRyxnQkFBTVMsUzs7QUFBMUJrVyxXLENBQ0V2UixXLEdBQWNyRix1QjtBQURoQjRXLFcsQ0FHRW5XLEcsR0FBTSxPO0FBSFJtVyxXLENBS0UxRCxTLEdBQVk7QUFDbEI7Ozs7Ozs7QUFPQXBHLFdBQVVxRyxvQkFBVUMsSUFSRjs7QUFVbEI7Ozs7Ozs7QUFPQUMsUUFBT0Ysb0JBQVVHLE1BakJDOztBQW1CbEI7Ozs7Ozs7QUFPQWQsdUJBQXNCVyxvQkFBVUMsSUExQmQ7O0FBNEJsQjs7Ozs7OztBQU9BeFQsU0FBUXVULG9CQUFVSSxPQUFWLENBQWtCSixvQkFBVUssTUFBNUIsQ0FuQ1U7O0FBcUNsQjs7Ozs7Ozs7QUFRQTdULFdBQVV3VCxvQkFBVU0sTUE3Q0Y7O0FBK0NsQjs7Ozs7OztBQU9BeEcsaUJBQWdCa0csb0JBQVVPO0FBdERSLEM7a0JBd1JMa0QsVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxU2Y7Ozs7QUFFQTs7Ozs7Ozs7OzsrZUFQQTs7Ozs7QUFTQTs7Ozs7OztJQU9NTyxxQjs7Ozs7Ozs7Ozs7OztBQVdMOzs7Ozs7OzsyQkFRUztBQUNSLFVBQ0M7QUFBQTtBQUFBO0FBQ0MsbUJBQVksS0FBSzdXLEtBQUwsQ0FBVzhXLFdBRHhCO0FBRUMsZ0JBQVcsS0FBS0MsYUFBTCxFQUZaO0FBR0MsY0FBUyxLQUFLM1IsV0FIZjtBQUlDLGVBQVUsS0FBS3BGLEtBQUwsQ0FBV1gsUUFKdEI7QUFLRSxTQUFLVyxLQUFMLENBQVc4VztBQUxiLElBREQ7QUFTQTs7QUFFRDs7Ozs7Ozs7OztBQTlCQTs7Ozs7Ozs7Ozs7a0NBdUNnQjtBQUNmLE9BQU1sYSxZQUFZLGlDQUFsQjs7QUFFQSxVQUFPQSxTQUFQO0FBQ0E7Ozs7RUE1Q2tDK0MsZ0JBQU1TLFM7O0FBQXBDeVcscUIsQ0FTRTFXLEcsR0FBTSx1QjtrQkFzQ0MsNkJBQWMwVyxxQkFBZCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFEZjs7OztBQUVBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBUkE7Ozs7O0FBVUE7Ozs7Ozs7SUFPTUcsa0I7OztBQUNMOzs7Ozs7OztBQThCQSw2QkFBWWhYLEtBQVosRUFBbUI7QUFBQTs7QUFBQSxzSUFDWkEsS0FEWTs7QUFFbEIsUUFBS2lYLElBQUwsR0FBWXRYLGdCQUFNNFYsU0FBTixFQUFaO0FBRmtCO0FBR2xCOztBQUVEOzs7Ozs7Ozs7OztBQWZBOzs7Ozs7Ozs7Ozs7c0NBd0JvQjtBQUNuQixRQUFLMEIsSUFBTCxDQUFVcEQsT0FBVixDQUFrQjlHLEtBQWxCO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7OzJCQVFTO0FBQ1IsVUFDQztBQUFBO0FBQUE7QUFDQyxnQkFBVSxnREFEWDtBQUVDLGNBQVMsS0FBS0EsS0FGZjtBQUdDLGdCQUFXLEtBQUtxQixTQUhqQjtBQUlDLFVBQUssS0FBSzZJLElBSlg7QUFLQyxlQUFTLEdBTFY7QUFNQztBQUFBO0FBQUE7QUFDQyxpQkFBVSxZQURYO0FBRUMsVUFBSSxLQUFLalgsS0FBTCxDQUFXa1gsTUFGaEI7QUFHQyxZQUFLLFNBSE47QUFJRSxVQUFLQyxjQUFMLENBQW9CLEtBQUtuWCxLQUFMLENBQVc3RyxRQUEvQjtBQUpGO0FBTkQsSUFERDtBQWVBOztBQUVEOzs7Ozs7Ozs7Ozs7aUNBU2VBLFEsRUFBVTtBQUN4QixPQUFJZ1UsY0FBSjs7QUFFQSxPQUFJaFUsWUFBWUEsU0FBU0YsTUFBekIsRUFBaUM7QUFDaENrVSxZQUFRaFUsU0FBUzJTLEdBQVQsQ0FBYSxnQkFBUTtBQUM1QixZQUNDO0FBQUE7QUFBQSxRQUFJLEtBQUtzQixLQUFLcEksT0FBZCxFQUF1QixNQUFLLFFBQTVCO0FBQ0Msb0NBQUMsK0JBQUQ7QUFDQyxnQkFBU29JLEtBQUtwSSxPQURmO0FBRUMsb0JBQ0MsT0FBT29JLEtBQUsyRixLQUFaLEtBQXNCLFFBQXRCLEdBQ0czRixLQUFLMkYsS0FEUixHQUVHM0YsS0FBSzJGLEtBQUwsRUFMTDtBQU9DLGFBQU0zRixLQUFLZ0s7QUFQWjtBQURELE1BREQ7QUFhQSxLQWRPLENBQVI7QUFlQTs7QUFFRCxVQUFPakssS0FBUDtBQUNBOzs7O0VBMUcrQnhOLGdCQUFNUyxTOztBQUFqQzRXLGtCLENBU0UzSyxZLEdBQWU7QUFDckI4QyxXQUFVLEtBRFc7QUFFckJNLGNBQWEscUJBRlE7QUFHckIxVyxPQUFNO0FBQ0w4VixXQUFTLENBQUMsRUFBRCxDQURKO0FBRUxJLGVBQWEsQ0FBQyxFQUFELENBRlI7QUFHTEMsZUFBYSxDQUFDLEVBQUQsQ0FIUjtBQUlMRSxRQUFNLENBQUMsRUFBRCxDQUpEO0FBS0xDLFFBQU0sQ0FBQyxFQUFEO0FBTEQ7QUFIZSxDO0FBVGpCMkgsa0IsQ0E2QkU3VyxHLEdBQU0sb0I7a0JBZ0ZDLGtDQUFtQjZXLGtCQUFuQixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pIZjs7OztBQUVBOzs7Ozs7Ozs7OytlQVBBOzs7OztBQVNBOzs7Ozs7SUFNTUssYzs7Ozs7Ozs7Ozs7OztBQThCTDs7Ozs7Ozs7O0FBN0JBOzs7Ozs7OzJCQXFDUztBQUNSLFVBQ0M7QUFBQTtBQUFBO0FBQ0MsZ0JBQVUsZ0RBRFg7QUFFQyxjQUFTLEtBQUt0SyxLQUZmO0FBR0MsZ0JBQVcsS0FBS3FCLFNBSGpCO0FBSUMsZUFBUyxHQUpWO0FBS0M7QUFBQTtBQUFBLE9BQUksV0FBVSxZQUFkLEVBQTJCLE1BQUssU0FBaEM7QUFDRSxVQUFLcE8sS0FBTCxDQUFXc1g7QUFEYjtBQUxELElBREQ7QUFXQTs7QUE5QkQ7Ozs7Ozs7Ozs7OztFQXBCNEIzWCxnQkFBTVMsUzs7QUFBN0JpWCxjLENBUUVoTCxZLEdBQWU7QUFDckI4QyxXQUFVLEtBRFc7QUFFckJNLGNBQWEscUJBRlE7QUFHckIxVyxPQUFNO0FBQ0w4VixXQUFTLENBQUMsRUFBRCxDQURKO0FBRUxJLGVBQWEsQ0FBQyxFQUFELENBRlI7QUFHTEMsZUFBYSxDQUFDLEVBQUQsQ0FIUjtBQUlMRSxRQUFNLENBQUMsRUFBRCxDQUpEO0FBS0xDLFFBQU0sQ0FBQyxFQUFEO0FBTEQ7QUFIZSxDO0FBUmpCZ0ksYyxDQTRCRWxYLEcsR0FBTSxVO2tCQXlCQyxrQ0FBbUJrWCxjQUFuQixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9EZjs7OztBQUVBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBUkE7Ozs7O0FBVUEsSUFBTUUsWUFBWSxFQUFsQjtBQUNBLElBQU1DLFVBQVUsRUFBaEI7O0FBRUE7Ozs7Ozs7SUFNTUMsZTs7O0FBYUwsMEJBQVl6WCxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsZ0lBQ1pBLEtBRFk7O0FBQUEsUUE2SW5CMFgsVUE3SW1CLEdBNklOLFlBQU07QUFDbEIsU0FBSzdLLFFBQUwsQ0FBYztBQUNiOEssY0FBVTtBQURHLElBQWQ7QUFHQSxHQWpKa0I7O0FBQUEsUUEySm5CQyxVQTNKbUIsR0EySk4sWUFBTTtBQUNsQixPQUFNMWQsZUFBZSxNQUFLZ0csT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FBckI7O0FBRUFnRCxnQkFBYWtMLFdBQWIsQ0FBeUIsVUFBekIsRUFBcUM7QUFDcEN5UyxTQUFLLE1BQUszUyxLQUFMLENBQVd5UztBQURvQixJQUFyQzs7QUFJQTtBQUNBO0FBQ0EsU0FBSzNYLEtBQUwsQ0FBV3FOLGVBQVg7QUFDQSxHQXJLa0I7O0FBQUEsUUErS25CeUssZUEvS21CLEdBK0tELFlBQU07QUFDdkIsU0FBS0MsU0FBTCxDQUFlbEUsT0FBZixDQUF1QjlHLEtBQXZCO0FBQ0EsR0FqTGtCOztBQUFBLFFBOExuQjZELGNBOUxtQixHQThMRixpQkFBUztBQUN6QixPQUFJM1YsTUFBTStULE9BQU4sS0FBa0J1SSxTQUFsQixJQUErQnRjLE1BQU0rVCxPQUFOLEtBQWtCd0ksT0FBckQsRUFBOEQ7QUFDN0R2YyxVQUFNUSxjQUFOO0FBQ0E7O0FBRUQsT0FBSVIsTUFBTStULE9BQU4sS0FBa0J1SSxTQUF0QixFQUFpQztBQUNoQyxVQUFLSyxVQUFMO0FBQ0EsSUFGRCxNQUVPLElBQUkzYyxNQUFNK1QsT0FBTixLQUFrQndJLE9BQXRCLEVBQStCO0FBQ3JDLFFBQU1wZ0IsU0FBUyxNQUFLOEksT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FBZjs7QUFFQTtBQUNBO0FBQ0EsVUFBSzhJLEtBQUwsQ0FBV3FOLGVBQVg7O0FBRUFqVyxXQUFPdUUsSUFBUCxDQUFZLGlCQUFaO0FBQ0E7QUFDRCxHQTlNa0I7O0FBQUEsUUF5Tm5CcWMscUJBek5tQixHQXlOSyxpQkFBUztBQUNoQyxTQUFLbkwsUUFBTCxDQUFjO0FBQ2I4SyxjQUFVMWMsTUFBTW9CLE1BQU4sQ0FBYUQ7QUFEVixJQUFkO0FBR0EsR0E3TmtCOztBQUFBLFFBeVBuQjZiLFlBelBtQixHQXlQSixZQUFNO0FBQ3BCLE9BQU03Z0IsU0FBUyxNQUFLOEksT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FBZjs7QUFFQSxPQUFNZ2hCLGVBQWUsTUFBS2hULEtBQUwsQ0FBV2hJLE9BQVgsQ0FBbUJpYixZQUFuQixDQUFnQyxtQkFBVztBQUMvRCxXQUFPamIsUUFBUW9NLFFBQVIsQ0FBaUIsb0JBQWpCLENBQVA7QUFDQSxJQUZvQixDQUFyQjs7QUFJQTRPLGdCQUFhM1QsTUFBYjs7QUFFQW5OLFVBQU91RSxJQUFQLENBQVksaUJBQVo7QUFDQSxHQW5Ra0I7O0FBR2xCLFFBQUtvYyxTQUFMLEdBQWlCcFksZ0JBQU00VixTQUFOLEVBQWpCO0FBQ0EsUUFBS3JRLEtBQUwsR0FBYSxNQUFLa1QsZUFBTCxFQUFiO0FBSmtCO0FBS2xCOztBQUVEOzs7Ozs7Ozs7Ozs7QUFqQkE7Ozs7Ozs7Ozs7OztzQ0EyQm9CO0FBQ25CLE9BQUksS0FBS3BZLEtBQUwsQ0FBV3NOLGVBQVgsSUFBOEIsS0FBS3ROLEtBQUwsQ0FBV3FZLGVBQTdDLEVBQThEO0FBQzdEO0FBQ0E7QUFDQSxRQUFJOWQsT0FBT3FQLHFCQUFYLEVBQWtDO0FBQ2pDclAsWUFBT3FQLHFCQUFQLENBQTZCLEtBQUtrTyxlQUFsQztBQUNBLEtBRkQsTUFFTztBQUNOelcsZ0JBQVcsS0FBS3lXLGVBQWhCLEVBQWlDLENBQWpDO0FBQ0E7QUFDRDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs4Q0FRNEI7QUFDM0IsUUFBS2pMLFFBQUwsQ0FBYyxLQUFLdUwsZUFBTCxFQUFkO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7O29DQVFrQjtBQUNqQjtBQUNBLE9BQU1oaEIsU0FBUyxLQUFLNEksS0FBTCxDQUFXRSxPQUFYLENBQW1COUksTUFBbkIsQ0FBMEJGLEdBQTFCLENBQThCLGNBQTlCLENBQWY7QUFDQSxPQUFJb2hCLGNBQUo7O0FBRUEsT0FBTTNkLFlBQVl2RCxPQUFPb0QsWUFBUCxFQUFsQjs7QUFFQSxPQUFJRyxTQUFKLEVBQWU7QUFDZCxRQUFNc0osa0JBQWtCdEosVUFBVXVKLGtCQUFWLEVBQXhCOztBQUVBLFFBQUlELGVBQUosRUFBcUI7QUFDcEJxVSxhQUFRclUsZ0JBQWdCd00sT0FBaEIsQ0FBd0IsMEJBQXhCLENBQVI7QUFDQTtBQUNEOztBQUVELE9BQU12VSxPQUFPb2MsUUFBUUEsTUFBTXZJLFlBQU4sQ0FBbUIsbUJBQW5CLENBQVIsR0FBa0QsRUFBL0Q7O0FBRUEsVUFBTztBQUNON1MsYUFBU29iLEtBREg7QUFFTkMsaUJBQWE7QUFDWnJjO0FBRFksS0FGUDtBQUtOeWIsY0FBVXpiO0FBTEosSUFBUDtBQU9BOztBQUVEOzs7Ozs7Ozs7OzsyQkFRUztBQUNSLE9BQU1zYyxpQkFBaUI7QUFDdEI5TyxhQUFTLEtBQUt4RSxLQUFMLENBQVd5UyxRQUFYLEdBQXNCLENBQXRCLEdBQTBCO0FBRGIsSUFBdkI7O0FBSUEsVUFDQztBQUFBO0FBQUEsTUFBSyxXQUFVLHdCQUFmO0FBQ0M7QUFBQTtBQUFBO0FBQ0Msb0JBQVlwZSxZQUFZNkgsT0FBWixDQUFvQnFYLFdBRGpDO0FBRUMsaUJBQVUsV0FGWDtBQUdDLG1CQUFVLHFCQUhYO0FBSUMsZ0JBQVUsQ0FBQyxLQUFLdlQsS0FBTCxDQUFXaEksT0FKdkI7QUFLQyxlQUFTLEtBQUsrYSxZQUxmO0FBTUMsZ0JBQVUsS0FBS2pZLEtBQUwsQ0FBV1gsUUFOdEI7QUFPQyxhQUFPOUYsWUFBWTZILE9BQVosQ0FBb0JxWCxXQVA1QjtBQVFDLG1DQUFDLG9CQUFELElBQVksV0FBVSxtQkFBdEIsRUFBMEMsUUFBTyxPQUFqRDtBQVJELEtBREQ7QUFXQztBQUFBO0FBQUEsT0FBSyxXQUFVLHdCQUFmO0FBQ0M7QUFDQyxpQkFBVSxVQURYO0FBRUMsZ0JBQVUsS0FBS1QscUJBRmhCO0FBR0MsaUJBQVcsS0FBS3BILGNBSGpCO0FBSUMsbUJBQWFyWCxZQUFZNkgsT0FBWixDQUFvQnNYLFFBSmxDO0FBS0MsV0FBSyxLQUFLWCxTQUxYO0FBTUMsWUFBSyxNQU5OO0FBT0MsYUFBTyxLQUFLN1MsS0FBTCxDQUFXeVM7QUFQbkIsT0FERDtBQVVDO0FBQUE7QUFBQTtBQUNDLHFCQUFZcGUsWUFBWTZILE9BQVosQ0FBb0J1WCxVQURqQztBQUVDLGtCQUFVLDJCQUZYO0FBR0MsZ0JBQVMsS0FBS2pCLFVBSGY7QUFJQyxjQUFPYyxjQUpSO0FBS0MsY0FBT2pmLFlBQVk2SCxPQUFaLENBQW9Cd1gsS0FMNUI7QUFNQyxvQ0FBQyxvQkFBRCxJQUFZLFFBQU8sYUFBbkI7QUFORDtBQVZELEtBWEQ7QUE4QkM7QUFBQTtBQUFBO0FBQ0Msb0JBQVlyZixZQUFZNkgsT0FBWixDQUFvQnlQLE9BRGpDO0FBRUMsaUJBQVUsV0FGWDtBQUdDLGdCQUFVLENBQUMsS0FBS2dJLGFBQUwsRUFIWjtBQUlDLGVBQVMsS0FBS2pCLFVBSmY7QUFLQyxhQUFPcmUsWUFBWTZILE9BQVosQ0FBb0J5UCxPQUw1QjtBQU1DLG1DQUFDLG9CQUFELElBQVksV0FBVSxtQkFBdEIsRUFBMEMsUUFBTyxPQUFqRDtBQU5EO0FBOUJELElBREQ7QUF5Q0E7O0FBRUQ7Ozs7Ozs7Ozs7OztBQWdCQTs7Ozs7Ozs7OztBQW9CQTs7Ozs7Ozs7OztBQVlBOzs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7Ozs7OztBQWVBOzs7Ozs7Ozs7O2tDQVVnQjtBQUNmLE9BQU1pSSxhQUNMLEtBQUs1VCxLQUFMLENBQVd5UyxRQUFYLElBQ0EsS0FBS3pTLEtBQUwsQ0FBV3lTLFFBQVgsS0FBd0IsS0FBS3pTLEtBQUwsQ0FBV3FULFdBQVgsQ0FBdUJyYyxJQUZoRDs7QUFJQSxVQUFPNGMsVUFBUDtBQUNBOztBQUVEOzs7Ozs7Ozs7Ozs7RUE5UDZCblosZ0JBQU1TLFM7O0FBQTlCcVgsZSxDQUNFMVMsVyxHQUFjckYsdUI7QUFEaEIrWCxlLENBV0V0WCxHLEdBQU0sVztrQkF3UUNULHdCQUFjRyxPQUFkLENBQXNCNFgsZUFBdEIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqU2Y7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBVEE7Ozs7O0FBV0EsSUFBTUYsWUFBWSxFQUFsQjtBQUNBLElBQU1DLFVBQVUsRUFBaEI7O0FBRUE7Ozs7Ozs7O0lBT011QixvQjs7O0FBS0wsK0JBQVkvWSxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsMElBQ1pBLEtBRFk7O0FBQUEsUUEwSm5CZ1osY0ExSm1CLEdBMEpGLFlBQU07QUFDdEIsT0FBTTllLGVBQWUsTUFBS2dHLE9BQUwsQ0FBYTlJLE1BQWIsQ0FBb0JGLEdBQXBCLENBQXdCLGNBQXhCLENBQXJCOztBQUVBZ0QsZ0JBQWFrTCxXQUFiLENBQXlCLFVBQXpCLEVBQXFDO0FBQ3BDOUcsVUFBTSxPQUQ4QjtBQUVwQ3VaLFNBQUssTUFBSzNTLEtBQUwsQ0FBVytUO0FBRm9CLElBQXJDOztBQUtBO0FBQ0E7QUFDQSxTQUFLalosS0FBTCxDQUFXcU4sZUFBWDtBQUNBLEdBcktrQjs7QUFBQSxRQStLbkI2TCxtQkEvS21CLEdBK0tHLFlBQU07QUFDM0JwZixzQkFBU2tQLFdBQVQsQ0FBcUIsTUFBS2tJLElBQUwsQ0FBVTZHLFNBQS9CLEVBQTBDaEwsS0FBMUM7QUFDQSxHQWpMa0I7O0FBQUEsUUE4TG5CNkQsY0E5TG1CLEdBOExGLGlCQUFTO0FBQ3pCLE9BQUkzVixNQUFNK1QsT0FBTixLQUFrQnVJLFNBQWxCLElBQStCdGMsTUFBTStULE9BQU4sS0FBa0J3SSxPQUFyRCxFQUE4RDtBQUM3RHZjLFVBQU1RLGNBQU47QUFDQTs7QUFFRCxPQUFJUixNQUFNK1QsT0FBTixLQUFrQnVJLFNBQXRCLEVBQWlDO0FBQ2hDLFVBQUt5QixjQUFMO0FBQ0EsSUFGRCxNQUVPLElBQUkvZCxNQUFNK1QsT0FBTixLQUFrQndJLE9BQXRCLEVBQStCO0FBQ3JDLFVBQUt4WCxLQUFMLENBQVdxTixlQUFYO0FBQ0E7QUFDRCxHQXhNa0I7O0FBQUEsUUFtTm5COEwscUJBbk5tQixHQW1OSyxpQkFBUztBQUNoQyxTQUFLdE0sUUFBTCxDQUFjO0FBQ2JvTSxjQUFVaGUsTUFBTW9CLE1BQU4sQ0FBYUQ7QUFEVixJQUFkO0FBR0EsR0F2TmtCOztBQUdsQixRQUFLOEksS0FBTCxHQUFhLE1BQUtrVCxlQUFMLEVBQWI7QUFIa0I7QUFJbEI7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7O3NDQVVvQjtBQUNuQixPQUFJLEtBQUtwWSxLQUFMLENBQVdzTixlQUFYLElBQThCLEtBQUt0TixLQUFMLENBQVdxWSxlQUE3QyxFQUE4RDtBQUM3RDtBQUNBO0FBQ0EsUUFBSTlkLE9BQU9xUCxxQkFBWCxFQUFrQztBQUNqQ3JQLFlBQU9xUCxxQkFBUCxDQUE2QixLQUFLc1AsbUJBQWxDO0FBQ0EsS0FGRCxNQUVPO0FBQ043WCxnQkFBVyxLQUFLNlgsbUJBQWhCLEVBQXFDLENBQXJDO0FBQ0E7QUFDRDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs4Q0FRNEI7QUFDM0IsT0FBTUUsV0FBVyxLQUFLaEIsZUFBTCxFQUFqQjs7QUFFQSxRQUFLdkwsUUFBTCxDQUFjO0FBQ2J3TSxTQUFLcGIsU0FEUTtBQUVibEYsVUFBTWtGLFNBRk87QUFHYnFiLFNBQUtGLFFBSFE7QUFJYkcsU0FBS3RiO0FBSlEsSUFBZDtBQU1BOztBQUVEOzs7Ozs7Ozs7OztvQ0FRa0I7QUFDakI7QUFDQSxPQUFNN0csU0FBUyxLQUFLNEksS0FBTCxDQUFXRSxPQUFYLENBQW1COUksTUFBbkIsQ0FBMEJGLEdBQTFCLENBQThCLGNBQTlCLENBQWY7QUFDQSxPQUFJZ0csZ0JBQUo7O0FBRUEsT0FBTXZDLFlBQVl2RCxPQUFPb0QsWUFBUCxFQUFsQjs7QUFFQSxPQUFJRyxTQUFKLEVBQWU7QUFDZCxRQUFNc0osa0JBQWtCdEosVUFBVXVKLGtCQUFWLEVBQXhCOztBQUVBLFFBQUlELGVBQUosRUFBcUI7QUFDcEIvRyxlQUFVK0csZ0JBQWdCd00sT0FBaEIsQ0FBd0IsNEJBQXhCLENBQVY7QUFDQTtBQUNEOztBQUVELE9BQU13SSxXQUFXL2IsVUFDZEEsUUFBUTZTLFlBQVIsQ0FBcUIsc0JBQXJCLENBRGMsR0FFZCxFQUZIOztBQUlBLFVBQU87QUFDTjdTLG9CQURNO0FBRU5zYyxrQkFBYztBQUNiUDtBQURhLEtBRlI7QUFLTkE7QUFMTSxJQUFQO0FBT0E7O0FBRUQ7Ozs7Ozs7Ozs7OzJCQVFTO0FBQ1IsT0FBTVEsbUJBQW1CbGdCLFlBQVk2SCxPQUFaLENBQW9Cc1ksY0FBN0M7O0FBRUEsT0FBTUMscUJBQXFCO0FBQzFCalEsYUFBUyxLQUFLeEUsS0FBTCxDQUFXK1QsUUFBWCxHQUFzQixDQUF0QixHQUEwQjtBQURULElBQTNCOztBQUlBLFVBQ0M7QUFBQTtBQUFBLE1BQUssV0FBVSwrQkFBZjtBQUNDO0FBQUE7QUFBQSxPQUFLLFdBQVUsd0JBQWY7QUFDQztBQUNDLGlCQUFVLFVBRFg7QUFFQyxnQkFBVSxLQUFLRSxxQkFGaEI7QUFHQyxpQkFBVyxLQUFLdkksY0FIakI7QUFJQyxtQkFBYTZJLGdCQUpkO0FBS0MsV0FBSSxXQUxMO0FBTUMsWUFBSyxNQU5OO0FBT0MsYUFBTyxLQUFLdlUsS0FBTCxDQUFXK1Q7QUFQbkIsT0FERDtBQVVDO0FBQ0Msb0JBQVkxZixZQUFZNkgsT0FBWixDQUFvQnVYLFVBRGpDO0FBRUMsaUJBQVUsMEJBRlg7QUFHQyxlQUFTLEtBQUtqQixVQUhmO0FBSUMsYUFBT2lDLGtCQUpSO0FBS0MsYUFBT3BnQixZQUFZNkgsT0FBWixDQUFvQndYO0FBTDVCO0FBVkQsS0FERDtBQW1CQztBQUFBO0FBQUE7QUFDQyxvQkFBWXJmLFlBQVk2SCxPQUFaLENBQW9CeVAsT0FEakM7QUFFQyxpQkFBVSxXQUZYO0FBR0MsZ0JBQVUsQ0FBQyxLQUFLZ0ksYUFBTCxFQUhaO0FBSUMsZUFBUyxLQUFLRyxjQUpmO0FBS0MsYUFBT3pmLFlBQVk2SCxPQUFaLENBQW9CeVAsT0FMNUI7QUFNQyxtQ0FBQyxvQkFBRCxJQUFZLFFBQU8sT0FBbkI7QUFORDtBQW5CRCxJQUREO0FBOEJBOztBQUVEOzs7Ozs7Ozs7Ozs7OytCQVVhO0FBQ1osUUFBS2hFLFFBQUwsQ0FBYztBQUNib00sY0FBVTtBQURHLElBQWQ7QUFHQTs7QUFFRDs7Ozs7Ozs7OztBQXFCQTs7Ozs7Ozs7OztBQVlBOzs7Ozs7Ozs7Ozs7O0FBdUJBOzs7Ozs7Ozs7Ozs7OztBQWVBOzs7Ozs7Ozs7O2tDQVVnQjtBQUNmLE9BQU1ILGFBQ0wsS0FBSzVULEtBQUwsQ0FBVytULFFBQVgsSUFDQSxLQUFLL1QsS0FBTCxDQUFXK1QsUUFBWCxLQUF3QixLQUFLL1QsS0FBTCxDQUFXc1UsWUFBWCxDQUF3QlAsUUFGakQ7O0FBSUEsVUFBT0gsVUFBUDtBQUNBOzs7O0VBOU9pQ25aLGdCQUFNUyxTOztBQUFuQzJZLG9CLENBQ0VoVSxXLEdBQWNyRix1QjtBQURoQnFaLG9CLENBR0U1WSxHLEdBQU0sZ0I7a0JBOE9DVCx3QkFBY0csT0FBZCxDQUFzQmtaLG9CQUF0QixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pRZjs7OztBQUNBOzs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFUQTs7Ozs7QUFXQTs7Ozs7SUFLTWEsZ0I7Ozs7Ozs7Ozs7Ozs7QUF3Qkw7Ozs7OzsyQkFNUztBQUNSLE9BQUksS0FBSzVaLEtBQUwsQ0FBV3NOLGVBQWYsRUFBZ0M7QUFDL0IsV0FBTyw4QkFBQyw4QkFBRCxFQUEwQixLQUFLdE4sS0FBL0IsQ0FBUDtBQUNBLElBRkQsTUFFTztBQUNOLFdBQ0M7QUFBQTtBQUFBO0FBQ0Msb0JBQVl6RyxZQUFZNkgsT0FBWixDQUFvQjBVLEtBRGpDO0FBRUMsaUJBQVUsV0FGWDtBQUdDLG1CQUFVLG9CQUhYO0FBSUMsZUFBUyxLQUFLOVYsS0FBTCxDQUFXaU4sZ0JBSnJCO0FBS0MsZ0JBQVUsS0FBS2pOLEtBQUwsQ0FBV1gsUUFMdEI7QUFNQyxhQUFPOUYsWUFBWTZILE9BQVosQ0FBb0IwVSxLQU41QjtBQU9DLG1DQUFDLG9CQUFELElBQVksUUFBTyxPQUFuQjtBQVBELEtBREQ7QUFXQTtBQUNEOzs7O0VBOUM2Qm5XLGdCQUFNUyxTOztBQUEvQndaLGdCLENBQ0V6WixHLEdBQU0sWTtBQURSeVosZ0IsQ0FHRWhILFMsR0FBWTtBQUNsQjs7Ozs7OztBQU9BRyxRQUFPRixvQkFBVUcsTUFSQzs7QUFVbEI7Ozs7Ozs7O0FBUUEzVCxXQUFVd1Qsb0JBQVVNO0FBbEJGLEM7a0JBOENMeUcsZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNURmOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVRBOzs7OztBQVdBOzs7Ozs7Ozs7O0lBVU1DLFc7Ozs7Ozs7Ozs7Ozs7OzhMQTZETDlJLGlCLEdBQW9CLFlBQU07QUFDekIsU0FBSy9RLEtBQUwsQ0FBV2lOLGdCQUFYLENBQTRCNE0sWUFBWTFaLEdBQXhDO0FBQ0EsRzs7QUE5REQ7Ozs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7OzJCQVFTO0FBQ1IsT0FBSSxLQUFLSCxLQUFMLENBQVdzTixlQUFmLEVBQWdDO0FBQy9CLFdBQU8sOEJBQUMseUJBQUQsRUFBcUIsS0FBS3ROLEtBQTFCLENBQVA7QUFDQSxJQUZELE1BRU87QUFDTixXQUNDO0FBQUE7QUFBQTtBQUNDLG9CQUFZekcsWUFBWTZILE9BQVosQ0FBb0JwRixJQURqQztBQUVDLGlCQUFVLFdBRlg7QUFHQyxtQkFBVSxjQUhYO0FBSUMsZUFBUyxLQUFLK1UsaUJBSmY7QUFLQyxnQkFBVSxLQUFLL1EsS0FBTCxDQUFXWCxRQUx0QjtBQU1DLGFBQU85RixZQUFZNkgsT0FBWixDQUFvQnBGLElBTjVCO0FBT0MsbUNBQUMsb0JBQUQsSUFBWSxRQUFPLE1BQW5CO0FBUEQsS0FERDtBQVdBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7OztFQXJEeUIyRCxnQkFBTVMsUzs7QUFBMUJ5WixXLENBU0V4TixZLEdBQWU7QUFDckJoSCxZQUFXO0FBQ1ZHLE1BQUksbUJBRE07QUFFVnpNLFFBQU0xQixTQUFTMEgsSUFBVCxHQUFnQjFILFNBQVMySCxLQUF6QixHQUFpQyxFQUY3QixDQUVnQztBQUZoQyxJQUdWc0csTUFBTTtBQUhJO0FBRFUsQztBQVRqQnVVLFcsQ0F5QkUxWixHLEdBQU0sTztrQkF5Q0MsK0JBQWdCMFosV0FBaEIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRmY7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFWQTs7Ozs7QUFZQTs7Ozs7Ozs7SUFRTUMsUTs7Ozs7Ozs7Ozs7OztBQXlCTDs7Ozs7Ozs7O0FBeEJBOzs7Ozs7OzsyQkFnQ1M7QUFDUixPQUFNeEcsMEJBQXdCLEtBQUtDLGVBQUwsRUFBOUI7O0FBRUEsVUFDQztBQUFBO0FBQUE7QUFDQyxtQkFBWWhhLFlBQVk2SCxPQUFaLENBQW9CMlksRUFEakM7QUFFQyxxQkFBY3pHLFNBQVN0UyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FGaEQ7QUFHQyxnQkFBV3NTLFFBSFo7QUFJQyxrQkFBVSxXQUpYO0FBS0MsY0FBUyxLQUFLOU8sVUFMZjtBQU1DLGVBQVUsS0FBS3hFLEtBQUwsQ0FBV1gsUUFOdEI7QUFPQyxZQUFPOUYsWUFBWTZILE9BQVosQ0FBb0IyWSxFQVA1QjtBQVFDLGtDQUFDLG9CQUFELElBQVksUUFBTyxJQUFuQjtBQVJELElBREQ7QUFZQTs7QUFqQ0Q7Ozs7Ozs7Ozs7OztFQWZzQnBhLGdCQUFNUyxTOztBQUF2QjBaLFEsQ0FTRXpOLFksR0FBZTtBQUNyQnBHLFFBQU87QUFDTi9JLFdBQVM7QUFESDtBQURjLEM7QUFUakI0YyxRLENBdUJFM1osRyxHQUFNLEk7a0JBNEJDLGlDQUFrQixrQ0FBbUIsMkJBQVkyWixRQUFaLENBQW5CLENBQWxCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEVmOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBVkE7Ozs7O0FBWUE7Ozs7Ozs7O0lBUU1FLFE7Ozs7Ozs7Ozs7Ozs7QUF5Qkw7Ozs7Ozs7OztBQXhCQTs7Ozs7Ozs7MkJBZ0NTO0FBQ1IsT0FBTTFHLDBCQUF3QixLQUFLQyxlQUFMLEVBQTlCOztBQUVBLFVBQ0M7QUFBQTtBQUFBO0FBQ0MsbUJBQVloYSxZQUFZNkgsT0FBWixDQUFvQjZZLEVBRGpDO0FBRUMscUJBQWMzRyxTQUFTdFMsT0FBVCxDQUFpQixTQUFqQixNQUFnQyxDQUFDLENBRmhEO0FBR0MsZ0JBQVdzUyxRQUhaO0FBSUMsa0JBQVUsV0FKWDtBQUtDLGNBQVMsS0FBSzlPLFVBTGY7QUFNQyxlQUFVLEtBQUt4RSxLQUFMLENBQVdYLFFBTnRCO0FBT0MsWUFBTzlGLFlBQVk2SCxPQUFaLENBQW9CNlksRUFQNUI7QUFRQyxrQ0FBQyxvQkFBRCxJQUFZLFFBQU8sSUFBbkI7QUFSRCxJQUREO0FBWUE7O0FBakNEOzs7Ozs7Ozs7Ozs7RUFmc0J0YSxnQkFBTVMsUzs7QUFBdkI0WixRLENBU0UzTixZLEdBQWU7QUFDckJwRyxRQUFPO0FBQ04vSSxXQUFTO0FBREg7QUFEYyxDO0FBVGpCOGMsUSxDQXVCRTdaLEcsR0FBTSxJO2tCQTRCQyxpQ0FBa0Isa0NBQW1CLDJCQUFZNlosUUFBWixDQUFuQixDQUFsQixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xFZjs7OztBQUVBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBUkE7Ozs7O0FBVUE7Ozs7OztJQU1NRSxXOzs7Ozs7Ozs7Ozs7O0FBdUJMOzs7Ozs7Ozs7QUF0QkE7Ozs7Ozs7OzJCQThCUztBQUNSLFVBQ0M7QUFBQTtBQUFBO0FBQ0MsbUJBQVkzZ0IsWUFBWTZILE9BQVosQ0FBb0IrWSxjQURqQztBQUVDLGdCQUFVLFdBRlg7QUFHQyxrQkFBVSxjQUhYO0FBSUMsY0FBUyxLQUFLL1UsV0FKZjtBQUtDLGVBQVUsS0FBS3BGLEtBQUwsQ0FBV1gsUUFMdEI7QUFNQyxZQUFPOUYsWUFBWTZILE9BQVosQ0FBb0IrWSxjQU41QjtBQU9DLGtDQUFDLG9CQUFELElBQVksUUFBTyxJQUFuQjtBQVBELElBREQ7QUFXQTs7QUE5QkQ7Ozs7Ozs7Ozs7OztFQWJ5QnhhLGdCQUFNUyxTOztBQUExQjhaLFcsQ0FTRTdOLFksR0FBZTtBQUNyQnJILFVBQVM7QUFEWSxDO0FBVGpCa1YsVyxDQXFCRS9aLEcsR0FBTSxPO2tCQXlCQyw2QkFBYytaLFdBQWQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JDckRTRSxVOztBQUp4Qjs7OztBQUVBOzs7Ozs7QUFQQTs7Ozs7QUFTZSxTQUFTQSxVQUFULE9BQThDO0FBQUEsMkJBQXpCeGQsU0FBeUI7QUFBQSxLQUF6QkEsU0FBeUIsa0NBQWIsRUFBYTtBQUFBLEtBQVR5ZCxNQUFTLFFBQVRBLE1BQVM7O0FBQzVELFFBQ0M7QUFBQyx5QkFBRCxDQUFlLFFBQWY7QUFBQTtBQUNFLG1CQUFjO0FBQUEsT0FBWmpqQixNQUFZLFNBQVpBLE1BQVk7O0FBQ2QsT0FBTThDLGVBQWU5QyxPQUFPRixHQUFQLENBQVcsY0FBWCxDQUFyQjtBQUNBLE9BQU1jLFlBQVlrQyxhQUFhdkQsTUFBYixDQUFvQnFCLFNBQXBCLElBQWlDLEVBQW5EO0FBQ0EsT0FBTXlJLE9BQVV6SSxTQUFWLFNBQXVCcWlCLE1BQTdCO0FBQ0EsT0FBTUMsa0JBQWtCMWQsa0JBQWdCQSxTQUFoQixHQUE4QixFQUF0RDtBQUNBLE9BQU0yZCxvQ0FBa0NELGVBQXhDOztBQUVBLFVBQ0M7QUFBQTtBQUFBLE1BQUssV0FBV0MsaUJBQWhCLEVBQW1DLFFBQU8sSUFBMUMsRUFBK0MsT0FBTSxJQUFyRDtBQUNDLDJDQUFLLE1BQU05WixJQUFYO0FBREQsSUFERDtBQUtBO0FBYkYsRUFERDtBQWlCQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCRDs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVZBOzs7OztBQVlBOzs7Ozs7OztJQVFNK1osc0I7Ozs7Ozs7Ozs7Ozs7QUF1Qkw7Ozs7Ozs7OztBQXRCQTs7Ozs7Ozs7MkJBOEJTO0FBQ1IsT0FBTWxILDBCQUF3QixLQUFLQyxlQUFMLEVBQTlCOztBQUVBLFVBQ0M7QUFBQTtBQUFBO0FBQ0MsbUJBQVloYSxZQUFZNkgsT0FBWixDQUFvQnFaLFdBRGpDO0FBRUMscUJBQWNuSCxTQUFTdFMsT0FBVCxDQUFpQixTQUFqQixNQUFnQyxDQUFDLENBRmhEO0FBR0MsZ0JBQVdzUyxRQUhaO0FBSUMsa0JBQVUsMkJBSlg7QUFLQyxjQUFTLEtBQUtsTyxXQUxmO0FBTUMsZUFBVSxLQUFLcEYsS0FBTCxDQUFXWCxRQU50QjtBQU9DLFlBQU85RixZQUFZNkgsT0FBWixDQUFvQnFaLFdBUDVCO0FBUUMsa0NBQUMsb0JBQUQsSUFBWSxRQUFPLG9CQUFuQjtBQVJELElBREQ7QUFZQTs7QUFqQ0Q7Ozs7Ozs7Ozs7OztFQWJvQzlhLGdCQUFNUyxTOztBQUFyQ29hLHNCLENBU0VuTyxZLEdBQWU7QUFDckJySCxVQUFTO0FBRFksQztBQVRqQndWLHNCLENBcUJFcmEsRyxHQUFNLGE7a0JBNEJDLDZCQUNkLG1DQUFvQixrQ0FBbUJxYSxzQkFBbkIsQ0FBcEIsQ0FEYyxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hFZjs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVZBOzs7OztBQVlBOzs7Ozs7OztJQVFNRSxvQjs7Ozs7Ozs7Ozs7OztBQXVCTDs7Ozs7Ozs7O0FBdEJBOzs7Ozs7OzsyQkE4QlM7QUFDUixPQUFNcEgsMEJBQXdCLEtBQUtDLGVBQUwsRUFBOUI7O0FBRUEsVUFDQztBQUFBO0FBQUE7QUFDQyxtQkFBWWhhLFlBQVk2SCxPQUFaLENBQW9CdVosU0FEakM7QUFFQyxxQkFBY3JILFNBQVN0UyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FGaEQ7QUFHQyxnQkFBV3NTLFFBSFo7QUFJQyxrQkFBVSx5QkFKWDtBQUtDLGNBQVMsS0FBS2xPLFdBTGY7QUFNQyxlQUFVLEtBQUtwRixLQUFMLENBQVdYLFFBTnRCO0FBT0MsWUFBTzlGLFlBQVk2SCxPQUFaLENBQW9CdVosU0FQNUI7QUFRQyxrQ0FBQyxvQkFBRCxJQUFZLFFBQU8sa0JBQW5CO0FBUkQsSUFERDtBQVlBOztBQWpDRDs7Ozs7Ozs7Ozs7O0VBYmtDaGIsZ0JBQU1TLFM7O0FBQW5Dc2Esb0IsQ0FTRXJPLFksR0FBZTtBQUNyQnJILFVBQVM7QUFEWSxDO0FBVGpCMFYsb0IsQ0FxQkV2YSxHLEdBQU0sVztrQkE0QkMsNkJBQ2QsbUNBQW9CLGtDQUFtQnVhLG9CQUFuQixDQUFwQixDQURjLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEVmOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBVkE7Ozs7O0FBWUE7Ozs7Ozs7O0lBUU1FLHFCOzs7Ozs7Ozs7Ozs7O0FBdUJMOzs7Ozs7Ozs7QUF0QkE7Ozs7Ozs7OzJCQThCUztBQUNSLE9BQU10SCwwQkFBd0IsS0FBS0MsZUFBTCxFQUE5Qjs7QUFFQSxVQUNDO0FBQUE7QUFBQTtBQUNDLG1CQUFZaGEsWUFBWTZILE9BQVosQ0FBb0J5WixVQURqQztBQUVDLHFCQUFjdkgsU0FBU3RTLE9BQVQsQ0FBaUIsU0FBakIsTUFBZ0MsQ0FBQyxDQUZoRDtBQUdDLGdCQUFXc1MsUUFIWjtBQUlDLGtCQUFVLDBCQUpYO0FBS0MsY0FBUyxLQUFLbE8sV0FMZjtBQU1DLGVBQVUsS0FBS3BGLEtBQUwsQ0FBV1gsUUFOdEI7QUFPQyxZQUFPOUYsWUFBWTZILE9BQVosQ0FBb0J5WixVQVA1QjtBQVFDLGtDQUFDLG9CQUFELElBQVksUUFBTyxtQkFBbkI7QUFSRCxJQUREO0FBWUE7O0FBakNEOzs7Ozs7Ozs7Ozs7RUFibUNsYixnQkFBTVMsUzs7QUFBcEN3YSxxQixDQVNFdk8sWSxHQUFlO0FBQ3JCckgsVUFBUztBQURZLEM7QUFUakI0VixxQixDQXFCRXphLEcsR0FBTSxZO2tCQTRCQyw2QkFDZCxtQ0FBb0Isa0NBQW1CeWEscUJBQW5CLENBQXBCLENBRGMsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoRWY7Ozs7QUFFQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVJBOzs7OztBQVVBOzs7OztJQUtNRSxXOzs7QUFhTCxzQkFBWTlhLEtBQVosRUFBbUI7QUFBQTs7QUFBQSx3SEFDWkEsS0FEWTs7QUFBQSxRQStDbkIrYSxXQS9DbUIsR0ErQ0wsWUFBTTtBQUNuQixTQUFLQyxTQUFMLENBQWVuSCxPQUFmLENBQXVCb0gsS0FBdkI7QUFDQSxHQWpEa0I7O0FBQUEsUUFtRW5CQyxjQW5FbUIsR0FtRUYsWUFBTTtBQUN0QixPQUFNQyxVQUFVLE1BQUtILFNBQUwsQ0FBZW5ILE9BQS9COztBQUVBO0FBQ0E7QUFDQSxPQUFJLENBQUNzSCxRQUFRQyxLQUFSLENBQWNuaUIsTUFBbkIsRUFBMkI7QUFDMUI7QUFDQTs7QUFFRCxPQUFNb2lCLFNBQVMsSUFBSUMsVUFBSixFQUFmO0FBQ0EsT0FBTUMsT0FBT0osUUFBUUMsS0FBUixDQUFjLENBQWQsQ0FBYjs7QUFFQUMsVUFBT0csTUFBUCxHQUFnQixpQkFBUztBQUN4QixRQUFNcGtCLFNBQVMsTUFBSzhJLE9BQUwsQ0FBYTlJLE1BQWIsQ0FBb0JGLEdBQXBCLENBQXdCLGNBQXhCLENBQWY7O0FBRUEsUUFBTXVrQixTQUFTcmtCLE9BQU91RSxJQUFQLENBQVksZ0JBQVosRUFBOEI7QUFDNUMrZixpQkFBWUg7QUFEZ0MsS0FBOUIsQ0FBZjs7QUFJQSxRQUFJRSxNQUFKLEVBQVk7QUFDWCxTQUFNbkgsS0FBS2pkLFNBQVN3RSxHQUFULENBQWFxQixPQUFiLENBQXFCcVgsY0FBckIsZ0JBQ0d0WixNQUFNb0IsTUFBTixDQUFhb2YsTUFEaEIsUUFBWDs7QUFJQXJrQixZQUFPb2QsYUFBUCxDQUFxQkYsRUFBckI7O0FBRUFsZCxZQUFPdUUsSUFBUCxDQUFZLGlCQUFaOztBQUVBLFNBQU1nZ0IsWUFBWTtBQUNqQnJILFlBRGlCO0FBRWpCaUg7QUFGaUIsTUFBbEI7O0FBS0Fua0IsWUFBT3VFLElBQVAsQ0FBWSxVQUFaLEVBQXdCZ2dCLFNBQXhCO0FBQ0E7QUFDRCxJQXZCRDs7QUF5QkFOLFVBQU9PLGFBQVAsQ0FBcUJMLElBQXJCOztBQUVBSixXQUFRL2UsS0FBUixHQUFnQixFQUFoQjtBQUNBLEdBM0drQjs7QUFFbEIsUUFBSzRlLFNBQUwsR0FBaUJyYixnQkFBTTRWLFNBQU4sRUFBakI7QUFGa0I7QUFHbEI7O0FBRUQ7Ozs7Ozs7Ozs7QUFmQTs7Ozs7Ozs7Ozs7OzJCQXVCUztBQUNSLE9BQU1zRyxZQUFZLEVBQUNDLFNBQVMsTUFBVixFQUFsQjs7QUFFQSxVQUNDO0FBQUE7QUFBQTtBQUNDO0FBQUE7QUFBQTtBQUNDLG9CQUFZdmlCLFlBQVk2SCxPQUFaLENBQW9CaVEsS0FEakM7QUFFQyxpQkFBVSxXQUZYO0FBR0MsbUJBQVUsY0FIWDtBQUlDLGVBQVMsS0FBSzBKLFdBSmY7QUFLQyxnQkFBVSxLQUFLL2EsS0FBTCxDQUFXWCxRQUx0QjtBQU1DLGFBQU85RixZQUFZNkgsT0FBWixDQUFvQmlRLEtBTjVCO0FBT0MsbUNBQUMsb0JBQUQsSUFBWSxRQUFPLGdCQUFuQjtBQVBELEtBREQ7QUFXQztBQUNDLGFBQU8sU0FEUjtBQUVDLGVBQVUsS0FBSzZKLGNBRmhCO0FBR0MsVUFBSyxLQUFLRixTQUhYO0FBSUMsWUFBT2EsU0FKUjtBQUtDLFdBQUs7QUFMTjtBQVhELElBREQ7QUFxQkE7O0FBRUQ7Ozs7Ozs7Ozs7QUFZQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFoRXlCbGMsZ0JBQU1TLFM7O0FBQTFCMGEsVyxDQUNFL1YsVyxHQUFjckYsdUI7QUFEaEJvYixXLENBV0UzYSxHLEdBQU0sZTtrQkFnSEMyYSxXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JJZjs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVZBOzs7OztBQVlBOzs7Ozs7OztJQVFNaUIsaUI7Ozs7Ozs7Ozs7Ozs7QUF1Qkw7Ozs7Ozs7OztBQXRCQTs7Ozs7Ozs7MkJBOEJTO0FBQ1IsT0FBTXpJLDBCQUF3QixLQUFLQyxlQUFMLEVBQTlCOztBQUVBLFVBQ0M7QUFBQTtBQUFBO0FBQ0MsbUJBQVloYSxZQUFZNkgsT0FBWixDQUFvQjRhLE1BRGpDO0FBRUMscUJBQWMxSSxTQUFTdFMsT0FBVCxDQUFpQixTQUFqQixNQUFnQyxDQUFDLENBRmhEO0FBR0MsZ0JBQVdzUyxRQUhaO0FBSUMsa0JBQVUscUJBSlg7QUFLQyxjQUFTLEtBQUtsTyxXQUxmO0FBTUMsZUFBVSxLQUFLcEYsS0FBTCxDQUFXWCxRQU50QjtBQU9DLFlBQU85RixZQUFZNkgsT0FBWixDQUFvQjRhLE1BUDVCO0FBUUMsa0NBQUMsb0JBQUQsSUFBWSxRQUFPLGFBQW5CO0FBUkQsSUFERDtBQVlBOztBQWpDRDs7Ozs7Ozs7Ozs7O0VBYitCcmMsZ0JBQU1TLFM7O0FBQWhDMmIsaUIsQ0FTRTFQLFksR0FBZTtBQUNyQnJILFVBQVM7QUFEWSxDO0FBVGpCK1csaUIsQ0FxQkU1YixHLEdBQU0sYTtrQkE0QkMsNkJBQ2QsbUNBQW9CLGtDQUFtQjRiLGlCQUFuQixDQUFwQixDQURjLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEVmOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFYQTs7Ozs7QUFhQTs7Ozs7Ozs7O0lBU01FLFk7Ozs7Ozs7Ozs7Ozs7QUE2Qkw7Ozs7Ozs7OztBQTVCQTs7Ozs7Ozs7MkJBb0NTO0FBQ1IsT0FBTTNJLDBCQUF3QixLQUFLQyxlQUFMLEVBQTlCOztBQUVBLFVBQ0M7QUFBQTtBQUFBO0FBQ0MsbUJBQVloYSxZQUFZNkgsT0FBWixDQUFvQjhhLE1BRGpDO0FBRUMscUJBQWM1SSxTQUFTdFMsT0FBVCxDQUFpQixTQUFqQixNQUFnQyxDQUFDLENBRmhEO0FBR0MsZ0JBQVdzUyxRQUhaO0FBSUMsa0JBQVUsZUFKWDtBQUtDLGNBQVMsS0FBS2xPLFdBTGY7QUFNQyxlQUFVLEtBQUtwRixLQUFMLENBQVdYLFFBTnRCO0FBT0MsWUFBTzlGLFlBQVk2SCxPQUFaLENBQW9COGEsTUFQNUI7QUFRQyxrQ0FBQyxvQkFBRCxJQUFZLFFBQU8sUUFBbkI7QUFSRCxJQUREO0FBWUE7O0FBakNEOzs7Ozs7Ozs7Ozs7RUFuQjBCdmMsZ0JBQU1TLFM7O0FBQTNCNmIsWSxDQVNFNVAsWSxHQUFlO0FBQ3JCckgsVUFBUyxRQURZO0FBRXJCSyxZQUFXO0FBQ1ZHLE1BQUksYUFETTtBQUVWek0sUUFBTTFCLFNBQVMwSCxJQUFULEdBQWdCLEVBRlosQ0FFZTtBQUZmLElBR1Z1RyxNQUFNO0FBSEksRUFGVTtBQU9yQlcsUUFBTztBQVBjLEM7QUFUakJnVyxZLENBMkJFOWIsRyxHQUFNLFE7a0JBNEJDLDZCQUNkLCtCQUFnQixrQ0FBbUIsMkJBQVk4YixZQUFaLENBQW5CLENBQWhCLENBRGMsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4RWY7Ozs7QUFFQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVJBOzs7OztBQVVBOzs7O0lBSU1FLHVCOzs7Ozs7Ozs7Ozs7OztzTkFxQkxDLFksR0FBZSxZQUFNO0FBQ3BCLFNBQUtoWCxXQUFMLENBQWlCLElBQWpCO0FBQ0EsRzs7Ozs7MkJBaEJRO0FBQ1IsVUFDQztBQUFBO0FBQUE7QUFDQyxtQkFBWTdMLFlBQVk2SCxPQUFaLENBQW9CMlUsS0FEakM7QUFFQyxnQkFBVSxXQUZYO0FBR0Msa0JBQVUsY0FIWDtBQUlDLGNBQVMsS0FBS3FHLFlBSmY7QUFLQyxlQUFVLEtBQUtwYyxLQUFMLENBQVdYLFFBTHRCO0FBTUMsWUFBTzlGLFlBQVk2SCxPQUFaLENBQW9CMlUsS0FONUI7QUFPQyxrQ0FBQyxvQkFBRCxJQUFZLFFBQU8sT0FBbkI7QUFQRCxJQUREO0FBV0E7Ozs7RUFuQm9DcFcsZ0JBQU1TLFM7O0FBQXRDK2IsdUIsQ0FDRTlQLFksR0FBZTtBQUNyQnJILFVBQVM7QUFEWSxDO0FBRGpCbVgsdUIsQ0FLRWhjLEcsR0FBTSxPO2tCQXFCQyw2QkFBY2djLHVCQUFkLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkNmOzs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFSQTs7Ozs7QUFVQTs7OztJQUlNRSx1Qjs7Ozs7Ozs7Ozs7Ozs7c05BcUJMRCxZLEdBQWUsWUFBTTtBQUNwQixTQUFLaFgsV0FBTCxDQUFpQixJQUFqQjtBQUNBLEc7Ozs7OzJCQWhCUTtBQUNSLFVBQ0M7QUFBQTtBQUFBO0FBQ0MsbUJBQVk3TCxZQUFZNkgsT0FBWixDQUFvQmlRLEtBRGpDO0FBRUMsZ0JBQVUsV0FGWDtBQUdDLGtCQUFVLGNBSFg7QUFJQyxjQUFTLEtBQUsrSyxZQUpmO0FBS0MsZUFBVSxLQUFLcGMsS0FBTCxDQUFXWCxRQUx0QjtBQU1DLFlBQU85RixZQUFZNkgsT0FBWixDQUFvQmlRLEtBTjVCO0FBT0Msa0NBQUMsb0JBQUQsSUFBWSxRQUFPLFNBQW5CO0FBUEQsSUFERDtBQVdBOzs7O0VBbkJvQzFSLGdCQUFNUyxTOztBQUF0Q2ljLHVCLENBQ0VoUSxZLEdBQWU7QUFDckJySCxVQUFTO0FBRFksQztBQURqQnFYLHVCLENBS0VsYyxHLEdBQU0sTztrQkFxQkMsNkJBQWNrYyx1QkFBZCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25DZjs7OztBQUVBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBUkE7Ozs7O0FBVUE7Ozs7SUFJTUMsdUI7Ozs7Ozs7Ozs7Ozs7O3NOQXFCTEYsWSxHQUFlLFlBQU07QUFDcEIsU0FBS2hYLFdBQUwsQ0FBaUIsSUFBakI7QUFDQSxHOzs7OzsyQkFoQlE7QUFDUixVQUNDO0FBQUE7QUFBQTtBQUNDLG1CQUFZN0wsWUFBWTZILE9BQVosQ0FBb0IwVSxLQURqQztBQUVDLGdCQUFVLFdBRlg7QUFHQyxrQkFBVSxjQUhYO0FBSUMsY0FBUyxLQUFLc0csWUFKZjtBQUtDLGVBQVUsS0FBS3BjLEtBQUwsQ0FBV1gsUUFMdEI7QUFNQyxZQUFPOUYsWUFBWTZILE9BQVosQ0FBb0IwVSxLQU41QjtBQU9DLGtDQUFDLG9CQUFELElBQVksUUFBTyxPQUFuQjtBQVBELElBREQ7QUFXQTs7OztFQW5Cb0NuVyxnQkFBTVMsUzs7QUFBdENrYyx1QixDQUNFalEsWSxHQUFlO0FBQ3JCckgsVUFBUztBQURZLEM7QUFEakJzWCx1QixDQUtFbmMsRyxHQUFNLE87a0JBcUJDLDZCQUFjbWMsdUJBQWQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQ2Y7Ozs7QUFFQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVJBOzs7OztBQVVBOzs7Ozs7O0lBT01DLDBCOzs7QUFDTDs7Ozs7Ozs7QUFnQ0EscUNBQVl2YyxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsc0pBQ1pBLEtBRFk7O0FBR2xCLFFBQUtrRixLQUFMLEdBQWE7QUFDWmlJLFVBQU87QUFESyxHQUFiO0FBSGtCO0FBTWxCOztBQUVEOzs7Ozs7Ozs7O0FBbEJBOzs7Ozs7Ozs7Ozs7NENBMEIwQkgsUyxFQUFXO0FBQ3BDLE9BQUksQ0FBQ0EsVUFBVXdQLElBQVgsSUFBbUJ4UCxVQUFVd1AsSUFBVixLQUFtQixLQUFLeGMsS0FBTCxDQUFXd2MsSUFBckQsRUFBMkQ7QUFDMURDLGlCQUFhLEtBQUtDLFFBQWxCOztBQUVBLFFBQUkxUCxVQUFVd1AsSUFBZCxFQUFvQjtBQUNuQixVQUFLRSxRQUFMLEdBQWdCcmIsV0FBVyxLQUFLc2IsWUFBaEIsRUFBOEIsS0FBSzNjLEtBQUwsQ0FBVzRjLEtBQXpDLENBQWhCO0FBQ0EsS0FGRCxNQUVPO0FBQ04sVUFBSy9QLFFBQUwsQ0FBYztBQUNiTSxhQUFPO0FBRE0sTUFBZDtBQUdBO0FBQ0Q7O0FBRUQsT0FBSUgsVUFBVTZQLG9CQUFkLEVBQW9DO0FBQ25DeGIsZUFBVyxLQUFLMEwsS0FBaEIsRUFBdUIsQ0FBdkI7QUFDQSxTQUFLL00sS0FBTCxDQUFXOGMsb0JBQVgsQ0FBZ0M7QUFDL0JDLGVBQVU7QUFEcUIsS0FBaEM7QUFHQTtBQUNEOztBQUVEOzs7Ozs7Ozs7O3lDQU91QjtBQUN0Qk4sZ0JBQWEsS0FBS0MsUUFBbEI7QUFDQTs7QUFFRDs7Ozs7Ozs7Ozs7MkJBUVM7QUFDUixPQUFJLENBQUMsS0FBSzFjLEtBQUwsQ0FBV3dNLFFBQVosSUFBd0IsQ0FBQyxLQUFLdEgsS0FBTCxDQUFXaUksS0FBWCxDQUFpQmxVLE1BQTlDLEVBQXNEO0FBQ3JELFdBQU8sSUFBUDtBQUNBOztBQUVELFVBQ0M7QUFBQyw0QkFBRDtBQUFBO0FBQ0UsU0FBSytqQix3QkFBTCxDQUE4QixLQUFLOVgsS0FBTCxDQUFXaUksS0FBekM7QUFERixJQUREO0FBS0E7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7d0NBVXNCSCxTLEVBQVdpUSxTLEVBQVc7QUFDM0MsVUFDQ2pRLFVBQVVSLFFBQVYsS0FBdUIsS0FBS3hNLEtBQUwsQ0FBV3dNLFFBQWxDLElBQ0FRLFVBQVV3UCxJQUFWLEtBQW1CLEtBQUt4YyxLQUFMLENBQVd3YyxJQUQ5QixJQUVBUyxVQUFVOVAsS0FBVixLQUFvQixLQUFLakksS0FBTCxDQUFXaUksS0FIaEM7QUFLQTs7QUFFRDs7Ozs7Ozs7Ozs7OzsyQ0FVeUJBLEssRUFBTztBQUFBOztBQUMvQkEsV0FBUUEsU0FBUyxFQUFqQjs7QUFFQSxPQUFNK1AsOEJBQThCLEtBQUtsZCxLQUFMLENBQ2xDa2QsMkJBREY7O0FBR0EsVUFBTy9QLE1BQU1yQixHQUFOLENBQVUsZ0JBQVE7QUFDeEIsUUFBTWxQLFlBQ0wsT0FBS29ELEtBQUwsQ0FBV3djLElBQVgsS0FBb0JwUCxLQUFLeUssR0FBekIsR0FDRywyQkFESCxHQUVHLG9CQUhKOztBQUtBLFdBQ0M7QUFBQTtBQUFBLE9BQUksS0FBS3pLLEtBQUt5SyxHQUFkLEVBQW1CLE1BQUssUUFBeEI7QUFDQztBQUFBO0FBQUE7QUFDQyxrQkFBV2piLFNBRFo7QUFFQyxxQkFBWXdRLEtBQUt5SyxHQUZsQjtBQUdDLGdCQUFTcUYsMkJBSFY7QUFJRTlQLFdBQUsrUDtBQUpQO0FBREQsS0FERDtBQVVBLElBaEJNLENBQVA7QUFpQkE7O0FBRUQ7Ozs7Ozs7Ozs7O2lDQVFlO0FBQUE7O0FBQ2QsT0FBSSxDQUFDLEtBQUtuZCxLQUFMLENBQVd3YyxJQUFoQixFQUFzQjtBQUNyQjtBQUNBOztBQUVELE9BQU1ZLFVBQVVDLFFBQVFDLE9BQVIsQ0FBZ0IsS0FBS3RkLEtBQUwsQ0FBVzdFLElBQVgsQ0FBZ0IsS0FBSzZFLEtBQUwsQ0FBV3djLElBQTNCLENBQWhCLENBQWhCOztBQUVBWSxXQUFRRyxJQUFSLENBQWEsaUJBQVM7QUFDckIsUUFBSXBRLE1BQU1sVSxNQUFOLElBQWdCLENBQUMsT0FBSytHLEtBQUwsQ0FBV3dNLFFBQWhDLEVBQTBDO0FBQ3pDLFlBQUt4TSxLQUFMLENBQVcyTSxjQUFYO0FBQ0E7O0FBRUQsV0FBS0UsUUFBTCxDQUFjO0FBQ2JNO0FBRGEsS0FBZDtBQUdBLElBUkQ7QUFTQTs7OztFQWxMdUN4TixnQkFBTVMsUzs7QUFBekNtYywwQixDQVNFbFEsWSxHQUFlO0FBQ3JCOEMsV0FBVSxLQURXO0FBRXJCaFUsT0FBTSxFQUZlO0FBR3JCeWhCLFFBQU8sR0FIYztBQUlyQm5OLGNBQWEscUJBSlE7QUFLckIxVyxPQUFNO0FBQ0w4VixXQUFTLENBQUMsRUFBRCxDQURKO0FBRUxJLGVBQWEsQ0FBQyxFQUFELENBRlI7QUFHTEMsZUFBYSxDQUFDLEVBQUQsQ0FIUjtBQUlMRSxRQUFNLENBQUMsRUFBRCxDQUpEO0FBS0xDLFFBQU0sQ0FBQyxFQUFEO0FBTEQ7QUFMZSxDO0FBVGpCa04sMEIsQ0ErQkVwYyxHLEdBQU0sNEI7a0JBc0pDLGtDQUFtQm9jLDBCQUFuQixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pNZjs7OztBQUNBOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBWEE7Ozs7O0FBYUE7Ozs7Ozs7O0lBUU1pQixnQjs7Ozs7Ozs7Ozs7OztBQTRCTDs7Ozs7OzJCQU1TO0FBQ1IsT0FBSSxLQUFLeGQsS0FBTCxDQUFXc04sZUFBZixFQUFnQztBQUMvQixTQUFLdE4sS0FBTCxHQUFhLEtBQUt5ZCxtQkFBTCxFQUFiOztBQUVBLFdBQU8sOEJBQUMsOEJBQUQsRUFBMEIsS0FBS3pkLEtBQS9CLENBQVA7QUFDQSxJQUpELE1BSU87QUFDTixXQUFPLDhCQUFDLG9CQUFELEVBQWdCLEtBQUtBLEtBQXJCLENBQVA7QUFDQTtBQUNEOztBQUVEOzs7Ozs7Ozs7c0NBTW9CO0FBQ25CLFFBQUtBLEtBQUwsQ0FBV2lOLGdCQUFYLENBQTRCdVEsaUJBQWlCcmQsR0FBN0M7QUFDQTs7OztFQXBENkJSLGdCQUFNUyxTOztBQUEvQm9kLGdCLENBQ0VuUixZLEdBQWU7QUFDckJoSCxZQUFXO0FBQ1ZHLE1BQUksbUJBRE07QUFFVnpNLFFBQU0xQixTQUFTMEgsSUFBVCxHQUFnQixFQUZaLENBRWU7QUFGZixJQUdWdUcsTUFBTTtBQUhJO0FBRFUsQztBQURqQmtZLGdCLENBU0VyZCxHLEdBQU0sWTtBQVRScWQsZ0IsQ0FXRTVLLFMsR0FBWTtBQUNsQjs7Ozs7QUFLQUcsUUFBT0Ysb0JBQVVHLE1BTkM7O0FBUWxCOzs7Ozs7QUFNQTNULFdBQVV3VCxvQkFBVU07QUFkRixDO2tCQTRDTCwyQkFBWSwrQkFBZ0JxSyxnQkFBaEIsQ0FBWixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkVmOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBVkE7Ozs7O0FBWUE7Ozs7Ozs7SUFPTUUsb0I7OztBQUtMOzs7O0FBSUEsK0JBQVkxZCxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsMElBQ1pBLEtBRFk7O0FBQUEsUUE2Q25CMmQsWUE3Q21CLEdBNkNKLFlBQU07QUFDcEIsT0FBTXZtQixTQUFTLE1BQUs4SSxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFmO0FBQ0EsT0FBTTJnQixNQUFNemdCLE9BQU9ULE1BQVAsQ0FBY3VILHFCQUExQjtBQUNBLE9BQU0wZixxQkFBcUJ4bUIsT0FBT1QsTUFBUCxDQUFjb0gsMEJBQXpDO0FBQ0EsT0FBTThmLGFBQWEsTUFBS0MsaUJBQUwsQ0FBdUJqSyxPQUF2QixHQUNoQixNQUFLaUssaUJBQUwsQ0FBdUJqSyxPQUF2QixDQUErQjNPLEtBQS9CLENBQXFDMlksVUFEckIsR0FFaEIsRUFGSDs7QUFJQSxPQUFNRSxxQkFBcUIsU0FBckJBLGtCQUFxQixlQUFnQjtBQUMxQyxVQUFLQyxXQUFMLENBQ0NDLGFBQWE3aEIsS0FEZCxFQUVDeWhCLFVBRkQsRUFHQ0ksYUFBYWQsS0FIZDtBQUtBLElBTkQ7O0FBUUEsT0FBSWxsQixlQUFLK0YsVUFBTCxDQUFnQjRmLGtCQUFoQixDQUFKLEVBQXlDO0FBQ3hDQSx1QkFBbUJNLEtBQW5CLENBQXlCLElBQXpCLEVBQStCLENBQUM5bUIsTUFBRCxFQUFTeWdCLEdBQVQsRUFBY2tHLGtCQUFkLENBQS9CO0FBQ0E7QUFDRCxHQWhFa0I7O0FBQUEsUUE0RW5CQyxXQTVFbUIsR0E0RUwsVUFBQ3JHLFFBQUQsRUFBV2tHLFVBQVgsRUFBdUJNLFNBQXZCLEVBQXFDO0FBQ2xELE9BQU0vbUIsU0FBUyxNQUFLOEksT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FBZjtBQUNBLE9BQU1rbkIsWUFBWSxJQUFJL21CLFNBQVNnbkIsSUFBYixDQUFrQmpuQixNQUFsQixFQUEwQixFQUFDa25CLGdCQUFnQixLQUFqQixFQUExQixDQUFsQjtBQUNBLE9BQU1DLFlBQVk7QUFDakJsaUIsWUFBUXdoQjtBQURTLElBQWxCO0FBR0EsT0FBTVcsa0JBQWtCLEVBQUNDLFNBQVMsSUFBVixFQUF4Qjs7QUFFQSxPQUFJOUcsUUFBSixFQUFjO0FBQ2IsUUFBSXZnQixPQUFPc25CLE9BQVAsSUFBa0J0bkIsT0FBT3NuQixPQUFQLENBQWVDLE1BQWpDLElBQTJDLENBQUNSLFNBQWhELEVBQTJEO0FBQzFEeEcsZ0JBQVdsYixTQUFTbWlCLE1BQVQsR0FBa0JqSCxRQUE3QjtBQUNBOztBQUVELFFBQUksTUFBS3pTLEtBQUwsQ0FBV2hJLE9BQWYsRUFBd0I7QUFDdkJxaEIsZUFBVXJpQixJQUFWLEdBQWlCeWIsUUFBakI7O0FBRUF5RyxlQUFVUyxNQUFWLENBQ0NOLFNBREQsRUFFQyxNQUFLclosS0FBTCxDQUFXaEksT0FGWixFQUdDc2hCLGVBSEQ7QUFLQSxLQVJELE1BUU87QUFDTkosZUFBVVUsTUFBVixDQUFpQm5ILFFBQWpCLEVBQTJCNEcsU0FBM0IsRUFBc0NDLGVBQXRDO0FBQ0E7O0FBRURwbkIsV0FBT3VFLElBQVAsQ0FBWSxpQkFBWjtBQUNBO0FBQ0QsR0F2R2tCOztBQUdsQixNQUFNSyxPQUFPLElBQUkzRSxTQUFTZ25CLElBQWI7QUFDWjtBQUNBLFFBQUtyZSxLQUFMLENBQVdFLE9BQVgsQ0FBbUI5SSxNQUFuQixDQUEwQkYsR0FBMUIsQ0FBOEIsY0FBOUIsQ0FGWSxFQUdYNm5CLGdCQUhXLEVBQWI7O0FBS0EsTUFBTTdpQixPQUFPRixPQUFPQSxLQUFLK1QsWUFBTCxDQUFrQixNQUFsQixDQUFQLEdBQW1DLEVBQWhEOztBQUVBLFFBQUsrTixpQkFBTCxHQUF5Qm5lLGdCQUFNNFYsU0FBTixFQUF6Qjs7QUFFQSxRQUFLclEsS0FBTCxHQUFhO0FBQ1poSSxZQUFTbEIsSUFERztBQUVaMmIsYUFBVXpiO0FBRkUsR0FBYjtBQVprQjtBQWdCbEI7O0FBRUQ7Ozs7Ozs7Ozs7MkJBTVM7QUFDUixVQUNDO0FBQUE7QUFBQSxNQUFLLFdBQVUsK0JBQWY7QUFDQyxrQ0FBQyx3QkFBRCxhQUFnQixLQUFLLEtBQUs0aEIsaUJBQTFCLElBQWlELEtBQUs5ZCxLQUF0RCxFQUREO0FBRUM7QUFBQTtBQUFBO0FBQ0Msb0JBQVcsUUFEWjtBQUVDLGlCQUFVLFdBRlg7QUFHQyxlQUFTLEtBQUsyZCxZQUhmO0FBSUMsYUFBTSxRQUpQO0FBS0MsbUNBQUMsb0JBQUQsSUFBWSxRQUFPLFFBQW5CO0FBTEQ7QUFGRCxJQUREO0FBWUE7O0FBRUQ7Ozs7Ozs7O0FBMkJBOzs7Ozs7Ozs7Ozs7OztFQTNFa0NoZSxnQkFBTVMsUzs7QUFBbkNzZCxvQixDQUNFM1ksVyxHQUFjckYsdUI7QUFEaEJnZSxvQixDQUdFdmQsRyxHQUFNLGdCO2tCQWdIQ1Qsd0JBQWNHLE9BQWQsQ0FBc0I2ZCxvQkFBdEIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pJZjs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQWJBOzs7OztBQWVBOzs7Ozs7OztJQVFNc0IsYzs7O0FBR0w7Ozs7Ozs7O0FBbUNBLHlCQUFZaGYsS0FBWixFQUFtQjtBQUFBOztBQUFBLDhIQUNaQSxLQURZOztBQUFBLFFBaU1uQjBYLFVBak1tQixHQWlNTixZQUFNO0FBQ2xCLFNBQUs3SyxRQUFMLENBQWM7QUFDYjhLLGNBQVU7QUFERyxJQUFkOztBQUlBLFNBQUtHLGVBQUw7QUFDQSxHQXZNa0I7O0FBQUEsUUEwT25CbEgsY0ExT21CLEdBME9GLGlCQUFTO0FBQ3pCLE9BQUkzVixNQUFNK1QsT0FBTixLQUFrQixFQUFsQixJQUF3Qi9ULE1BQU0rVCxPQUFOLEtBQWtCLEVBQTlDLEVBQWtEO0FBQ2pEL1QsVUFBTVEsY0FBTjtBQUNBOztBQUVELE9BQUlSLE1BQU0rVCxPQUFOLEtBQWtCLEVBQXRCLEVBQTBCO0FBQ3pCLFVBQUtnUCxXQUFMO0FBQ0EsSUFGRCxNQUVPLElBQUkvaUIsTUFBTStULE9BQU4sS0FBa0IsRUFBdEIsRUFBMEI7QUFDaEMsVUFBS25DLFFBQUwsQ0FBYztBQUNiZ1EsMkJBQXNCO0FBRFQsS0FBZDtBQUdBLElBSk0sTUFJQSxJQUFJNWhCLE1BQU0rVCxPQUFOLEtBQWtCLEVBQXRCLEVBQTBCO0FBQ2hDLFFBQU01WCxTQUFTLE1BQUs4SSxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFmOztBQUVBLFFBQUlHLFNBQVNnbkIsSUFBYixDQUFrQmpuQixNQUFsQixFQUEwQjZuQixnQkFBMUI7O0FBRUEsVUFBSy9lLE9BQUwsQ0FBYTlJLE1BQWIsQ0FDRUYsR0FERixDQUNNLGNBRE4sRUFFRXlFLElBRkYsQ0FFTyxpQkFGUDtBQUdBO0FBQ0QsR0E5UGtCOztBQUFBLFFBeVFuQnFjLHFCQXpRbUIsR0F5UUssaUJBQVM7QUFDaEMsU0FBS25MLFFBQUwsQ0FBYztBQUNiOEssY0FBVTFjLE1BQU1vQixNQUFOLENBQWFEO0FBRFYsSUFBZDs7QUFJQSxTQUFLMGIsZUFBTDtBQUNBLEdBL1FrQjs7QUFBQSxRQTBSbkJvSCx1QkExUm1CLEdBMFJPLGlCQUFTO0FBQ2xDLFNBQUtyUyxRQUFMLENBQWM7QUFDYkosa0JBQWMsSUFERDtBQUVib1IsZ0JBQVk1aUIsTUFBTW9CLE1BQU4sQ0FBYTBULFlBQWIsQ0FBMEIsWUFBMUI7QUFGQyxJQUFkOztBQUtBLFNBQUsrSCxlQUFMO0FBQ0EsR0FqU2tCOztBQUFBLFFBaVZuQnFILFdBalZtQixHQWlWTCxZQUFNO0FBQ25CLE9BQU0vbkIsU0FBUyxNQUFLOEksT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FBZjtBQUNBLE9BQU1rbkIsWUFBWSxJQUFJL21CLFNBQVNnbkIsSUFBYixDQUFrQmpuQixNQUFsQixDQUFsQjtBQUNBLE9BQU11RCxZQUFZdkQsT0FBT29ELFlBQVAsRUFBbEI7QUFDQSxPQUFNNGtCLFlBQVl6a0IsVUFBVTBrQixlQUFWLEVBQWxCOztBQUVBakIsYUFBVTdaLE1BQVYsQ0FBaUIsTUFBS1csS0FBTCxDQUFXaEksT0FBNUIsRUFBcUMsRUFBQ3VoQixTQUFTLElBQVYsRUFBckM7O0FBRUE5akIsYUFBVTJrQixlQUFWLENBQTBCRixTQUExQjs7QUFFQTtBQUNBO0FBQ0EsU0FBS3BmLEtBQUwsQ0FBV3FOLGVBQVg7O0FBRUFqVyxVQUFPdUUsSUFBUCxDQUFZLGlCQUFaO0FBQ0EsR0FoV2tCOztBQUFBLFFBeVhuQnFpQixXQXpYbUIsR0F5WEwsWUFBTTtBQUNuQixPQUFNNW1CLFNBQVMsTUFBSzhJLE9BQUwsQ0FBYTlJLE1BQWIsQ0FBb0JGLEdBQXBCLENBQXdCLGNBQXhCLENBQWY7QUFDQSxPQUFNa25CLFlBQVksSUFBSS9tQixTQUFTZ25CLElBQWIsQ0FBa0JqbkIsTUFBbEIsRUFBMEI7QUFDM0NrbkIsb0JBQWdCLE1BQUt0ZSxLQUFMLENBQVdzZTtBQURnQixJQUExQixDQUFsQjtBQUdBLE9BQUlDLFlBQVk7QUFDZmxpQixZQUFRLE1BQUs2SSxLQUFMLENBQVcyWSxVQUFYLElBQXlCO0FBRGxCLElBQWhCO0FBR0EsT0FBTVcsa0JBQWtCLEVBQUNDLFNBQVMsSUFBVixFQUF4Qjs7QUFFQSxPQUFJLE1BQUt2WixLQUFMLENBQVd5UyxRQUFmLEVBQXlCO0FBQ3hCLFFBQUksTUFBS3pTLEtBQUwsQ0FBV2hJLE9BQWYsRUFBd0I7QUFDdkJxaEIsZUFBVXJpQixJQUFWLEdBQWlCLE1BQUtnSixLQUFMLENBQVd5UyxRQUE1Qjs7QUFFQXlHLGVBQVVTLE1BQVYsQ0FDQ04sU0FERCxFQUVDLE1BQUtyWixLQUFMLENBQVdoSSxPQUZaLEVBR0NzaEIsZUFIRDtBQUtBLEtBUkQsTUFRTztBQUNOLFNBQUksQ0FBQyxNQUFLdFosS0FBTCxDQUFXMlksVUFBaEIsRUFBNEJVLFlBQVksRUFBWjs7QUFFNUJILGVBQVVVLE1BQVYsQ0FDQyxNQUFLNVosS0FBTCxDQUFXeVMsUUFEWixFQUVDNEcsU0FGRCxFQUdDQyxlQUhEO0FBS0E7O0FBRURwbkIsV0FBT3VFLElBQVAsQ0FBWSxpQkFBWjtBQUNBOztBQUVEO0FBQ0E7QUFDQSxTQUFLcUUsS0FBTCxDQUFXcU4sZUFBWDtBQUNBLEdBNVprQjs7QUFHbEIsUUFBSzBLLFNBQUwsR0FBaUJwWSxnQkFBTTRWLFNBQU4sRUFBakI7QUFDQSxRQUFLclEsS0FBTCxHQUFhLE1BQUtxYSxnQkFBTCxFQUFiO0FBSmtCO0FBS2xCOztBQUVEOzs7Ozs7Ozs7Ozs7QUFqQkE7Ozs7Ozs7Ozs7OztzQ0EyQm9CO0FBQ25CLE9BQUksS0FBS3ZmLEtBQUwsQ0FBV3NOLGVBQVgsSUFBOEIsS0FBS3ROLEtBQUwsQ0FBV3FZLGVBQTdDLEVBQThEO0FBQzdEO0FBQ0E7QUFDQSxTQUFLUCxlQUFMO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7OENBUTRCO0FBQzNCLFFBQUtqTCxRQUFMLENBQWMsS0FBSzBTLGdCQUFMLEVBQWQ7QUFDQTs7QUFFRDs7Ozs7Ozs7Ozs7MkJBUVM7QUFDUixPQUFJQyxpQkFBaUI7QUFDcEJDLG9CQUFnQixLQUFLemYsS0FBTCxDQUFXeWYsY0FEUDtBQUVwQnJvQixZQUFRLEtBQUs4SSxPQUFMLENBQWE5SSxNQUZEO0FBR3BCc29CLDRCQUF3QixLQUFLUix1QkFIVDtBQUlwQlMsb0JBQ0MsS0FBS3phLEtBQUwsQ0FBVzJZLFVBQVgsSUFBeUJ0a0IsWUFBWTZILE9BQVosQ0FBb0J3ZTtBQUwxQixJQUFyQjs7QUFRQUosb0JBQWlCLEtBQUtwVCxrQkFBTCxDQUNoQm9ULGNBRGdCLEVBRWhCSywrQkFBcUIxZixHQUZMLENBQWpCOztBQUtBLE9BQUkyZiw2QkFBSjs7QUFFQSxPQUFJLEtBQUs5ZixLQUFMLENBQVc3RSxJQUFmLEVBQXFCO0FBQ3BCLFFBQUk0a0IsU0FBUyxLQUFLL2YsS0FBTCxDQUFXN0UsSUFBeEI7O0FBRUEsUUFBSSxDQUFDbEQsZUFBSytGLFVBQUwsQ0FBZ0IraEIsTUFBaEIsQ0FBTCxFQUE4QjtBQUM3QixTQUFNNVMsUUFBUSxLQUFLbk4sS0FBTCxDQUFXN0UsSUFBekI7O0FBRUE0a0IsY0FBUztBQUFBLGFBQU01UyxLQUFOO0FBQUEsTUFBVDtBQUNBOztBQUVELFFBQUk2Uyw0QkFBNEI7QUFDL0JuRCwyQkFBc0IsS0FBSzNYLEtBQUwsQ0FBVzJYLG9CQURGO0FBRS9CMWhCLFdBQU00a0IsTUFGeUI7QUFHL0Izb0IsYUFBUSxLQUFLOEksT0FBTCxDQUFhOUksTUFIVTtBQUkvQjhsQixrQ0FBNkIsS0FBSytDLDRCQUpIO0FBSy9CelIsZ0JBQVcsS0FBS3hPLEtBQUwsQ0FBVzJNLGNBTFM7QUFNL0JtUSwyQkFBc0IsS0FBS29ELHFCQU5JO0FBTy9CMUQsV0FBTSxLQUFLdFgsS0FBTCxDQUFXeVM7QUFQYyxLQUFoQzs7QUFVQXFJLGdDQUE0QixLQUFLNVQsa0JBQUwsQ0FDM0I0VCx5QkFEMkIsRUFFM0J6RCxxQ0FBMkJwYyxHQUZBLENBQTVCOztBQUtBMmYsMkJBQ0MsOEJBQUMsb0NBQUQsRUFBZ0NFLHlCQUFoQyxDQUREO0FBR0E7O0FBRUQsT0FBSUcsd0JBQUo7O0FBRUEsT0FBSSxLQUFLamIsS0FBTCxDQUFXeVMsUUFBZixFQUF5QjtBQUN4QndJLHNCQUNDO0FBQUE7QUFBQTtBQUNDLG9CQUFZNW1CLFlBQVk2SCxPQUFaLENBQW9CdVgsVUFEakM7QUFFQyxpQkFBVSwyQkFGWDtBQUdDLGVBQVMsS0FBS2pCLFVBSGY7QUFJQyxhQUFPbmUsWUFBWTZILE9BQVosQ0FBb0J3WCxLQUo1QjtBQUtDLG1DQUFDLG9CQUFELElBQVksUUFBTyxjQUFuQjtBQUxELEtBREQ7QUFTQTs7QUFFRCxPQUFNd0gsa0JBQWtCLEVBQXhCOztBQUVBLE9BQUksQ0FBQy9vQixTQUFTYyxHQUFULENBQWFDLEVBQWQsSUFBb0JtQixZQUFZNkgsT0FBcEMsRUFBNkM7QUFDNUNnZixvQkFBZ0JDLFdBQWhCLEdBQThCOW1CLFlBQVk2SCxPQUFaLENBQW9Cc1gsUUFBbEQ7QUFDQTs7QUFFRCxVQUNDO0FBQUE7QUFBQSxNQUFLLFdBQVUsd0JBQWY7QUFDQztBQUFBO0FBQUE7QUFDQyxvQkFBWW5mLFlBQVk2SCxPQUFaLENBQW9Ca2YsVUFEakM7QUFFQyxpQkFBVSxXQUZYO0FBR0MsZ0JBQVUsQ0FBQyxLQUFLcGIsS0FBTCxDQUFXaEksT0FIdkI7QUFJQyxlQUFTLEtBQUtpaUIsV0FKZjtBQUtDLGFBQU81bEIsWUFBWTZILE9BQVosQ0FBb0JtRCxNQUw1QjtBQU1DLG1DQUFDLG9CQUFELElBQVksUUFBTyxjQUFuQjtBQU5ELEtBREQ7QUFTQztBQUFBO0FBQUEsT0FBSyxXQUFVLHdCQUFmO0FBQ0UsVUFBS3ZFLEtBQUwsQ0FBV3VnQixrQkFBWCxJQUNBLDhCQUFDLDhCQUFELEVBQTBCZixjQUExQixDQUZGO0FBSUM7QUFBQTtBQUFBLFFBQUssV0FBVSxvQkFBZjtBQUNDO0FBQ0Msa0JBQVUsVUFEWDtBQUVDLGlCQUFVLEtBQUt4SCxxQkFGaEI7QUFHQyxrQkFBVyxLQUFLcEg7QUFIakIsU0FJS3dQLGVBSkw7QUFLQyxZQUFLLEtBQUtySSxTQUxYO0FBTUMsYUFBSyxNQU5OO0FBT0MsY0FBTyxLQUFLN1MsS0FBTCxDQUFXeVM7QUFQbkIsU0FERDtBQVVFbUk7QUFWRixNQUpEO0FBZ0JFSztBQWhCRixLQVREO0FBMkJDO0FBQUE7QUFBQTtBQUNDLG9CQUFZNW1CLFlBQVk2SCxPQUFaLENBQW9CeVAsT0FEakM7QUFFQyxpQkFBVSxXQUZYO0FBR0MsZ0JBQVUsQ0FBQyxLQUFLZ0ksYUFBTCxFQUhaO0FBSUMsZUFBUyxLQUFLbUYsV0FKZjtBQUtDLGFBQU96a0IsWUFBWTZILE9BQVosQ0FBb0J5UCxPQUw1QjtBQU1DLG1DQUFDLG9CQUFELElBQVksV0FBVSxtQkFBdEIsRUFBMEMsUUFBTyxPQUFqRDtBQU5EO0FBM0JELElBREQ7QUFzQ0E7O0FBRUQ7Ozs7Ozs7Ozs7OztxQ0FTbUI7QUFDbEI7QUFEa0IsT0FFWHpaLE1BRlcsR0FFRCxLQUFLNEksS0FBTCxDQUFXRSxPQUZWLENBRVg5SSxNQUZXO0FBQUEsT0FHWG9wQixpQkFIVyxHQUdVLEtBQUt4Z0IsS0FIZixDQUdYd2dCLGlCQUhXOzs7QUFLbEIsT0FBTXhrQixPQUFPLElBQUkzRSxTQUFTZ25CLElBQWIsQ0FDWmpuQixPQUFPRixHQUFQLENBQVcsY0FBWCxDQURZLEVBRVg2bkIsZ0JBRlcsRUFBYjtBQUdBLE9BQU03aUIsT0FBUUYsUUFBUUEsS0FBSytULFlBQUwsQ0FBa0IsTUFBbEIsQ0FBVCxJQUF1QyxFQUFwRDtBQUNBLE9BQU0xVCxTQUNKTCxRQUFRQSxLQUFLK1QsWUFBTCxDQUFrQixRQUFsQixDQUFULElBQXlDeVEsaUJBRDFDOztBQUdBLFVBQU87QUFDTjNELDBCQUFzQixLQURoQjtBQUVOM2YsYUFBU2xCLElBRkg7QUFHTnVjLGlCQUFhO0FBQ1pyYyxlQURZO0FBRVpHO0FBRlksS0FIUDtBQU9Oc2IsY0FBVXpiLElBUEo7QUFRTjJoQixnQkFBWXhoQjtBQVJOLElBQVA7QUFVQTs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOzs7Ozs7OztvQ0FRa0I7QUFDakIsT0FBTTJVLFdBQVcsSUFBakI7O0FBRUEsT0FBTXlQLGNBQWMsU0FBZEEsV0FBYyxHQUFXO0FBQzlCelAsYUFBUytHLFNBQVQsQ0FBbUJsRSxPQUFuQixDQUEyQjlHLEtBQTNCO0FBQ0EsSUFGRDs7QUFJQSxPQUFJeFMsT0FBT3FQLHFCQUFYLEVBQWtDO0FBQ2pDclAsV0FBT3FQLHFCQUFQLENBQTZCNlcsV0FBN0I7QUFDQSxJQUZELE1BRU87QUFDTnBmLGVBQVdvZixXQUFYLEVBQXdCLENBQXhCO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7OztBQWlDQTs7Ozs7Ozs7Ozs7QUFpQkE7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOzs7Ozs7Ozs7K0NBUzZCeGxCLEssRUFBTztBQUNuQyxRQUFLNFIsUUFBTCxDQUFjO0FBQ2JKLGtCQUFjLElBREQ7QUFFYmtMLGNBQVUxYyxNQUFNb0IsTUFBTixDQUFhMFQsWUFBYixDQUEwQixZQUExQjtBQUZHLElBQWQ7O0FBS0EsUUFBSytILGVBQUw7QUFDQTs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7a0NBV2dCO0FBQ2YsT0FBTWdCLGFBQ0wsS0FBSzVULEtBQUwsQ0FBV3lTLFFBQVgsS0FDQyxLQUFLelMsS0FBTCxDQUFXeVMsUUFBWCxLQUF3QixLQUFLelMsS0FBTCxDQUFXcVQsV0FBWCxDQUF1QnJjLElBQS9DLElBQ0EsS0FBS2dKLEtBQUwsQ0FBVzJZLFVBQVgsS0FBMEIsS0FBSzNZLEtBQUwsQ0FBV3FULFdBQVgsQ0FBdUJsYyxNQUZsRCxDQUREOztBQUtBLFVBQU95YyxVQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUF5QkE7Ozs7Ozs7O3dDQVFzQjVULEssRUFBTztBQUM1QixRQUFLMkgsUUFBTCxDQUFjO0FBQ2JnUSwwQkFBc0IzWCxNQUFNNlg7QUFEZixJQUFkO0FBR0E7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7RUF0WjRCcGQsZ0JBQU1TLFM7O0FBQTdCNGUsYyxDQUNFamEsVyxHQUFjckYsdUI7QUFEaEJzZixjLENBV0UzUyxZLEdBQWU7QUFDckJpUyxpQkFBZ0IsSUFESztBQUVyQm9DLGtCQUFpQixFQUZJO0FBR3JCdlIsV0FBVSxJQUhXO0FBSXJCd1IsbUJBQWtCLElBSkc7QUFLckJILG9CQUFtQixFQUxFO0FBTXJCL1EsY0FBYSxxQkFOUTtBQU9yQjFXLE9BQU07QUFDTDhWLFdBQVMsQ0FBQyxFQUFELENBREo7QUFFTEksZUFBYSxDQUFDLEVBQUQsQ0FGUjtBQUdMQyxlQUFhLENBQUMsRUFBRCxDQUhSO0FBSUxFLFFBQU0sQ0FBQyxFQUFELENBSkQ7QUFLTEMsUUFBTSxDQUFDLEVBQUQ7QUFMRCxFQVBlO0FBY3JCa1IscUJBQW9CO0FBZEMsQztBQVhqQnZCLGMsQ0FvQ0U3ZSxHLEdBQU0sVTtrQkFpYUNULHdCQUFjRyxPQUFkLENBQ2QsOEJBQWUsa0NBQW1CbWYsY0FBbkIsQ0FBZixDQURjLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdmRmOzs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFSQTs7Ozs7QUFVQTs7Ozs7O0lBTU1hLG9COzs7Ozs7Ozs7Ozs7O0FBV0w7Ozs7Ozs7OzJCQVFTO0FBQ1IsT0FBTUgseUJBQXlCLEtBQUsxZixLQUFMLENBQVcwZixzQkFBMUM7QUFDQSxPQUFNa0IscUJBQXFCLEtBQUs1Z0IsS0FBTCxDQUFXeWYsY0FBdEM7O0FBRUEsVUFDQztBQUFBO0FBQUE7QUFDQyxnQkFBVSxrR0FEWDtBQUVDLGVBQVMsR0FGVjtBQUdDO0FBQUE7QUFBQTtBQUNDLHVCQUFlLEtBQUt6ZixLQUFMLENBQVd3TSxRQUQzQjtBQUVDLG9CQUFZLEtBQUt4TSxLQUFMLENBQVcyZixjQUZ4QjtBQUdDLGlCQUFVLG9CQUhYO0FBSUMsZUFBUyxLQUFLM2YsS0FBTCxDQUFXMk0sY0FKckI7QUFLQyxZQUFLLFVBTE47QUFNQyxnQkFBVSxLQUFLM00sS0FBTCxDQUFXWCxRQU50QjtBQU9DLGFBQU8sS0FBS1csS0FBTCxDQUFXMmYsY0FQbkI7QUFRQztBQUFBO0FBQUEsUUFBSyxXQUFVLGNBQWY7QUFDQztBQUFBO0FBQUEsU0FBTSxXQUFVLHFDQUFoQjtBQUNFLFlBQUszZixLQUFMLENBQVcyZjtBQURiLE9BREQ7QUFJQyxvQ0FBQyxvQkFBRCxJQUFZLFFBQU8sY0FBbkI7QUFKRDtBQVJELEtBSEQ7QUFrQkUsU0FBSzNmLEtBQUwsQ0FBV3dNLFFBQVgsSUFDQSw4QkFBQywwQkFBRDtBQUNDLHlCQUFvQm9VLGtCQURyQjtBQUVDLDZCQUF3QmxCLHNCQUZ6QjtBQUdDLGdCQUFXLEtBQUsxZixLQUFMLENBQVcyTSxjQUh2QjtBQUlDLHFCQUFnQixLQUFLM00sS0FBTCxDQUFXMmY7QUFKNUI7QUFuQkYsSUFERDtBQTZCQTs7QUFFRDs7Ozs7Ozs7Ozs7QUFyREE7Ozs7Ozs7Ozs7O3dDQStEc0IzUyxTLEVBQVc7QUFDaEMsVUFDQ0EsVUFBVVIsUUFBVixLQUF1QixLQUFLeE0sS0FBTCxDQUFXd00sUUFBbEMsSUFDQVEsVUFBVTJTLGNBQVYsS0FBNkIsS0FBSzNmLEtBQUwsQ0FBVzJmLGNBRnpDO0FBSUE7Ozs7RUFyRWlDaGdCLGdCQUFNUyxTOztBQUFuQ3lmLG9CLENBU0UxZixHLEdBQU0sZ0I7a0JBK0RDMGYsb0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkZmOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVpBOzs7OztBQWNBOzs7Ozs7Ozs7Ozs7SUFZTWdCLFU7Ozs7Ozs7Ozs7Ozs7OzRMQW1GTDlQLGlCLEdBQW9CLFlBQU07QUFDekIsU0FBSy9RLEtBQUwsQ0FBV2lOLGdCQUFYLENBQTRCNFQsV0FBVzFnQixHQUF2QztBQUNBLEc7OztBQWxGRDs7Ozs7Ozs7OztBQWdCQTs7Ozs7Ozs7Ozs7Ozs7QUFVQTs7Ozs7Ozs7NkJBUVc7QUFDVixVQUNDLElBQUk5SSxTQUFTZ25CLElBQWIsQ0FDQyxLQUFLbmUsT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FERCxFQUVFNm5CLGdCQUZGLE9BRXlCLElBSDFCO0FBS0E7O0FBRUQ7Ozs7Ozs7Ozs7OzJCQVFTO0FBQ1IsT0FBTXpMLDBCQUF3QixLQUFLQyxlQUFMLEVBQTlCOztBQUVBLE9BQUksS0FBS3ZULEtBQUwsQ0FBV3NOLGVBQWYsRUFBZ0M7QUFDL0IsUUFBTXROLFFBQVEsS0FBS3lkLG1CQUFMLEVBQWQ7O0FBRUEsV0FBTyw4QkFBQyx3QkFBRCxFQUFvQnpkLEtBQXBCLENBQVA7QUFDQSxJQUpELE1BSU87QUFDTixXQUNDO0FBQUE7QUFBQTtBQUNDLG9CQUFZekcsWUFBWTZILE9BQVosQ0FBb0JwRixJQURqQztBQUVDLGlCQUFXc1gsUUFGWjtBQUdDLG1CQUFVLGFBSFg7QUFJQyxlQUFTLEtBQUt2QyxpQkFKZjtBQUtDLGdCQUFVLEtBQUsvUSxLQUFMLENBQVdYLFFBTHRCO0FBTUMsYUFBTzlGLFlBQVk2SCxPQUFaLENBQW9CcEYsSUFONUI7QUFPQyxtQ0FBQyxvQkFBRCxJQUFZLFFBQU8sTUFBbkI7QUFQRCxLQUREO0FBV0E7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7O0VBM0V3QjJELGdCQUFNUyxTOztBQUF6QnlnQixVLENBQ0U5YixXLEdBQWNyRix1QjtBQURoQm1oQixVLENBV0V4VSxZLEdBQWU7QUFDckJoSCxZQUFXO0FBQ1ZHLE1BQUksbUJBRE07QUFFVnpNLFFBQU0xQixTQUFTMEgsSUFBVCxHQUFnQixFQUZaLENBRWU7QUFGZixJQUdWdUcsTUFBTTtBQUhJO0FBRFUsQztBQVhqQnViLFUsQ0EyQkUxZ0IsRyxHQUFNLE07a0JBNkRDLDJCQUFZLCtCQUFnQixrQ0FBbUIwZ0IsVUFBbkIsQ0FBaEIsQ0FBWixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdHZjs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVZBOzs7OztBQVlBOzs7Ozs7OztJQVFNQyxpQjs7Ozs7Ozs7Ozs7OztBQTBCTDs7Ozs7Ozs7O0FBekJBOzs7Ozs7OzsyQkFpQ1M7QUFDUixPQUFNeE4sMEJBQXdCLEtBQUtDLGVBQUwsRUFBOUI7O0FBRUEsVUFDQztBQUFBO0FBQUE7QUFDQyxtQkFBWWhhLFlBQVk2SCxPQUFaLENBQW9CMmYsWUFEakM7QUFFQyxxQkFBY3pOLFNBQVN0UyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FGaEQ7QUFHQyxnQkFBV3NTLFFBSFo7QUFJQyxrQkFBVSxXQUpYO0FBS0MsY0FBUyxLQUFLbE8sV0FMZjtBQU1DLGVBQVUsS0FBS3BGLEtBQUwsQ0FBV1gsUUFOdEI7QUFPQyxZQUFPOUYsWUFBWTZILE9BQVosQ0FBb0IyZixZQVA1QjtBQVFDLGtDQUFDLG9CQUFELElBQVksUUFBTyxTQUFuQjtBQVJELElBREQ7QUFZQTs7QUFqQ0Q7Ozs7Ozs7Ozs7OztFQWhCK0JwaEIsZ0JBQU1TLFM7O0FBQWhDMGdCLGlCLENBU0V6VSxZLEdBQWU7QUFDckJySCxVQUFTLGNBRFk7QUFFckJpQixRQUFPO0FBQ04vSSxXQUFTO0FBREg7QUFGYyxDO0FBVGpCNGpCLGlCLENBd0JFM2dCLEcsR0FBTSxJO2tCQTRCQyw2QkFDZCxrQ0FBbUIsMkJBQVkyZ0IsaUJBQVosQ0FBbkIsQ0FEYyxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25FZjs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVZBOzs7OztBQVlBOzs7Ozs7OztJQVFNRSxrQjs7Ozs7Ozs7Ozs7OztBQXVCTDs7Ozs7Ozs7O0FBdEJBOzs7Ozs7OzsyQkE4QlM7QUFDUixPQUFNMU4sMEJBQXdCLEtBQUtDLGVBQUwsRUFBOUI7O0FBRUEsVUFDQztBQUFBO0FBQUE7QUFDQyxtQkFBWWhhLFlBQVk2SCxPQUFaLENBQW9CNmYsT0FEakM7QUFFQyxxQkFBYzNOLFNBQVN0UyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FGaEQ7QUFHQyxnQkFBV3NTLFFBSFo7QUFJQyxrQkFBVSxzQkFKWDtBQUtDLGNBQVMsS0FBS2xPLFdBTGY7QUFNQyxlQUFVLEtBQUtwRixLQUFMLENBQVdYLFFBTnRCO0FBT0MsWUFBTzlGLFlBQVk2SCxPQUFaLENBQW9CNmYsT0FQNUI7QUFRQyxrQ0FBQyxvQkFBRCxJQUFZLFFBQU8sYUFBbkI7QUFSRCxJQUREO0FBWUE7O0FBakNEOzs7Ozs7Ozs7Ozs7RUFiZ0N0aEIsZ0JBQU1TLFM7O0FBQWpDNGdCLGtCLENBU0UzVSxZLEdBQWU7QUFDckJySCxVQUFTO0FBRFksQztBQVRqQmdjLGtCLENBcUJFN2dCLEcsR0FBTSxjO2tCQTRCQyw2QkFDZCxtQ0FBb0Isa0NBQW1CNmdCLGtCQUFuQixDQUFwQixDQURjLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEVmOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBVkE7Ozs7O0FBWUE7Ozs7Ozs7OztJQVNNRSx3Qjs7Ozs7Ozs7Ozs7OztBQXVCTDs7Ozs7Ozs7O0FBdEJBOzs7Ozs7OzsyQkE4QlM7QUFDUixPQUFNNU4sMEJBQXdCLEtBQUtDLGVBQUwsRUFBOUI7O0FBRUEsVUFDQztBQUFBO0FBQUE7QUFDQyxtQkFBWWhhLFlBQVk2SCxPQUFaLENBQW9CdVosU0FEakM7QUFFQyxxQkFBY3JILFNBQVN0UyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FGaEQ7QUFHQyxnQkFBV3NTLFFBSFo7QUFJQyxrQkFBVSw2QkFKWDtBQUtDLGNBQVMsS0FBS2xPLFdBTGY7QUFNQyxlQUFVLEtBQUtwRixLQUFMLENBQVdYLFFBTnRCO0FBT0MsWUFBTzlGLFlBQVk2SCxPQUFaLENBQW9CdVosU0FQNUI7QUFRQyxrQ0FBQyxvQkFBRCxJQUFZLFFBQU8sWUFBbkI7QUFSRCxJQUREO0FBWUE7O0FBakNEOzs7Ozs7Ozs7Ozs7RUFic0NoYixnQkFBTVMsUzs7QUFBdkM4Z0Isd0IsQ0FTRTdVLFksR0FBZTtBQUNyQnJILFVBQVM7QUFEWSxDO0FBVGpCa2Msd0IsQ0FxQkUvZ0IsRyxHQUFNLGU7a0JBNEJDLDZCQUNkLG1DQUFvQixrQ0FBbUIrZ0Isd0JBQW5CLENBQXBCLENBRGMsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRWY7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFWQTs7Ozs7QUFZQTs7Ozs7Ozs7SUFRTUMseUI7Ozs7Ozs7Ozs7Ozs7QUF1Qkw7Ozs7Ozs7OztBQXRCQTs7Ozs7Ozs7MkJBOEJTO0FBQ1IsT0FBTTdOLDBCQUF3QixLQUFLQyxlQUFMLEVBQTlCOztBQUVBLFVBQ0M7QUFBQTtBQUFBO0FBQ0MsbUJBQVloYSxZQUFZNkgsT0FBWixDQUFvQnlaLFVBRGpDO0FBRUMscUJBQWN2SCxTQUFTdFMsT0FBVCxDQUFpQixTQUFqQixNQUFnQyxDQUFDLENBRmhEO0FBR0MsZ0JBQVdzUyxRQUhaO0FBSUMsa0JBQVUsOEJBSlg7QUFLQyxjQUFTLEtBQUtsTyxXQUxmO0FBTUMsZUFBVSxLQUFLcEYsS0FBTCxDQUFXWCxRQU50QjtBQU9DLFlBQU85RixZQUFZNkgsT0FBWixDQUFvQnlaLFVBUDVCO0FBUUMsa0NBQUMsb0JBQUQsSUFBWSxRQUFPLGFBQW5CO0FBUkQsSUFERDtBQVlBOztBQWpDRDs7Ozs7Ozs7Ozs7O0VBYnVDbGIsZ0JBQU1TLFM7O0FBQXhDK2dCLHlCLENBU0U5VSxZLEdBQWU7QUFDckJySCxVQUFTO0FBRFksQztBQVRqQm1jLHlCLENBcUJFaGhCLEcsR0FBTSxnQjtrQkE0QkMsNkJBQ2QsbUNBQW9CLGtDQUFtQmdoQix5QkFBbkIsQ0FBcEIsQ0FEYyxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hFZjs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFUQTs7Ozs7QUFXQTs7Ozs7SUFLTUMsb0I7Ozs7Ozs7Ozs7Ozs7QUFLTDs7Ozs7Ozs7MkJBUVM7QUFDUixPQUFJQywyQkFBSjtBQUNBLE9BQUlDLDZCQUFKOztBQUVBLE9BQUksS0FBS3RoQixLQUFMLENBQVd3TSxRQUFmLEVBQXlCO0FBQ3hCOFUsMkJBQXVCRixxQkFBcUJqaEIsR0FBckIsR0FBMkIsTUFBbEQ7QUFDQWtoQix5QkFDQyw4QkFBQyw0QkFBRDtBQUNDLGVBQVUsS0FBS0UsWUFBTCxFQURYO0FBRUMsa0JBQWEsS0FGZDtBQUdDLGFBQVFELG9CQUhUO0FBSUMsZ0JBQVcsS0FBS3RoQixLQUFMLENBQVcyTTtBQUp2QixNQUREO0FBUUE7O0FBRUQsT0FBTXZWLFNBQVMsS0FBSzhJLE9BQUwsQ0FBYTlJLE1BQWIsQ0FBb0JGLEdBQXBCLENBQXdCLGNBQXhCLENBQWY7O0FBRUEsT0FBTXNxQixnQkFBZ0IsS0FBS0QsWUFBTCxHQUNwQjFWLE1BRG9CLENBQ2IscUJBQWE7QUFDcEIsUUFBTTdHLFVBQVU1TixPQUFPNk4sVUFBUCxDQUFrQndjLFVBQVV6YyxPQUE1QixDQUFoQjs7QUFFQSxXQUFPQSxVQUFVQSxRQUFRRSxLQUFSLEtBQWtCN04sU0FBUzhOLFdBQXJDLEdBQW1ELEtBQTFEO0FBQ0EsSUFMb0IsRUFNcEJ1YyxHQU5vQixFQUF0Qjs7QUFRQSxPQUFNQyxnQkFBZ0JILGNBQWNwSyxJQUFwQzs7QUFFQSxVQUNDO0FBQUE7QUFBQSxNQUFLLFdBQVUsb0VBQWY7QUFDQztBQUFBO0FBQUE7QUFDQyx1QkFBZSxLQUFLcFgsS0FBTCxDQUFXd00sUUFEM0I7QUFFQyxvQkFBWWdWLGNBQWN6TyxLQUYzQjtBQUdDLG1CQUFXdU8sb0JBSFo7QUFJQyxpQkFBVSxvQkFKWDtBQUtDLGVBQVMsS0FBS3RoQixLQUFMLENBQVcyTSxjQUxyQjtBQU1DLFlBQUssVUFOTjtBQU9DLGdCQUFVLEtBQUszTSxLQUFMLENBQVdYLFFBUHRCO0FBUUMsYUFBTzlGLFlBQVk2SCxPQUFaLENBQW9Cd2dCLEdBUjVCO0FBU0M7QUFBQTtBQUFBLFFBQUssV0FBVSxjQUFmO0FBQ0Msb0NBQUMsb0JBQUQsSUFBWSxRQUFRRCxhQUFwQixHQUREO0FBRUMsb0NBQUMsb0JBQUQsSUFBWSxRQUFPLGNBQW5CO0FBRkQ7QUFURCxLQUREO0FBZUVOO0FBZkYsSUFERDtBQW1CQTs7QUFFRDs7Ozs7Ozs7Ozs7OztpQ0FVZTtBQUNkLFVBQ0MsS0FBS3JoQixLQUFMLENBQVc3RyxRQUFYLElBQXVCLENBQ3RCO0FBQ0M2TCxhQUFTLGFBRFY7QUFFQ29TLFVBQU0sWUFGUDtBQUdDckUsV0FBT3haLFlBQVk2SCxPQUFaLENBQW9CdVo7QUFINUIsSUFEc0IsRUFNdEI7QUFDQzNWLGFBQVMsZUFEVjtBQUVDb1MsVUFBTSxjQUZQO0FBR0NyRSxXQUFPeFosWUFBWTZILE9BQVosQ0FBb0JxWjtBQUg1QixJQU5zQixFQVd0QjtBQUNDelYsYUFBUyxjQURWO0FBRUNvUyxVQUFNLGFBRlA7QUFHQ3JFLFdBQU94WixZQUFZNkgsT0FBWixDQUFvQnlaO0FBSDVCLElBWHNCLEVBZ0J0QjtBQUNDN1YsYUFBUyxjQURWO0FBRUNvUyxVQUFNLGVBRlA7QUFHQ3JFLFdBQU94WixZQUFZNkgsT0FBWixDQUFvQnlnQjtBQUg1QixJQWhCc0IsQ0FEeEI7QUF3QkE7Ozs7RUFqR2lDbGlCLGdCQUFNUyxTOztBQUFuQ2doQixvQixDQUNFcmMsVyxHQUFjckYsdUI7QUFEaEIwaEIsb0IsQ0FHRWpoQixHLEdBQU0sZ0I7a0JBaUdDaWhCLG9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9HZjs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVZBOzs7OztBQVlBOzs7Ozs7OztJQVFNVSxxQjs7Ozs7Ozs7Ozs7OztBQXVCTDs7Ozs7Ozs7O0FBdEJBOzs7Ozs7OzsyQkE4QlM7QUFDUixPQUFNeE8sMEJBQXdCLEtBQUtDLGVBQUwsRUFBOUI7O0FBRUEsVUFDQztBQUFBO0FBQUE7QUFDQyxtQkFBWWhhLFlBQVk2SCxPQUFaLENBQW9CcVosV0FEakM7QUFFQyxxQkFBY25ILFNBQVN0UyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FGaEQ7QUFHQyxnQkFBV3NTLFFBSFo7QUFJQyxrQkFBVSx5QkFKWDtBQUtDLGNBQVMsS0FBS2xPLFdBTGY7QUFNQyxlQUFVLEtBQUtwRixLQUFMLENBQVdYLFFBTnRCO0FBT0MsWUFBTzlGLFlBQVk2SCxPQUFaLENBQW9CcVosV0FQNUI7QUFRQyxrQ0FBQyxvQkFBRCxJQUFZLFFBQU8sY0FBbkI7QUFSRCxJQUREO0FBWUE7O0FBakNEOzs7Ozs7Ozs7Ozs7RUFibUM5YSxnQkFBTVMsUzs7QUFBcEMwaEIscUIsQ0FTRXpWLFksR0FBZTtBQUNyQnJILFVBQVM7QUFEWSxDO0FBVGpCOGMscUIsQ0FxQkUzaEIsRyxHQUFNLGlCO2tCQTRCQyw2QkFDZCxtQ0FBb0Isa0NBQW1CMmhCLHFCQUFuQixDQUFwQixDQURjLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEVmOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBVkE7Ozs7O0FBWUE7Ozs7Ozs7O0lBUU1DLHNCOzs7Ozs7Ozs7Ozs7O0FBdUJMOzs7Ozs7Ozs7QUF0QkE7Ozs7Ozs7OzJCQThCUztBQUNSLE9BQU16TywwQkFBd0IsS0FBS0MsZUFBTCxFQUE5Qjs7QUFFQSxVQUNDO0FBQUE7QUFBQTtBQUNDLG1CQUFZaGEsWUFBWTZILE9BQVosQ0FBb0J5Z0IsWUFEakM7QUFFQyxxQkFBY3ZPLFNBQVN0UyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FGaEQ7QUFHQyxnQkFBV3NTLFFBSFo7QUFJQyxrQkFBVSwwQkFKWDtBQUtDLGNBQVMsS0FBS2xPLFdBTGY7QUFNQyxlQUFVLEtBQUtwRixLQUFMLENBQVdYLFFBTnRCO0FBT0MsWUFBTzlGLFlBQVk2SCxPQUFaLENBQW9CeWdCLFlBUDVCO0FBUUMsa0NBQUMsb0JBQUQsSUFBWSxRQUFPLGVBQW5CO0FBUkQsSUFERDtBQVlBOztBQWpDRDs7Ozs7Ozs7Ozs7O0VBYm9DbGlCLGdCQUFNUyxTOztBQUFyQzJoQixzQixDQVNFMVYsWSxHQUFlO0FBQ3JCckgsVUFBUztBQURZLEM7QUFUakIrYyxzQixDQXFCRTVoQixHLEdBQU0sa0I7a0JBNEJDLDZCQUNkLG1DQUFvQixrQ0FBbUI0aEIsc0JBQW5CLENBQXBCLENBRGMsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoRWY7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFWQTs7Ozs7QUFZQTs7Ozs7Ozs7SUFRTUMsVzs7Ozs7Ozs7Ozs7OztBQTBCTDs7Ozs7Ozs7O0FBekJBOzs7Ozs7OzsyQkFpQ1M7QUFDUixPQUFNMU8sMEJBQXdCLEtBQUtDLGVBQUwsRUFBOUI7O0FBRUEsVUFDQztBQUFBO0FBQUE7QUFDQyxtQkFBWWhhLFlBQVk2SCxPQUFaLENBQW9CNmdCLEtBRGpDO0FBRUMscUJBQWMzTyxTQUFTdFMsT0FBVCxDQUFpQixTQUFqQixNQUFnQyxDQUFDLENBRmhEO0FBR0MsZ0JBQVdzUyxRQUhaO0FBSUMsa0JBQVUsY0FKWDtBQUtDLGNBQVMsS0FBS2xPLFdBTGY7QUFNQyxlQUFVLEtBQUtwRixLQUFMLENBQVdYLFFBTnRCO0FBT0MsWUFBTzlGLFlBQVk2SCxPQUFaLENBQW9CNmdCLEtBUDVCO0FBUUMsa0NBQUMsb0JBQUQsSUFBWSxRQUFPLGFBQW5CO0FBUkQsSUFERDtBQVlBOztBQWpDRDs7Ozs7Ozs7Ozs7O0VBaEJ5QnRpQixnQkFBTVMsUzs7QUFBMUI0aEIsVyxDQVNFM1YsWSxHQUFlO0FBQ3JCckgsVUFBUyxZQURZO0FBRXJCaUIsUUFBTztBQUNOL0ksV0FBUztBQURIO0FBRmMsQztBQVRqQjhrQixXLENBd0JFN2hCLEcsR0FBTSxPO2tCQTRCQyw2QkFBYyxrQ0FBbUIsMkJBQVk2aEIsV0FBWixDQUFuQixDQUFkLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkVmOzs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFSQTs7Ozs7QUFVQTs7Ozs7O0lBTU1FLGtCOzs7Ozs7Ozs7Ozs7O0FBdUJMOzs7Ozs7Ozs7QUF0QkE7Ozs7Ozs7OzJCQThCUztBQUNSLFVBQ0M7QUFBQTtBQUFBO0FBQ0MsbUJBQVkzb0IsWUFBWTZILE9BQVosQ0FBb0IrZ0IsWUFEakM7QUFFQyxnQkFBVSxXQUZYO0FBR0Msa0JBQVUscUJBSFg7QUFJQyxjQUFTLEtBQUsvYyxXQUpmO0FBS0MsZUFBVSxLQUFLcEYsS0FBTCxDQUFXWCxRQUx0QjtBQU1DLFlBQU85RixZQUFZNkgsT0FBWixDQUFvQitnQixZQU41QjtBQU9DLGtDQUFDLG9CQUFELElBQVksUUFBTyxjQUFuQjtBQVBELElBREQ7QUFXQTs7QUE5QkQ7Ozs7Ozs7Ozs7OztFQWJnQ3hpQixnQkFBTVMsUzs7QUFBakM4aEIsa0IsQ0FTRTdWLFksR0FBZTtBQUNyQnJILFVBQVM7QUFEWSxDO0FBVGpCa2Qsa0IsQ0FxQkUvaEIsRyxHQUFNLGM7a0JBeUJDLDZCQUFjK2hCLGtCQUFkLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekRmOzs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFSQTs7Ozs7QUFVQTs7Ozs7O0lBTU1FLGlCOzs7Ozs7Ozs7Ozs7O0FBT0w7OzsyQkFHUztBQUNSLFVBQ0M7QUFBQTtBQUFBO0FBQ0MsbUJBQVk3b0IsWUFBWTZILE9BQVosQ0FBb0J6QyxXQURqQztBQUVDLHFCQUFjLEtBRmY7QUFHQyxnQkFBVSxXQUhYO0FBSUMsY0FBUyxLQUFLeUcsV0FKZjtBQUtDLFlBQU83TCxZQUFZNkgsT0FBWixDQUFvQnpDLFdBTDVCO0FBTUMsa0NBQUMsb0JBQUQsSUFBWSxRQUFPLGNBQW5CO0FBTkQsSUFERDtBQVVBOzs7O0VBckI4QmdCLGdCQUFNUyxTOztBQUFoQ2dpQixpQixDQUNFL1YsWSxHQUFlO0FBQ3JCckgsVUFBUztBQURZLEM7QUFEakJvZCxpQixDQUtFamlCLEcsR0FBTSxhO2tCQW1CQyw2QkFBY2lpQixpQkFBZCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQ2Y7Ozs7OztBQUVBOzs7QUFHQSxTQUFTQyxlQUFULENBQXlCQyxNQUF6QixFQUFpQztBQUNoQyxTQUFPLHdDQUFNLFdBQVUsY0FBaEIsR0FBUDtBQUNBOztBQUVEOzs7Ozs7OztBQWRBOzs7OztBQXNCQUQsZ0JBQWdCbGlCLEdBQWhCLEdBQXNCLFdBQXRCOztrQkFFZWtpQixlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25CZjs7OztBQUNBOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVZBOzs7OztBQVlBOzs7OztJQUtNRSxhOzs7Ozs7Ozs7Ozs7O0FBOERMOzs7Ozs7MkJBTVM7QUFBQTs7QUFDUixPQUFJQyxnQkFBZ0IsTUFBcEI7O0FBRUEsT0FBTUMsV0FBVyxLQUFLQyxZQUFMLEVBQWpCOztBQUVBRCxZQUFTNVMsT0FBVCxDQUFpQixnQkFBUTtBQUN4QixRQUFJLE9BQUtrQyxZQUFMLENBQWtCM0UsS0FBS25ILEtBQXZCLENBQUosRUFBbUM7QUFDbEN1YyxxQkFBZ0JwVixLQUFLOUgsSUFBckI7QUFDQTtBQUNELElBSkQ7O0FBTFEsZ0JBVzZDLEtBQUt0RixLQVhsRDtBQUFBLE9BV0Q1SSxNQVhDLFVBV0RBLE1BWEM7QUFBQSxPQVdPb1YsUUFYUCxVQVdPQSxRQVhQO0FBQUEsT0FXaUJuTixRQVhqQixVQVdpQkEsUUFYakI7QUFBQSxPQVcyQnNOLGNBWDNCLFVBVzJCQSxjQVgzQjs7O0FBYVIsT0FBTXFGLG9CQUFvQjtBQUN6QkMsaUJBQWF1USxhQURZO0FBRXpCcHJCLGtCQUZ5QjtBQUd6Qm9YLGVBQVc3QixjQUhjO0FBSXpCdUYsMEJBQXNCLEtBSkc7QUFLekI1UyxZQUFRbWpCO0FBTGlCLElBQTFCOztBQVFBLFVBQ0M7QUFBQTtBQUFBLE1BQUssV0FBVSwwREFBZjtBQUNDO0FBQUE7QUFBQTtBQUNDLHVCQUFlalcsUUFEaEI7QUFFQyxpQkFBVSxvQkFGWDtBQUdDLGVBQVNHLGNBSFY7QUFJQyxZQUFLLFVBSk47QUFLQyxnQkFBVXROLFFBTFg7QUFNQztBQUFBO0FBQUE7QUFDQyxvQ0FBQyxvQkFBRCxJQUFZLFFBQU8sV0FBbkIsR0FERDtBQUFBO0FBR0VtakI7QUFIRjtBQU5ELEtBREQ7QUFhRWhXLGdCQUFZLDhCQUFDLDBCQUFELEVBQXNCd0YsaUJBQXRCO0FBYmQsSUFERDtBQWlCQTs7OzhCQUVXcFYsUyxFQUFXO0FBQUE7O0FBQ3RCLE9BQU14RixTQUFTLEtBQUs4SSxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFmOztBQUVBLE9BQU1pYixjQUFjO0FBQ25CalYsYUFBUyxLQURVO0FBRW5CZixnQkFBWTtBQUNYMFYsWUFBT2pWO0FBREk7QUFGTyxJQUFwQjs7QUFPQSxPQUFNcUosUUFBUSxJQUFJNU8sU0FBUzRPLEtBQWIsQ0FBbUJrTSxXQUFuQixDQUFkOztBQUVBL2EsVUFBT29ELFlBQVAsR0FBc0JtSyxJQUF0Qjs7QUFFQSxRQUFLK2QsWUFBTCxHQUFvQjdTLE9BQXBCLENBQTRCLGdCQUFRO0FBQ25DLFFBQUksT0FBS2tDLFlBQUwsQ0FBa0IzRSxLQUFLbkgsS0FBdkIsQ0FBSixFQUFtQztBQUNsQzdPLFlBQU93TixXQUFQLENBQW1CLElBQUl2TixTQUFTNE8sS0FBYixDQUFtQm1ILEtBQUtuSCxLQUF4QixDQUFuQjtBQUNBO0FBQ0QsSUFKRDs7QUFNQTdPLFVBQU9vTixVQUFQLENBQWtCeUIsS0FBbEI7O0FBRUE3TyxVQUFPb0QsWUFBUCxHQUFzQnFLLE1BQXRCOztBQUVBek4sVUFBT3VFLElBQVAsQ0FBWSxpQkFBWixFQUErQixJQUEvQjtBQUNBOztBQUVEOzs7Ozs7Ozs7Ozs7OytCQVVhd1csVyxFQUFhO0FBQ3pCLE9BQU1qWSxlQUFlLEtBQUtnRyxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFyQjs7QUFFQSxPQUFJeXJCLFNBQVMsSUFBYjs7QUFFQSxPQUFNN21CLGNBQWM1QixhQUFhNEIsV0FBYixFQUFwQjs7QUFFQSxPQUFJQSxlQUFlQSxZQUFZRyxXQUEvQixFQUE0QztBQUMzQ2tXLGdCQUFZaFcsVUFBWixDQUF1QjBWLEtBQXZCLENBQTZCM0wsS0FBN0IsQ0FBbUMsR0FBbkMsRUFBd0MySixPQUF4QyxDQUFnRCxxQkFBYTtBQUM1RDhTLGNBQVNBLFVBQVU3bUIsWUFBWUcsV0FBWixDQUF3QnFOLFFBQXhCLENBQWlDMU0sU0FBakMsQ0FBbkI7QUFDQSxLQUZEO0FBR0EsSUFKRCxNQUlPO0FBQ04rbEIsYUFBUyxLQUFUO0FBQ0E7O0FBRUQsVUFBT0EsTUFBUDtBQUNBOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7O2lDQWFlO0FBQ2QsVUFDQyxLQUFLM2lCLEtBQUwsQ0FBV1YsTUFBWCxJQUFxQixDQUNwQjtBQUNDZ0csVUFBTSxNQURQO0FBRUNXLFdBQU87QUFDTi9JLGNBQVMsS0FESDtBQUVOZixpQkFBWTtBQUNYMFYsYUFBTztBQURJLE1BRk47QUFLTnZULFdBQU07QUFMQSxLQUZSO0FBU0M4VCxhQUFTLEtBQUtDLFdBQUwsQ0FBaUIzWSxJQUFqQixDQUFzQixJQUF0QixFQUE0QixFQUE1QjtBQVRWLElBRG9CLEVBWXBCO0FBQ0M0TCxVQUFNLE1BRFA7QUFFQ1csV0FBTztBQUNOL0ksY0FBUyxLQURIO0FBRU5mLGlCQUFZO0FBQ1gwVixhQUFPO0FBREksTUFGTjtBQUtOdlQsV0FBTTtBQUxBLEtBRlI7QUFTQzhULGFBQVMsS0FBS0MsV0FBTCxDQUFpQjNZLElBQWpCLENBQXNCLElBQXRCLEVBQTRCLFdBQTVCO0FBVFYsSUFab0IsRUF1QnBCO0FBQ0M0TCxVQUFNLE1BRFA7QUFFQ1csV0FBTztBQUNOL0ksY0FBUyxLQURIO0FBRU5mLGlCQUFZO0FBQ1gwVixhQUFPO0FBREksTUFGTjtBQUtOdlQsV0FBTTtBQUxBLEtBRlI7QUFTQzhULGFBQVMsS0FBS0MsV0FBTCxDQUFpQjNZLElBQWpCLENBQXNCLElBQXRCLEVBQTRCLFdBQTVCO0FBVFYsSUF2Qm9CLEVBa0NwQjtBQUNDNEwsVUFBTSxNQURQO0FBRUNXLFdBQU87QUFDTi9JLGNBQVMsS0FESDtBQUVOZixpQkFBWTtBQUNYMFYsYUFBTztBQURJLE1BRk47QUFLTnZULFdBQU07QUFMQSxLQUZSO0FBU0M4VCxhQUFTLEtBQUtDLFdBQUwsQ0FBaUIzWSxJQUFqQixDQUFzQixJQUF0QixFQUE0QixXQUE1QjtBQVRWLElBbENvQixFQTZDcEI7QUFDQzRMLFVBQU0sTUFEUDtBQUVDVyxXQUFPO0FBQ04vSSxjQUFTLEtBREg7QUFFTmYsaUJBQVk7QUFDWDBWLGFBQU87QUFESSxNQUZOO0FBS052VCxXQUFNO0FBTEEsS0FGUjtBQVNDOFQsYUFBUyxLQUFLQyxXQUFMLENBQWlCM1ksSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEIsV0FBNUI7QUFUVixJQTdDb0IsRUF3RHBCO0FBQ0M0TCxVQUFNLE1BRFA7QUFFQ1csV0FBTztBQUNOL0ksY0FBUyxLQURIO0FBRU5mLGlCQUFZO0FBQ1gwVixhQUFPO0FBREksTUFGTjtBQUtOdlQsV0FBTTtBQUxBLEtBRlI7QUFTQzhULGFBQVMsS0FBS0MsV0FBTCxDQUFpQjNZLElBQWpCLENBQXNCLElBQXRCLEVBQTRCLFdBQTVCO0FBVFYsSUF4RG9CLENBRHRCO0FBc0VBOzs7O0VBdlAwQmlHLGdCQUFNUyxTOztBQUE1Qm1pQixhLENBQ0V4ZCxXLEdBQWNyRix1QjtBQURoQjZpQixhLENBR0VwaUIsRyxHQUFNLFM7QUFIUm9pQixhLENBS0UzUCxTLEdBQVk7QUFDbEI7Ozs7Ozs7QUFPQXBHLFdBQVVxRyxvQkFBVUMsSUFSRjs7QUFVbEI7Ozs7Ozs7QUFPQUMsUUFBT0Ysb0JBQVVHLE1BakJDOztBQW1CbEI7Ozs7Ozs7QUFPQWQsdUJBQXNCVyxvQkFBVUMsSUExQmQ7O0FBNEJsQjs7Ozs7OztBQU9BeFQsU0FBUXVULG9CQUFVSSxPQUFWLENBQWtCSixvQkFBVUssTUFBNUIsQ0FuQ1U7O0FBcUNsQjs7Ozs7Ozs7QUFRQTdULFdBQVV3VCxvQkFBVU0sTUE3Q0Y7O0FBK0NsQjs7Ozs7OztBQU9BeEcsaUJBQWdCa0csb0JBQVVPO0FBdERSLEM7a0JBcVBMbVAsYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0UWY7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFWQTs7Ozs7QUFZQTs7Ozs7Ozs7SUFRTUssWTs7Ozs7Ozs7Ozs7OztBQXdCTDs7Ozs7Ozs7QUF2QkE7Ozs7Ozs7OzJCQThCUztBQUNSLE9BQU10UCwwQkFBd0IsS0FBS0MsZUFBTCxFQUE5Qjs7QUFFQSxVQUNDO0FBQUE7QUFBQTtBQUNDLG1CQUFZaGEsWUFBWTZILE9BQVosQ0FBb0J5aEIsTUFEakM7QUFFQyxxQkFBY3ZQLFNBQVN0UyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FGaEQ7QUFHQyxnQkFBV3NTLFFBSFo7QUFJQyxrQkFBVSxlQUpYO0FBS0MsY0FBUyxLQUFLbE8sV0FMZjtBQU1DLGVBQVUsS0FBS3BGLEtBQUwsQ0FBV1gsUUFOdEI7QUFPQyxZQUFPOUYsWUFBWTZILE9BQVosQ0FBb0J5aEIsTUFQNUI7QUFRQyxrQ0FBQyxvQkFBRCxJQUFZLFFBQU8sZUFBbkI7QUFSRCxJQUREO0FBWUE7O0FBaENEOzs7Ozs7Ozs7Ozs7RUFkMEJsakIsZ0JBQU1TLFM7O0FBQTNCd2lCLFksQ0FTRXZXLFksR0FBZTtBQUNyQnJILFVBQVMsUUFEWTtBQUVyQmlCLFFBQU87QUFGYyxDO0FBVGpCMmMsWSxDQXNCRXppQixHLEdBQU0sUTtrQkEyQkMsNkJBQWMsa0NBQW1CLDJCQUFZeWlCLFlBQVosQ0FBbkIsQ0FBZCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hFZjs7Ozs7Ozs7OzsrZUFMQTs7Ozs7QUFPQTs7Ozs7SUFLTUUsdUI7Ozs7Ozs7Ozs7Ozs7QUFHTDs7Ozs7Ozs7MkJBUVM7QUFDUixPQUFJLEtBQUs5aUIsS0FBTCxDQUFXVixNQUFYLElBQXFCLEtBQUtVLEtBQUwsQ0FBV1YsTUFBWCxDQUFrQnJHLE1BQTNDLEVBQW1EO0FBQ2xELFdBQU87QUFBQTtBQUFBLE9BQU0sV0FBVSxnQkFBaEI7QUFBa0MsVUFBSytHLEtBQUwsQ0FBV3NGO0FBQTdDLEtBQVA7QUFDQSxJQUZELE1BRU87QUFDTixXQUFPLElBQVA7QUFDQTtBQUNEOzs7O0VBakJvQzNGLGdCQUFNUyxTOztBQUF0QzBpQix1QixDQUNFM2lCLEcsR0FBTSx3QjtrQkFtQkMyaUIsdUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0JmOzs7O0FBRUE7Ozs7Ozs7Ozs7K2VBUEE7Ozs7O0FBU0E7Ozs7OztJQU1NQywwQjs7Ozs7Ozs7Ozs7Ozs7NE5Bc0RMQyxhLEdBQWdCLFlBQU07QUFDckIsT0FBTTVyQixTQUFTLE1BQUs4SSxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFmOztBQUVBRSxVQUFPZ08sV0FBUCxDQUFtQixjQUFuQjs7QUFFQSxTQUFLcEYsS0FBTCxDQUFXaWpCLFlBQVgsQ0FBd0JwVCxPQUF4QixDQUFnQyxxQkFBYTtBQUM1QyxRQUFNcVQsYUFBYSxJQUFJN3JCLFNBQVM0TyxLQUFiLENBQW1CLEVBQUMvSSxTQUFTaW1CLFNBQVYsRUFBbkIsQ0FBbkI7O0FBRUEvckIsV0FBT3dOLFdBQVAsQ0FBbUJzZSxVQUFuQjtBQUNBLElBSkQ7O0FBTUE5ckIsVUFBT3VFLElBQVAsQ0FBWSxpQkFBWjtBQUNBLEc7OztBQS9ERDs7Ozs7Ozs7OztBQVlBOzs7Ozs7Ozs7Ozs7OztBQVVBOzs7Ozs7OzsyQkFRUztBQUNSLFVBQ0M7QUFBQTtBQUFBLE1BQUksTUFBSyxRQUFUO0FBQ0M7QUFBQTtBQUFBO0FBQ0MsaUJBQVUsb0JBRFg7QUFFQyxlQUFTLEtBQUtxbkIsYUFGZjtBQUdDLGdCQUFVLEtBQUtoakIsS0FBTCxDQUFXWCxRQUh0QjtBQUlFOUYsaUJBQVk2SCxPQUFaLENBQW9Cb1E7QUFKdEI7QUFERCxJQUREO0FBVUE7O0FBRUQ7Ozs7Ozs7Ozs7OztFQTlDd0M3UixnQkFBTVMsUzs7QUFBekMyaUIsMEIsQ0FDRWhlLFcsR0FBY3JGLHVCO0FBRGhCcWpCLDBCLENBV0UxVyxZLEdBQWU7QUFDckI0VyxlQUFjLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLEVBQStCLElBQS9CLEVBQXFDLEtBQXJDO0FBRE8sQztBQVhqQkYsMEIsQ0F1QkU1aUIsRyxHQUFNLDRCO2tCQThDQzRpQiwwQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvRWY7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBVEE7Ozs7O0FBV0E7Ozs7Ozs7O0lBUU1LLG9COzs7Ozs7Ozs7Ozs7OztnTkF1RUxDLFEsR0FBVyxZQUFNO0FBQ2hCLE9BQUksTUFBS3JqQixLQUFMLENBQVdvUyxPQUFmLEVBQXdCO0FBQ3ZCLFVBQUtwUyxLQUFMLENBQVdvUyxPQUFYO0FBQ0EsSUFGRCxNQUVPO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBS2xTLE9BQUwsQ0FBYTlJLE1BQWIsQ0FBb0JGLEdBQXBCLENBQXdCLGNBQXhCLEVBQXdDa08sV0FBeEMsQ0FBb0QsY0FBcEQ7O0FBRUEsVUFBS1osVUFBTDtBQUNBO0FBQ0QsRzs7O0FBL0VEOzs7Ozs7Ozs7Ozs7OztBQVVBOzs7Ozs7O3VDQU9xQjtBQUNwQjtBQUNBO0FBQ0EsT0FBSThlLFdBQVc7QUFDZHBtQixhQUFTLE1BREs7QUFFZG9DLFlBQVE7QUFDUGlrQixhQUFRO0FBREQ7QUFGTSxJQUFmOztBQU9BRCxjQUFXanNCLFNBQVN5TyxLQUFULENBQWVDLEtBQWYsQ0FBcUJ1ZCxRQUFyQixFQUErQixLQUFLdGpCLEtBQUwsQ0FBV2lHLEtBQTFDLENBQVg7O0FBRUEsUUFBS3VkLFFBQUwsR0FBZ0IsSUFBSW5zQixTQUFTNE8sS0FBYixDQUFtQnFkLFFBQW5CLEVBQTZCRyxZQUE3QixDQUNmLEtBQUt6akIsS0FBTCxDQUFXc0YsSUFESSxDQUFoQjtBQUdBOztBQUVEOzs7Ozs7Ozs7OzsyQkFRUztBQUNSO0FBQ0E7QUFDQSxPQUFNMUksWUFDTCxLQUFLb0QsS0FBTCxDQUFXc0YsSUFBWCxLQUFvQixLQUFLdEYsS0FBTCxDQUFXaVMsV0FBL0IsR0FDRywyQkFESCxHQUVHLG9CQUhKOztBQUtBLFVBQ0M7QUFDQyxlQUFXclYsU0FEWjtBQUVDLDZCQUF5QixFQUFDOG1CLFFBQVEsS0FBS0YsUUFBZCxFQUYxQjtBQUdDLGFBQVMsS0FBS0gsUUFIZjtBQUlDLGNBQVUsS0FBS3JqQixLQUFMLENBQVdYO0FBSnRCLEtBREQ7QUFRQTs7QUFFRDs7Ozs7Ozs7Ozs7O0VBL0RrQ00sZ0JBQU1TLFM7O0FBQW5DZ2pCLG9CLENBQ0VyZSxXLEdBQWNyRix1QjtBQURoQjBqQixvQixDQVdFampCLEcsR0FBTSxzQjtrQkEwRUMsaUNBQWtCLDJCQUFZaWpCLG9CQUFaLENBQWxCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkdmOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVpBOzs7OztBQWNBOzs7Ozs7O0lBT01PLGdCOzs7Ozs7Ozs7Ozs7O0FBZ0NMOzs7Ozs7Ozs7O0FBL0JBOzs7Ozs7OztzQ0F3Q29CO0FBQ25CN3BCLHNCQUFTa1AsV0FBVCxDQUFxQixJQUFyQixFQUEyQitELEtBQTNCO0FBQ0E7O0FBRUQ7Ozs7Ozs7OztBQXZCQTs7Ozs7Ozs7Ozs7dUNBOEJxQjtBQUNwQixPQUFNNlcsY0FBYyxFQUFwQjtBQUNBLE9BQU1DLGVBQWUsRUFBckI7QUFDQSxPQUFNQyxlQUFlLEVBQXJCOztBQUVBLFFBQUs5akIsS0FBTCxDQUFXVixNQUFYLENBQWtCdVEsT0FBbEIsQ0FBMEIsZ0JBQVE7QUFDakMsUUFBTTVKLFFBQVEsSUFBSTVPLFNBQVM0TyxLQUFiLENBQW1CbUgsS0FBS25ILEtBQXhCLENBQWQ7O0FBRUEsUUFBSUEsTUFBTTNILElBQU4sS0FBZWpILFNBQVMwc0IsV0FBNUIsRUFBeUM7QUFDeENILGlCQUFZNWdCLElBQVosQ0FBaUJvSyxJQUFqQjtBQUNBLEtBRkQsTUFFTyxJQUFJbkgsTUFBTTNILElBQU4sS0FBZWpILFNBQVMyc0IsWUFBNUIsRUFBMEM7QUFDaERILGtCQUFhN2dCLElBQWIsQ0FBa0JvSyxJQUFsQjtBQUNBLEtBRk0sTUFFQSxJQUFJbkgsTUFBTTNILElBQU4sS0FBZWpILFNBQVM0c0IsWUFBNUIsRUFBMEM7QUFDaERILGtCQUFhOWdCLElBQWIsQ0FBa0JvSyxJQUFsQjtBQUNBO0FBQ0QsSUFWRDs7QUFZQSxRQUFLOFcsWUFBTCxHQUFvQk4sV0FBcEI7QUFDQSxRQUFLTyxhQUFMLEdBQXFCTixZQUFyQjtBQUNBLFFBQUtPLGFBQUwsR0FBcUJOLFlBQXJCO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7OzJCQVFTO0FBQ1IsT0FBSU8seUJBQUo7O0FBRUEsT0FBSSxLQUFLcmtCLEtBQUwsQ0FBV2tTLG9CQUFmLEVBQXFDO0FBQ3BDbVMsdUJBQ0MsOEJBQUMsb0NBQUQ7QUFDQyxnQkFBVyxLQUFLcmtCLEtBQUwsQ0FBVzJNO0FBRHZCLE1BREQ7QUFLQTs7QUFFRCxVQUNDO0FBQUMsNEJBQUQ7QUFBb0IsU0FBSzNNLEtBQXpCO0FBQ0Vxa0Isb0JBREY7QUFHQyxrQ0FBQyxnQ0FBRDtBQUNDLFdBQU05cUIsWUFBWTZILE9BQVosQ0FBb0J3aUIsV0FEM0I7QUFFQyxhQUFRLEtBQUtNO0FBRmQsTUFIRDtBQU9FLFNBQUtJLGtCQUFMLENBQXdCLEtBQUtKLFlBQTdCLENBUEY7QUFTQyxrQ0FBQyxnQ0FBRDtBQUNDLFdBQU0zcUIsWUFBWTZILE9BQVosQ0FBb0J5aUIsWUFEM0I7QUFFQyxhQUFRLEtBQUtNO0FBRmQsTUFURDtBQWFFLFNBQUtHLGtCQUFMLENBQXdCLEtBQUtILGFBQTdCLENBYkY7QUFlQyxrQ0FBQyxnQ0FBRDtBQUNDLFdBQU01cUIsWUFBWTZILE9BQVosQ0FBb0IwaUIsWUFEM0I7QUFFQyxhQUFRLEtBQUtNO0FBRmQsTUFmRDtBQW1CRSxTQUFLRSxrQkFBTCxDQUF3QixLQUFLRixhQUE3QjtBQW5CRixJQUREO0FBdUJBOztBQUVEOzs7Ozs7Ozs7Ozs7O3FDQVVtQjlrQixNLEVBQVE7QUFBQTs7QUFDMUIsT0FBSTZOLGNBQUo7O0FBRUEsT0FBSTdOLFVBQVVBLE9BQU9yRyxNQUFyQixFQUE2QjtBQUM1QmtVLFlBQVE3TixPQUFPd00sR0FBUCxDQUFXLGdCQUFRO0FBQzFCLFlBQ0M7QUFBQTtBQUFBLFFBQUksS0FBS3NCLEtBQUs5SCxJQUFkLEVBQW9CLE1BQUssUUFBekI7QUFDQyxvQ0FBQyw4QkFBRDtBQUNDLG9CQUFhLE9BQUt0RixLQUFMLENBQVdpUyxXQUR6QjtBQUVDLGFBQU03RSxLQUFLOUgsSUFGWjtBQUdDLGNBQU84SCxLQUFLbkgsS0FIYjtBQUlDLGdCQUFTbUgsS0FBS2dGO0FBSmY7QUFERCxNQUREO0FBVUEsS0FYTyxDQUFSO0FBWUE7O0FBRUQsVUFBT2pGLEtBQVA7QUFDQTs7OztFQW5KNkJ4TixnQkFBTVMsUzs7QUFBL0J1akIsZ0IsQ0FTRXRYLFksR0FBZTtBQUNyQjhDLFdBQVUsS0FEVztBQUVyQk0sY0FBYSxxQkFGUTtBQUdyQjFXLE9BQU07QUFDTDhWLFdBQVMsQ0FBQyxFQUFELENBREo7QUFFTEksZUFBYSxDQUFDLEVBQUQsQ0FGUjtBQUdMQyxlQUFhLENBQUMsRUFBRCxDQUhSO0FBSUxFLFFBQU0sQ0FBQyxFQUFELENBSkQ7QUFLTEMsUUFBTSxDQUFDLEVBQUQ7QUFMRCxFQUhlO0FBVXJCNkMsdUJBQXNCO0FBVkQsQztBQVRqQnlSLGdCLENBOEJFeGpCLEcsR0FBTSxrQjtrQkF3SEMsa0NBQW1Cd2pCLGdCQUFuQixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RLZjs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFUQTs7Ozs7QUFXQTs7Ozs7OztJQU9NWSxZOzs7Ozs7Ozs7Ozs7O0FBYUw7Ozs7Ozs7OzJCQVFTO0FBQUE7O0FBQ1IsT0FBSXRTLGNBQWMxWSxZQUFZNkgsT0FBWixDQUFvQm9RLE1BQXRDOztBQUVBLE9BQU1sUyxTQUFTLEtBQUtrbEIsVUFBTCxFQUFmOztBQUVBbGxCLFVBQU91USxPQUFQLENBQWUsZ0JBQVE7QUFDdEIsUUFBSSxPQUFLa0MsWUFBTCxDQUFrQjNFLEtBQUtuSCxLQUF2QixDQUFKLEVBQW1DO0FBQ2xDZ00sbUJBQWM3RSxLQUFLOUgsSUFBbkI7QUFDQTtBQUNELElBSkQ7O0FBTUEsT0FBSW1mLHlCQUFKOztBQUVBLE9BQUksS0FBS3prQixLQUFMLENBQVd3TSxRQUFmLEVBQXlCO0FBQ3hCaVksdUJBQ0MsOEJBQUMsMEJBQUQ7QUFDQyxrQkFBYXhTLFdBRGQ7QUFFQyxnQkFBVyxLQUFLalMsS0FBTCxDQUFXMk0sY0FGdkI7QUFHQywyQkFBc0IsS0FBSzNNLEtBQUwsQ0FBV2tTLG9CQUhsQztBQUlDLGFBQVE1UztBQUpULE1BREQ7QUFRQTs7QUFFRCxVQUNDO0FBQUE7QUFBQSxNQUFLLFdBQVUsdUNBQWY7QUFDQztBQUFBO0FBQUE7QUFDQyx1QkFBZSxLQUFLVSxLQUFMLENBQVd3TSxRQUQzQjtBQUVDLG9CQUFZalQsWUFBWTZILE9BQVosQ0FBb0I5QixNQUFwQixHQUE2QixHQUE3QixHQUFtQzJTLFdBRmhEO0FBR0MsaUJBQVUsb0JBSFg7QUFJQyxlQUFTLEtBQUtqUyxLQUFMLENBQVcyTSxjQUpyQjtBQUtDLFlBQUssVUFMTjtBQU1DLGdCQUFVLEtBQUszTSxLQUFMLENBQVdYLFFBTnRCO0FBT0MsYUFBTzlGLFlBQVk2SCxPQUFaLENBQW9COUIsTUFBcEIsR0FBNkIsR0FBN0IsR0FBbUMyUyxXQVAzQztBQVFDO0FBQUE7QUFBQSxRQUFLLFdBQVUsY0FBZjtBQUNDO0FBQUE7QUFBQSxTQUFNLFdBQVUscUNBQWhCO0FBQ0VBO0FBREYsT0FERDtBQUlDLG9DQUFDLG9CQUFELElBQVksUUFBTyxjQUFuQjtBQUpEO0FBUkQsS0FERDtBQWdCRXdTO0FBaEJGLElBREQ7QUFvQkE7O0FBRUQ7Ozs7Ozs7Ozs7OztBQWhFQTs7Ozs7Ozs7Ozs7K0JBMEVhdFMsVyxFQUFhO0FBQ3pCLE9BQU1qWSxlQUFlLEtBQUtnRyxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFyQjs7QUFFQTtBQUNBO0FBQ0FpYixpQkFBYzlhLFNBQVN5TyxLQUFULENBQWVDLEtBQWYsQ0FBcUIsRUFBQzdJLFNBQVMsTUFBVixFQUFyQixFQUF3Q2lWLFdBQXhDLENBQWQ7O0FBRUEsT0FBTWxNLFFBQVEsSUFBSTVPLFNBQVM0TyxLQUFiLENBQW1Ca00sV0FBbkIsQ0FBZDs7QUFFQSxVQUFPbE0sTUFBTU0sV0FBTixDQUFrQnJNLGFBQWE0QixXQUFiLEVBQWxCLEVBQThDNUIsWUFBOUMsQ0FBUDtBQUNBOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7K0JBWWE7QUFDWixVQUNDLEtBQUs4RixLQUFMLENBQVdWLE1BQVgsSUFBcUIsQ0FDcEI7QUFDQ2dHLFVBQU0vTCxZQUFZNkgsT0FBWixDQUFvQjJZLEVBRDNCO0FBRUM5VCxXQUFPO0FBQ04vSSxjQUFTO0FBREg7QUFGUixJQURvQixFQU9wQjtBQUNDb0ksVUFBTS9MLFlBQVk2SCxPQUFaLENBQW9CNlksRUFEM0I7QUFFQ2hVLFdBQU87QUFDTi9JLGNBQVM7QUFESDtBQUZSLElBUG9CLEVBYXBCO0FBQ0NvSSxVQUFNL0wsWUFBWTZILE9BQVosQ0FBb0JzakIsU0FEM0I7QUFFQ3plLFdBQU87QUFDTi9JLGNBQVM7QUFESDtBQUZSLElBYm9CLEVBbUJwQjtBQUNDb0ksVUFBTS9MLFlBQVk2SCxPQUFaLENBQW9CdWpCLElBRDNCO0FBRUMxZSxXQUFPO0FBQ04vSSxjQUFTO0FBREg7QUFGUixJQW5Cb0IsRUF5QnBCO0FBQ0NvSSxVQUFNL0wsWUFBWTZILE9BQVosQ0FBb0JpVixJQUQzQjtBQUVDcFEsV0FBTztBQUNOL0ksY0FBUztBQURIO0FBRlIsSUF6Qm9CLENBRHRCO0FBa0NBOzs7O0VBeEl5QnlDLGdCQUFNUyxTOztBQUEzQm1rQixZLENBQ0V4ZixXLEdBQWNyRix1QjtBQURoQjZrQixZLENBV0Vwa0IsRyxHQUFNLFE7a0JBZ0lDb2tCLFk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEpmOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBVkE7Ozs7O0FBWUE7Ozs7Ozs7OztJQVNNSyxlOzs7Ozs7Ozs7Ozs7O0FBd0JMOzs7Ozs7Ozs7QUF2QkE7Ozs7Ozs7OzJCQStCUztBQUNSLE9BQU10UiwwQkFBd0IsS0FBS0MsZUFBTCxFQUE5Qjs7QUFFQSxVQUNDO0FBQUE7QUFBQTtBQUNDLG1CQUFZaGEsWUFBWTZILE9BQVosQ0FBb0J5akIsU0FEakM7QUFFQyxxQkFBY3ZSLFNBQVN0UyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FGaEQ7QUFHQyxnQkFBV3NTLFFBSFo7QUFJQyxrQkFBVSxrQkFKWDtBQUtDLGNBQVMsS0FBS2xPLFdBTGY7QUFNQyxlQUFVLEtBQUtwRixLQUFMLENBQVdYLFFBTnRCO0FBT0MsWUFBTzlGLFlBQVk2SCxPQUFaLENBQW9CeWpCLFNBUDVCO0FBUUMsa0NBQUMsb0JBQUQsSUFBWSxRQUFPLFdBQW5CO0FBUkQsSUFERDtBQVlBOztBQWpDRDs7Ozs7Ozs7Ozs7O0VBZDZCbGxCLGdCQUFNUyxTOztBQUE5QndrQixlLENBU0V2WSxZLEdBQWU7QUFDckJySCxVQUFTLFdBRFk7QUFFckJpQixRQUFPO0FBRmMsQztBQVRqQjJlLGUsQ0FzQkV6a0IsRyxHQUFNLFc7a0JBNEJDLDZCQUFjLGtDQUFtQiwyQkFBWXlrQixlQUFaLENBQW5CLENBQWQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRWY7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFWQTs7Ozs7QUFZQTs7Ozs7Ozs7O0lBU01FLGlCOzs7Ozs7Ozs7Ozs7O0FBd0JMOzs7Ozs7Ozs7QUF2QkE7Ozs7Ozs7OzJCQStCUztBQUNSLE9BQU14UiwwQkFBd0IsS0FBS0MsZUFBTCxFQUE5Qjs7QUFFQSxVQUNDO0FBQUE7QUFBQTtBQUNDLG1CQUFZaGEsWUFBWTZILE9BQVosQ0FBb0IyakIsV0FEakM7QUFFQyxxQkFBY3pSLFNBQVN0UyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FGaEQ7QUFHQyxnQkFBV3NTLFFBSFo7QUFJQyxrQkFBVSxvQkFKWDtBQUtDLGNBQVMsS0FBS2xPLFdBTGY7QUFNQyxlQUFVLEtBQUtwRixLQUFMLENBQVdYLFFBTnRCO0FBT0MsWUFBTzlGLFlBQVk2SCxPQUFaLENBQW9CMmpCLFdBUDVCO0FBUUMsa0NBQUMsb0JBQUQsSUFBWSxRQUFPLGFBQW5CO0FBUkQsSUFERDtBQVlBOztBQWpDRDs7Ozs7Ozs7Ozs7O0VBZCtCcGxCLGdCQUFNUyxTOztBQUFoQzBrQixpQixDQVNFelksWSxHQUFlO0FBQ3JCckgsVUFBUyxhQURZO0FBRXJCaUIsUUFBTztBQUZjLEM7QUFUakI2ZSxpQixDQXNCRTNrQixHLEdBQU0sYTtrQkE0QkMsNkJBQ2Qsa0NBQW1CLDJCQUFZMmtCLGlCQUFaLENBQW5CLENBRGMsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRWY7Ozs7QUFFQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVJBOzs7OztBQVVBOzs7OztJQUtNRSxlOzs7Ozs7Ozs7Ozs7O0FBV0w7Ozs7Ozs7OzJCQVFTO0FBQ1IsT0FBSTNELDJCQUFKO0FBQ0EsT0FBSUMsNkJBQUo7O0FBRUEsT0FBSSxLQUFLdGhCLEtBQUwsQ0FBV3dNLFFBQWYsRUFBeUI7QUFDeEI4VSwyQkFBdUIwRCxnQkFBZ0I3a0IsR0FBaEIsR0FBc0IsTUFBN0M7QUFDQWtoQix5QkFDQyw4QkFBQyw0QkFBRDtBQUNDLGVBQVUsS0FBS0UsWUFBTCxFQURYO0FBRUMsYUFBUUQsb0JBRlQ7QUFHQyxnQkFBVyxLQUFLdGhCLEtBQUwsQ0FBVzJNO0FBSHZCLE1BREQ7QUFPQTs7QUFFRCxVQUNDO0FBQUE7QUFBQSxNQUFLLFdBQVUsOEJBQWY7QUFDQztBQUFBO0FBQUE7QUFDQyx1QkFBZSxLQUFLM00sS0FBTCxDQUFXd00sUUFEM0I7QUFFQyxvQkFBWWpULFlBQVk2SCxPQUFaLENBQW9CNmpCLElBRmpDO0FBR0MsbUJBQVczRCxvQkFIWjtBQUlDLGlCQUFVLFdBSlg7QUFLQyxlQUFTLEtBQUt0aEIsS0FBTCxDQUFXMk0sY0FMckI7QUFNQyxnQkFBVSxLQUFLM00sS0FBTCxDQUFXWCxRQU50QjtBQU9DLGFBQU85RixZQUFZNkgsT0FBWixDQUFvQjZqQixJQVA1QjtBQVFDLG1DQUFDLG9CQUFELElBQVksUUFBTyxVQUFuQjtBQVJELEtBREQ7QUFXRTVEO0FBWEYsSUFERDtBQWVBOztBQUVEOzs7Ozs7Ozs7OztBQWxEQTs7Ozs7Ozs7Ozs7aUNBNERlO0FBQ2QsVUFDQyxLQUFLcmhCLEtBQUwsQ0FBVzdHLFFBQVgsSUFBdUIsQ0FDdEI7QUFDQzZMLGFBQVMsa0JBRFY7QUFFQytOLFdBQU94WixZQUFZNkgsT0FBWixDQUFvQjhqQjtBQUY1QixJQURzQixFQUt0QjtBQUNDbGdCLGFBQVMsaUJBRFY7QUFFQytOLFdBQU94WixZQUFZNkgsT0FBWixDQUFvQitqQjtBQUY1QixJQUxzQixFQVN0QjtBQUNDbmdCLGFBQVMsWUFEVjtBQUVDK04sV0FBT3haLFlBQVk2SCxPQUFaLENBQW9CZ2tCO0FBRjVCLElBVHNCLEVBYXRCO0FBQ0NwZ0IsYUFBUyxXQURWO0FBRUMrTixXQUFPeFosWUFBWTZILE9BQVosQ0FBb0Jpa0I7QUFGNUIsSUFic0IsRUFpQnRCO0FBQ0NyZ0IsYUFBUyxlQURWO0FBRUMrTixXQUFPeFosWUFBWTZILE9BQVosQ0FBb0Jra0I7QUFGNUIsSUFqQnNCLEVBcUJ0QjtBQUNDdGdCLGFBQVMsZ0JBRFY7QUFFQytOLFdBQU94WixZQUFZNkgsT0FBWixDQUFvQm1rQjtBQUY1QixJQXJCc0IsRUF5QnRCO0FBQ0N2Z0IsYUFBUyxxQkFEVjtBQUVDK04sV0FBT3haLFlBQVk2SCxPQUFaLENBQW9Cb2tCO0FBRjVCLElBekJzQixFQTZCdEI7QUFDQ3hnQixhQUFTLG1CQURWO0FBRUMrTixXQUFPeFosWUFBWTZILE9BQVosQ0FBb0Jxa0I7QUFGNUIsSUE3QnNCLENBRHhCO0FBb0NBOzs7O0VBbEc0QjlsQixnQkFBTVMsUzs7QUFBOUI0a0IsZSxDQVNFN2tCLEcsR0FBTSxXO2tCQTRGQzZrQixlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9HZjs7OztBQUVBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBUkE7Ozs7O0FBVUE7Ozs7O0lBS01VLGlCOzs7Ozs7Ozs7Ozs7O0FBV0w7Ozs7Ozs7OzJCQVFTO0FBQ1IsT0FBSXJFLDJCQUFKO0FBQ0EsT0FBSUMsNkJBQUo7O0FBRUEsT0FBSSxLQUFLdGhCLEtBQUwsQ0FBV3dNLFFBQWYsRUFBeUI7QUFDeEI4VSwyQkFBdUJvRSxrQkFBa0J2bEIsR0FBbEIsR0FBd0IsTUFBL0M7QUFDQWtoQix5QkFDQyw4QkFBQyw0QkFBRDtBQUNDLGVBQVUsS0FBS0UsWUFBTCxFQURYO0FBRUMsYUFBUUQsb0JBRlQ7QUFHQyxnQkFBVyxLQUFLdGhCLEtBQUwsQ0FBVzJNO0FBSHZCLE1BREQ7QUFPQTs7QUFFRCxVQUNDO0FBQUE7QUFBQSxNQUFLLFdBQVUsOEJBQWY7QUFDQztBQUFBO0FBQUE7QUFDQyx1QkFBZSxLQUFLM00sS0FBTCxDQUFXd00sUUFEM0I7QUFFQyxvQkFBWWpULFlBQVk2SCxPQUFaLENBQW9CdWtCLE1BRmpDO0FBR0MsbUJBQVdyRSxvQkFIWjtBQUlDLGlCQUFVLFdBSlg7QUFLQyxlQUFTLEtBQUt0aEIsS0FBTCxDQUFXMk0sY0FMckI7QUFNQyxZQUFLLFNBTk47QUFPQyxnQkFBVSxLQUFLM00sS0FBTCxDQUFXWCxRQVB0QjtBQVFDLGFBQU85RixZQUFZNkgsT0FBWixDQUFvQnVrQixNQVI1QjtBQVNDLG1DQUFDLG9CQUFELElBQVksUUFBTyxZQUFuQjtBQVRELEtBREQ7QUFZRXRFO0FBWkYsSUFERDtBQWdCQTs7QUFFRDs7Ozs7Ozs7Ozs7QUFuREE7Ozs7Ozs7Ozs7O2lDQTZEZTtBQUNkLFVBQ0MsS0FBS3JoQixLQUFMLENBQVc3RyxRQUFYLElBQXVCLENBQ3RCO0FBQ0M2TCxhQUFTLG9CQURWO0FBRUMrTixXQUFPeFosWUFBWTZILE9BQVosQ0FBb0J3a0I7QUFGNUIsSUFEc0IsRUFLdEI7QUFDQzVnQixhQUFTLG1CQURWO0FBRUMrTixXQUFPeFosWUFBWTZILE9BQVosQ0FBb0J5a0I7QUFGNUIsSUFMc0IsRUFTdEI7QUFDQzdnQixhQUFTLGNBRFY7QUFFQytOLFdBQU94WixZQUFZNkgsT0FBWixDQUFvQjBrQjtBQUY1QixJQVRzQixDQUR4QjtBQWdCQTs7OztFQS9FOEJubUIsZ0JBQU1TLFM7O0FBQWhDc2xCLGlCLENBU0V2bEIsRyxHQUFNLGE7a0JBeUVDdWxCLGlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVGZjs7OztBQUVBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBUkE7Ozs7O0FBVUEsSUFBTW5PLFlBQVksRUFBbEI7QUFDQSxJQUFNQyxVQUFVLEVBQWhCOztBQUVBLElBQU11TyxjQUFjO0FBQ25CQyxPQUFNLE1BRGE7QUFFbkJDLE9BQU07QUFGYSxDQUFwQjs7QUFLQSxJQUFNQyxxQkFBcUIsQ0FBM0I7O0FBRUE7Ozs7Ozs7SUFNTUMsZTs7O0FBNkJMOzs7Ozs7Ozs7QUExQkE7Ozs7Ozs7QUFpQ0EsMEJBQVlubUIsS0FBWixFQUFtQjtBQUFBOztBQUFBLGdJQUNaQSxLQURZOztBQUFBLFFBaUNuQm9tQixZQWpDbUIsR0FpQ0osWUFBTTtBQUNwQixPQUFNaHZCLFNBQVMsTUFBSzhJLE9BQUwsQ0FBYTlJLE1BQWIsQ0FBb0JGLEdBQXBCLENBQXdCLGNBQXhCLENBQWY7QUFDQSxPQUFNbXZCLGFBQWEsSUFBSWh2QixTQUFTaXZCLEtBQWIsQ0FBbUJsdkIsTUFBbkIsQ0FBbkI7O0FBRUFpdkIsY0FBV3ZILE1BQVgsQ0FBa0I7QUFDakIvWCxXQUFPLE1BQUsvRyxLQUFMLENBQVd1bUIsZUFERDtBQUVqQkMsVUFBTSxNQUFLdGhCLEtBQUwsQ0FBV3NoQixJQUZBO0FBR2pCQyxVQUFNLE1BQUt2aEIsS0FBTCxDQUFXdWhCO0FBSEEsSUFBbEI7O0FBTUEsU0FBS3ptQixLQUFMLENBQVdxTixlQUFYOztBQUVBalcsVUFBT3VFLElBQVAsQ0FBWSxpQkFBWjtBQUNBLEdBOUNrQjs7QUFBQSxRQTBEbkIrcUIsYUExRG1CLEdBMERILFVBQUNDLFNBQUQsRUFBWTFyQixLQUFaLEVBQXNCO0FBQ3JDLE9BQU1pSyxRQUFRLEVBQWQ7O0FBRUEsT0FBSXloQixjQUFjWixZQUFZQyxJQUExQixJQUFrQ1csY0FBY1osWUFBWUUsSUFBaEUsRUFBc0U7QUFDckUvZ0IsVUFBTXloQixTQUFOLElBQW1CemUsS0FBS0MsR0FBTCxDQUFTbE4sTUFBTW9CLE1BQU4sQ0FBYUQsS0FBdEIsRUFBNkI4cEIsa0JBQTdCLENBQW5CO0FBQ0EsSUFGRCxNQUVPO0FBQ05oaEIsVUFBTXloQixTQUFOLElBQW1CMXJCLE1BQU1vQixNQUFOLENBQWFELEtBQWhDO0FBQ0E7O0FBRUQsU0FBS3lRLFFBQUwsQ0FBYzNILEtBQWQ7QUFDQSxHQXBFa0I7O0FBQUEsUUFpRm5CMEwsY0FqRm1CLEdBaUZGLGlCQUFTO0FBQ3pCLE9BQUkzVixNQUFNK1QsT0FBTixLQUFrQnVJLFNBQWxCLElBQStCdGMsTUFBTStULE9BQU4sS0FBa0J3SSxPQUFyRCxFQUE4RDtBQUM3RHZjLFVBQU1RLGNBQU47QUFDQTs7QUFFRCxPQUFJUixNQUFNK1QsT0FBTixLQUFrQnVJLFNBQXRCLEVBQWlDO0FBQ2hDLFVBQUs2TyxZQUFMO0FBQ0EsSUFGRCxNQUVPLElBQUluckIsTUFBTStULE9BQU4sS0FBa0J3SSxPQUF0QixFQUErQjtBQUNyQyxVQUFLeFgsS0FBTCxDQUFXcU4sZUFBWDtBQUNBO0FBQ0QsR0EzRmtCOztBQUdsQixRQUFLdVosT0FBTCxHQUFlam5CLGdCQUFNNFYsU0FBTixFQUFmO0FBQ0EsUUFBS3NSLE9BQUwsR0FBZWxuQixnQkFBTTRWLFNBQU4sRUFBZjtBQUNBLFFBQUtyUSxLQUFMLEdBQWE7QUFDWnNoQixTQUFNLENBRE07QUFFWkMsU0FBTTtBQUZNLEdBQWI7QUFMa0I7QUFTbEI7O0FBRUQ7Ozs7Ozs7Ozs7OztBQTVCQTs7Ozs7Ozs7Ozs7O3NDQXNDb0I7QUFDbkIsUUFBS0csT0FBTCxDQUFhL1MsT0FBYixDQUFxQjlHLEtBQXJCO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7QUF1QkE7Ozs7Ozs7Ozs7OztBQXNCQTs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTs7Ozs7Ozs7MkJBUVM7QUFDUixPQUFNK1osT0FBT0MsS0FBS0MsR0FBTCxFQUFiO0FBQ0EsT0FBTUMsU0FBU0gsT0FBT2YsWUFBWUUsSUFBbEM7QUFDQSxPQUFNaUIsU0FBU0osT0FBT2YsWUFBWUMsSUFBbEM7O0FBRUEsVUFDQztBQUFBO0FBQUEsTUFBSyxXQUFVLHlCQUFmO0FBQ0M7QUFBQTtBQUFBLE9BQU8sU0FBU2lCLE1BQWhCO0FBQXlCMXRCLGlCQUFZNkgsT0FBWixDQUFvQnFsQjtBQUE3QyxLQUREO0FBRUM7QUFBQTtBQUFBLE9BQUssV0FBVSwwQkFBZjtBQUNDO0FBQ0MsaUJBQVUsVUFEWDtBQUVDLFVBQUlRLE1BRkw7QUFHQyxXQUFLZixrQkFITjtBQUlDLGdCQUFVLEtBQUtRLGFBQUwsQ0FBbUJodEIsSUFBbkIsQ0FDVCxJQURTLEVBRVRxc0IsWUFBWUUsSUFGSCxDQUpYO0FBUUMsaUJBQVcsS0FBS3JWLGNBUmpCO0FBU0MsbUJBQVksTUFUYjtBQVVDLFdBQUssS0FBS2dXLE9BVlg7QUFXQyxZQUFLLFFBWE47QUFZQyxhQUFPLEtBQUsxaEIsS0FBTCxDQUFXdWhCO0FBWm5CO0FBREQsS0FGRDtBQW1CQztBQUFBO0FBQUEsT0FBTyxTQUFTUyxNQUFoQjtBQUF5QjN0QixpQkFBWTZILE9BQVosQ0FBb0IrbEI7QUFBN0MsS0FuQkQ7QUFvQkM7QUFBQTtBQUFBLE9BQUssV0FBVSwwQkFBZjtBQUNDO0FBQ0MsaUJBQVUsVUFEWDtBQUVDLFVBQUlELE1BRkw7QUFHQyxXQUFLaEIsa0JBSE47QUFJQyxnQkFBVSxLQUFLUSxhQUFMLENBQW1CaHRCLElBQW5CLENBQ1QsSUFEUyxFQUVUcXNCLFlBQVlDLElBRkgsQ0FKWDtBQVFDLGlCQUFXLEtBQUtwVixjQVJqQjtBQVNDLG1CQUFZLFFBVGI7QUFVQyxXQUFLLEtBQUtpVyxPQVZYO0FBV0MsWUFBSyxRQVhOO0FBWUMsYUFBTyxLQUFLM2hCLEtBQUwsQ0FBV3NoQjtBQVpuQjtBQURELEtBcEJEO0FBcUNDO0FBQUE7QUFBQTtBQUNDLG9CQUFXLFNBRFo7QUFFQyxpQkFBVSxXQUZYO0FBR0MsZUFBUyxLQUFLSixZQUhmO0FBSUMsbUNBQUMsb0JBQUQsSUFBWSxRQUFPLE9BQW5CO0FBSkQ7QUFyQ0QsSUFERDtBQThDQTs7OztFQTVMNEJ6bUIsZ0JBQU1TLFM7O0FBQTlCK2xCLGUsQ0FDRXBoQixXLEdBQWNyRix1QjtBQURoQnltQixlLENBVUU5WixZLEdBQWU7QUFDckJrYSxrQkFBaUI7QUFDaEJhLFVBQVEsQ0FEUTtBQUVoQkMsZUFBYSxDQUZHO0FBR2hCQyxlQUFhLENBSEc7QUFJaEJyaEIsU0FBTztBQUpTO0FBREksQztBQVZqQmtnQixlLENBMkJFaG1CLEcsR0FBTSxXO2tCQW9LQ2dtQixlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BOZjs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFUQTs7Ozs7QUFXQTs7Ozs7SUFLTW9CLGtCOzs7Ozs7Ozs7Ozs7O0FBYUw7Ozs7Ozs7OzJCQVFTO0FBQ1IsT0FBSWxHLDJCQUFKO0FBQ0EsT0FBSUMsNkJBQUo7O0FBRUEsT0FBSSxLQUFLdGhCLEtBQUwsQ0FBV3dNLFFBQWYsRUFBeUI7QUFDeEI4VSwyQkFBdUJpRyxtQkFBbUJwbkIsR0FBbkIsR0FBeUIsTUFBaEQ7QUFDQWtoQix5QkFDQyw4QkFBQyw0QkFBRDtBQUNDLGVBQVUsS0FBS0UsWUFBTCxFQURYO0FBRUMsYUFBUUQsb0JBRlQ7QUFHQyxnQkFBVyxLQUFLdGhCLEtBQUwsQ0FBVzJNO0FBSHZCLE1BREQ7QUFPQTs7QUFFRCxPQUFNNmEsZ0JBQWdCLElBQUlud0IsU0FBU2l2QixLQUFiLENBQ3JCLEtBQUtwbUIsT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FEcUIsRUFFcEJ1d0IsVUFGb0IsRUFBdEI7QUFHQSxPQUFNQyxxQkFBcUJudUIsWUFBWTZILE9BQVosQ0FBb0J1bUIsT0FBcEIsR0FBOEIsR0FBekQ7QUFDQSxPQUFNQyxxQkFDTHJ1QixZQUFZNkgsT0FBWixDQUFvQixZQUFZb21CLGFBQWhDLENBREQ7O0FBR0EsVUFDQztBQUFBO0FBQUEsTUFBSyxXQUFVLDBDQUFmO0FBQ0M7QUFBQTtBQUFBO0FBQ0MsdUJBQWUsS0FBS3huQixLQUFMLENBQVd3TSxRQUQzQjtBQUVDLG9CQUFXLEVBRlo7QUFHQyxpQkFBVSxvQkFIWDtBQUlDLGVBQVMsS0FBS3hNLEtBQUwsQ0FBVzJNLGNBSnJCO0FBS0MsWUFBSyxVQUxOO0FBTUMsZ0JBQVUsS0FBSzNNLEtBQUwsQ0FBV1gsUUFOdEI7QUFPQyxhQUFNLEVBUFA7QUFRQztBQUFBO0FBQUEsUUFBSyxXQUFVLGNBQWY7QUFDQztBQUFBO0FBQUEsU0FBTSxXQUFVLHFDQUFoQjtBQUNFcW9CLHlCQURGO0FBQ3NCLFVBRHRCO0FBRUM7QUFBQTtBQUFBO0FBQVNFO0FBQVQ7QUFGRCxPQUREO0FBS0Msb0NBQUMsb0JBQUQsSUFBWSxRQUFPLGNBQW5CO0FBTEQ7QUFSRCxLQUREO0FBaUJFdkc7QUFqQkYsSUFERDtBQXFCQTs7QUFFRDs7Ozs7Ozs7Ozs7O0FBL0RBOzs7Ozs7Ozs7OztpQ0F5RWU7QUFDZCxVQUNDLEtBQUtyaEIsS0FBTCxDQUFXN0csUUFBWCxJQUF1QixDQUN0QjtBQUNDNkwsYUFBUyxrQkFEVjtBQUVDK04sV0FBT3haLFlBQVk2SCxPQUFaLENBQW9CeW1CO0FBRjVCLElBRHNCLEVBS3RCO0FBQ0M3aUIsYUFBUyxpQkFEVjtBQUVDK04sV0FBT3haLFlBQVk2SCxPQUFaLENBQW9CMG1CO0FBRjVCLElBTHNCLEVBU3RCO0FBQ0M5aUIsYUFBUyxvQkFEVjtBQUVDK04sV0FBT3haLFlBQVk2SCxPQUFaLENBQW9CMm1CO0FBRjVCLElBVHNCLEVBYXRCO0FBQ0MvaUIsYUFBUyxrQkFEVjtBQUVDK04sV0FBT3haLFlBQVk2SCxPQUFaLENBQW9CNG1CO0FBRjVCLElBYnNCLENBRHhCO0FBb0JBOzs7O0VBakcrQnJvQixnQkFBTVMsUzs7QUFBakNtbkIsa0IsQ0FDRXhpQixXLEdBQWNyRix1QjtBQURoQjZuQixrQixDQVdFcG5CLEcsR0FBTSxjO2tCQXlGQ29uQixrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvR2Y7Ozs7QUFFQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVJBOzs7OztBQVVBOzs7OztJQUtNVSxpQjs7Ozs7Ozs7Ozs7Ozs7ME1BMkNMQyxZLEdBQWUsWUFBTTtBQUNwQixPQUFNOXdCLFNBQVMsTUFBSzhJLE9BQUwsQ0FBYTlJLE1BQWIsQ0FBb0JGLEdBQXBCLENBQXdCLGNBQXhCLENBQWY7QUFDQSxPQUFNbXZCLGFBQWEsSUFBSWh2QixTQUFTaXZCLEtBQWIsQ0FBbUJsdkIsTUFBbkIsQ0FBbkI7O0FBRUFpdkIsY0FBVzloQixNQUFYOztBQUVBbk4sVUFBT3VFLElBQVAsQ0FBWSxpQkFBWjtBQUNBLEc7OztBQS9DRDs7Ozs7Ozs7Ozs7Ozs7QUFVQTs7Ozs7Ozs7MkJBUVM7QUFDUixVQUNDO0FBQUE7QUFBQTtBQUNDLG1CQUFZcEMsWUFBWTZILE9BQVosQ0FBb0IrbUIsV0FEakM7QUFFQyxnQkFBVSxXQUZYO0FBR0Msa0JBQVUscUJBSFg7QUFJQyxjQUFTLEtBQUtELFlBSmY7QUFLQyxlQUFVLEtBQUtsb0IsS0FBTCxDQUFXWCxRQUx0QjtBQU1DLFlBQU85RixZQUFZNkgsT0FBWixDQUFvQittQixXQU41QjtBQU9DLGtDQUFDLG9CQUFELElBQVksUUFBTyxPQUFuQjtBQVBELElBREQ7QUFXQTs7QUFFRDs7Ozs7Ozs7Ozs7O0VBbkMrQnhvQixnQkFBTVMsUzs7QUFBaEM2bkIsaUIsQ0FDRWxqQixXLEdBQWNyRix1QjtBQURoQnVvQixpQixDQVdFOW5CLEcsR0FBTSxhO2tCQTBDQzhuQixpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvRGY7Ozs7QUFFQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVJBOzs7OztBQVVBOzs7OztJQUtNRyxjOzs7Ozs7Ozs7Ozs7O0FBV0w7Ozs7Ozs7OzJCQVFTO0FBQ1IsT0FBSS9HLDJCQUFKO0FBQ0EsT0FBSUMsNkJBQUo7O0FBRUEsT0FBSSxLQUFLdGhCLEtBQUwsQ0FBV3dNLFFBQWYsRUFBeUI7QUFDeEI4VSwyQkFBdUI4RyxlQUFlam9CLEdBQWYsR0FBcUIsTUFBNUM7QUFDQWtoQix5QkFDQyw4QkFBQyw0QkFBRDtBQUNDLGVBQVUsS0FBS0UsWUFBTCxFQURYO0FBRUMsYUFBUUQsb0JBRlQ7QUFHQyxnQkFBVyxLQUFLdGhCLEtBQUwsQ0FBVzJNO0FBSHZCLE1BREQ7QUFPQTs7QUFFRCxVQUNDO0FBQUE7QUFBQSxNQUFLLFdBQVUsOEJBQWY7QUFDQztBQUFBO0FBQUE7QUFDQyx1QkFBZSxLQUFLM00sS0FBTCxDQUFXd00sUUFEM0I7QUFFQyxvQkFBWWpULFlBQVk2SCxPQUFaLENBQW9Cd2dCLEdBRmpDO0FBR0MsbUJBQVdOLG9CQUhaO0FBSUMsaUJBQVUsV0FKWDtBQUtDLGVBQVMsS0FBS3RoQixLQUFMLENBQVcyTSxjQUxyQjtBQU1DLFlBQUssVUFOTjtBQU9DLGdCQUFVLEtBQUszTSxLQUFMLENBQVdYLFFBUHRCO0FBUUMsYUFBTzlGLFlBQVk2SCxPQUFaLENBQW9Cd2dCLEdBUjVCO0FBU0MsbUNBQUMsb0JBQUQsSUFBWSxRQUFPLFNBQW5CO0FBVEQsS0FERDtBQVlFUDtBQVpGLElBREQ7QUFnQkE7O0FBRUQ7Ozs7Ozs7Ozs7O0FBbkRBOzs7Ozs7Ozs7OztpQ0E2RGU7QUFDZCxVQUNDLEtBQUtyaEIsS0FBTCxDQUFXN0csUUFBWCxJQUF1QixDQUN0QjtBQUNDNkwsYUFBUyxpQkFEVjtBQUVDK04sV0FBT3haLFlBQVk2SCxPQUFaLENBQW9CaW5CO0FBRjVCLElBRHNCLEVBS3RCO0FBQ0NyakIsYUFBUyxnQkFEVjtBQUVDK04sV0FBT3haLFlBQVk2SCxPQUFaLENBQW9Ca25CO0FBRjVCLElBTHNCLEVBU3RCO0FBQ0N0akIsYUFBUyxXQURWO0FBRUMrTixXQUFPeFosWUFBWTZILE9BQVosQ0FBb0JtbkI7QUFGNUIsSUFUc0IsQ0FEeEI7QUFnQkE7Ozs7RUEvRTJCNW9CLGdCQUFNUyxTOztBQUE3QmdvQixjLENBU0Vqb0IsRyxHQUFNLFU7a0JBeUVDaW9CLGM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUZmOzs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFSQTs7Ozs7QUFVQTs7Ozs7Ozs7O0lBU01JLFc7Ozs7Ozs7Ozs7Ozs7QUFXTDs7Ozs7Ozs7MkJBUVM7QUFDUixPQUFJLEtBQUt4b0IsS0FBTCxDQUFXc04sZUFBZixFQUFnQztBQUMvQixXQUFPLDhCQUFDLHlCQUFELEVBQXFCLEtBQUt0TixLQUExQixDQUFQO0FBQ0EsSUFGRCxNQUVPO0FBQ04sV0FDQztBQUFBO0FBQUE7QUFDQyxvQkFBWXpHLFlBQVk2SCxPQUFaLENBQW9CcW5CLEtBRGpDO0FBRUMsaUJBQVUsV0FGWDtBQUdDLG1CQUFVLGNBSFg7QUFJQyxlQUFTLEtBQUt6b0IsS0FBTCxDQUFXaU4sZ0JBSnJCO0FBS0MsZ0JBQVUsS0FBS2pOLEtBQUwsQ0FBV1gsUUFMdEI7QUFNQyxhQUFPOUYsWUFBWTZILE9BQVosQ0FBb0JxbkIsS0FONUI7QUFPQyxtQ0FBQyxvQkFBRCxJQUFZLFFBQU8sT0FBbkI7QUFQRCxLQUREO0FBV0E7QUFDRDtBQWxDRDs7Ozs7Ozs7Ozs7O0VBRHlCOW9CLGdCQUFNUyxTOztBQUExQm9vQixXLENBU0Vyb0IsRyxHQUFNLE87a0JBNkJDcW9CLFc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcERmOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVRBOzs7OztBQVdBOzs7Ozs7O0lBT01FLGdCOzs7Ozs7Ozs7Ozs7O0FBOEJMOzs7Ozs7OztBQTdCQTs7Ozs7OztzQ0FvQ29CO0FBQ25CNXVCLHNCQUFTa1AsV0FBVCxDQUFxQixJQUFyQixFQUEyQitELEtBQTNCO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7QUFyQkE7Ozs7Ozs7Ozs7OzJCQTZCUztBQUNSLE9BQU00YixjQUFjLEtBQUtDLGtCQUFMLEVBQXBCOztBQUVBLFVBQU87QUFBQyw0QkFBRDtBQUFvQixTQUFLNW9CLEtBQXpCO0FBQWlDMm9CO0FBQWpDLElBQVA7QUFDQTs7QUFFRDs7Ozs7Ozs7Ozs7OzJDQVN5QjtBQUN4QixVQUNDLEtBQUszb0IsS0FBTCxDQUFXNGdCLGtCQUFYLElBQWlDLENBQ2hDO0FBQ0M3TixXQUFPeFosWUFBWTZILE9BQVosQ0FBb0J3ZSxpQkFENUI7QUFFQ3hqQixXQUFPO0FBRlIsSUFEZ0MsRUFLaEM7QUFDQzJXLFdBQU94WixZQUFZNkgsT0FBWixDQUFvQnluQixjQUQ1QjtBQUVDenNCLFdBQU87QUFGUixJQUxnQyxFQVNoQztBQUNDMlcsV0FBT3haLFlBQVk2SCxPQUFaLENBQW9CMG5CLGVBRDVCO0FBRUMxc0IsV0FBTztBQUZSLElBVGdDLEVBYWhDO0FBQ0MyVyxXQUFPeFosWUFBWTZILE9BQVosQ0FBb0IybkIsZ0JBRDVCO0FBRUMzc0IsV0FBTztBQUZSLElBYmdDLEVBaUJoQztBQUNDMlcsV0FBT3haLFlBQVk2SCxPQUFaLENBQW9CNG5CLGFBRDVCO0FBRUM1c0IsV0FBTztBQUZSLElBakJnQyxDQURsQztBQXdCQTs7QUFFRDs7Ozs7Ozs7Ozs7O3VDQVNxQjtBQUFBOztBQUNwQixPQUFJNnNCLFVBQVUsS0FBS0Msc0JBQUwsRUFBZDs7QUFFQSxPQUFNeEoseUJBQXlCLEtBQUsxZixLQUFMLENBQVcwZixzQkFBMUM7O0FBRUF1SixhQUFVQSxRQUFRbmQsR0FBUixDQUFZLGtCQUFVO0FBQy9CLFFBQU1sUCxZQUNMLE9BQUtvRCxLQUFMLENBQVcyZixjQUFYLEtBQThCdGpCLE9BQU9ELEtBQXJDLEdBQ0csMkJBREgsR0FFRyxvQkFISjs7QUFLQSxXQUNDO0FBQUE7QUFBQSxPQUFJLEtBQUtDLE9BQU9ELEtBQWhCLEVBQXVCLE1BQUssUUFBNUI7QUFDQztBQUFBO0FBQUE7QUFDQyxrQkFBV1EsU0FEWjtBQUVDLHFCQUFZUCxPQUFPRCxLQUZwQjtBQUdDLGdCQUFTc2pCLHNCQUhWO0FBSUVyakIsYUFBTzBXO0FBSlQ7QUFERCxLQUREO0FBVUEsSUFoQlMsQ0FBVjs7QUFrQkEsVUFBT2tXLE9BQVA7QUFDQTs7OztFQTVINkJ0cEIsZ0JBQU1TLFM7O0FBQS9Cc29CLGdCLENBUUVyYyxZLEdBQWU7QUFDckI4QyxXQUFVLElBRFc7QUFFckJNLGNBQWEscUJBRlE7QUFHckIxVyxPQUFNO0FBQ0w4VixXQUFTLENBQUMsRUFBRCxDQURKO0FBRUxJLGVBQWEsQ0FBQyxFQUFELENBRlI7QUFHTEMsZUFBYSxDQUFDLEVBQUQsQ0FIUjtBQUlMRSxRQUFNLENBQUMsRUFBRCxDQUpEO0FBS0xDLFFBQU0sQ0FBQyxFQUFEO0FBTEQ7QUFIZSxDO0FBUmpCcVosZ0IsQ0E0QkV2b0IsRyxHQUFNLFk7a0JBbUdDLGtDQUFtQnVvQixnQkFBbkIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1SWY7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBVEE7Ozs7O0FBV0EsSUFBTVMsbUJBQW1CLEdBQXpCOztBQUVBOzs7Ozs7OztJQU9NQyxhOzs7Ozs7Ozs7Ozs7OztrTUFvQkxyTyxXLEdBQWMsWUFBTTtBQUNuQixPQUFNM2pCLFNBQVMsTUFBSzhJLE9BQUwsQ0FBYTlJLE1BQWIsQ0FBb0JGLEdBQXBCLENBQXdCLGNBQXhCLENBQWY7O0FBRUEsT0FBTWtuQixZQUFZLElBQUkvbUIsU0FBU2duQixJQUFiLENBQWtCam5CLE1BQWxCLENBQWxCOztBQUVBLE9BQUksTUFBS3FOLFFBQUwsRUFBSixFQUFxQjtBQUNwQjJaLGNBQVU3WixNQUFWLENBQWlCNlosVUFBVVcsZ0JBQVYsRUFBakI7QUFDQSxJQUZELE1BRU87QUFDTlgsY0FBVVUsTUFBVixDQUFpQixNQUFLdUssUUFBTCxFQUFqQixFQUFrQztBQUNqQ3hYLFlBQU8saUJBRDBCO0FBRWpDeFYsYUFBUTtBQUZ5QixLQUFsQztBQUlBOztBQUVEakYsVUFBT3VFLElBQVAsQ0FBWSxpQkFBWjtBQUNBLEc7OztBQWhDRDs7Ozs7Ozs7OztBQVVBOzs7Ozs7Ozs7Ozs7O0FBd0JBOzs7Ozs7Ozs2QkFRVztBQUNWLE9BQU1LLE9BQU8sSUFBSTNFLFNBQVNnbkIsSUFBYixDQUNaLEtBQUtuZSxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQURZLEVBRVg2bkIsZ0JBRlcsRUFBYjs7QUFJQSxVQUNDL2lCLFFBQ0FBLEtBQUsrVCxZQUFMLENBQWtCLE1BQWxCLEVBQTBCL08sT0FBMUIsQ0FBa0MsMEJBQWxDLE1BQWtFLENBQUMsQ0FGcEU7QUFJQTs7QUFFRDs7Ozs7Ozs7Ozs7MkJBUVM7QUFDUixPQUFNc1MsMEJBQXdCLEtBQUtDLGVBQUwsRUFBOUI7O0FBRUEsVUFDQztBQUFBO0FBQUE7QUFDQyxtQkFBWWhhLFlBQVk2SCxPQUFaLENBQW9Ca29CLE9BRGpDO0FBRUMsZ0JBQVdoVyxRQUZaO0FBR0Msa0JBQVUsZ0JBSFg7QUFJQyxjQUFTLEtBQUt5SCxXQUpmO0FBS0MsZUFBVSxLQUFLL2EsS0FBTCxDQUFXWCxRQUx0QjtBQU1DLFlBQU85RixZQUFZNkgsT0FBWixDQUFvQmtvQixPQU41QjtBQU9DLGtDQUFDLG9CQUFELElBQVksUUFBTyxTQUFuQjtBQVBELElBREQ7QUFXQTs7QUFFRDs7Ozs7Ozs7Ozs7Ozs2QkFVVztBQUNWLE9BQU1wdkIsZUFBZSxLQUFLZ0csT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FBckI7QUFDQSxPQUFNcXlCLGVBQWVydkIsYUFDbkJNLFlBRG1CLEdBRW5CZ3ZCLGVBRm1CLEdBR25CQyxTQUhtQixDQUdULENBSFMsRUFHTk4sZ0JBSE0sQ0FBckI7QUFJQSxPQUFNdFIsTUFBTSxLQUFLN1gsS0FBTCxDQUFXNlgsR0FBdkI7QUFDQSxPQUFNNlIsTUFBTSxLQUFLMXBCLEtBQUwsQ0FBVzBwQixHQUF2QjtBQUNBLE9BQUlDLGNBQ0gsMkNBQTJDSixZQUQ1Qzs7QUFHQSxPQUFJMVIsR0FBSixFQUFTO0FBQ1I4UixtQkFBZSxVQUFVOVIsR0FBekI7QUFDQTs7QUFFRCxPQUFJNlIsR0FBSixFQUFTO0FBQ1JDLG1CQUFlLFVBQVVELEdBQXpCO0FBQ0E7O0FBRUQsVUFBT0MsV0FBUDtBQUNBOzs7O0VBOUcwQmhxQixnQkFBTVMsUzs7QUFBNUJncEIsYSxDQUNFcmtCLFcsR0FBY3JGLHVCO0FBRGhCMHBCLGEsQ0FXRWpwQixHLEdBQU0sUztrQkFzR0Msa0NBQW1CaXBCLGFBQW5CLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaElmOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBVkE7Ozs7O0FBWUE7Ozs7Ozs7O0lBUU1RLG1COzs7Ozs7Ozs7Ozs7O0FBMEJMOzs7Ozs7Ozs7QUF6QkE7Ozs7Ozs7OzJCQWlDUztBQUNSLE9BQU10VywwQkFBd0IsS0FBS0MsZUFBTCxFQUE5Qjs7QUFFQSxVQUNDO0FBQUE7QUFBQTtBQUNDLG1CQUFZaGEsWUFBWTZILE9BQVosQ0FBb0J5b0IsWUFEakM7QUFFQyxxQkFBY3ZXLFNBQVN0UyxPQUFULENBQWlCLFNBQWpCLE1BQWdDLENBQUMsQ0FGaEQ7QUFHQyxnQkFBV3NTLFFBSFo7QUFJQyxrQkFBVSxXQUpYO0FBS0MsY0FBUyxLQUFLbE8sV0FMZjtBQU1DLGVBQVUsS0FBS3BGLEtBQUwsQ0FBV1gsUUFOdEI7QUFPQyxZQUFPOUYsWUFBWTZILE9BQVosQ0FBb0J5b0IsWUFQNUI7QUFRQyxrQ0FBQyxvQkFBRCxJQUFZLFFBQU8sU0FBbkI7QUFSRCxJQUREO0FBWUE7O0FBakNEOzs7Ozs7Ozs7Ozs7RUFoQmlDbHFCLGdCQUFNUyxTOztBQUFsQ3dwQixtQixDQVNFdmQsWSxHQUFlO0FBQ3JCckgsVUFBUyxjQURZO0FBRXJCaUIsUUFBTztBQUNOL0ksV0FBUztBQURIO0FBRmMsQztBQVRqQjBzQixtQixDQXdCRXpwQixHLEdBQU0sSTtrQkE0QkMsNkJBQ2Qsa0NBQW1CLDJCQUFZeXBCLG1CQUFaLENBQW5CLENBRGMsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuRWY7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVhBOzs7OztBQWFBOzs7Ozs7Ozs7SUFTTUUsZTs7Ozs7Ozs7Ozs7OztBQTZCTDs7Ozs7Ozs7O0FBNUJBOzs7Ozs7OzsyQkFvQ1M7QUFDUixPQUFNeFcsMEJBQXdCLEtBQUtDLGVBQUwsRUFBOUI7O0FBRUEsVUFDQztBQUFBO0FBQUE7QUFDQyxtQkFBWWhhLFlBQVk2SCxPQUFaLENBQW9CMm9CLFNBRGpDO0FBRUMscUJBQWN6VyxTQUFTdFMsT0FBVCxDQUFpQixTQUFqQixNQUFnQyxDQUFDLENBRmhEO0FBR0MsZ0JBQVdzUyxRQUhaO0FBSUMsa0JBQVUsa0JBSlg7QUFLQyxjQUFTLEtBQUtsTyxXQUxmO0FBTUMsZUFBVSxLQUFLcEYsS0FBTCxDQUFXWCxRQU50QjtBQU9DLFlBQU85RixZQUFZNkgsT0FBWixDQUFvQjJvQixTQVA1QjtBQVFDLGtDQUFDLG9CQUFELElBQVksUUFBTyxXQUFuQjtBQVJELElBREQ7QUFZQTs7QUFqQ0Q7Ozs7Ozs7Ozs7OztFQW5CNkJwcUIsZ0JBQU1TLFM7O0FBQTlCMHBCLGUsQ0FTRXpkLFksR0FBZTtBQUNyQnJILFVBQVMsV0FEWTtBQUVyQkssWUFBVztBQUNWRyxNQUFJLGFBRE07QUFFVnpNLFFBQU0xQixTQUFTMEgsSUFBVCxHQUFnQixFQUZaLENBRWU7QUFGZixJQUdWdUcsTUFBTTtBQUhJLEVBRlU7QUFPckJXLFFBQU87QUFQYyxDO0FBVGpCNmpCLGUsQ0EyQkUzcEIsRyxHQUFNLFc7a0JBNEJDLDZCQUNkLCtCQUFnQixrQ0FBbUIsMkJBQVkycEIsZUFBWixDQUFuQixDQUFoQixDQURjLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEVmOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O2tOQW5FQTs7Ozs7c0ZBc0VFelosc0NBQTRCbFEsRyxFQUFNa1EscUMsMENBQ2xDaUIsZ0NBQXNCblIsRyxFQUFNbVIsK0IsMENBQzVCK0IscUJBQVdsVCxHLEVBQU1rVCxvQiwwQ0FDakJJLDRCQUFrQnRULEcsRUFBTXNULDJCLDBDQUN4QnVDLHVCQUFhN1YsRyxFQUFNNlYsc0IsMENBQ25CSSxxQkFBV2pXLEcsRUFBTWlXLG9CLDBDQUNqQkUsc0JBQVluVyxHLEVBQU1tVyxxQiwwQ0FDbEJPLGdDQUFzQjFXLEcsRUFBTTBXLCtCLDBDQUM1QkcsNkJBQW1CN1csRyxFQUFNNlcsNEIsMENBQ3pCSyx5QkFBZWxYLEcsRUFBTWtYLHdCLDBDQUNyQkksMEJBQWdCdFgsRyxFQUFNc1gseUIsMENBQ3RCb0Msc0JBQVkxWixHLEVBQU0wWixxQiwwQ0FDbEJkLCtCQUFxQjVZLEcsRUFBTTRZLDhCLDBDQUMzQmEsMkJBQWlCelosRyxFQUFNeVosMEIsMENBQ3ZCRSxrQkFBUzNaLEcsRUFBTTJaLGlCLDBDQUNmRSxrQkFBUzdaLEcsRUFBTTZaLGlCLDBDQUNmRSxzQkFBWS9aLEcsRUFBTStaLHFCLDBDQUNsQk0saUNBQXVCcmEsRyxFQUFNcWEsZ0MsMENBQzdCRSwrQkFBcUJ2YSxHLEVBQU11YSw4QiwwQ0FDM0JFLGdDQUFzQnphLEcsRUFBTXlhLCtCLDBDQUM1QkUsc0JBQVkzYSxHLEVBQU0yYSxxQiwwQ0FDbEJpQiw0QkFBa0I1YixHLEVBQU00YiwyQiwwQ0FDeEJFLHVCQUFhOWIsRyxFQUFNOGIsc0IsMENBQ25CRSxrQ0FBd0JoYyxHLEVBQU1nYyxpQywwQ0FDOUJFLGtDQUF3QmxjLEcsRUFBTWtjLGlDLDBDQUM5QkMsa0NBQXdCbmMsRyxFQUFNbWMsaUMsMENBQzlCQyxxQ0FBMkJwYyxHLEVBQU1vYyxvQywwQ0FDakNpQiwyQkFBaUJyZCxHLEVBQU1xZCwwQiwwQ0FDdkJFLCtCQUFxQnZkLEcsRUFBTXVkLDhCLDBDQUMzQnNCLHlCQUFlN2UsRyxFQUFNNmUsd0IsMENBQ3JCYSwrQkFBcUIxZixHLEVBQU0wZiw4QiwwQ0FDM0JnQixxQkFBVzFnQixHLEVBQU0wZ0Isb0IsMENBQ2pCbUosbUJBQVM3cEIsRyxFQUFNNnBCLGtCLDBDQUNmaEosNkJBQW1CN2dCLEcsRUFBTTZnQiw0QiwwQ0FDekJJLCtCQUFxQmpoQixHLEVBQU1paEIsOEIsMENBQzNCRixtQ0FBeUIvZ0IsRyxFQUFNK2dCLGtDLDBDQUMvQkMsb0NBQTBCaGhCLEcsRUFBTWdoQixtQywwQ0FDaENXLGdDQUFzQjNoQixHLEVBQU0yaEIsK0IsMENBQzVCQyxpQ0FBdUI1aEIsRyxFQUFNNGhCLGdDLDBDQUM3QkMsc0JBQVk3aEIsRyxFQUFNNmhCLHFCLDBDQUNsQkUsNkJBQW1CL2hCLEcsRUFBTStoQiw0QiwwQ0FDekJFLDRCQUFrQmppQixHLEVBQU1paUIsMkIsMENBQ3hCQywwQkFBZ0JsaUIsRyxFQUFNa2lCLHlCLDBDQUN0QkUsd0JBQWNwaUIsRyxFQUFNb2lCLHVCLDBDQUNwQkssdUJBQWF6aUIsRyxFQUFNeWlCLHNCLDBDQUNuQnFILGlDQUF1QjlwQixHLEVBQU04cEIsZ0MsMENBQzdCbEgscUNBQTJCNWlCLEcsRUFBTTRpQixvQywwQ0FDakNLLCtCQUFxQmpqQixHLEVBQU1pakIsOEIsMENBQzNCTywyQkFBaUJ4akIsRyxFQUFNd2pCLDBCLDBDQUN2QlksdUJBQWFwa0IsRyxFQUFNb2tCLHNCLDBDQUNuQkssMEJBQWdCemtCLEcsRUFBTXlrQix5QiwwQ0FDdEJFLDRCQUFrQjNrQixHLEVBQU0ya0IsMkIsMENBQ3hCRSwwQkFBZ0I3a0IsRyxFQUFNNmtCLHlCLDBDQUN0QlUsNEJBQWtCdmxCLEcsRUFBTXVsQiwyQiwwQ0FDeEJTLDBCQUFnQmhtQixHLEVBQU1nbUIseUIsMENBQ3RCb0IsNkJBQW1CcG5CLEcsRUFBTW9uQiw0QiwwQ0FDekJVLDRCQUFrQjluQixHLEVBQU04bkIsMkIsMENBQ3hCRyx5QkFBZWpvQixHLEVBQU1pb0Isd0IsMENBQ3JCSSxzQkFBWXJvQixHLEVBQU1xb0IscUIsMENBQ2xCRSwyQkFBaUJ2b0IsRyxFQUFNdW9CLDBCLDBDQUN2QlUsd0JBQWNqcEIsRyxFQUFNaXBCLHVCLDBDQUNwQmMsbUJBQVMvcEIsRyxFQUFNK3BCLGtCLDBDQUNmSiwwQkFBZ0IzcEIsRyxFQUFNMnBCLHlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvSHhCOzs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsSUFBTUssb0JBQW9CO0FBQ3pCOzs7Ozs7O0FBT0EzbEIsV0FSeUIsd0JBUVo7QUFDWixNQUFJdk0sZUFBSytGLFVBQUwsQ0FBZ0IsS0FBS3lHLFFBQXJCLEtBQWtDeE0sZUFBSytGLFVBQUwsQ0FBZ0IsS0FBSzBHLFFBQXJCLENBQXRDLEVBQXNFO0FBQ3JFLE9BQU10TixTQUFTLEtBQUs0SSxLQUFMLENBQVc1SSxNQUFYLENBQWtCRixHQUFsQixDQUFzQixjQUF0QixDQUFmOztBQUVBRSxVQUFPb0QsWUFBUCxHQUFzQm1LLElBQXRCOztBQUVBLE9BQUksS0FBS0YsUUFBTCxFQUFKLEVBQXFCO0FBQ3BCck4sV0FBT3dOLFdBQVAsQ0FBbUIsS0FBS0YsUUFBTCxFQUFuQjtBQUNBLElBRkQsTUFFTztBQUNOdE4sV0FBT29OLFVBQVAsQ0FBa0IsS0FBS0UsUUFBTCxFQUFsQjtBQUNBOztBQUVEdE4sVUFBT29ELFlBQVAsR0FBc0JxSyxNQUF0Qjs7QUFFQXpOLFVBQU91RSxJQUFQLENBQVksaUJBQVosRUFBK0IsSUFBL0I7QUFDQTtBQUNEO0FBeEJ3QixDQUExQixDLENBdEJBOzs7OztrQkFpRGV3dUIsaUI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakRmOzs7OztBQUtBOzs7Ozs7QUFNQSxJQUFNQyxzQkFBc0I7QUFDM0I7Ozs7Ozs7O0FBUUEzbEIsU0FUMkIsc0JBU2hCO0FBQ1YsTUFBTXJOLFNBQVMsS0FBSzRJLEtBQUwsQ0FBVzVJLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLGNBQXRCLENBQWY7O0FBRUEsTUFBTThOLFVBQVU1TixPQUFPNk4sVUFBUCxDQUFrQixLQUFLakYsS0FBTCxDQUFXZ0YsT0FBN0IsQ0FBaEI7O0FBRUEsU0FBT0EsVUFBVUEsUUFBUUUsS0FBUixLQUFrQjdOLFNBQVM4TixXQUFyQyxHQUFtRCxLQUExRDtBQUNBO0FBZjBCLENBQTVCOztrQkFrQmVpbEIsbUI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hCZjs7Ozs7O0FBRUE7Ozs7O0FBS0EsSUFBTUMsZ0JBQWdCO0FBQ3JCO0FBQ0F6WCxZQUFXO0FBQ1Y7Ozs7Ozs7QUFPQTVOLFdBQVM2TixvQkFBVUcsTUFBVixDQUFpQnNYLFVBUmhCOztBQVVWOzs7Ozs7O0FBT0FDLHFCQUFtQjFYLG9CQUFVQztBQWpCbkIsRUFGVTs7QUFzQnJCOzs7Ozs7OztBQVFBMU4sWUE5QnFCLHVCQThCVGpLLElBOUJTLEVBOEJIO0FBQ2pCLE1BQU0vRCxTQUFTLEtBQUs0SSxLQUFMLENBQVc1SSxNQUFYLENBQWtCRixHQUFsQixDQUFzQixjQUF0QixDQUFmOztBQUVBRSxTQUFPZ08sV0FBUCxDQUFtQixLQUFLcEYsS0FBTCxDQUFXZ0YsT0FBOUIsRUFBdUM3SixJQUF2Qzs7QUFFQSxNQUFJLEtBQUs2RSxLQUFMLENBQVd1cUIsaUJBQWYsRUFBa0M7QUFDakNuekIsVUFBT296QixlQUFQLENBQXVCLElBQXZCO0FBQ0E7O0FBRURwekIsU0FBT3VFLElBQVAsQ0FBWSxpQkFBWixFQUErQixJQUEvQjtBQUNBO0FBeENvQixDQUF0QixDLENBWkE7Ozs7O2tCQXVEZTB1QixhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRGY7Ozs7QUFFQTs7Ozs7O0FBRUE7Ozs7OztBQVRBOzs7OztBQWVBLElBQU1JLGtCQUFrQjtBQUN2QjtBQUNBN1gsWUFBVztBQUNWOzs7Ozs7Ozs7OztBQVdBdk4sYUFBV3dOLG9CQUFVSyxNQUFWLENBQWlCb1g7QUFabEIsRUFGWTs7QUFpQnZCOzs7Ozs7O0FBT0FJLG1CQXhCdUIsZ0NBd0JGO0FBQ3BCLE1BQU14d0IsZUFBZSxLQUFLOEYsS0FBTCxDQUFXNUksTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBckI7QUFDQSxNQUFNbU8sWUFBWSxLQUFLckYsS0FBTCxDQUFXcUYsU0FBN0I7O0FBRUEsTUFBTW5NLGNBQ0xtTSxVQUFVQyxJQUFWLElBQWtCLENBQUU0QyxLQUFLeWlCLE1BQUwsS0FBZ0IsR0FBakIsS0FBMEIsQ0FBM0IsRUFBOEJDLFFBQTlCLEVBRG5COztBQUdBLE1BQUk1bEIsVUFBVTlLLGFBQWErSyxVQUFiLENBQXdCL0wsV0FBeEIsQ0FBZDs7QUFFQSxNQUFJLENBQUM4TCxPQUFMLEVBQWM7QUFDYkEsYUFBVSxJQUFJM04sU0FBUzJOLE9BQWIsQ0FBcUI5SyxZQUFyQixFQUFtQztBQUM1Q3VKLFVBQU0sVUFBU3JNLE1BQVQsRUFBaUI7QUFDdEIsU0FBTW1PLGNBQWNGLFVBQVVHLEVBQTlCOztBQUVBLFNBQUl2TixlQUFLb0YsUUFBTCxDQUFja0ksV0FBZCxDQUFKLEVBQWdDO0FBQy9CLFdBQUtBLFdBQUwsRUFBa0J6TyxJQUFsQixDQUF1QixJQUF2QixFQUE2Qk0sTUFBN0I7QUFDQSxNQUZELE1BRU8sSUFBSWEsZUFBSytGLFVBQUwsQ0FBZ0J1SCxXQUFoQixDQUFKLEVBQWtDO0FBQ3hDQSxrQkFBWXpPLElBQVosQ0FBaUIsSUFBakIsRUFBdUJNLE1BQXZCO0FBQ0E7QUFDRCxLQVJLLENBUUpzQyxJQVJJLENBUUMsSUFSRDtBQURzQyxJQUFuQyxDQUFWOztBQVlBUSxnQkFBYWQsVUFBYixDQUF3QkYsV0FBeEIsRUFBcUM4TCxPQUFyQztBQUNBOztBQUVELE9BQUtTLHdCQUFMLEdBQ0N2TCxhQUFhd0wsZ0JBQWIsQ0FBOEJDLFVBQTlCLENBQXlDTixVQUFVdE0sSUFBbkQsQ0FERDs7QUFHQW1CLGVBQWEwTCxZQUFiLENBQTBCUCxVQUFVdE0sSUFBcEMsRUFBMENHLFdBQTFDO0FBQ0EsRUFyRHNCOzs7QUF1RHZCOzs7Ozs7O0FBT0EyeEIscUJBOUR1QixrQ0E4REE7QUFDdEIsT0FBSzdxQixLQUFMLENBQVc1SSxNQUFYLENBQ0VGLEdBREYsQ0FDTSxjQUROLEVBRUUwTyxZQUZGLENBR0UsS0FBSzVGLEtBQUwsQ0FBV3FGLFNBQVgsQ0FBcUJ0TSxJQUh2QixFQUlFLEtBQUswTSx3QkFKUDtBQU1BO0FBckVzQixDQUF4Qjs7a0JBd0VlZ2xCLGU7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xGZjs7OztBQUVBOzs7Ozs7QUFFQTs7Ozs7O0FBVEE7Ozs7O0FBZUEsSUFBTUssY0FBYztBQUNuQjtBQUNBbFksWUFBVztBQUNWOzs7Ozs7O0FBT0F4YixVQUFReWIsb0JBQVVLLE1BQVYsQ0FBaUJvWDtBQVJmLEVBRlE7O0FBYW5COzs7Ozs7Ozs7OztBQVdBN00sb0JBeEJtQiwrQkF3QkN6ZCxLQXhCRCxFQXdCUTtBQUMxQkEsVUFBUUEsU0FBUyxLQUFLQSxLQUF0Qjs7QUFFQSxNQUFNOUYsZUFBZSxLQUFLOEYsS0FBTCxDQUFXNUksTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsY0FBdEIsQ0FBckI7QUFDQSxNQUFNMk8sWUFBWTNMLGFBQWF2RCxNQUFiLENBQW9Ca1AsU0FBcEIsSUFBaUMsRUFBbkQ7QUFDQSxNQUFNNFYsU0FBU3BrQixTQUFTeU8sS0FBVCxDQUFlQyxLQUFmLENBQ2QvRixLQURjLEVBRWQ2RixVQUFVbVoseUJBQWU3ZSxHQUF6QixDQUZjLENBQWY7O0FBS0EsU0FBT3NiLE1BQVA7QUFDQTtBQW5Da0IsQ0FBcEI7O2tCQXNDZXFQLFc7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hEZjs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7QUFVQSxJQUFNQyxxQkFBcUI7QUFDMUI7Ozs7Ozs7OztBQVNBeFgsZ0JBVjBCLDZCQVVSO0FBQ2pCLE1BQUl2TixlQUFlLEVBQW5COztBQUVBO0FBQ0EsTUFBSS9OLGVBQUsrRixVQUFMLENBQWdCLEtBQUt5RyxRQUFyQixLQUFrQyxLQUFLQSxRQUFMLEVBQXRDLEVBQXVEO0FBQ3REdUIsbUJBQWdCLG1CQUFoQjtBQUNBOztBQUVEO0FBQ0EsTUFBSS9OLGVBQUsrRixVQUFMLENBQWdCLEtBQUtndEIsVUFBckIsS0FBb0MsS0FBS0EsVUFBTCxFQUF4QyxFQUEyRDtBQUMxRGhsQixtQkFBZ0IscUJBQWhCO0FBQ0E7O0FBRUQsU0FBT0EsWUFBUDtBQUNBO0FBeEJ5QixDQUEzQixDLENBakJBOzs7OztrQkE0Q2Ura0Isa0I7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDZjs7OztBQUVBOzs7Ozs7QUFFQTs7Ozs7OztBQVRBOzs7OztBQWdCQSxJQUFNRSxjQUFjO0FBQ25CO0FBQ0FyWSxZQUFXO0FBQ1Y7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkEzTSxTQUFPNE0sb0JBQVVxWSxTQUFWLENBQW9CLENBQUNyWSxvQkFBVUssTUFBWCxFQUFtQkwsb0JBQVVHLE1BQTdCLENBQXBCLENBakJHOztBQW1CVjs7Ozs7Ozs7QUFRQVosV0FBU1Msb0JBQVVPO0FBM0JULEVBRlE7O0FBZ0NuQjs7Ozs7Ozs7QUFRQXNYLG1CQXhDbUIsZ0NBd0NFO0FBQ3BCLE1BQUl6a0IsUUFBUSxLQUFLakcsS0FBTCxDQUFXaUcsS0FBdkI7O0FBRUEsTUFBSWhPLGVBQUtvRixRQUFMLENBQWM0SSxLQUFkLENBQUosRUFBMEI7QUFDekIsT0FBTXRFLFFBQVFzRSxNQUFNQyxLQUFOLENBQVksR0FBWixDQUFkO0FBQ0EsT0FBSUMsZ0JBQWdCLEtBQUtuRyxLQUFMLENBQVc1SSxNQUFYLENBQWtCRixHQUFsQixDQUFzQixjQUF0QixFQUFzQ1AsTUFBMUQ7QUFDQSxPQUFJeVAsV0FBV3pFLE1BQU0wRSxLQUFOLEVBQWY7O0FBRUEsVUFDQ0QsWUFDQW5PLGVBQUt1RixRQUFMLENBQWMySSxhQUFkLENBREEsSUFFQWxPLGVBQUt1RixRQUFMLENBQWMySSxjQUFjQyxRQUFkLENBQWQsQ0FIRCxFQUlFO0FBQ0RELG9CQUFnQkEsY0FBY0MsUUFBZCxDQUFoQjtBQUNBQSxlQUFXekUsTUFBTTBFLEtBQU4sRUFBWDtBQUNBOztBQUVELE9BQUlwTyxlQUFLdUYsUUFBTCxDQUFjMkksYUFBZCxDQUFKLEVBQWtDO0FBQ2pDRixZQUFRRSxhQUFSO0FBQ0E7QUFDRDs7QUFFRCxPQUFLRyxNQUFMLEdBQWMsSUFBSWpQLFNBQVM0TyxLQUFiLENBQW1CQSxLQUFuQixDQUFkO0FBQ0EsRUEvRGtCOzs7QUFpRW5COzs7Ozs7OztBQVFBNGtCLHFCQXpFbUIsa0NBeUVJO0FBQ3RCLE9BQUt2a0IsTUFBTCxHQUFjLElBQWQ7QUFDQSxFQTNFa0I7OztBQTZFbkI7Ozs7Ozs7OztBQVNBNUIsU0F0Rm1CLHNCQXNGUjtBQUNWLFNBQU8sS0FBSzRCLE1BQVo7QUFDQSxFQXhGa0I7OztBQTBGbkI7Ozs7Ozs7O0FBUUE3QixTQWxHbUIsc0JBa0dSO0FBQ1YsTUFBTXJOLFNBQVMsS0FBSzRJLEtBQUwsQ0FBVzVJLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLGNBQXRCLENBQWY7O0FBRUEsTUFBTTRFLGNBQWMxRSxPQUFPMEUsV0FBUCxFQUFwQjs7QUFFQSxTQUFPLEtBQUs0SSxRQUFMLEdBQWdCNkIsV0FBaEIsQ0FBNEJ6SyxXQUE1QixFQUF5QzFFLE1BQXpDLENBQVA7QUFDQTtBQXhHa0IsQ0FBcEI7O2tCQTJHZTZ6QixXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzREN0SFB6a0IsTzs7Ozs7Ozs7O3dEQUNBQSxPOzs7Ozs7Ozs7a0RBQ0FBLE87Ozs7Ozs7OztvREFDQUEsTzs7Ozs7Ozs7O2dEQUNBQSxPOzs7Ozs7Ozs7dURBQ0FBLE87Ozs7Ozs7OztnREFDQUEsTzs7Ozs7Ozs7O21EQUNBQSxPOzs7Ozs7Ozs7bURBQ0FBLE87Ozs7Ozs7OzttREFDQUEsTzs7Ozs7Ozs7O29EQUNBQSxPOzs7Ozs7Ozs7dURBQ0FBLE87Ozs7Ozs7OzsyREFDQUEsTzs7Ozs7Ozs7O21EQUNBQSxPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDYlI7Ozs7QUFFQTs7Ozs7O0FBRUE7Ozs7Ozs7QUFUQTs7Ozs7QUFnQkEsSUFBTTJrQixpQkFBaUI7QUFDdEI7Ozs7Ozs7Ozs7QUFVQUMsdUJBWHNCLGtDQVdDaHNCLE9BWEQsRUFXVWlNLGVBWFYsRUFXMkI7QUFDaEQsTUFBTTJGLFdBQVcsSUFBakI7O0FBRUEsTUFBSS9ZLGVBQUsrRixVQUFMLENBQWdCb0IsT0FBaEIsQ0FBSixFQUE4QjtBQUM3QkEsYUFBVUEsUUFBUXRJLElBQVIsQ0FBYSxJQUFiLEtBQXNCLEVBQWhDO0FBQ0E7O0FBRUQsU0FBT3NJLFFBQVFxRCxNQUFSLENBQWUsVUFBQzZJLElBQUQsRUFBT0MsTUFBUCxFQUFrQjtBQUN2QyxPQUFJQyxNQUFNck4sT0FBTixDQUFjb04sTUFBZCxDQUFKLEVBQTJCO0FBQzFCRCxTQUFLdEksSUFBTCxDQUFVZ08sU0FBU3ZGLGlCQUFULENBQTJCRixNQUEzQixFQUFtQ0YsZUFBbkMsQ0FBVjtBQUNBLFdBQU9DLElBQVA7QUFDQSxJQUhELE1BR087QUFDTixXQUFPMEYsU0FBU3ZGLGlCQUFULENBQTJCck0sT0FBM0IsRUFBb0NpTSxlQUFwQyxDQUFQO0FBQ0E7QUFDRCxHQVBNLEVBT0osRUFQSSxDQUFQO0FBUUEsRUExQnFCOzs7QUE0QnRCOzs7Ozs7Ozs7OztBQVdBSSxrQkF2Q3NCLDZCQXVDSnJNLE9BdkNJLEVBdUNLaU0sZUF2Q0wsRUF1Q3NCO0FBQzNDLE1BQU1LLGNBQWMsRUFBcEI7O0FBRUEsTUFBTXhSLGVBQWUsS0FBSzhGLEtBQUwsQ0FBVzVJLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLGNBQXRCLENBQXJCO0FBQ0EsTUFBTTJPLFlBQVkzTCxhQUFhdkQsTUFBYixDQUFvQmtQLFNBQXBCLElBQWlDLEVBQW5EOztBQUVBLE1BQUk1TixlQUFLK0YsVUFBTCxDQUFnQm9CLE9BQWhCLENBQUosRUFBOEI7QUFDN0JBLGFBQVVBLFFBQVF0SSxJQUFSLENBQWEsSUFBYixLQUFzQixFQUFoQztBQUNBOztBQUVELE1BQU02VSxpQkFBaUIsS0FBS0MsZUFBTCxDQUN0QnhNLFFBQ0V5TSxNQURGLENBQ1Msa0JBQVU7QUFDakIsVUFDQ04sV0FDQ2hTLFlBQVk2SixPQUFaLENBQW9CbUksTUFBcEIsS0FDQWhTLFlBQVk2SixPQUFaLENBQW9CbUksT0FBT2pHLElBQTNCLENBRkQsQ0FERDtBQUtBLEdBUEYsRUFRRXdHLEdBUkYsQ0FRTSxrQkFBVTtBQUNkLE9BQUk3VCxlQUFLb0YsUUFBTCxDQUFja08sTUFBZCxDQUFKLEVBQTJCO0FBQzFCRyxnQkFBWUgsTUFBWixJQUFzQjFGLFVBQVUwRixNQUFWLENBQXRCO0FBQ0FBLGFBQVNoUyxZQUFZNkosT0FBWixDQUFvQm1JLE1BQXBCLENBQVQ7QUFDQSxJQUhELE1BR08sSUFBSXRULGVBQUtvRixRQUFMLENBQWNrTyxPQUFPakcsSUFBckIsQ0FBSixFQUFnQztBQUN0Q29HLGdCQUNDblMsWUFBWTZKLE9BQVosQ0FBb0JtSSxPQUFPakcsSUFBM0IsRUFBaUNuRixHQURsQyxJQUVJOUksU0FBU3lPLEtBQVQsQ0FBZUMsS0FBZixDQUFxQkYsVUFBVTBGLE1BQVYsQ0FBckIsRUFBd0NBLE9BQU9RLEdBQS9DLENBRko7QUFHQVIsYUFBU2hTLFlBQVk2SixPQUFaLENBQW9CbUksT0FBT2pHLElBQTNCLENBQVQ7QUFDQTs7QUFFRCxVQUFPaUcsTUFBUDtBQUNBLEdBcEJGLENBRHNCLEVBc0JyQk8sR0F0QnFCLENBc0JqQixVQUFTUCxNQUFULEVBQWlCUyxLQUFqQixFQUF3QjtBQUM3QixPQUFJaE0sUUFBUSxLQUFLaU0sbUJBQUwsQ0FDWDtBQUNDN1UsWUFBUSxLQUFLNEksS0FBTCxDQUFXNUksTUFEcEI7QUFFQytJLFNBQ0NvTCxPQUFPcEwsR0FBUCxLQUFlLFdBQWYsR0FDR29MLE9BQU9wTCxHQURWLEdBRU1vTCxPQUFPcEwsR0FGYixTQUVvQjZMLEtBTHRCO0FBTUNFLFlBQVFYLE9BQU9wTCxHQU5oQjtBQU9DZCxjQUNDLEtBQUtXLEtBQUwsQ0FBV21NLE9BQVgsSUFDQSxLQUFLbk0sS0FBTCxDQUFXbU0sT0FBWCxDQUFtQm5NLEtBQW5CLENBQXlCa00sTUFBekIsS0FBb0NYLE9BQU9wTCxHQUQzQyxHQUVHLENBRkgsR0FHRyxDQUFDLENBWE47QUFZQ2dNLGFBQVMsS0FBS25NLEtBQUwsQ0FBV21NO0FBWnJCLElBRFcsRUFlWFosT0FBT3BMLEdBZkksQ0FBWjs7QUFrQkFILFdBQVEsS0FBS29NLGtCQUFMLENBQXdCcE0sS0FBeEIsRUFBK0J1TCxPQUFPcEwsR0FBdEMsQ0FBUjs7QUFFQSxPQUFJa0wsZUFBSixFQUFxQjtBQUNwQnJMLFlBQVEzSSxTQUFTeU8sS0FBVCxDQUFlQyxLQUFmLENBQXFCL0YsS0FBckIsRUFBNEJxTCxlQUE1QixDQUFSO0FBQ0E7O0FBRURyTCxXQUFRM0ksU0FBU3lPLEtBQVQsQ0FBZUMsS0FBZixDQUFxQi9GLEtBQXJCLEVBQTRCMEwsWUFBWUgsT0FBT3BMLEdBQW5CLENBQTVCLENBQVI7O0FBRUEsVUFBT1IsZ0JBQU1oRCxhQUFOLENBQW9CNE8sTUFBcEIsRUFBNEJ2TCxLQUE1QixDQUFQO0FBQ0EsR0FsRHNCLEVBa0RwQixJQWxEb0IsQ0FBdkI7O0FBb0RBLFNBQU8yTCxjQUFQO0FBQ0E7QUF0R3FCLENBQXZCOztrQkF5R2V3ZixjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwSGY7Ozs7OztBQUVBOzs7Ozs7QUFNQSxJQUFNRSxpQkFBaUI7QUFDdEI7Ozs7Ozs7OztBQVNBQyxtQkFWc0IsZ0NBVUQ7QUFDcEIsTUFBSTNrQixrQkFBa0IsY0FBdEI7O0FBRUEsTUFDQzFPLGVBQUsrRixVQUFMLENBQWdCLEtBQUs0SSxtQkFBckIsS0FDQSxLQUFLQSxtQkFBTCxFQUZELEVBR0U7QUFDRCxPQUNDLEtBQUtBLG1CQUFMLEdBQTJCQyxTQUEzQixLQUNBeFAsU0FBU3lQLHVCQUZWLEVBR0U7QUFDREgsdUJBQW1CLG1CQUFuQjtBQUNBLElBTEQsTUFLTztBQUNOQSx1QkFBbUIsc0JBQW5CO0FBQ0E7QUFDRDs7QUFFRCxTQUFPQSxlQUFQO0FBQ0E7QUE1QnFCLENBQXZCLEMsQ0FiQTs7Ozs7a0JBNENlMGtCLGM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDZjs7Ozs7O0FBRUE7Ozs7O0FBS0EsSUFBTUUsaUJBQWlCO0FBQ3RCOzs7Ozs7OztBQVFBQywwQkFUc0IscUNBU0lDLFVBVEosRUFTZ0I7QUFDckMsT0FBSzVlLFFBQUwsQ0FBYztBQUNiSCxvQkFBaUIsSUFESjtBQUViRCxpQkFBYztBQUZELEdBQWQ7QUFJQSxFQWRxQjs7O0FBZ0J0Qjs7Ozs7OztBQU9BMkwsZ0JBdkJzQiw2QkF1Qko7QUFDakIsU0FBTztBQUNOMUwsb0JBQWlCLElBRFg7QUFFTkQsaUJBQWM7QUFGUixHQUFQO0FBSUEsRUE1QnFCOzs7QUE4QnRCOzs7Ozs7Ozs7Ozs7Ozs7QUFlQUwsbUJBN0NzQiw4QkE2Q0hFLEdBN0NHLEVBNkNFQyxPQTdDRixFQTZDVztBQUNoQyxTQUFPbFYsU0FBU3lPLEtBQVQsQ0FBZUMsS0FBZixDQUFxQnVHLEdBQXJCLEVBQTBCO0FBQ2hDRSxhQUFVLEtBQUt0SCxLQUFMLENBQVd1SCxZQUFYLEtBQTRCRixPQUE1QixHQUFzQyxJQUF0QyxHQUE2QyxLQUR2QjtBQUVoQ2xOLGFBQVUsS0FBSzZGLEtBQUwsQ0FBV3dILGVBQVgsS0FBK0JILE9BQS9CLEdBQXlDLENBQXpDLEdBQTZDLENBQUMsQ0FGeEI7QUFHaENJLG1CQUFnQixLQUFLQSxjQUFMLENBQW9CalQsSUFBcEIsQ0FBeUIsSUFBekIsRUFBK0I2UyxPQUEvQjtBQUhnQixHQUExQixDQUFQO0FBS0EsRUFuRHFCOzs7QUFxRHRCOzs7Ozs7Ozs7O0FBVUFJLGVBL0RzQiwwQkErRFBGLFlBL0RPLEVBK0RPRyxlQS9EUCxFQStEd0I7QUFDN0MsT0FBS0MsUUFBTCxDQUNDO0FBQ0NILG9CQUFpQkQsWUFEbEI7QUFFQ0EsaUJBQ0NBLGlCQUFpQixLQUFLdkgsS0FBTCxDQUFXdUgsWUFBNUIsR0FDR0EsWUFESCxHQUVHO0FBTEwsR0FERCxFQVFDLFlBQVc7QUFDVixPQUFJLENBQUMsS0FBS3ZILEtBQUwsQ0FBV3VILFlBQWhCLEVBQThCO0FBQzdCLFFBQUksS0FBS0ssU0FBVCxFQUFvQjtBQUNuQixVQUFLQSxTQUFMLENBQWVGLGVBQWY7QUFDQSxLQUZELE1BRU87QUFDTjlTLHdCQUFTa1AsV0FBVCxDQUFxQixJQUFyQixFQUEyQitELEtBQTNCO0FBQ0E7QUFDRDtBQUNELEdBaEJGO0FBa0JBO0FBbEZxQixDQUF2QixDLENBWkE7Ozs7O2tCQWlHZXdlLGM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakdmOzs7OztBQUtBOzs7Ozs7OztBQVFBLElBQU1HLGtCQUFrQjtBQUN2Qjs7Ozs7Ozs7QUFRQXJlLGdCQVR1QiwyQkFTUEgsYUFUTyxFQVNRO0FBQzlCLE1BQUksS0FBS2hJLEtBQUwsQ0FBV2dJLGFBQVgsS0FBNkJBLGFBQWpDLEVBQWdEO0FBQy9DLFFBQUtMLFFBQUwsQ0FBYztBQUNiSyxtQkFBZTtBQURGLElBQWQ7QUFHQTtBQUNELEVBZnNCOzs7QUFpQnZCOzs7Ozs7Ozs7OztBQVdBc2UsMEJBNUJ1QixxQ0E0QkdDLFVBNUJILEVBNEJlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBSzVlLFFBQUwsQ0FBYztBQUNiSyxrQkFBZTtBQURGLEdBQWQ7QUFHQSxFQXBDc0I7OztBQXNDdkI7Ozs7Ozs7OztBQVNBdEIsZ0JBL0N1QiwyQkErQ1B1QixLQS9DTyxFQStDQTtBQUFBOztBQUN0QixTQUFPQSxNQUFNdEIsTUFBTixDQUFhLGdCQUFRO0FBQzNCLE9BQUksTUFBSzNHLEtBQUwsQ0FBV2dJLGFBQWYsRUFBOEI7QUFDN0IsUUFBSSxNQUFLaEksS0FBTCxDQUFXZ0ksYUFBWCxLQUE2QkUsS0FBS2pOLEdBQXRDLEVBQTJDO0FBQzFDLFlBQU9pTixJQUFQO0FBQ0E7QUFDRCxJQUpELE1BSU87QUFDTixXQUFPQSxJQUFQO0FBQ0E7QUFDRCxHQVJNLENBQVA7QUFTQSxFQXpEc0I7OztBQTJEdkI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBbkIsb0JBNUV1QiwrQkE0RUhLLEdBNUVHLEVBNEVFQyxPQTVFRixFQTRFVztBQUNqQyxTQUFPbFYsU0FBU3lPLEtBQVQsQ0FBZUMsS0FBZixDQUFxQnVHLEdBQXJCLEVBQTBCO0FBQ2hDZSxvQkFBaUIsS0FBS0EsZUFBTCxDQUFxQjNULElBQXJCLENBQTBCLElBQTFCLEVBQWdDNlMsT0FBaEMsQ0FEZTtBQUVoQ2Usb0JBQWlCLEtBQUtwSSxLQUFMLENBQVdnSSxhQUFYLEtBQTZCWCxPQUZkO0FBR2hDVSxxQkFBa0IsS0FBS0EsZ0JBQUwsQ0FBc0J2VCxJQUF0QixDQUEyQixJQUEzQixFQUFpQzZTLE9BQWpDO0FBSGMsR0FBMUIsQ0FBUDtBQUtBLEVBbEZzQjs7O0FBb0Z2Qjs7Ozs7Ozs7QUFRQVUsaUJBNUZ1Qiw0QkE0Rk5DLGFBNUZNLEVBNEZTO0FBQy9CLE9BQUtMLFFBQUwsQ0FBYztBQUNiSztBQURhLEdBQWQ7QUFHQTtBQWhHc0IsQ0FBeEI7O2tCQW1HZXdlLGU7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNHZjs7OztBQUNBOzs7O0FBRUE7Ozs7OztBQUVBLElBQU1uZSxpQkFBaUIsQ0FBdkIsQyxDQVZBOzs7OztBQVdBLElBQU1DLGlCQUFpQixDQUF2QjtBQUNBLElBQU1DLGlCQUFpQixDQUFDLENBQXhCOztBQUVBLElBQU1DLGNBQWMsQ0FBcEI7QUFDQSxJQUFNQyxvQkFBb0IsQ0FBMUI7QUFDQSxJQUFNQyx1QkFBdUIsQ0FBN0I7O0FBRUE7Ozs7OztBQU1BLElBQU0rZCxxQkFBcUI7QUFDMUI7QUFDQS9ZLFlBQVc7QUFDVjs7Ozs7Ozs7Ozs7O0FBWUFwRSxhQUFXcUUsb0JBQVVPLElBYlg7O0FBZVY7Ozs7Ozs7QUFPQWpFLFlBQVUwRCxvQkFBVUMsSUFBVixDQUFld1gsVUF0QmY7O0FBd0JWOzs7Ozs7QUFNQXBjLG1CQUFpQjJFLG9CQUFVQyxJQTlCakI7O0FBZ0NWOzs7Ozs7O0FBT0FyRCxlQUFhb0Qsb0JBQVVHLE1BQVYsQ0FBaUJzWCxVQXZDcEI7O0FBeUNWOzs7Ozs7Ozs7QUFTQXZ4QixRQUFNOFosb0JBQVVLLE1BQVYsQ0FBaUJvWDtBQWxEYixFQUZlOztBQXVEMUI7Ozs7Ozs7QUFPQXNCLGtCQTlEMEIsK0JBOEROO0FBQ25CLE9BQUtuZCxRQUFMO0FBQ0EsRUFoRXlCOzs7QUFrRTFCOzs7Ozs7OztBQVFBb2QsbUJBMUUwQixnQ0EwRUw7QUFDcEIsT0FBS3BkLFFBQUw7QUFDQSxFQTVFeUI7OztBQThFMUI7Ozs7Ozs7Ozs7QUFVQTFCLE1BeEYwQixpQkF3RnBCOVIsS0F4Rm9CLEVBd0ZiO0FBQ1osTUFBSSxDQUFDQSxLQUFELElBQVUsS0FBSzRTLGNBQUwsQ0FBb0I1UyxNQUFNb0IsTUFBMUIsQ0FBZCxFQUFpRDtBQUNoRCxPQUFJLEtBQUt5UixZQUFMLElBQXFCLEtBQUtBLFlBQUwsQ0FBa0I3VSxNQUEzQyxFQUFtRDtBQUNsRCxRQUFNOFUscUJBQXFCLEtBQUtELFlBQUwsQ0FDMUIsS0FBS0UsaUJBRHFCLENBQTNCO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUNDdlQsU0FBU3dULGFBQVQsS0FBMkJGLGtCQUEzQixJQUNBLENBQUMsS0FBSy9OLEtBQUwsQ0FBV2tPLGVBRmIsRUFHRTtBQUNELFNBQ0MsS0FBS0osWUFBTCxDQUFrQjlNLE9BQWxCLENBQTBCdkcsU0FBU3dULGFBQW5DLE1BQXNELENBQUMsQ0FEeEQsRUFFRTtBQUNERix5QkFBbUJoQixLQUFuQjtBQUNBO0FBQ0Q7O0FBRUQsUUFBSTlSLEtBQUosRUFBVztBQUNWQSxXQUFNa1QsZUFBTjtBQUNBbFQsV0FBTVEsY0FBTjtBQUNBO0FBQ0Q7QUFDRDtBQUNELEVBbkh5Qjs7O0FBcUgxQjs7Ozs7Ozs7QUFRQTJTLFVBN0gwQixxQkE2SGhCblQsS0E3SGdCLEVBNkhUO0FBQ2hCLE1BQUksS0FBSzRTLGNBQUwsQ0FBb0I1UyxNQUFNb0IsTUFBMUIsS0FBcUMsS0FBS3lSLFlBQTlDLEVBQTREO0FBQzNELE9BQU1PLFNBQVMsS0FBS0MsZUFBTCxDQUFxQnJULEtBQXJCLENBQWY7O0FBRUEsT0FBSW9ULE9BQU8vUCxJQUFYLEVBQWlCO0FBQ2hCckQsVUFBTWtULGVBQU47QUFDQWxULFVBQU1RLGNBQU47O0FBRUEsUUFBSTRTLE9BQU8vUCxJQUFQLEtBQWdCcVAsaUJBQXBCLEVBQXVDO0FBQ3RDLFVBQUtZLFVBQUwsQ0FBZ0JGLE9BQU94SCxTQUF2QjtBQUNBOztBQUVELFFBQUl3SCxPQUFPL1AsSUFBUCxLQUFnQnNQLG9CQUFwQixFQUEwQztBQUN6QyxVQUFLNU4sS0FBTCxDQUFXd08sU0FBWCxDQUFxQkgsT0FBT3hILFNBQTVCO0FBQ0E7QUFDRDtBQUNEO0FBQ0QsRUE5SXlCOzs7QUFnSjFCOzs7Ozs7OztBQVFBaUcsVUF4SjBCLHFCQXdKaEJqRyxTQXhKZ0IsRUF3Skw7QUFDcEJBLGNBQVk1TyxlQUFLeUcsUUFBTCxDQUFjbUksU0FBZCxJQUEyQkEsU0FBM0IsR0FBdUMsQ0FBbkQ7O0FBRUEsT0FBSzBILFVBQUwsQ0FBZ0IxSCxTQUFoQjtBQUNBLEVBNUp5Qjs7O0FBOEoxQjs7Ozs7Ozs7Ozs7QUFXQXlILGdCQXpLMEIsMkJBeUtWclQsS0F6S1UsRUF5S0g7QUFDdEIsTUFBTW9ULFNBQVM7QUFDZC9QLFNBQU1vUDtBQURRLEdBQWY7O0FBSUEsTUFBSSxLQUFLMU4sS0FBTCxDQUFXakgsSUFBZixFQUFxQjtBQUNwQixPQUFNOE4sWUFBWSxLQUFLNkgsc0JBQUwsQ0FBNEJ6VCxLQUE1QixDQUFsQjs7QUFFQSxPQUFJNEwsU0FBSixFQUFlO0FBQ2R3SCxXQUFPeEgsU0FBUCxHQUFtQkEsU0FBbkI7QUFDQXdILFdBQU8vUCxJQUFQLEdBQWNxUCxpQkFBZDtBQUNBOztBQUVELE9BQU1nQixnQkFBZ0IsS0FBS0Msc0JBQUwsQ0FBNEIzVCxLQUE1QixFQUFtQzRMLFNBQW5DLENBQXRCOztBQUVBLE9BQUk4SCxjQUFjRSxPQUFsQixFQUEyQjtBQUMxQlIsV0FBT3hILFNBQVAsR0FBbUI4SCxjQUFjOUgsU0FBakM7QUFDQXdILFdBQU8vUCxJQUFQLEdBQWNzUCxvQkFBZDtBQUNBO0FBQ0Q7O0FBRUQsU0FBT1MsTUFBUDtBQUNBLEVBL0x5Qjs7O0FBaU0xQjs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQU8sdUJBak4wQixrQ0FpTkgzVCxLQWpORyxFQWlOSTZULGtCQWpOSixFQWlOd0I7QUFDakQsTUFBTUgsZ0JBQWdCO0FBQ3JCOUgsY0FBV2lJLGtCQURVO0FBRXJCRCxZQUFTO0FBRlksR0FBdEI7O0FBS0EsTUFBSSxLQUFLN08sS0FBTCxDQUFXd08sU0FBZixFQUEwQjtBQUN6QixPQUFJLEtBQUtPLFdBQUwsQ0FBaUI5VCxNQUFNK1QsT0FBdkIsRUFBZ0MsS0FBS2hQLEtBQUwsQ0FBV2pILElBQVgsQ0FBZ0I4VixPQUFoRCxDQUFKLEVBQThEO0FBQzdERixrQkFBY0UsT0FBZCxHQUF3QixJQUF4QjtBQUNBO0FBQ0QsT0FBSSxLQUFLRSxXQUFMLENBQWlCOVQsTUFBTStULE9BQXZCLEVBQWdDLEtBQUtoUCxLQUFMLENBQVdqSCxJQUFYLENBQWdCa1csV0FBaEQsQ0FBSixFQUFrRTtBQUNqRU4sa0JBQWNFLE9BQWQsR0FBd0IsSUFBeEI7QUFDQUYsa0JBQWM5SCxTQUFkLEdBQTBCMkcsY0FBMUI7QUFDQTtBQUNELE9BQUksS0FBS3VCLFdBQUwsQ0FBaUI5VCxNQUFNK1QsT0FBdkIsRUFBZ0MsS0FBS2hQLEtBQUwsQ0FBV2pILElBQVgsQ0FBZ0JtVyxXQUFoRCxDQUFKLEVBQWtFO0FBQ2pFUCxrQkFBY0UsT0FBZCxHQUF3QixJQUF4QjtBQUNBRixrQkFBYzlILFNBQWQsR0FBMEI0RyxjQUExQjtBQUNBOztBQUVELE9BQ0MsQ0FBQ2tCLGNBQWNFLE9BQWYsSUFDQSxDQUFDLEtBQUs3TyxLQUFMLENBQVdtUCxRQURaLElBRUFMLGtCQUhELEVBSUU7QUFDREgsa0JBQWNFLE9BQWQsR0FDRUMsdUJBQXVCckIsY0FBdkIsSUFDQSxLQUFLTyxpQkFBTCxLQUEyQixDQUQ1QixJQUVDYyx1QkFBdUJ0QixjQUF2QixJQUNBLEtBQUtRLGlCQUFMLEtBQ0MsS0FBS0YsWUFBTCxDQUFrQjdVLE1BQWxCLEdBQTJCLENBTDlCO0FBTUE7QUFDRDs7QUFFRCxTQUFPMFYsYUFBUDtBQUNBLEVBblB5Qjs7O0FBcVAxQjs7Ozs7Ozs7Ozs7QUFXQUQsdUJBaFEwQixrQ0FnUUh6VCxLQWhRRyxFQWdRSTtBQUM3QixNQUFJNEwsWUFBWTBHLGNBQWhCOztBQUVBLE1BQUksS0FBS3dCLFdBQUwsQ0FBaUI5VCxNQUFNK1QsT0FBdkIsRUFBZ0MsS0FBS2hQLEtBQUwsQ0FBV2pILElBQVgsQ0FBZ0JxVyxJQUFoRCxDQUFKLEVBQTJEO0FBQzFEdkksZUFBWTJHLGNBQVo7QUFDQTtBQUNELE1BQUksS0FBS3VCLFdBQUwsQ0FBaUI5VCxNQUFNK1QsT0FBdkIsRUFBZ0MsS0FBS2hQLEtBQUwsQ0FBV2pILElBQVgsQ0FBZ0JzVyxJQUFoRCxDQUFKLEVBQTJEO0FBQzFEeEksZUFBWTRHLGNBQVo7QUFDQTs7QUFFRCxNQUFJeFMsTUFBTXFVLE9BQVYsRUFBbUI7QUFDbEJ6SSxnQkFBYSxDQUFDLENBQWQ7QUFDQTs7QUFFRCxTQUFPQSxTQUFQO0FBQ0EsRUEvUXlCOzs7QUFpUjFCOzs7Ozs7Ozs7OztBQVdBa0ksWUE1UjBCLHVCQTRSZEMsT0E1UmMsRUE0UkxqVyxJQTVSSyxFQTRSQztBQUMxQixTQUFPZCxlQUFLa0csT0FBTCxDQUFhcEYsSUFBYixJQUNKQSxLQUFLaUksT0FBTCxDQUFhZ08sT0FBYixNQUEwQixDQUFDLENBRHZCLEdBRUpBLFlBQVlqVyxJQUZmO0FBR0EsRUFoU3lCOzs7QUFrUzFCOzs7Ozs7Ozs7OztBQVdBOFUsZUE3UzBCLDBCQTZTWDNRLE9BN1NXLEVBNlNGO0FBQ3ZCLE1BQU1nTyxVQUFVaE8sUUFBUWdPLE9BQVIsQ0FBZ0J0SixXQUFoQixFQUFoQjs7QUFFQSxTQUNDc0osWUFBWSxPQUFaLElBQ0FBLFlBQVksUUFEWixJQUVBQSxZQUFZLFVBSGI7QUFLQSxFQXJUeUI7OztBQXVUMUI7Ozs7Ozs7OztBQVNBcUQsV0FoVTBCLHNCQWdVZjFILFNBaFVlLEVBZ1VKO0FBQ3JCLE1BQU0wSSxpQkFBaUIsS0FBS3pCLFlBQUwsQ0FBa0I3VSxNQUF6Qzs7QUFFQSxNQUFJdVcsYUFBYSxLQUFLMUIsWUFBTCxDQUFrQixLQUFLRSxpQkFBdkIsQ0FBakI7O0FBRUF3QixhQUFXclksWUFBWCxDQUF3QixVQUF4QixFQUFvQyxDQUFDLENBQXJDOztBQUVBLE9BQUs2VyxpQkFBTCxJQUEwQm5ILFNBQTFCOztBQUVBLE1BQUksS0FBSzdHLEtBQUwsQ0FBV21QLFFBQWYsRUFBeUI7QUFDeEI7QUFDQTtBQUNBLFFBQUtuQixpQkFBTCxHQUNDLENBQUUsS0FBS0EsaUJBQUwsR0FBeUJ1QixjQUExQixHQUE0Q0EsY0FBN0MsSUFDQUEsY0FGRDtBQUdBLEdBTkQsTUFNTztBQUNOLFFBQUt2QixpQkFBTCxHQUF5QjlGLEtBQUtFLEdBQUwsQ0FDeEJGLEtBQUtDLEdBQUwsQ0FBUyxLQUFLNkYsaUJBQWQsRUFBaUN1QixpQkFBaUIsQ0FBbEQsQ0FEd0IsRUFFeEIsQ0FGd0IsQ0FBekI7QUFJQTs7QUFFREMsZUFBYSxLQUFLMUIsWUFBTCxDQUFrQixLQUFLRSxpQkFBdkIsQ0FBYjs7QUFFQXdCLGFBQVdyWSxZQUFYLENBQXdCLFVBQXhCLEVBQW9DLENBQXBDO0FBQ0FxWSxhQUFXekMsS0FBWDtBQUNBLEVBMVZ5Qjs7O0FBNFYxQjs7Ozs7Ozs7QUFRQTBCLFNBcFcwQixzQkFvV2Y7QUFBQTs7QUFDVixNQUFNMUYsVUFBVWpQLG1CQUFTa1AsV0FBVCxDQUFxQixJQUFyQixDQUFoQjs7QUFFQSxNQUFJRCxPQUFKLEVBQWE7QUFDWixPQUFNMEcsY0FBYzFHLFFBQVEyRyxnQkFBUixDQUNuQixLQUFLMVAsS0FBTCxDQUFXeVAsV0FEUSxDQUFwQjs7QUFJQSxPQUFJRSxzQkFBc0IsRUFBMUI7O0FBRUEsUUFBSzdCLFlBQUwsR0FBb0IsRUFBcEI7O0FBRUF0QyxTQUFNb0UsU0FBTixDQUFnQjNPLEtBQWhCLENBQXNCbkssSUFBdEIsQ0FBMkIyWSxXQUEzQixFQUF3Q0ksT0FBeEMsQ0FBZ0QsZ0JBQVE7QUFDdkQsUUFBTUMsZUFBZTFDLEtBQUsyQyxZQUFMLENBQWtCLGVBQWxCLENBQXJCOztBQUVBLFFBQUlELFlBQUosRUFBa0I7QUFDakJILHlCQUFvQjNNLElBQXBCLENBQXlCb0ssSUFBekI7QUFDQSxLQUZELE1BRU87QUFDTixXQUFLVSxZQUFMLENBQWtCOUssSUFBbEIsQ0FBdUJvSyxJQUF2QjtBQUNBO0FBQ0QsSUFSRDs7QUFVQXVDLHlCQUFzQkEsb0JBQW9CSyxJQUFwQixDQUF5QixVQUFDQyxDQUFELEVBQUlDLENBQUosRUFBVTtBQUN4RCxXQUNDalksZUFBS2tZLEtBQUwsQ0FBV0YsRUFBRUYsWUFBRixDQUFlLGVBQWYsQ0FBWCxJQUNBOVgsZUFBS2tZLEtBQUwsQ0FBV0QsRUFBRUgsWUFBRixDQUFlLGVBQWYsQ0FBWCxDQUZEO0FBSUEsSUFMcUIsQ0FBdEI7O0FBT0EsUUFBS2pDLFlBQUwsR0FBb0I2QixvQkFBb0IvTSxNQUFwQixDQUEyQixLQUFLa0wsWUFBaEMsQ0FBcEI7O0FBRUEsUUFBS0UsaUJBQUwsR0FBeUIsQ0FBekI7O0FBRUEsUUFBS0YsWUFBTCxDQUFrQnNDLElBQWxCLENBQXVCLFVBQUNoRCxJQUFELEVBQU9wQixLQUFQLEVBQWlCO0FBQ3ZDLFFBQUlvQixLQUFLMkMsWUFBTCxDQUFrQixVQUFsQixNQUFrQyxHQUF0QyxFQUEyQztBQUMxQyxXQUFLL0IsaUJBQUwsR0FBeUJoQyxLQUF6QjtBQUNBLFdBQUtlLEtBQUw7O0FBRUEsWUFBTyxJQUFQO0FBQ0E7QUFDRCxJQVBEO0FBUUE7QUFDRDtBQTlZeUIsQ0FBM0I7O2tCQWlaZTRlLGtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwYWY7Ozs7OztBQUVBOzs7OztBQUtBLElBQU1HLHlCQUF5QjtBQUM5QjtBQUNBbFosWUFBVztBQUNWOzs7Ozs7O0FBT0FwTCxlQUFhcUwsb0JBQVVLO0FBUmIsRUFGbUI7O0FBYTlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkF0TSxvQkEvQjhCLGlDQStCUjtBQUNyQixNQUFNVyxlQUFlLEtBQUt2SCxLQUFMLENBQVd3SCxXQUFYLEdBQ2xCLEtBQUt4SCxLQUFMLENBQVd3SCxXQUFYLENBQXVCck0sSUFETCxHQUVsQixJQUZIOztBQUlBLE1BQUksQ0FBQ29NLFlBQUwsRUFBbUI7QUFDbEI7QUFDQTs7QUFFRCxNQUFNRSxnQkFBZ0JGLGFBQWFFLGFBQW5DOztBQUVBLE1BQU1DLGNBQWNILGFBQWFHLFdBQWpDOztBQUVBLE1BQU1DLE1BQU07QUFDWFQsTUFBR0ssYUFBYUcsV0FBYixDQUF5QkUsS0FEakI7QUFFWFIsTUFBR0ssY0FBY0ksTUFBZCxDQUFxQlI7QUFGYixHQUFaOztBQUtBLE1BQUlSLFlBQVlZLGNBQWNJLE1BQWQsQ0FBcUJoQixTQUFyQzs7QUFFQSxNQUFNaUIsVUFBVUwsY0FBY0ksTUFBZCxDQUFxQkMsT0FBckM7O0FBRUEsTUFBTUMsWUFBWU4sY0FBY0ksTUFBZCxDQUFxQkUsU0FBdkM7O0FBRUEsTUFBSUQsV0FBV0MsU0FBWCxJQUF3QkEsVUFBVVYsR0FBVixLQUFrQlMsUUFBUVQsR0FBdEQsRUFBMkQ7QUFDMURSLGVBQVl4UCxTQUFTMlEsdUJBQXJCO0FBQ0E7O0FBRUQsTUFBSWQsVUFBSjtBQUNBLE1BQUlFLFVBQUo7O0FBRUE7QUFDQTs7QUFFQSxNQUFJTyxJQUFJVCxDQUFKLElBQVNTLElBQUlQLENBQWpCLEVBQW9CO0FBQ25CRixPQUFJLEtBQUtlLFVBQUwsQ0FBZ0JSLGFBQWhCLEVBQStCRSxJQUFJVCxDQUFuQyxDQUFKOztBQUVBLE9BQUlMLGNBQWN4UCxTQUFTMlEsdUJBQTNCLEVBQW9EO0FBQ25EWixRQUFJYyxLQUFLQyxHQUFMLENBQVNSLElBQUlQLENBQWIsRUFBZ0JLLGNBQWNJLE1BQWQsQ0FBcUJSLEdBQXJDLENBQUo7QUFDQSxJQUZELE1BRU87QUFDTkQsUUFBSWMsS0FBS0UsR0FBTCxDQUNIVCxJQUFJUCxDQURELEVBRUgsS0FBS2lCLFVBQUwsQ0FBZ0JaLGFBQWhCLEVBQStCQyxXQUEvQixDQUZHLENBQUo7QUFJQTtBQUNELEdBWEQsTUFXTztBQUNOUixPQUFJTyxjQUFjSSxNQUFkLENBQXFCVixJQUFyQixHQUE0Qk0sY0FBY0ksTUFBZCxDQUFxQlAsS0FBckIsR0FBNkIsQ0FBN0Q7O0FBRUEsT0FBSVQsY0FBY3hQLFNBQVN5UCx1QkFBM0IsRUFBb0Q7QUFDbkRNLFFBQUksS0FBS2lCLFVBQUwsQ0FBZ0JaLGFBQWhCLEVBQStCQyxXQUEvQixDQUFKO0FBQ0EsSUFGRCxNQUVPO0FBQ05OLFFBQUlLLGNBQWNJLE1BQWQsQ0FBcUJSLEdBQXpCO0FBQ0E7QUFDRDs7QUFFRCxTQUFPO0FBQ05SLHVCQURNO0FBRU5LLE9BRk07QUFHTkU7QUFITSxHQUFQO0FBS0EsRUEzRjZCOzs7QUE2RjlCOzs7Ozs7Ozs7OztBQVdBYSxXQXhHOEIsc0JBd0duQlIsYUF4R21CLEVBd0dKYSxNQXhHSSxFQXdHSTtBQUNqQyxNQUFNVCxTQUFTSixjQUFjSSxNQUE3Qjs7QUFFQSxNQUFNVixPQUFPVSxPQUFPRSxTQUFQLEdBQW1CRixPQUFPRSxTQUFQLENBQWlCWixJQUFwQyxHQUEyQ1UsT0FBT1YsSUFBL0Q7QUFDQSxNQUFNb0IsUUFBUVYsT0FBT0MsT0FBUCxHQUFpQkQsT0FBT0MsT0FBUCxDQUFlUyxLQUFoQyxHQUF3Q1YsT0FBT1UsS0FBN0Q7O0FBRUEsTUFBSXJCLFVBQUo7O0FBRUEsTUFBSUMsT0FBT21CLE1BQVAsSUFBaUJDLFFBQVFELE1BQTdCLEVBQXFDO0FBQ3BDcEIsT0FBSW9CLE1BQUo7QUFDQSxHQUZELE1BRU87QUFDTixPQUFNRSxXQUFXTixLQUFLTyxHQUFMLENBQVN0QixPQUFPbUIsTUFBaEIsQ0FBakI7QUFDQSxPQUFNSSxZQUFZUixLQUFLTyxHQUFMLENBQVNGLFFBQVFELE1BQWpCLENBQWxCOztBQUVBLE9BQUlFLFdBQVdFLFNBQWYsRUFBMEI7QUFDekI7QUFDQXhCLFFBQUlDLElBQUo7QUFDQSxJQUhELE1BR087QUFDTkQsUUFBSXFCLEtBQUo7QUFDQTtBQUNEOztBQUVELFNBQU9yQixDQUFQO0FBQ0EsRUEvSDZCOzs7QUFpSTlCOzs7Ozs7Ozs7OztBQVdBbUIsV0E1SThCLHNCQTRJbkJaLGFBNUltQixFQTRJSkMsV0E1SUksRUE0SVM7QUFDdEMsTUFBSU4sSUFBSSxDQUFSOztBQUVBLE1BQUlLLGlCQUFpQkMsV0FBckIsRUFBa0M7QUFDakMsT0FBTWlCLGdCQUFnQixJQUFJdFIsU0FBU3dFLEdBQVQsQ0FBYXFCLE9BQWpCLENBQXlCd0ssWUFBWXJMLE1BQXJDLENBQXRCOztBQUVBLE9BQ0NzTSxjQUFjak8sQ0FBZCxJQUNBaU8sY0FBY2pFLFFBQWQsQ0FBdUIsVUFBdkIsTUFBdUMsTUFGeEMsRUFHRTtBQUNEMEMsUUFDQ00sWUFBWXJMLE1BQVosQ0FBbUJ1TSxTQUFuQixHQUNBbEIsWUFBWXJMLE1BQVosQ0FBbUJ3TSxZQUZwQjtBQUdBLElBUEQsTUFPTztBQUNOekIsUUFBSUssY0FBY0ksTUFBZCxDQUFxQmlCLE1BQXpCO0FBQ0E7QUFDRDs7QUFFRCxTQUFPMUIsQ0FBUDtBQUNBO0FBL0o2QixDQUEvQixDLENBWkE7Ozs7O2tCQThLZTBrQixzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDektmOzs7O0FBQ0E7Ozs7QUFFQTs7Ozs7O0FBRUE7Ozs7Ozs7QUFPQSxJQUFNQyxpQkFBaUI7QUFDdEJDLFNBQVEsQ0FBQ0YsZ0NBQUQsQ0FEYzs7QUFHdEI7QUFDQWxaLFlBQVc7QUFDVjs7Ozs7Ozs7QUFRQXZJLHVCQUFxQndJLG9CQUFVQyxJQVRyQjs7QUFXVjs7Ozs7Ozs7Ozs7O0FBWUE3SixVQUFRNEosb0JBQVVLO0FBdkJSLEVBSlc7O0FBOEJ0Qjs7Ozs7Ozs7QUFRQStZLGdCQXRDc0IsNkJBc0NKO0FBQ2pCLFNBQU87QUFDTmhqQixXQUFRO0FBQ1A5QixVQUFNLENBREM7QUFFUEUsU0FBSztBQUZFLElBREY7QUFLTmdELHdCQUFxQjtBQUxmLEdBQVA7QUFPQSxFQTlDcUI7OztBQWdEdEI7Ozs7Ozs7QUFPQTZoQixnQkF2RHNCLDZCQXVESjtBQUNqQixNQUFJM3hCLE9BQU9tTSxvQkFBWCxFQUFpQztBQUNoQ25NLFVBQU9tTSxvQkFBUCxDQUE0QixLQUFLRCxpQkFBakM7QUFDQTtBQUNELEVBM0RxQjs7O0FBNkR0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE4RCx1QkE5RXNCLGtDQThFQ3hELEtBOUVELEVBOEVRQyxZQTlFUixFQThFc0I7QUFDM0NBLGlCQUNDQSxnQkFBZ0IsSUFBSTNQLFNBQVN3RSxHQUFULENBQWF0QixNQUFqQixDQUF3QkEsTUFBeEIsRUFBZ0MwTSxlQUFoQyxFQURqQjs7QUFHQSxNQUFJQyxJQUFJSCxNQUFNSSxJQUFkO0FBQ0EsTUFBSUMsSUFBSUwsTUFBTU0sR0FBZDs7QUFFQSxNQUFJTixNQUFNSSxJQUFOLEdBQWFKLE1BQU1PLEtBQW5CLEdBQTJCTixhQUFhTSxLQUE1QyxFQUFtRDtBQUNsREosUUFBS0gsTUFBTUksSUFBTixHQUFhSixNQUFNTyxLQUFuQixHQUEyQk4sYUFBYU0sS0FBN0M7QUFDQTs7QUFFRCxNQUFJRixJQUFJLENBQVIsRUFBVztBQUNWQSxPQUFJLENBQUo7QUFDQTs7QUFFRCxTQUFPO0FBQ05GLE9BRE07QUFFTkU7QUFGTSxHQUFQO0FBSUEsRUFqR3FCOzs7QUFtR3RCOzs7Ozs7Ozs7Ozs7OztBQWNBZ0UsaUJBakhzQiw0QkFpSExqRSxJQWpISyxFQWlIQ0UsR0FqSEQsRUFpSE1SLFNBakhOLEVBaUhpQjtBQUN0QyxNQUFNa0MsVUFBVWpQLG1CQUFTa1AsV0FBVCxDQUFxQixJQUFyQixDQUFoQjs7QUFFQSxNQUFNQyxTQUFTLEtBQUtqSixLQUFMLENBQVdpSixNQUExQjtBQUNBLE1BQU1DLGNBQWNILFFBQVFHLFdBQTVCO0FBQ0EsTUFBTWlqQixZQUFZampCLGNBQWMsQ0FBaEM7O0FBRUEsTUFDQ3JDLGNBQWN4UCxTQUFTeVAsdUJBQXZCLElBQ0FELGNBQWN4UCxTQUFTMlEsdUJBRnhCLEVBR0U7QUFDRGIsVUFBT0EsT0FBTzhCLE9BQU85QixJQUFkLEdBQXFCZ2xCLFNBQTVCOztBQUVBOWtCLFNBQ0NSLGNBQWN4UCxTQUFTeVAsdUJBQXZCLEdBQ0dPLE1BQU00QixPQUFPNUIsR0FEaEIsR0FFR0EsTUFBTTBCLFFBQVFGLFlBQWQsR0FBNkJJLE9BQU81QixHQUh4QztBQUlBLEdBVkQsTUFVTyxJQUNOUixjQUFjeFAsU0FBUzhSLHVCQUF2QixJQUNBdEMsY0FBY3hQLFNBQVMrUix1QkFGakIsRUFHTDtBQUNEakMsVUFDQ04sY0FBY3hQLFNBQVM4Uix1QkFBdkIsR0FDR2hDLE9BQU84QixPQUFPOUIsSUFBZCxHQUFxQjRCLFFBQVFGLFlBQVIsR0FBdUIsQ0FEL0MsR0FFRzFCLE9BQVEsSUFBSTRCLFFBQVFGLFlBQWIsR0FBNkIsQ0FBcEMsR0FBd0NJLE9BQU85QixJQUhuRDs7QUFLQUUsU0FBTUEsTUFBTTRCLE9BQU81QixHQUFiLEdBQW1CMEIsUUFBUUYsWUFBUixHQUF1QixDQUFoRDtBQUNBOztBQUVELE1BQUkxQixPQUFPLENBQVgsRUFBYztBQUNiQSxVQUFPLENBQVA7QUFDQTs7QUFFRCxNQUFJQSxPQUFPMU0sU0FBU3FDLElBQVQsQ0FBY29NLFdBQWQsR0FBNEJpakIsU0FBdkMsRUFBa0Q7QUFDakRobEIsVUFBTzFNLFNBQVNxQyxJQUFULENBQWNvTSxXQUFkLEdBQTRCaWpCLFNBQW5DO0FBQ0E7O0FBRUQsTUFBSTlrQixNQUFNLENBQVYsRUFBYTtBQUNaQSxTQUFNLENBQU47QUFDQTs7QUFFRCxTQUFPLENBQUNGLElBQUQsRUFBT0UsR0FBUCxDQUFQO0FBQ0EsRUEzSnFCOzs7QUE2SnRCOzs7Ozs7OztBQVFBeUMsVUFyS3NCLHVCQXFLVjtBQUNYLE1BQU1mLFVBQVVqUCxtQkFBU2tQLFdBQVQsQ0FBcUIsSUFBckIsQ0FBaEI7O0FBRUEsTUFBSUQsT0FBSixFQUFhO0FBQ1osT0FBTU0sYUFBYSxJQUFJaFMsU0FBU3dFLEdBQVQsQ0FBYXFCLE9BQWpCLENBQXlCNkwsT0FBekIsQ0FBbkI7O0FBRUEsVUFBT00sV0FBV0MsUUFBWCxDQUFvQixzQkFBcEIsQ0FBUDtBQUNBOztBQUVELFNBQU8sS0FBUDtBQUNBLEVBL0txQjs7O0FBaUx0Qjs7Ozs7Ozs7O0FBU0FtQixZQTFMc0IsdUJBMExWbEIsVUExTFUsRUEwTEVDLFFBMUxGLEVBMExZO0FBQ2pDLE1BQU1ILGFBQWEsSUFBSWhTLFNBQVN3RSxHQUFULENBQWFxQixPQUFqQixDQUF5QnBELG1CQUFTa1AsV0FBVCxDQUFxQixJQUFyQixDQUF6QixDQUFuQjs7QUFFQUssYUFBV0ksU0FBWCxDQUFxQjtBQUNwQnRDLFNBQU1vQyxXQUFXLENBQVgsSUFBZ0IsSUFERjtBQUVwQmxDLFFBQUtrQyxXQUFXLENBQVgsSUFBZ0IsSUFGRDtBQUdwQkcsWUFBUyxDQUhXO0FBSXBCQyxrQkFBZTtBQUpLLEdBQXJCOztBQU9BTixhQUFXbFAsV0FBWCxDQUF1Qix3QkFBdkI7O0FBRUEsT0FBS2l5QixRQUFMLENBQWMsWUFBTTtBQUNuQi9pQixjQUFXaFEsUUFBWCxDQUFvQix1QkFBcEI7QUFDQWdRLGNBQVdoUSxRQUFYLENBQW9CLHNCQUFwQjtBQUNBZ1EsY0FBV0ksU0FBWCxDQUFxQjtBQUNwQnRDLFVBQU1xQyxTQUFTLENBQVQsSUFBYyxJQURBO0FBRXBCbkMsU0FBS21DLFNBQVMsQ0FBVCxJQUFjLElBRkM7QUFHcEJFLGFBQVM7QUFIVyxJQUFyQjs7QUFNQTtBQUNBckksY0FBVyxZQUFNO0FBQ2hCZ0ksZUFBV0ksU0FBWCxDQUFxQjtBQUNwQkUsb0JBQWU7QUFESyxLQUFyQjtBQUdBLElBSkQsRUFJRyxHQUpIO0FBS0EsR0FmRDtBQWdCQSxFQXROcUI7OztBQXdOdEI7Ozs7Ozs7QUFPQTBpQixLQS9Oc0Isa0JBK05mO0FBQ04sTUFBTXRqQixVQUFValAsbUJBQVNrUCxXQUFULENBQXFCLElBQXJCLENBQWhCO0FBQ0EsTUFBTW5NLFNBQVMsS0FBS21ELEtBQUwsQ0FBVzVJLE1BQVgsQ0FBa0JGLEdBQWxCLENBQXNCLFFBQXRCLENBQWY7O0FBRUEsTUFBTTJTLFlBQVloTixTQUFTQSxPQUFPZ04sU0FBaEIsR0FBNEIsQ0FBOUM7O0FBRUEsTUFBSSxDQUFDLEtBQUtDLFNBQUwsRUFBRCxJQUFxQmYsT0FBekIsRUFBa0M7QUFDakMsT0FBTWdCLG1CQUFtQixLQUFLbkQsbUJBQUwsRUFBekI7O0FBRUEsT0FBSW1ELGdCQUFKLEVBQXNCO0FBQ3JCLFFBQU1WLGFBQWEsSUFBSWhTLFNBQVN3RSxHQUFULENBQWFxQixPQUFqQixDQUF5QjZMLE9BQXpCLENBQW5COztBQUVBLFFBQUlpQixlQUFKO0FBQUEsUUFBWUMsZUFBWjtBQUFBLFFBQW9CQyxpQkFBcEI7QUFBQSxRQUE4QkMsaUJBQTlCOztBQUVBSCxhQUFTRSxXQUFXRSxXQUFXZixXQUFXM0UsUUFBWCxDQUFvQixNQUFwQixDQUFYLENBQXBCO0FBQ0F1RixhQUFTRSxXQUFXQyxXQUFXZixXQUFXM0UsUUFBWCxDQUFvQixLQUFwQixDQUFYLENBQXBCOztBQUVBLFFBQUksS0FBSzFFLEtBQUwsQ0FBV3FLLG1CQUFmLEVBQW9DO0FBQ25DLFNBQU1DLE1BQU0sS0FBS0Msc0JBQUwsQ0FBNEI7QUFDdkNDLGNBQVFKLFdBQVdyQixRQUFRRixZQUFuQixDQUQrQjtBQUV2QzFCLFlBQU02QyxNQUZpQztBQUd2QzNDLFdBQUs0QyxNQUhrQztBQUl2QzNDLGFBQU84QyxXQUFXckIsUUFBUUcsV0FBbkI7QUFKZ0MsTUFBNUIsQ0FBWjs7QUFPQWMsY0FBU00sSUFBSXBELENBQWI7QUFDQStDLGNBQVNLLElBQUlsRCxDQUFiO0FBQ0E7O0FBRUQsUUFDQzJDLGlCQUFpQmxELFNBQWpCLEtBQ0F4UCxTQUFTeVAsdUJBRlYsRUFHRTtBQUNEcUQsZ0JBQ0MsS0FBS25LLEtBQUwsQ0FBV3lILGFBQVgsQ0FBeUJJLE1BQXpCLENBQWdDaUIsTUFBaEMsR0FBeUNlLFNBRDFDO0FBRUEsS0FORCxNQU1PO0FBQ05NLGdCQUFXLEtBQUtuSyxLQUFMLENBQVd5SCxhQUFYLENBQXlCSSxNQUF6QixDQUFnQ1IsR0FBaEMsR0FBc0N3QyxTQUFqRDtBQUNBOztBQUVELFNBQUtZLFdBQUwsQ0FBaUIsQ0FBQ1AsUUFBRCxFQUFXQyxRQUFYLENBQWpCLEVBQXVDLENBQUNILE1BQUQsRUFBU0MsTUFBVCxDQUF2QztBQUNBO0FBQ0Q7QUFDRCxFQXpRcUI7OztBQTJRdEI7Ozs7Ozs7QUFPQXFpQixlQWxSc0IsNEJBa1JMO0FBQ2hCLE1BQU12aUIsbUJBQW1CLEtBQUtuRCxtQkFBTCxFQUF6Qjs7QUFFQSxNQUFNbUMsVUFBVWpQLG1CQUFTa1AsV0FBVCxDQUFxQixJQUFyQixDQUFoQjs7QUFFQSxNQUFJZSxvQkFBb0JoQixPQUF4QixFQUFpQztBQUNoQyxPQUFNbE0sU0FBUyxLQUFLbUQsS0FBTCxDQUFXNUksTUFBWCxDQUFrQkYsR0FBbEIsQ0FBc0IsUUFBdEIsS0FBbUN1RCxTQUFTcUMsSUFBM0Q7QUFDQSxPQUFNNE4sY0FBY0MsaUJBQWlCOU4sTUFBakIsQ0FBcEI7QUFDQSxPQUFNK04sbUJBQW1CQyxTQUN4QkgsWUFBWUksZ0JBQVosQ0FBNkIsYUFBN0IsQ0FEd0IsRUFFeEIsRUFGd0IsQ0FBekI7QUFJQSxPQUFNQyxvQkFBb0JGLFNBQ3pCSCxZQUFZSSxnQkFBWixDQUE2QixjQUE3QixDQUR5QixFQUV6QixFQUZ5QixDQUExQjtBQUlBLE9BQU1FLGFBQ0xKLG1CQUFtQi9OLE9BQU9vTyxXQUExQixHQUF3Q0YsaUJBRHpDOztBQUdBLE9BQU1sQixZQUFZaE4sT0FBT3FPLE9BQVAsS0FBbUIsTUFBbkIsR0FBNEJyTyxPQUFPZ04sU0FBbkMsR0FBK0MsQ0FBakU7O0FBRUEsT0FBTXNCLEtBQUssS0FBS0MsZ0JBQUwsQ0FDVnJCLGlCQUFpQjdDLENBRFAsRUFFVjZDLGlCQUFpQjNDLENBRlAsRUFHVjJDLGlCQUFpQmxELFNBSFAsQ0FBWDtBQUtBc0UsTUFBRyxDQUFILEtBQVN0QixTQUFUOztBQUVBLE9BQUlzQixHQUFHLENBQUgsSUFBUSxDQUFaLEVBQWU7QUFDZEEsT0FBRyxDQUFILElBQVEsQ0FBUjtBQUNBO0FBQ0QsT0FBSUEsR0FBRyxDQUFILElBQVFILGFBQWFqQyxRQUFRRyxXQUFqQyxFQUE4QztBQUM3Q2lDLE9BQUcsQ0FBSCxJQUFRSCxhQUFhakMsUUFBUUcsV0FBN0I7QUFDQTs7QUFFRCxPQUFJN1IsU0FBU3dFLEdBQVQsQ0FBYXFCLE9BQWpCLENBQXlCNkwsT0FBekIsRUFBa0NVLFNBQWxDLENBQTRDO0FBQzNDdEMsVUFBTWdFLEdBQUcsQ0FBSCxJQUFRLElBRDZCO0FBRTNDOUQsU0FBSzhELEdBQUcsQ0FBSCxJQUFRO0FBRjhCLElBQTVDO0FBSUE7QUFDRCxFQTFUcUI7OztBQTRUdEI7Ozs7Ozs7OztBQVNBaWhCLFNBclVzQixvQkFxVWJqckIsUUFyVWEsRUFxVUg7QUFDbEIsTUFBSTVHLE9BQU9xUCxxQkFBWCxFQUFrQztBQUNqQyxRQUFLbkQsaUJBQUwsR0FBeUJsTSxPQUFPcVAscUJBQVAsQ0FBNkJ6SSxRQUE3QixDQUF6QjtBQUNBLEdBRkQsTUFFTztBQUNOQTtBQUNBO0FBQ0Q7QUEzVXFCLENBQXZCLEMsQ0FqQkE7Ozs7O2tCQStWZTRxQixjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFWZjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBWEE7Ozs7O0FBYUE7Ozs7Ozs7SUFPTVEsRTs7O0FBR0w7Ozs7Ozs7O0FBaURBLGFBQVl2c0IsS0FBWixFQUFtQjtBQUFBOztBQUFBLHNHQUNaQSxLQURZOztBQUFBLFFBd09uQndzQixzQkF4T21CLEdBd09NLFlBQU07QUFDOUIsT0FBTXAxQixTQUFTLE1BQUs4SSxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFmOztBQUVBRSxVQUFPMlYsS0FBUDtBQUNBLEdBNU9rQjs7QUFHbEIsUUFBSzdILEtBQUwsR0FBYTtBQUNadW5CLFdBQVE7QUFESSxHQUFiO0FBSGtCO0FBTWxCOztBQUVEOzs7Ozs7Ozs7OztzQ0FPb0I7QUFBQTs7QUFDbkIsT0FBTXIxQixTQUFTLEtBQUs4SSxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFmOztBQUVBRSxVQUFPMkQsRUFBUCxDQUFVLG1CQUFWLEVBQStCLEtBQUsyeEIsb0JBQXBDLEVBQTBELElBQTFEO0FBQ0F0MUIsVUFBTzJELEVBQVAsQ0FBVSxpQkFBVixFQUE2QixLQUFLNHhCLGtCQUFsQyxFQUFzRCxJQUF0RDtBQUNBdjFCLFVBQU8yRCxFQUFQLENBQVUsS0FBVixFQUFpQixLQUFLNnhCLFlBQXRCLEVBQW9DLElBQXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQUtDLGtCQUFMLEdBQTBCLGlCQUFTO0FBQ2xDLFdBQUtDLFlBQUwsQ0FBa0I3eEIsTUFBTW9CLE1BQXhCO0FBQ0EsSUFGRDs7QUFJQSxRQUFLMHdCLGdCQUFMLEdBQXdCMTFCLFNBQVN5TyxLQUFULENBQWVrbkIsUUFBZixDQUN2QixrQkFBVTtBQUNULFdBQUtGLFlBQUwsQ0FBa0JyeUIsU0FBU3dULGFBQTNCO0FBQ0EsSUFIc0IsRUFJdkIsS0FBS2pPLEtBQUwsQ0FBV3ZCLFdBSlksRUFLdkIsSUFMdUIsQ0FBeEI7O0FBUUFoRSxZQUFTb2EsZ0JBQVQsQ0FBMEIsV0FBMUIsRUFBdUMsS0FBS2dZLGtCQUE1QztBQUNBcHlCLFlBQVNvYSxnQkFBVCxDQUEwQixTQUExQixFQUFxQyxLQUFLa1ksZ0JBQTFDO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7OztxQ0FTbUJFLFMsRUFBV0MsUyxFQUFXO0FBQ3hDLE9BQU1ua0IsVUFBVWpQLG1CQUFTa1AsV0FBVCxDQUFxQixJQUFyQixDQUFoQjs7QUFFQSxPQUFNNVIsU0FBUyxLQUFLOEksT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FBZjs7QUFFQSxPQUFJNlIsT0FBSixFQUFhO0FBQ1ozUixXQUFPdUUsSUFBUCxDQUFZLFlBQVosRUFBMEI7QUFDekJ3eEIsY0FBUyxLQUFLQyw0QkFBTCxDQUFrQ3JrQixPQUFsQztBQURnQixLQUExQjtBQUdBOztBQUVEM1IsVUFBT3VFLElBQVAsQ0FBWSxjQUFaLEVBQTRCO0FBQzNCc3hCLHdCQUQyQjtBQUUzQkMsd0JBRjJCO0FBRzNCbHRCLFdBQU8sS0FBS0EsS0FIZTtBQUkzQmtGLFdBQU8sS0FBS0E7QUFKZSxJQUE1QjtBQU1BOzs7eUNBRXNCbW9CLFUsRUFBWTtBQUNsQyxPQUFJLENBQUMsS0FBS0Msb0JBQVYsRUFBZ0M7QUFDL0IsU0FBS0Esb0JBQUwsR0FBNEIsRUFBNUI7QUFDQTs7QUFFRCxPQUFJLENBQUMsS0FBS0Esb0JBQUwsQ0FBMEJELFVBQTFCLENBQUwsRUFBNEM7QUFDM0MsU0FBS0Msb0JBQUwsQ0FBMEJELFVBQTFCLElBQXdDLElBQUloMkIsU0FBU2syQixRQUFiLENBQ3ZDLEtBQUtDLGVBQUwsR0FBdUJILFVBQXZCLENBRHVDLENBQXhDO0FBR0E7O0FBRUQsVUFBTyxLQUFLQyxvQkFBTCxDQUEwQkQsVUFBMUIsQ0FBUDtBQUNBOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7OztvQ0Fja0I7QUFDakIsVUFDQyxLQUFLcnRCLEtBQUwsQ0FBV3l0QixXQUFYLElBQTBCO0FBQ3pCQyxlQUFXbjBCLFlBQVk2SCxPQUFaLENBQW9CdXNCLG1CQUROO0FBRXpCQyxnQkFBWXIwQixZQUFZNkgsT0FBWixDQUFvQnlzQixvQkFGUDtBQUd6QkMsa0JBQWN2MEIsWUFBWTZILE9BQVosQ0FBb0Iyc0I7QUFIVCxJQUQzQjtBQU9BOztBQUVEOzs7Ozs7Ozs7Ozs7OytDQVU2QmhsQixPLEVBQVM7QUFDckMsT0FBTWlsQixtQkFBbUJqbEIsUUFBUTJHLGdCQUFSLENBQXlCLGtCQUF6QixDQUF6Qjs7QUFFQSxPQUFJLENBQUNzZSxpQkFBaUIvMEIsTUFBdEIsRUFBOEI7QUFDN0IsV0FBTyxLQUFLdTBCLGVBQUwsR0FBdUJFLFNBQTlCO0FBQ0EsSUFGRCxNQUVPO0FBQ04sUUFBTU8sZUFBZXppQixNQUFNb0UsU0FBTixDQUFnQjNPLEtBQWhCLENBQ25CbkssSUFEbUIsQ0FDZGszQixnQkFEYyxFQUVuQmxpQixHQUZtQixDQUVmLG1CQUFXO0FBQ2YsWUFBT29pQixRQUFRbmUsWUFBUixDQUFxQixZQUFyQixDQUFQO0FBQ0EsS0FKbUIsQ0FBckI7O0FBTUEsUUFBTXNkLGFBQ0xZLGFBQWFoMUIsTUFBYixLQUF3QixDQUF4QixHQUE0QixZQUE1QixHQUEyQyxjQUQ1Qzs7QUFHQSxXQUFPLEtBQUtrMUIsc0JBQUwsQ0FBNEJkLFVBQTVCLEVBQXdDZSxNQUF4QyxDQUErQztBQUNyRDUyQixlQUFVeTJCLGFBQ1JJLElBRFEsQ0FDSCxHQURHLEVBRVI3MUIsT0FGUSxDQUVBLFdBRkEsRUFFYSxVQUFVLElBRnZCO0FBRDJDLEtBQS9DLENBQVA7QUFLQTtBQUNEOztBQUVEOzs7Ozs7Ozs7O3lDQU91QjtBQUN0QixPQUFJLEtBQUtxMEIsa0JBQVQsRUFBNkI7QUFDNUJweUIsYUFBUzZ6QixtQkFBVCxDQUE2QixXQUE3QixFQUEwQyxLQUFLekIsa0JBQS9DO0FBQ0E7O0FBRUQsT0FBSSxLQUFLRSxnQkFBVCxFQUEyQjtBQUMxQixTQUFLQSxnQkFBTCxDQUFzQndCLE1BQXRCO0FBQ0E5ekIsYUFBUzZ6QixtQkFBVCxDQUE2QixTQUE3QixFQUF3QyxLQUFLdkIsZ0JBQTdDO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7OzJCQVNTO0FBQUE7O0FBQ1IsT0FBSSxLQUFLN25CLEtBQUwsQ0FBV3VuQixNQUFmLEVBQXVCO0FBQ3RCLFdBQU8sSUFBUDtBQUNBOztBQUVELE9BQUlqMUIsV0FBV3NCLE9BQU9DLElBQVAsQ0FBWSxLQUFLaUgsS0FBTCxDQUFXeEksUUFBdkIsRUFBaUNzVSxHQUFqQyxDQUFxQyxtQkFBVztBQUM5RCxXQUFPdlMsWUFBWWlLLFFBQVosQ0FBcUIwcUIsT0FBckIsS0FBaUMzekIsT0FBTzJ6QixPQUFQLENBQXhDO0FBQ0EsSUFGYyxDQUFmOztBQUlBMTJCLGNBQVcsS0FBS29VLGVBQUwsQ0FBcUJwVSxRQUFyQixFQUErQnNVLEdBQS9CLENBQW1DLG1CQUFXO0FBQ3hELFFBQU05TCxRQUFRLE9BQUtpTSxtQkFBTCxDQUNiO0FBQ0N0VixhQUFRLE9BQUtxSixLQUFMLENBQVd4SSxRQUFYLENBQW9CMDJCLFFBQVEvdEIsR0FBNUIsQ0FEVDtBQUVDL0ksYUFBUSxPQUFLOEksT0FBTCxDQUFhOUksTUFGdEI7QUFHQ29RLGtCQUFhLE9BQUt0QyxLQUFMLENBQVdzQyxXQUh6QjtBQUlDckgsVUFBSyt0QixRQUFRL3RCLEdBSmQ7QUFLQ3FPLGdCQUFXLE9BQUtnZSxzQkFMakI7QUFNQy9rQixvQkFBZSxPQUFLdkMsS0FBTCxDQUFXdUM7QUFOM0IsS0FEYSxFQVNieW1CLFFBQVEvdEIsR0FUSyxDQUFkOztBQVlBLFdBQU9SLGdCQUFNaEQsYUFBTixDQUFvQnV4QixPQUFwQixFQUE2Qmx1QixLQUE3QixDQUFQO0FBQ0EsSUFkVSxDQUFYOztBQWdCQSxVQUNDO0FBQUE7QUFBQSxNQUFLLFdBQVUsYUFBZixFQUE2QixXQUFXLEtBQUtvTyxTQUE3QztBQUNFNVc7QUFERixJQUREO0FBS0E7O0FBRUQ7Ozs7Ozs7Ozs7OztxQ0FTbUJnM0IsTSxFQUFRO0FBQzFCLE9BQU1wM0IsU0FBUyxLQUFLOEksT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FBZjs7QUFFQUUsVUFBTzJWLEtBQVA7O0FBRUEsUUFBS0YsUUFBTCxDQUFjO0FBQ2JLLG1CQUFlLElBREY7QUFFYnpGLG1CQUFlclEsT0FBT3EzQixnQkFBUDtBQUZGLElBQWQ7QUFJQTs7QUFFRDs7Ozs7Ozs7Ozs7OztBQWNBOzs7Ozs7Ozs7O3VDQVVxQnh6QixLLEVBQU87QUFDM0IsUUFBSzRSLFFBQUwsQ0FBYztBQUNickYsaUJBQWF2TSxLQURBO0FBRWJ3eEIsWUFBUSxLQUZLO0FBR2J2ZixtQkFBZSxJQUhGO0FBSWJ6RixtQkFBZXhNLE1BQU1FLElBQU4sQ0FBV3NNO0FBSmIsSUFBZDtBQU1BOztBQUVEOzs7Ozs7Ozs7OzsrQkFRYXhNLEssRUFBTztBQUNuQixPQUFNeU0sY0FBY3pNLE1BQU1FLElBQU4sQ0FBV3V6QixRQUFYLENBQW9CaDBCLENBQXhDOztBQUVBLE9BQUlnTixZQUFZaW5CLE1BQVosSUFBc0JqbkIsWUFBWXNILE9BQVosS0FBd0IsR0FBbEQsRUFBdUQ7QUFDdEQsU0FBS2pDLEtBQUw7QUFDQTtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7OytCQVVhMVEsTSxFQUFRO0FBQ3BCLE9BQU0wTSxVQUFValAsbUJBQVNrUCxXQUFULENBQXFCLElBQXJCLENBQWhCOztBQUVBLE9BQUlELE9BQUosRUFBYTtBQUNaLFFBQU1wUSxXQUFXLEtBQUt1SCxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixFQUF3Q3lCLFFBQXhDLEVBQWpCO0FBQ0EsUUFBTXFCLGFBQWFxQyxPQUFPckMsVUFBMUI7QUFDQSxRQUFNNDBCLGFBQWEsSUFBSXYzQixTQUFTd0UsR0FBVCxDQUFhNUUsSUFBakIsQ0FBc0JvRixNQUF0QixDQUFuQjs7QUFFQSxRQUFJLENBQUMxRCxRQUFMLEVBQWU7QUFDZCxVQUFLa1UsUUFBTCxDQUFjO0FBQ2I0ZixjQUFRO0FBREssTUFBZDtBQUdBLEtBSkQsTUFJTztBQUNOLFNBQUluaUIsTUFDSDNSLFNBQVMrQixDQUFULEtBQWUyQixNQUFmLElBQ0ExRCxTQUFTazJCLFFBQVQsQ0FBa0JELFVBQWxCLENBREEsSUFFQSxJQUFJdjNCLFNBQVN3RSxHQUFULENBQWFxQixPQUFqQixDQUF5QjZMLE9BQXpCLEVBQWtDOGxCLFFBQWxDLENBQTJDRCxVQUEzQyxDQUhEOztBQUtBLFNBQUk1MEIsVUFBSixFQUFnQjtBQUNmc1EsWUFBTUEsT0FBT3RRLFdBQVdvRSxFQUFYLEtBQWtCLFVBQS9CO0FBQ0E7O0FBRUQsU0FBSSxDQUFDa00sR0FBTCxFQUFVO0FBQ1QsV0FBS3VDLFFBQUwsQ0FBYztBQUNiNGYsZUFBUTtBQURLLE9BQWQ7QUFHQTtBQUNEO0FBQ0Q7QUFDRDs7OztFQTVXZTlzQixnQkFBTVMsUzs7QUErV3ZCOzs7Ozs7O0FBT0E7Ozs7Ozs7Ozs7O0FBdFhNbXNCLEUsQ0FDRXhuQixXLEdBQWNyRix1QjtBQURoQjZzQixFLENBV0VsZ0IsWSxHQUFlO0FBQ3JCOEMsV0FBVSxJQURXO0FBRXJCTSxjQUFhLHNCQUZRO0FBR3JCaFIsY0FBYSxDQUhRO0FBSXJCMUYsT0FBTTtBQUNMcVcsUUFBTTtBQUREO0FBSmUsQztBQVhqQm1kLEUsQ0FvQkUzWixTLEdBQVk7QUFDbEI7Ozs7Ozs7Ozs7QUFVQTZhLGNBQWE1YSxvQkFBVUssTUFYTDs7QUFhbEI7Ozs7Ozs7QUFPQXpVLGNBQWFvVSxvQkFBVU0sTUFwQkw7O0FBc0JsQjs7Ozs7OztBQU9BM2IsV0FBVXFiLG9CQUFVSyxNQUFWLENBQWlCb1g7QUE3QlQsQztrQkE2V0wsK0JBQWdCLGtDQUFtQmlDLEVBQW5CLENBQWhCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaFpmOzs7O0FBQ0E7Ozs7OztrTkFOQTs7Ozs7c0ZBU0V1QyxxQkFBVzN1QixHLEVBQU0ydUIsb0IsMENBQ2pCQyx3QkFBYzV1QixHLEVBQU00dUIsdUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTHRCOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBYkE7Ozs7O0FBZUEsSUFBTUMsZ0JBQWdCLENBQXRCO0FBQ0EsSUFBTUMsaUJBQWlCLENBQXZCOztBQUVBOzs7Ozs7Ozs7O0lBU01ILFU7OztBQUdMLHFCQUFZOXVCLEtBQVosRUFBbUI7QUFBQTs7QUFBQSxzSEFDWkEsS0FEWTs7QUFHbEIsUUFBS2tGLEtBQUwsR0FBYSxFQUFiO0FBSGtCO0FBSWxCOztBQUVEOzs7Ozs7Ozs7Ozs7c0NBUW9CO0FBQ25CLFFBQUtncUIsZUFBTDtBQUNBOztBQUVEOzs7Ozs7Ozs7Ozs7O3FDQVVtQkMsVSxFQUFZQyxVLEVBQVk7QUFDMUMsUUFBS0YsZUFBTDs7QUFFQTtBQUNBO0FBQ0EsT0FBSSxLQUFLbHZCLEtBQUwsQ0FBV3NOLGVBQWYsRUFBZ0M7QUFDL0IsU0FBS1AsS0FBTDtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7OzsyQkFTUztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDQyxDQUFDLEtBQUs3SCxLQUFMLENBQVdnSSxhQUFaLElBQ0EsS0FBS2xOLEtBQUwsQ0FBV3dILFdBRFgsSUFFQSxLQUFLeEgsS0FBTCxDQUFXd0gsV0FBWCxDQUF1QnJNLElBQXZCLENBQTRCdU0sV0FBNUIsQ0FBd0NyTCxNQUZ4QyxJQUdBLENBQUMsS0FBSzJELEtBQUwsQ0FBV3dILFdBQVgsQ0FBdUJyTSxJQUF2QixDQUE0QnVNLFdBQTVCLENBQXdDckwsTUFBeEMsQ0FBK0NnekIsaUJBSmpELEVBS0U7QUFDRCxXQUFPLElBQVA7QUFDQTs7QUFFRCxPQUFNandCLFVBQVUsS0FBS2t3QixXQUFMLEVBQWhCO0FBQ0EsT0FBTTF5QixZQUFZLEtBQUsyeUIsb0JBQUwsRUFBbEI7O0FBRUEsVUFDQztBQUFBO0FBQUE7QUFDQyxtQkFBWWgyQixZQUFZNkgsT0FBWixDQUFvQmpDLEdBRGpDO0FBRUMsZ0JBQVd2QyxTQUZaO0FBR0Msc0JBQWUsS0FBS29ELEtBQUwsQ0FBV3JKLE1BQVgsQ0FBa0IwSSxRQUFsQixJQUE4QixDQUg5QztBQUlDLGNBQVMsS0FBSzBOLEtBQUwsQ0FBV3JULElBQVgsQ0FBZ0IsSUFBaEIsQ0FKVjtBQUtDLGdCQUFXLEtBQUswVSxTQUFMLENBQWUxVSxJQUFmLENBQW9CLElBQXBCLENBTFo7QUFNQyxXQUFLLFNBTk47QUFPQyxlQUFTLElBUFY7QUFRQztBQUFBO0FBQUEsT0FBSyxXQUFVLGNBQWY7QUFBK0IwRjtBQUEvQjtBQVJELElBREQ7QUFZQTs7QUFFRDs7Ozs7Ozs7Ozs7O2dDQVNjO0FBQ2IsT0FBSUEsZ0JBQUo7O0FBRUEsT0FBSSxLQUFLWSxLQUFMLENBQVdzTixlQUFmLEVBQWdDO0FBQy9CbE8sY0FBVSxLQUFLcU0saUJBQUwsQ0FBdUIsS0FBS3pMLEtBQUwsQ0FBV3JKLE1BQVgsQ0FBa0J5SSxPQUF6QyxDQUFWO0FBQ0EsSUFGRCxNQUVPO0FBQ04sUUFBSSxLQUFLWSxLQUFMLENBQVd5SCxhQUFYLElBQTRCLEtBQUt6SCxLQUFMLENBQVd5SCxhQUFYLENBQXlCSSxNQUF6RCxFQUFpRTtBQUNoRXpJLGVBQ0M7QUFBQTtBQUFBO0FBQ0MscUJBQVk3RixZQUFZNkgsT0FBWixDQUFvQmpDLEdBRGpDO0FBRUMsa0JBQVUseUJBRlg7QUFHQyxnQkFBUyxLQUFLYSxLQUFMLENBQVdpTixnQkFBWCxDQUE0QnZULElBQTVCLENBQ1IsSUFEUSxFQUVSbzFCLFdBQVczdUIsR0FGSCxDQUhWO0FBT0MsY0FBTzVHLFlBQVk2SCxPQUFaLENBQW9CakMsR0FQNUI7QUFRQyxvQ0FBQyxvQkFBRCxJQUFZLFFBQU8sTUFBbkI7QUFSRCxNQUREO0FBWUE7QUFDRDs7QUFFRCxVQUFPQyxPQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7Ozt5Q0FTdUI7QUFDdEIsT0FBSWtVLFdBQVcsZ0JBQWY7O0FBRUEsT0FBSSxLQUFLdFQsS0FBTCxDQUFXc04sZUFBZixFQUFnQztBQUMvQmdHLGVBQVcsZ0JBQWdCLEtBQUtnWSxrQkFBTCxFQUEzQjtBQUNBOztBQUVELFVBQU9oWSxRQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7O29DQVFrQjtBQUNqQixPQUFJekwsZUFBSjs7QUFFQTtBQUNBLE9BQUksQ0FBQy9OLG1CQUFTa1AsV0FBVCxDQUFxQixJQUFyQixDQUFMLEVBQWlDO0FBQ2hDO0FBQ0E7O0FBRUQsT0FBSSxLQUFLaEosS0FBTCxDQUFXc04sZUFBZixFQUFnQztBQUMvQixTQUFLZ2YsY0FBTDtBQUNBLFNBQUtELElBQUw7QUFDQSxJQUhELE1BR087QUFDTixRQUFJLEtBQUtyc0IsS0FBTCxDQUFXeUgsYUFBZixFQUE4QjtBQUM3QkksY0FBUyxLQUFLN0gsS0FBTCxDQUFXeUgsYUFBWCxDQUF5QkksTUFBbEM7QUFDQTs7QUFFRCxRQUFJQSxNQUFKLEVBQVk7QUFDWCxTQUFNa0IsVUFBVWpQLG1CQUFTa1AsV0FBVCxDQUFxQixJQUFyQixDQUFoQjs7QUFFQSxTQUFNSyxhQUFhLElBQUloUyxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUI2TCxPQUF6QixDQUFuQjs7QUFFQSxTQUFNaEIsWUFBWUYsT0FBT0UsU0FBUCxJQUFvQkYsTUFBdEM7O0FBRUEsU0FBTTNOLGVBQWUsS0FBS2dHLE9BQUwsQ0FBYTlJLE1BQWIsQ0FBb0JGLEdBQXBCLENBQXdCLGNBQXhCLENBQXJCOztBQUVBLFNBQU1zNEIsYUFBYXQxQixhQUFhdkIsUUFBYixHQUF3QjgyQixhQUF4QixFQUFuQjs7QUFFQSxTQUFJQyxtQkFBSjs7QUFFQSxTQUFNQyxXQUNMLEtBQUszdkIsS0FBTCxDQUFXckosTUFBWCxDQUFrQmc1QixRQUFsQixJQUE4QixLQUFLM3ZCLEtBQUwsQ0FBVzJ2QixRQUQxQzs7QUFHQSxTQUFJQSxhQUFhWCxhQUFqQixFQUFnQztBQUMvQlUsbUJBQ0NGLFdBQVdyb0IsSUFBWCxHQUNBNEIsUUFBUUcsV0FEUixHQUVBLEtBQUtsSixLQUFMLENBQVc0dkIsZUFBWCxDQUEyQnpvQixJQUYzQixHQUdBLElBSkQ7QUFLQSxNQU5ELE1BTU87QUFDTnVvQixtQkFDQ0YsV0FBV2puQixLQUFYLEdBQ0EsS0FBS3ZJLEtBQUwsQ0FBVzR2QixlQUFYLENBQTJCem9CLElBRDNCLEdBRUEsSUFIRDtBQUlBOztBQUVENEIsYUFBUTlDLEtBQVIsQ0FBY2tCLElBQWQsR0FBcUJ1b0IsVUFBckI7O0FBRUEzbUIsYUFBUTlDLEtBQVIsQ0FBY29CLEdBQWQsR0FDQ2EsS0FBSzJuQixLQUFMLENBQVcsQ0FBQ2hvQixPQUFPaUIsTUFBUCxHQUFnQmpCLE9BQU9SLEdBQXhCLElBQStCLENBQTFDLElBQStDLElBRGhEOztBQUdBLFNBQU14SyxTQUFTLEtBQUtxRCxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixRQUF4QixDQUFmOztBQUVBLFNBQU0yUyxZQUFZaE4sU0FBU0EsT0FBT2dOLFNBQWhCLEdBQTRCLENBQTlDOztBQUVBLFNBQUkzUCxhQUFhZ0QsT0FBYixDQUFxQndILFFBQXJCLENBQThCLFVBQTlCLE1BQThDLE1BQWxELEVBQTBEO0FBQ3pEcUUsY0FBUTlDLEtBQVIsQ0FBY29CLEdBQWQsR0FDQ2EsS0FBSzJuQixLQUFMLENBQ0Nob0IsT0FBT1IsR0FBUCxHQUNDMEIsUUFBUUYsWUFBUixHQUF1QixDQUR4QixHQUVDZCxVQUFVeUMsTUFBVixHQUFtQixDQUZwQixHQUdDWCxTQUpGLElBS0ksSUFOTDtBQU9BLE1BUkQsTUFRTztBQUNOZCxjQUFROUMsS0FBUixDQUFjb0IsR0FBZCxHQUNDYSxLQUFLMm5CLEtBQUwsQ0FDQzMxQixhQUFhZ0QsT0FBYixDQUFxQnhDLENBQXJCLENBQXVCa08sU0FBdkIsR0FDQ2IsVUFBVXlDLE1BQVYsR0FBbUIsQ0FEcEIsR0FFQ3pCLFFBQVFGLFlBQVIsR0FBdUIsQ0FIekIsSUFJSSxJQUxMO0FBTUE7O0FBRURFLGFBQVE5QyxLQUFSLENBQWN5RCxPQUFkLEdBQXdCLENBQXhCOztBQUVBTCxnQkFBV2xQLFdBQVgsQ0FBdUIsY0FBdkI7O0FBRUEsVUFBSyt4QixlQUFMO0FBQ0E7QUFDRDtBQUNEOzs7O0VBL051QnZzQixnQkFBTVMsUzs7QUFrTy9COzs7Ozs7Ozs7O0FBbE9NMHVCLFUsQ0FDRS9wQixXLEdBQWNyRix1QjtBQXlPdEJvdkIsV0FBVzN1QixHQUFYLEdBQWlCLEtBQWpCOztBQUVBOzs7Ozs7OztBQVFBMnVCLFdBQVczbkIsSUFBWCxHQUFrQjZuQixhQUFsQjs7QUFFQTs7Ozs7Ozs7QUFRQUYsV0FBV3ZtQixLQUFYLEdBQW1CMG1CLGNBQW5COztBQUVBOzs7Ozs7OztBQVFBSCxXQUFXemlCLFlBQVgsR0FBMEI7QUFDekI4QyxXQUFVLElBRGU7QUFFekJNLGNBQWEsWUFGWTtBQUd6Qm1nQixrQkFBaUI7QUFDaEJ6b0IsUUFBTSxFQURVO0FBRWhCRSxPQUFLO0FBRlcsRUFIUTtBQU96QnRPLE9BQU07QUFDTDhWLFdBQVMsQ0FBQyxFQUFELENBREo7QUFFTE8sUUFBTSxDQUFDLEVBQUQsRUFBSyxFQUFMLENBRkQ7QUFHTEMsUUFBTSxDQUFDLEVBQUQsRUFBSyxFQUFMO0FBSEQsRUFQbUI7QUFZekJzZ0IsV0FBVVg7QUFaZSxDQUExQjs7a0JBZWUsOEJBQ2QsK0JBQWdCLGtDQUFtQiw4QkFBZUYsVUFBZixDQUFuQixDQUFoQixDQURjLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3U2Y7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFiQTs7Ozs7QUFlQTs7Ozs7Ozs7O0lBU01DLGE7OztBQUdMLHdCQUFZL3VCLEtBQVosRUFBbUI7QUFBQTs7QUFBQSw0SEFDWkEsS0FEWTs7QUFHbEIsUUFBS2tGLEtBQUwsR0FBYSxFQUFiO0FBSGtCO0FBSWxCOztBQUVEOzs7Ozs7Ozs7Ozs7c0NBUW9CO0FBQ25CLFFBQUtncUIsZUFBTDtBQUNBOztBQUVEOzs7Ozs7Ozs7Ozs7O3FDQVVtQkMsVSxFQUFZQyxVLEVBQVk7QUFDMUMsUUFBS0YsZUFBTDtBQUNBOztBQUVEOzs7Ozs7Ozs7Ozs7MkJBU1M7QUFDUixPQUFNWSxtQkFBbUIsS0FBS0Msb0JBQUwsRUFBekI7O0FBRUEsT0FBSUQsZ0JBQUosRUFBc0I7QUFDckIsUUFBTUUsdUJBQXVCLEtBQUtDLHFCQUFMLENBQzVCSCxpQkFBaUJ4RSxrQkFEVyxDQUE3QjtBQUdBLFFBQUkza0Isd0JBQUo7O0FBRUEsUUFBSXFwQixvQkFBSixFQUEwQjtBQUN6QnJwQix1QkFBa0JxcEIsc0JBQWxCO0FBQ0EsS0FGRCxNQUVPO0FBQ05ycEIsdUJBQWtCLEtBQUsya0Isa0JBQUwsRUFBbEI7QUFDQTs7QUFFRCxRQUFNNEUsYUFBYSx1QkFBdUJ2cEIsZUFBMUM7O0FBRUEsUUFBSXZILFVBQVUwd0IsaUJBQWlCMXdCLE9BQS9COztBQUVBLFFBQUksUUFBT0EsT0FBUCx5Q0FBT0EsT0FBUCxPQUFtQixRQUFuQixJQUErQixDQUFDb00sTUFBTXJOLE9BQU4sQ0FBY2lCLE9BQWQsQ0FBcEMsRUFBNEQ7QUFDM0RBLGVBQ0NBLFFBQVEsS0FBS2MsT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsTUFBeEIsQ0FBUixLQUNBa0ksUUFBUSxRQUFSLENBRkQ7QUFHQTs7QUFFRCxRQUFNK3dCLGVBQWUsS0FBSy9FLHNCQUFMLENBQTRCaHNCLE9BQTVCLEVBQXFDO0FBQ3pEaVosc0JBQWlCLEtBQUtyWSxLQUFMLENBQVd3SCxXQUFYLEdBQ2QsS0FBS3hILEtBQUwsQ0FBV3dILFdBQVgsQ0FBdUJyTSxJQUF2QixDQUE0QmtkLGVBRGQsR0FFZCxJQUhzRDtBQUl6RCtYLG9CQUFlTixpQkFBaUJ4cUI7QUFKeUIsS0FBckMsQ0FBckI7O0FBT0EsUUFBTStxQixZQUNMRixhQUFhdGtCLE1BQWIsQ0FBb0Isa0JBQVU7QUFDN0IsWUFBT0wsTUFBTXJOLE9BQU4sQ0FBY29OLE1BQWQsQ0FBUDtBQUNBLEtBRkQsRUFFR3RTLE1BRkgsR0FFWSxDQUhiOztBQUtBLFFBQUkyRCxZQUFZLGNBQWhCOztBQUVBLFFBQUl5ekIsU0FBSixFQUFlO0FBQ2R6ekIsa0JBQWEsc0JBQWI7QUFDQTs7QUFFRCxXQUNDO0FBQUE7QUFBQTtBQUNDLG9CQUFZckQsWUFBWTZILE9BQVosQ0FBb0I5QixNQURqQztBQUVDLGlCQUFXNHdCLFVBRlo7QUFHQyx1QkFBZSxLQUFLbHdCLEtBQUwsQ0FBV3JKLE1BQVgsQ0FBa0IwSSxRQUFsQixJQUE4QixDQUg5QztBQUlDLGVBQVMsS0FBSzBOLEtBQUwsQ0FBV3JULElBQVgsQ0FBZ0IsSUFBaEIsQ0FKVjtBQUtDLGlCQUFXLEtBQUswVSxTQUFMLENBQWUxVSxJQUFmLENBQW9CLElBQXBCLENBTFo7QUFNQyxZQUFLLFNBTk47QUFPQyxnQkFBUyxJQVBWO0FBUUM7QUFBQTtBQUFBLFFBQUssV0FBV2tELFNBQWhCO0FBQ0V1ekIsbUJBQWFya0IsR0FBYixDQUFpQixVQUFDMVAsS0FBRCxFQUFRNFAsS0FBUixFQUFrQjtBQUNuQyxXQUFJUixNQUFNck4sT0FBTixDQUFjL0IsS0FBZCxDQUFKLEVBQTBCO0FBQ3pCLGVBQ0M7QUFBQTtBQUFBLFdBQUssV0FBVSxRQUFmLEVBQXdCLEtBQUs0UCxLQUE3QjtBQUNFNVAsZUFBTTBQLEdBQU4sQ0FBVSxrQkFBVTtBQUNwQixpQkFBT1AsTUFBUDtBQUNBLFVBRkE7QUFERixTQUREO0FBT0EsUUFSRCxNQVFPO0FBQ04sZUFBT25QLEtBQVA7QUFDQTtBQUNELE9BWkE7QUFERjtBQVJELEtBREQ7QUEwQkE7O0FBRUQsVUFBTyxJQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7d0NBVXNCazBCLFcsRUFBYTtBQUNsQyxPQUFJQywwQkFBSjs7QUFFQSxPQUFJdDRCLGVBQUsrRixVQUFMLENBQWdCc3lCLFdBQWhCLENBQUosRUFBa0M7QUFDakNDLHdCQUFvQkQsV0FBcEI7QUFDQSxJQUZELE1BRU8sSUFBSXI0QixlQUFLb0YsUUFBTCxDQUFjaXpCLFdBQWQsQ0FBSixFQUFnQztBQUN0QyxRQUFNM3VCLFFBQVEydUIsWUFBWXBxQixLQUFaLENBQWtCLEdBQWxCLENBQWQ7QUFDQSxRQUFJQyxnQkFBZ0I1TCxNQUFwQjtBQUNBLFFBQUk2TCxXQUFXekUsTUFBTTBFLEtBQU4sRUFBZjs7QUFFQSxXQUNDRCxZQUNBbk8sZUFBS3VGLFFBQUwsQ0FBYzJJLGFBQWQsQ0FEQSxJQUVBbE8sZUFBS3VGLFFBQUwsQ0FBYzJJLGNBQWNDLFFBQWQsQ0FBZCxDQUhELEVBSUU7QUFDREQscUJBQWdCQSxjQUFjQyxRQUFkLENBQWhCO0FBQ0FBLGdCQUFXekUsTUFBTTBFLEtBQU4sRUFBWDtBQUNBOztBQUVELFFBQUlwTyxlQUFLK0YsVUFBTCxDQUFnQm1JLGFBQWhCLENBQUosRUFBb0M7QUFDbkNvcUIseUJBQW9CcHFCLGFBQXBCO0FBQ0E7QUFDRDs7QUFFRCxVQUFPb3FCLGlCQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7Ozt5Q0FTdUI7QUFDdEIsT0FBTWhwQixlQUFlLEtBQUt2SCxLQUFMLENBQVd3SCxXQUFYLEdBQ2xCLEtBQUt4SCxLQUFMLENBQVd3SCxXQUFYLENBQXVCck0sSUFETCxHQUVsQixJQUZIO0FBR0EsT0FBSVIsa0JBQUo7O0FBRUEsT0FBSTRNLFlBQUosRUFBa0I7QUFDakIsU0FBS3ZILEtBQUwsQ0FBV3JKLE1BQVgsQ0FBa0I0SSxVQUFsQixDQUE2QjZRLElBQTdCLENBQWtDLFVBQVNoRCxJQUFULEVBQWU7QUFDaEQsU0FBTW9qQixTQUFTLEtBQUtQLHFCQUFMLENBQTJCN2lCLEtBQUs3SyxJQUFoQyxDQUFmO0FBQ0EsU0FBSWtaLGVBQUo7O0FBRUEsU0FBSStVLE1BQUosRUFBWTtBQUNYL1UsZUFDQ2xVLGFBQWE4USxlQUFiLEtBQWlDakwsS0FBSzlILElBQXRDLElBQ0FrckIsT0FBTztBQUNOcjFCLGFBQU1vTSxZQURBO0FBRU5uUSxlQUFRLEtBQUs4SSxPQUFMLENBQWE5STtBQUZmLE9BQVAsQ0FGRDtBQU1BOztBQUVELFNBQUlxa0IsTUFBSixFQUFZO0FBQ1g5Z0Isa0JBQVl5UyxJQUFaO0FBQ0E7O0FBRUQsWUFBT3FPLE1BQVA7QUFDQSxLQWxCRCxFQWtCRyxJQWxCSDtBQW1CQTs7QUFFRCxVQUFPOWdCLFNBQVA7QUFDQTs7QUFFRDs7Ozs7Ozs7Ozs7b0NBUWtCO0FBQ2pCO0FBQ0EsT0FBSSxDQUFDYixtQkFBU2tQLFdBQVQsQ0FBcUIsSUFBckIsQ0FBTCxFQUFpQztBQUNoQztBQUNBOztBQUVELE9BQU04bUIsbUJBQW1CLEtBQUtDLG9CQUFMLEVBQXpCO0FBQ0EsT0FBSXRVLGVBQUo7O0FBRUE7QUFDQTtBQUNBLE9BQUlxVSxnQkFBSixFQUFzQjtBQUNyQixRQUFNVyxnQkFBZ0IsS0FBS1IscUJBQUwsQ0FDckJILGlCQUFpQlksV0FESSxDQUF0Qjs7QUFJQSxRQUFJRCxhQUFKLEVBQW1CO0FBQ2xCaFYsY0FBU2dWLGNBQWMzNUIsSUFBZCxDQUFtQixJQUFuQixFQUF5QjtBQUNqQ00sY0FBUSxLQUFLOEksT0FBTCxDQUFhOUksTUFEWTtBQUVqQ29RLG1CQUFhLEtBQUt4SCxLQUFMLENBQVd3SCxXQUZTO0FBR2pDQyxxQkFBZSxLQUFLekgsS0FBTCxDQUFXeUg7QUFITyxNQUF6QixDQUFUO0FBS0E7QUFDRDs7QUFFRCxPQUFJLENBQUNnVSxNQUFMLEVBQWE7QUFDWixTQUFLNlEsY0FBTDtBQUNBLFNBQUtELElBQUw7QUFDQTtBQUNEOzs7O0VBeE8wQjFzQixnQkFBTVMsUzs7QUEyT2xDOzs7Ozs7Ozs7O0FBM09NMnVCLGEsQ0FDRWhxQixXLEdBQWNyRix1QjtBQWtQdEJxdkIsY0FBYzFpQixZQUFkLEdBQTZCO0FBQzVCOEMsV0FBVSxJQURrQjtBQUU1Qk0sY0FBYSw0REFGZTtBQUc1QjFXLE9BQU07QUFDTDhWLFdBQVMsQ0FBQyxFQUFELENBREo7QUFFTE8sUUFBTSxDQUFDLEVBQUQsRUFBSyxFQUFMLENBRkQ7QUFHTEMsUUFBTSxDQUFDLEVBQUQsRUFBSyxFQUFMO0FBSEQ7QUFIc0IsQ0FBN0I7O0FBVUE7Ozs7Ozs7O0FBUUEwZixjQUFjNXVCLEdBQWQsR0FBb0IsUUFBcEI7O2tCQUVlLDhCQUNkLCtCQUFnQixrQ0FBbUIsOEJBQWU0dUIsYUFBZixDQUFuQixDQUFoQixDQURjLEM7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxUmY7Ozs7QUFFQTs7Ozs7Ozs7OzsrZUFQQTs7Ozs7QUFTQTtBQUNBLElBQUksQ0FBQzEzQixTQUFTcW5CLE9BQVQsQ0FBaUJ4bkIsR0FBakIsQ0FBcUIsaUJBQXJCLENBQUwsRUFBOEM7QUFDN0MsS0FBTXk1QixjQUFjLEVBQXBCOztBQUVBOzs7Ozs7Ozs7OztBQVdBLFVBQVNDLG9CQUFULENBQThCOXRCLFVBQTlCLEVBQTBDK3RCLGdCQUExQyxFQUE0RHo1QixNQUE1RCxFQUFvRTtBQUNuRSxNQUFJMDVCLGVBQWV2M0IsWUFBWTZKLE9BQVosQ0FBb0JOLFVBQXBCLENBQW5COztBQUVBNnRCLGNBQVl2NUIsT0FBT2tPLElBQW5CLElBQTJCcXJCLFlBQVl2NUIsT0FBT2tPLElBQW5CLEtBQTRCLEVBQXZEO0FBQ0FxckIsY0FBWXY1QixPQUFPa08sSUFBbkIsRUFBeUJ4QyxVQUF6QixJQUNDNnRCLFlBQVl2NUIsT0FBT2tPLElBQW5CLEVBQXlCeEMsVUFBekIsS0FBd0MrdEIsZ0JBRHpDOztBQUdBLE1BQUksQ0FBQ0MsWUFBTCxFQUFtQjtBQUFBOztBQUNsQkE7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQSxtTUE4REMxVSxZQTlERCxHQThEZ0IsWUFBTTtBQUNwQixVQUFNaGxCLFNBQVMsTUFBSzhJLE9BQUwsQ0FBYTlJLE1BQWIsQ0FBb0JGLEdBQXBCLENBQXdCLGNBQXhCLENBQWY7O0FBRUEsVUFBTTY1QixnQkFDTEosWUFBWXY1QixPQUFPa08sSUFBbkIsRUFBeUJ4QyxVQUF6QixFQUFxQ2tDLE9BRHRDOztBQUdBLFVBQU1nc0IsZ0JBQ0xMLFlBQVl2NUIsT0FBT2tPLElBQW5CLEVBQXlCeEMsVUFBekIsRUFBcUNtdUIsT0FEdEM7O0FBR0EsVUFBSUQsYUFBSixFQUFtQjtBQUNsQkEscUJBQWNsNkIsSUFBZDtBQUNBLE9BRkQsTUFFTztBQUNOTSxjQUFPZ08sV0FBUCxDQUFtQjJyQixhQUFuQjtBQUNBOztBQUVEMzVCLGFBQU91RSxJQUFQLENBQVksaUJBQVo7QUFDQSxNQTlFRjtBQUFBOztBQUFBO0FBQUE7OztBQU9DO0FBQ0E7QUFDQTtBQVRELGlDQVVhLENBQUU7QUFWZjtBQUFBO0FBQUEsOEJBWVU7QUFDUixVQUFNdkUsU0FBUyxLQUFLOEksT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FBZjs7QUFFQSxVQUFNZzZCLGtCQUFrQiw0QkFBeEI7O0FBRUEsVUFBTUMsb0JBQ0xSLFlBQVl2NUIsT0FBT2tPLElBQW5CLEVBQXlCeEMsVUFBekIsRUFBcUN3QyxJQUFyQyxJQUNBcXJCLFlBQVl2NUIsT0FBT2tPLElBQW5CLEVBQXlCeEMsVUFBekIsRUFBcUNrQyxPQURyQyxJQUVBbEMsVUFIRDs7QUFLQSxVQUFNc3VCLGNBQ0xULFlBQVl2NUIsT0FBT2tPLElBQW5CLEVBQXlCeEMsVUFBekIsRUFBcUNpUSxLQUR0Qzs7QUFHQSxVQUFNc2UsYUFBYSxZQUFZRixpQkFBL0I7O0FBRUEsVUFBTXhQLGdCQUFnQixhQUFhd1AsaUJBQW5DOztBQUVBLFVBQU1HLFlBQVksRUFBbEI7O0FBRUEsVUFBTUMsV0FBV2w2QixTQUFTbTZCLElBQVQsQ0FBY0MsWUFBZCxDQUNoQk4saUJBRGdCLENBQWpCOztBQUlBLFVBQUlJLFFBQUosRUFBYztBQUNiLFdBQU1HLGdCQUFnQkgsU0FBU3JyQixLQUFULENBQWUsR0FBZixDQUF0Qjs7QUFFQW9yQixpQkFBVUssZUFBVixHQUE0QkQsY0FBYyxDQUFkLEVBQWlCakksU0FBakIsQ0FDM0JpSSxjQUFjLENBQWQsRUFBaUIxd0IsT0FBakIsQ0FBeUIsR0FBekIsSUFBZ0MsQ0FETCxDQUE1QjtBQUdBc3dCLGlCQUFVTSxrQkFBVixHQUErQkYsY0FBYyxDQUFkLEVBQWlCakksU0FBakIsQ0FDOUJpSSxjQUFjLENBQWQsRUFBaUIxd0IsT0FBakIsQ0FBeUIsR0FBekIsSUFBZ0MsQ0FERixDQUEvQjtBQUdBc3dCLGlCQUFVTyxjQUFWLEdBQTJCSCxjQUFjLENBQWQsRUFBaUJqSSxTQUFqQixDQUMxQmlJLGNBQWMsQ0FBZCxFQUFpQjF3QixPQUFqQixDQUF5QixHQUF6QixJQUFnQyxDQUROLENBQTNCO0FBR0E7O0FBRUQsYUFDQztBQUFBO0FBQUE7QUFDQyxzQkFBWW93QixXQURiO0FBRUMsbUJBQVdGLGVBRlo7QUFHQyxxQkFBV0csVUFIWjtBQUlDLGlCQUFTLEtBQUtqVixZQUpmO0FBS0Msa0JBQVUsS0FBS3BjLEtBQUwsQ0FBV1gsUUFMdEI7QUFNQyxlQUFPK3hCLFdBTlI7QUFPQywrQ0FBTSxXQUFXelAsYUFBakIsRUFBZ0MsT0FBTzJQLFNBQXZDO0FBUEQsT0FERDtBQVdBO0FBNURGOztBQUFBO0FBQUEsS0FBNkIzeEIsZ0JBQU1TLFNBQW5DLFVBQ1EyRSxXQURSLEdBQ3NCckYsdUJBRHRCLFNBR1FveUIsV0FIUixHQUdzQmh2QixVQUh0QixTQUtRM0MsR0FMUixHQUtjMkMsVUFMZDs7QUFpRkF2SixlQUFZNkosT0FBWixDQUFvQk4sVUFBcEIsSUFBa0NndUIsWUFBbEM7QUFDQTs7QUFFRCxTQUFPQSxZQUFQO0FBQ0E7O0FBRUQ7QUFDQSxLQUFJLENBQUN6NUIsU0FBU3FuQixPQUFULENBQWlCeG5CLEdBQWpCLENBQXFCLFFBQXJCLENBQUwsRUFBcUM7QUFDcENHLFdBQVMwNkIsU0FBVCxHQUFxQixRQUFyQjs7QUFFQTE2QixXQUFTcW5CLE9BQVQsQ0FBaUJ2ZixHQUFqQixDQUFxQixRQUFyQixFQUErQixFQUEvQjtBQUNBOztBQUVEOzs7Ozs7Ozs7O0FBVUE5SCxVQUFTcW5CLE9BQVQsQ0FBaUJ2ZixHQUFqQixDQUFxQixpQkFBckIsRUFBd0M7QUFDdkM2eUIsWUFBVSxDQUFDLGFBQUQsQ0FENkI7O0FBR3ZDOzs7Ozs7O0FBT0FDLFlBVnVDLHNCQVU1Qjc2QixNQVY0QixFQVVwQjtBQUNsQkEsVUFBTzg2QixFQUFQLENBQVVDLFNBQVYsR0FBc0IsVUFBU3J2QixVQUFULEVBQXFCK3RCLGdCQUFyQixFQUF1QztBQUM1RCxTQUFLMXhCLEdBQUwsQ0FBUzJELFVBQVQsRUFBcUJ6TCxTQUFTMDZCLFNBQTlCLEVBQXlDbEIsZ0JBQXpDO0FBQ0EsSUFGRDs7QUFJQXo1QixVQUFPODZCLEVBQVAsQ0FBVUUsVUFBVixDQUFxQi82QixTQUFTMDZCLFNBQTlCLEVBQXlDO0FBQ3hDNXlCLFNBQUt5eEIsb0JBRG1DO0FBRXhDOVIsVUFGd0Msa0JBRWpDK1IsZ0JBRmlDLEVBRWY7QUFDeEIsU0FBTS90QixhQUNMLGtCQUFtQm9GLEtBQUt5aUIsTUFBTCxLQUFnQixHQUFqQixLQUEwQixDQUE1QyxDQUREO0FBRUEsU0FBTW1HLGVBQWVGLHFCQUNwQjl0QixVQURvQixFQUVwQit0QixnQkFGb0IsQ0FBckI7O0FBS0EsWUFBTyxJQUFJQyxZQUFKLEVBQVA7QUFDQTtBQVh1QyxJQUF6QztBQWFBO0FBNUJzQyxFQUF4QztBQThCQSxDOzs7Ozs7Ozs7Ozs7OztBQ2pLRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwrRTs7Ozs7Ozs7Ozs7Ozs7OztBQ1ZBOzs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFSQTs7Ozs7QUFVQTtBQUNBLElBQUksQ0FBQ3o1QixTQUFTcW5CLE9BQVQsQ0FBaUJ4bkIsR0FBakIsQ0FBcUIscUJBQXJCLENBQUwsRUFBa0Q7QUFDakQsS0FBTW03QixrQkFBa0IsRUFBeEI7O0FBRUE7Ozs7Ozs7Ozs7QUFVQSxVQUFTQyx3QkFBVCxDQUNDQyxjQURELEVBRUNDLG9CQUZELEVBR0NwN0IsTUFIRCxFQUlFO0FBQ0QsTUFBSXE3QixtQkFBbUJsNUIsWUFBWTZKLE9BQVosQ0FBb0JtdkIsY0FBcEIsQ0FBdkI7O0FBRUFGLGtCQUFnQmo3QixPQUFPa08sSUFBdkIsSUFBK0Irc0IsZ0JBQWdCajdCLE9BQU9rTyxJQUF2QixLQUFnQyxFQUEvRDtBQUNBK3NCLGtCQUFnQmo3QixPQUFPa08sSUFBdkIsRUFBNkJpdEIsY0FBN0IsSUFDQ0YsZ0JBQWdCajdCLE9BQU9rTyxJQUF2QixFQUE2Qml0QixjQUE3QixLQUNBQyxvQkFGRDs7QUFJQSxNQUFJLENBQUNDLGdCQUFMLEVBQXVCO0FBQUE7O0FBQ3RCQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOzs7QUFPQztBQUNBO0FBQ0E7QUFURCxpQ0FVYSxDQUFFO0FBVmY7QUFBQTtBQUFBLDhCQVlVO0FBQ1IsVUFBTXI3QixTQUFTLEtBQUs4SSxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFmOztBQUVBLFVBQU13N0IsNkJBQ0xMLGdCQUFnQmo3QixPQUFPa08sSUFBdkIsRUFBNkJpdEIsY0FBN0IsRUFBNkNqdEIsSUFBN0MsSUFDQStzQixnQkFBZ0JqN0IsT0FBT2tPLElBQXZCLEVBQTZCaXRCLGNBQTdCLEVBQTZDdnRCLE9BRDdDLElBRUF1dEIsY0FIRDs7QUFLQSxVQUFNckIsa0JBQWtCLDRCQUF4Qjs7QUFFQSxVQUFNdlAsZ0JBQ0wsYUFBYStRLDBCQURkOztBQUdBLFVBQU1wQixZQUFZLEVBQWxCOztBQUVBLFVBQU1DLFdBQVdsNkIsU0FBU202QixJQUFULENBQWNDLFlBQWQsQ0FDaEJpQiwwQkFEZ0IsQ0FBakI7O0FBSUEsVUFBSW5CLFFBQUosRUFBYztBQUNiLFdBQU1HLGdCQUFnQkgsU0FBU3JyQixLQUFULENBQWUsR0FBZixDQUF0Qjs7QUFFQW9yQixpQkFBVUssZUFBVixHQUE0QkQsY0FBYyxDQUFkLEVBQWlCakksU0FBakIsQ0FDM0JpSSxjQUFjLENBQWQsRUFBaUIxd0IsT0FBakIsQ0FBeUIsR0FBekIsSUFBZ0MsQ0FETCxDQUE1QjtBQUdBc3dCLGlCQUFVTSxrQkFBVixHQUErQkYsY0FBYyxDQUFkLEVBQWlCakksU0FBakIsQ0FDOUJpSSxjQUFjLENBQWQsRUFBaUIxd0IsT0FBakIsQ0FBeUIsR0FBekIsSUFBZ0MsQ0FERixDQUEvQjtBQUdBc3dCLGlCQUFVTyxjQUFWLEdBQTJCSCxjQUFjLENBQWQsRUFBaUJqSSxTQUFqQixDQUMxQmlJLGNBQWMsQ0FBZCxFQUFpQjF3QixPQUFqQixDQUF5QixHQUF6QixJQUFnQyxDQUROLENBQTNCO0FBR0E7O0FBRUQsYUFDQztBQUFBO0FBQUEsU0FBSyxXQUFVLDhCQUFmO0FBQ0M7QUFBQTtBQUFBO0FBQ0MsMEJBQWUsS0FBS2hCLEtBQUwsQ0FBV3dNLFFBRDNCO0FBRUMsdUJBQ0M2bEIsZ0JBQWdCajdCLE9BQU9rTyxJQUF2QixFQUE2Qml0QixjQUE3QixFQUNFeGYsS0FKSjtBQU1DLG9CQUFXbWUsZUFOWjtBQU9DLGtCQUFTLEtBQUtseEIsS0FBTCxDQUFXMk0sY0FQckI7QUFRQyxlQUFLLFVBUk47QUFTQyxtQkFBVSxLQUFLM00sS0FBTCxDQUFXWCxRQVR0QjtBQVVDLGdCQUNDZ3pCLGdCQUFnQmo3QixPQUFPa08sSUFBdkIsRUFBNkJpdEIsY0FBN0IsRUFDRXhmLEtBWko7QUFjQztBQUNDLG9CQUFXNE8sYUFEWjtBQUVDLGdCQUFPMlA7QUFGUjtBQWRELFFBREQ7QUFvQkUsWUFBS3R4QixLQUFMLENBQVd3TSxRQUFYLElBQ0E7QUFBQyxnQ0FBRDtBQUFBO0FBQ0Msb0JBQVcsS0FBS3hNLEtBQUwsQ0FBVzJNLGNBRHZCO0FBRUUsYUFBS2dtQixhQUFMO0FBRkY7QUFyQkYsT0FERDtBQTZCQTtBQTFFRjtBQUFBO0FBQUEscUNBNEVpQjtBQUNmLFVBQU12N0IsU0FBUyxLQUFLOEksT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FBZjtBQUNBLFVBQU1pVyxRQUFRcWxCLHFCQUFxQkksTUFBckIsRUFBZDtBQUNBLFVBQU1DLFlBQVkvNUIsT0FBT0MsSUFBUCxDQUFZb1UsS0FBWixFQUFtQnJCLEdBQW5CLENBQXVCLGVBQU87QUFDL0MsV0FBTWduQixXQUFXMTdCLE9BQU8yN0IsV0FBUCxDQUFtQjV5QixHQUFuQixDQUFqQjs7QUFFQSxXQUFJLENBQUMyeUIsUUFBTCxFQUFlO0FBQ2QsZUFBTyxJQUFQO0FBQ0E7O0FBRUQsV0FBTUUscUJBQ0xGLFNBQVNHLFVBQVQsSUFBdUJILFFBRHhCO0FBRUEsV0FBTUksZ0JBQWdCL2xCLE1BQU1oTixHQUFOLENBQXRCOztBQUVBLFdBQU12RCxZQUNMLHlCQUNDczJCLGtCQUFrQjc3QixTQUFTOE4sV0FBM0IsR0FDRSxRQURGLEdBRUUsRUFISCxDQUREO0FBS0EsV0FBTW9OLFdBQ0wyZ0Isa0JBQWtCNzdCLFNBQVM4N0IsaUJBRDVCO0FBRUEsV0FBTWxDLFVBQVUsU0FBVkEsT0FBVSxHQUFXO0FBQzFCLFlBQUkrQixtQkFBbUJodUIsT0FBdkIsRUFBZ0M7QUFDL0I1TixnQkFBT2dPLFdBQVAsQ0FBbUI0dEIsbUJBQW1CaHVCLE9BQXRDO0FBQ0EsU0FGRCxNQUVPLElBQUlndUIsbUJBQW1CL0IsT0FBdkIsRUFBZ0M7QUFDdEMrQiw0QkFBbUIvQixPQUFuQixDQUEyQi9TLEtBQTNCLENBQ0M4VSxrQkFERDtBQUdBO0FBQ0QsUUFSRDs7QUFVQSxjQUNDO0FBQUE7QUFBQSxVQUFJLEtBQUtGLFNBQVN4dEIsSUFBbEIsRUFBd0IsTUFBSyxRQUE3QjtBQUNDO0FBQUE7QUFBQTtBQUNDLHFCQUFXMUksU0FEWjtBQUVDLG9CQUFVMlYsUUFGWDtBQUdDLG1CQUFTMGUsT0FIVjtBQUlFK0IsNEJBQW1CamdCO0FBSnJCO0FBREQsUUFERDtBQVVBLE9BdENpQixDQUFsQjs7QUF3Q0EsYUFBTzhmLFNBQVA7QUFDQTtBQXhIRjs7QUFBQTtBQUFBLEtBQWlDbHpCLGdCQUFNUyxTQUF2QyxVQUNRMkUsV0FEUixHQUNzQnJGLHVCQUR0QixTQUdRb3lCLFdBSFIsR0FHc0JTLGNBSHRCLFNBS1FweUIsR0FMUixHQUtjb3lCLGNBTGQ7O0FBMkhBaDVCLGVBQVk2SixPQUFaLENBQW9CbXZCLGNBQXBCLElBQXNDRSxnQkFBdEM7QUFDQTs7QUFFRCxTQUFPQSxnQkFBUDtBQUNBOztBQUVEO0FBQ0EsS0FBSSxDQUFDcDdCLFNBQVNxbkIsT0FBVCxDQUFpQnhuQixHQUFqQixDQUFxQixZQUFyQixDQUFMLEVBQXlDO0FBQ3hDRyxXQUFTKzdCLGNBQVQsR0FBMEIsWUFBMUI7O0FBRUEvN0IsV0FBU3FuQixPQUFULENBQWlCdmYsR0FBakIsQ0FBcUIsWUFBckIsRUFBbUMsRUFBbkM7QUFDQTs7QUFFRDs7Ozs7Ozs7Ozs7QUFXQTlILFVBQVNxbkIsT0FBVCxDQUFpQnZmLEdBQWpCLENBQXFCLHFCQUFyQixFQUE0QztBQUMzQzZ5QixZQUFVLENBQUMsYUFBRCxFQUFnQixlQUFoQixDQURpQzs7QUFHM0M7Ozs7Ozs7QUFPQUMsWUFWMkMsc0JBVWhDNzZCLE1BVmdDLEVBVXhCO0FBQ2xCQSxVQUFPODZCLEVBQVAsQ0FBVW1CLGFBQVYsR0FBMEIsVUFDekJkLGNBRHlCLEVBRXpCQyxvQkFGeUIsRUFHeEI7QUFDRCxTQUFLcnpCLEdBQUwsQ0FDQ296QixjQURELEVBRUNsN0IsU0FBU2k4QixhQUZWLEVBR0NkLG9CQUhEO0FBS0EsSUFURDs7QUFXQXA3QixVQUFPODZCLEVBQVAsQ0FBVUUsVUFBVixDQUFxQi82QixTQUFTaThCLGFBQTlCLEVBQTZDO0FBQzVDbjBCLFNBQUttekIsd0JBRHVDO0FBRTVDeFQsVUFGNEMsa0JBRXJDMFQsb0JBRnFDLEVBRWY7QUFDNUIsU0FBTUQsaUJBQ0wsa0JBQW1CcnFCLEtBQUt5aUIsTUFBTCxLQUFnQixHQUFqQixLQUEwQixDQUE1QyxDQUREO0FBRUEsU0FBTThILG1CQUFtQkgseUJBQ3hCQyxjQUR3QixFQUV4QkMsb0JBRndCLENBQXpCOztBQUtBLFlBQU8sSUFBSUMsZ0JBQUosRUFBUDtBQUNBO0FBWDJDLElBQTdDO0FBYUE7QUFuQzBDLEVBQTVDO0FBcUNBLEM7Ozs7Ozs7Ozs7Ozs7O0FDN05EOzs7OztBQUtBO0FBQ0EsSUFBSSxDQUFDcDdCLFNBQVNxbkIsT0FBVCxDQUFpQnhuQixHQUFqQixDQUFxQixlQUFyQixDQUFMLEVBQTRDO0FBQzNDOzs7Ozs7Ozs7Ozs7QUFZQUcsVUFBU3FuQixPQUFULENBQWlCdmYsR0FBakIsQ0FBcUIsZUFBckIsRUFBc0M7QUFDckM7Ozs7Ozs7QUFPQTh5QixZQVJxQyxzQkFRMUI3NkIsTUFSMEIsRUFRbEI7QUFDbEI7QUFDQSxPQUFJQyxTQUFTcW5CLE9BQVQsQ0FBaUJ4bkIsR0FBakIsQ0FBcUIsTUFBckIsQ0FBSixFQUFrQztBQUNqQztBQUNBOztBQUVELE9BQU1xOEIsU0FBUyxFQUFmO0FBQ0EsT0FBTUMsY0FBZXA4QixPQUFPcThCLENBQVAsQ0FBU0MsVUFBVCxHQUFzQixFQUEzQztBQUNBLE9BQU1iLFlBQWF6N0IsT0FBT3E4QixDQUFQLENBQVNaLFNBQVQsR0FBcUIsRUFBeEM7O0FBRUEsUUFBSyxJQUFJNzVCLElBQUksQ0FBYixFQUFnQkEsSUFBSXU2QixPQUFPdDZCLE1BQTNCLEVBQW1DRCxHQUFuQyxFQUF3QztBQUN2Q3c2QixnQkFBWUQsT0FBT3Y2QixDQUFQLENBQVosSUFBeUJBLElBQUksQ0FBN0I7QUFDQTs7QUFFRDs7Ozs7Ozs7O0FBU0E1QixVQUFPdThCLFlBQVAsR0FBc0IsVUFBU3J1QixJQUFULEVBQWVzdUIsS0FBZixFQUFzQjtBQUMzQ0osZ0JBQVlsdUIsSUFBWixJQUFvQnN1QixTQUFTLEdBQTdCO0FBQ0EsSUFGRDs7QUFJQTs7Ozs7OztBQU9BeDhCLFVBQU95OEIsV0FBUCxHQUFxQixVQUFTdnVCLElBQVQsRUFBZTJ0QixVQUFmLEVBQTJCO0FBQy9DLFFBQUlPLFlBQVlQLFdBQVdhLEtBQXZCLENBQUosRUFBbUM7QUFDbENqQixlQUFVdnRCLElBQVYsSUFBa0I7QUFDakJBLGdCQURpQjtBQUVqQjJ0QjtBQUZpQixNQUFsQjtBQUlBO0FBQ0QsSUFQRDs7QUFTQTs7Ozs7O0FBTUE3N0IsVUFBTzI4QixZQUFQLEdBQXNCLFVBQVNDLFdBQVQsRUFBc0I7QUFDM0MsU0FBSyxJQUFNQyxRQUFYLElBQXVCRCxXQUF2QixFQUFvQztBQUNuQyxTQUNDbDdCLE9BQU84VyxTQUFQLENBQWlCc2tCLGNBQWpCLENBQWdDcDlCLElBQWhDLENBQ0NrOUIsV0FERCxFQUVDQyxRQUZELENBREQsRUFLRTtBQUNELFdBQUtKLFdBQUwsQ0FBaUJJLFFBQWpCLEVBQTJCRCxZQUFZQyxRQUFaLENBQTNCO0FBQ0E7QUFDRDtBQUNELElBWEQ7O0FBYUE7Ozs7Ozs7QUFPQTc4QixVQUFPMjdCLFdBQVAsR0FBcUIsVUFBU3p0QixJQUFULEVBQWU7QUFDbkMsV0FBT3V0QixVQUFVdnRCLElBQVYsQ0FBUDtBQUNBLElBRkQ7O0FBSUE7Ozs7OztBQU1BbE8sVUFBTys4QixjQUFQLEdBQXdCLFVBQVM3dUIsSUFBVCxFQUFlO0FBQ3RDLFdBQU91dEIsVUFBVXZ0QixJQUFWLENBQVA7QUFDQSxJQUZEO0FBR0E7QUExRm9DLEVBQXRDO0FBNEZBLEM7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxR0Q7Ozs7QUFFQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVJBOzs7OztBQVVBO0FBQ0EsSUFBSSxDQUFDak8sU0FBU3FuQixPQUFULENBQWlCeG5CLEdBQWpCLENBQXFCLDBCQUFyQixDQUFMLEVBQXVEO0FBQ3RELEtBQU1rOUIsa0JBQWtCLEVBQXhCOztBQUVBOzs7Ozs7Ozs7O0FBVUEsS0FBTUMsZ0NBQWdDLFNBQWhDQSw2QkFBZ0MsQ0FDckNDLG1CQURxQyxFQUVyQ0MseUJBRnFDLEVBR3JDbjlCLE1BSHFDLEVBSXBDO0FBQ0QsTUFBSW85Qix3QkFBd0JqN0IsWUFBWTZKLE9BQVosQ0FBb0JreEIsbUJBQXBCLENBQTVCOztBQUVBRixrQkFBZ0JoOUIsT0FBT2tPLElBQXZCLElBQStCOHVCLGdCQUFnQmg5QixPQUFPa08sSUFBdkIsS0FBZ0MsRUFBL0Q7QUFDQTh1QixrQkFBZ0JoOUIsT0FBT2tPLElBQXZCLEVBQTZCZ3ZCLG1CQUE3QixJQUNDRixnQkFBZ0JoOUIsT0FBT2tPLElBQXZCLEVBQTZCZ3ZCLG1CQUE3QixLQUNBQyx5QkFGRDs7QUFJQSxNQUFJLENBQUNDLHFCQUFMLEVBQTRCO0FBQUE7O0FBQzNCQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOzs7QUFPQztBQUNBO0FBUkQsbUNBU2UsQ0FBRTtBQVRqQjtBQUFBO0FBQUEsOEJBV1U7QUFDUixVQUFNcDlCLFNBQVMsS0FBSzhJLE9BQUwsQ0FBYTlJLE1BQWIsQ0FBb0JGLEdBQXBCLENBQXdCLGNBQXhCLENBQWY7O0FBRUEsVUFBTXc3Qiw2QkFDTDBCLGdCQUFnQmg5QixPQUFPa08sSUFBdkIsRUFBNkJndkIsbUJBQTdCLEVBQ0VodkIsSUFERixJQUVBOHVCLGdCQUFnQmg5QixPQUFPa08sSUFBdkIsRUFBNkJndkIsbUJBQTdCLEVBQ0V0dkIsT0FIRixJQUlBc3ZCLG1CQUxEOztBQU9BLFVBQU1wRCxrQkFBa0IsNEJBQXhCOztBQUVBLFVBQU12UCxnQkFDTCxhQUFhK1EsMEJBRGQ7O0FBR0EsVUFBTXBCLFlBQVksRUFBbEI7O0FBRUEsVUFBTUMsV0FBV2w2QixTQUFTbTZCLElBQVQsQ0FBY0MsWUFBZCxDQUNoQmlCLDBCQURnQixDQUFqQjs7QUFJQSxVQUFJbkIsUUFBSixFQUFjO0FBQ2IsV0FBTUcsZ0JBQWdCSCxTQUFTcnJCLEtBQVQsQ0FBZSxHQUFmLENBQXRCOztBQUVBb3JCLGlCQUFVSyxlQUFWLEdBQTRCRCxjQUFjLENBQWQsRUFBaUJqSSxTQUFqQixDQUMzQmlJLGNBQWMsQ0FBZCxFQUFpQjF3QixPQUFqQixDQUF5QixHQUF6QixJQUFnQyxDQURMLENBQTVCO0FBR0Fzd0IsaUJBQVVNLGtCQUFWLEdBQStCRixjQUFjLENBQWQsRUFBaUJqSSxTQUFqQixDQUM5QmlJLGNBQWMsQ0FBZCxFQUFpQjF3QixPQUFqQixDQUF5QixHQUF6QixJQUFnQyxDQURGLENBQS9CO0FBR0Fzd0IsaUJBQVVPLGNBQVYsR0FBMkJILGNBQWMsQ0FBZCxFQUFpQmpJLFNBQWpCLENBQzFCaUksY0FBYyxDQUFkLEVBQWlCMXdCLE9BQWpCLENBQXlCLEdBQXpCLElBQWdDLENBRE4sQ0FBM0I7QUFHQTs7QUFFRCxVQUFJeXpCLGNBQUo7O0FBRUEsVUFBSSxLQUFLejBCLEtBQUwsQ0FBV3dNLFFBQWYsRUFBeUI7QUFDeEJpb0IsZUFBUSxLQUFLQyxTQUFMLEVBQVI7QUFDQTs7QUFFRCxhQUNDO0FBQUE7QUFBQSxTQUFLLFdBQVUsOEJBQWY7QUFDQztBQUFBO0FBQUE7QUFDQywwQkFBZSxLQUFLMTBCLEtBQUwsQ0FBV3dNLFFBRDNCO0FBRUMsdUJBQ0M0bkIsZ0JBQWdCaDlCLE9BQU9rTyxJQUF2QixFQUNDZ3ZCLG1CQURELEVBRUV2aEIsS0FMSjtBQU9DLG9CQUFXbWUsZUFQWjtBQVFDLGtCQUFTLEtBQUtseEIsS0FBTCxDQUFXMk0sY0FSckI7QUFTQyxlQUFLLFVBVE47QUFVQyxtQkFBVSxLQUFLM00sS0FBTCxDQUFXWCxRQVZ0QjtBQVdDLGdCQUNDKzBCLGdCQUFnQmg5QixPQUFPa08sSUFBdkIsRUFDQ2d2QixtQkFERCxFQUVFdmhCLEtBZEo7QUFnQkM7QUFDQyxvQkFBVzRPLGFBRFo7QUFFQyxnQkFBTzJQO0FBRlI7QUFoQkQsUUFERDtBQXNCRW1EO0FBdEJGLE9BREQ7QUEwQkE7QUE5RUY7QUFBQTtBQUFBLGlDQWdGYTtBQUNYLFVBQU1yOUIsU0FBUyxLQUFLOEksT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FBZjs7QUFFQSxVQUFNeTlCLHlCQUNMUCxnQkFBZ0JoOUIsT0FBT2tPLElBQXZCLEVBQTZCZ3ZCLG1CQUE3QixFQUNFTSxPQUZIOztBQUlBLFVBQU1ILFFBQVE7QUFDYkksYUFBTSxLQUFLNzBCLEtBQUwsQ0FBVzJNLGNBREo7QUFFYjBmLGFBQU0sS0FBS3JzQixLQUFMLENBQVcyTTtBQUZKLE9BQWQ7O0FBS0EsVUFBTW1vQixlQUFlLElBQUl6OUIsU0FBU3dFLEdBQVQsQ0FBYXFCLE9BQWpCLENBQXlCLEtBQXpCLENBQXJCOztBQUVBLFVBQU02M0IsUUFBUTtBQUNiNzNCLGdCQUFTNDNCLFlBREk7QUFFYi83QixhQUFNO0FBRk8sT0FBZDs7QUFLQTtBQUNBLFVBQUk0N0Isc0JBQUosRUFBNEI7QUFDM0JBLDhCQUF1Qjc5QixJQUF2QixDQUE0QixJQUE1QixFQUFrQzI5QixLQUFsQyxFQUF5Q00sS0FBekM7QUFDQTs7QUFFRDtBQUNBOztBQUVBLGFBQ0M7QUFBQywrQkFBRDtBQUFBLFNBQWdCLFdBQVcsS0FBSy8wQixLQUFMLENBQVcyTSxjQUF0QztBQUNDO0FBQ0MsbUJBQVdtb0IsYUFBYS9rQixZQUFiLENBQTBCLE9BQTFCLENBRFo7QUFFQyxpQ0FBeUI7QUFDeEIyVCxpQkFBUW9SLGFBQWFFLE9BQWI7QUFEZ0I7QUFGMUI7QUFERCxPQUREO0FBVUE7QUFySEY7O0FBQUE7QUFBQSxLQUFzQ3IxQixnQkFBTVMsU0FBNUMsVUFDUTJFLFdBRFIsR0FDc0JyRix1QkFEdEIsU0FHUW95QixXQUhSLEdBR3NCd0MsbUJBSHRCLFNBS1FuMEIsR0FMUixHQUtjbTBCLG1CQUxkOztBQXdIQS82QixlQUFZNkosT0FBWixDQUFvQmt4QixtQkFBcEIsSUFBMkNFLHFCQUEzQztBQUNBOztBQUVELFNBQU9BLHFCQUFQO0FBQ0EsRUF6SUQ7O0FBMklBO0FBQ0EsS0FBSSxDQUFDbjlCLFNBQVNxbkIsT0FBVCxDQUFpQnhuQixHQUFqQixDQUFxQixpQkFBckIsQ0FBTCxFQUE4QztBQUM3Q0csV0FBUzQ5QixjQUFULEdBQTBCLGlCQUExQjs7QUFFQTU5QixXQUFTcW5CLE9BQVQsQ0FBaUJ2ZixHQUFqQixDQUFxQixpQkFBckIsRUFBd0MsRUFBeEM7QUFDQTs7QUFFRDtBQUNBLEtBQUksQ0FBQzlILFNBQVNxbkIsT0FBVCxDQUFpQnhuQixHQUFqQixDQUFxQixhQUFyQixDQUFMLEVBQTBDO0FBQ3pDRyxXQUFTNDlCLGNBQVQsR0FBMEIsYUFBMUI7O0FBRUE1OUIsV0FBU3FuQixPQUFULENBQWlCdmYsR0FBakIsQ0FBcUIsYUFBckIsRUFBb0MsRUFBcEM7QUFDQTs7QUFFRDs7Ozs7Ozs7OztBQVVBOUgsVUFBU3FuQixPQUFULENBQWlCdmYsR0FBakIsQ0FBcUIsMEJBQXJCLEVBQWlEO0FBQ2hENnlCLFlBQVUsQ0FBQyxhQUFELENBRHNDOztBQUdoRDs7Ozs7OztBQU9BQyxZQVZnRCxzQkFVckM3NkIsTUFWcUMsRUFVN0I7QUFDbEJBLFVBQU84NkIsRUFBUCxDQUFVZ0Qsa0JBQVYsR0FBK0IsVUFDOUJaLG1CQUQ4QixFQUU5QkMseUJBRjhCLEVBRzdCO0FBQ0QsU0FBS3AxQixHQUFMLENBQ0NtMUIsbUJBREQsRUFFQ2o5QixTQUFTNDlCLGNBRlYsRUFHQ1YseUJBSEQ7QUFLQSxJQVREOztBQVdBbjlCLFVBQU84NkIsRUFBUCxDQUFVRSxVQUFWLENBQXFCLzZCLFNBQVM0OUIsY0FBOUIsRUFBOEM7QUFDN0M5MUIsU0FBS2sxQiw2QkFEd0M7QUFFN0N2VixVQUY2QyxrQkFFdEN5Vix5QkFGc0MsRUFFWDtBQUNqQyxTQUFNRCxzQkFDTCwyQkFBNEJwc0IsS0FBS3lpQixNQUFMLEtBQWdCLEdBQWpCLEtBQTBCLENBQXJELENBREQ7QUFFQSxTQUFNNkosd0JBQXdCSCw4QkFDN0JDLG1CQUQ2QixFQUU3QkMseUJBRjZCLENBQTlCOztBQUtBLFlBQU8sSUFBSUMscUJBQUosRUFBUDtBQUNBO0FBWDRDLElBQTlDO0FBYUE7QUFuQytDLEVBQWpEO0FBcUNBLEM7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzTkQ7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBVEE7Ozs7O0FBV0E7QUFDQSxJQUFJLENBQUNuOUIsU0FBU3FuQixPQUFULENBQWlCeG5CLEdBQWpCLENBQXFCLG9CQUFyQixDQUFMLEVBQWlEO0FBQ2hELEtBQU1pK0Isa0JBQWtCLEVBQXhCOztBQUVBOzs7Ozs7Ozs7O0FBVUEsS0FBTUMsMEJBQTBCLFNBQTFCQSx1QkFBMEIsQ0FDL0JDLGFBRCtCLEVBRS9CQyxtQkFGK0IsRUFHL0JsK0IsTUFIK0IsRUFJOUI7QUFDRCxNQUFJbStCLGtCQUFrQmg4QixZQUFZNkosT0FBWixDQUFvQml5QixhQUFwQixDQUF0Qjs7QUFFQUYsa0JBQWdCLzlCLE9BQU9rTyxJQUF2QixJQUErQjZ2QixnQkFBZ0IvOUIsT0FBT2tPLElBQXZCLEtBQWdDLEVBQS9EO0FBQ0E2dkIsa0JBQWdCLzlCLE9BQU9rTyxJQUF2QixFQUE2Qit2QixhQUE3QixJQUNDRixnQkFBZ0IvOUIsT0FBT2tPLElBQXZCLEVBQTZCK3ZCLGFBQTdCLEtBQStDQyxtQkFEaEQ7QUFFQUgsa0JBQWdCLzlCLE9BQU9rTyxJQUF2QixFQUE2Qit2QixhQUE3QixFQUE0Q0csWUFBNUMsR0FBMkR2M0IsU0FBM0Q7O0FBRUEsTUFBSSxDQUFDczNCLGVBQUwsRUFBc0I7QUFBQTs7QUFDckJBO0FBQUE7O0FBT0MsNkJBQVl2MUIsS0FBWixFQUFtQjtBQUFBOztBQUFBLG1JQUNaQSxLQURZOztBQUFBLFdBK0huQnFqQixRQS9IbUIsR0ErSFIsaUJBQVM7QUFDbkIsVUFBTWpzQixTQUFTLE1BQUs4SSxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFmOztBQUVBLFVBQU11K0IsY0FDTE4sZ0JBQWdCLzlCLE9BQU9rTyxJQUF2QixFQUE2Qit2QixhQUE3QixDQUREOztBQUdBLFVBQUlJLFlBQVl4RSxPQUFoQixFQUF5QjtBQUN4QixXQUFNeUUsV0FBV3o2QixNQUFNMDZCLGFBQU4sQ0FBb0I1bEIsWUFBcEIsQ0FDaEIsWUFEZ0IsQ0FBakI7O0FBSUEwbEIsbUJBQVl4RSxPQUFaLENBQW9CbjZCLElBQXBCLFFBQStCNCtCLFFBQS9COztBQUVBUCx1QkFBZ0IvOUIsT0FBT2tPLElBQXZCLEVBQ0MrdkIsYUFERCxFQUVFRyxZQUZGLEdBRWlCRSxRQUZqQjs7QUFJQXQrQixjQUFPdUUsSUFBUCxDQUFZLGlCQUFaO0FBQ0E7QUFDRCxNQWxKa0I7O0FBRWxCLFdBQUt1SixLQUFMLEdBQWE7QUFDWjlJLGFBQ0MrNEIsZ0JBQWdCLzlCLE9BQU9rTyxJQUF2QixFQUE2Qit2QixhQUE3QixFQUNFRztBQUhTLE1BQWI7QUFGa0I7QUFPbEI7O0FBRUQ7QUFDQTs7O0FBakJEO0FBQUE7QUFBQSw4QkFrQlUsQ0FBRTtBQWxCWjtBQUFBO0FBQUEsbUNBbUJlLENBQUU7QUFuQmpCO0FBQUE7QUFBQSwrQkFvQlcsQ0FBRTtBQXBCYjtBQUFBO0FBQUEsOEJBcUJVLENBQUU7QUFyQlo7QUFBQTtBQUFBLGdDQXNCWSxDQUFFO0FBdEJkO0FBQUE7QUFBQSxpQ0F1QmEsQ0FBRTtBQXZCZjtBQUFBO0FBQUEsZ0NBd0JZLENBQUU7QUF4QmQ7QUFBQTtBQUFBLDRCQXlCUSxDQUFFO0FBekJWO0FBQUE7QUFBQSwrQkEwQlcsQ0FBRTtBQTFCYjtBQUFBO0FBQUEsa0NBMkJjLENBQUU7QUEzQmhCO0FBQUE7QUFBQSxpQ0E0QmEsQ0FBRTtBQTVCZjtBQUFBO0FBQUEseUJBOEJLcDVCLEtBOUJMLEVBOEJZdzVCLE9BOUJaLEVBOEJxQnpZLEtBOUJyQixFQThCNEI7QUFDMUIsV0FBSzBZLE1BQUwsQ0FBWTd5QixJQUFaLENBQWlCO0FBQ2hCNHlCLHVCQURnQjtBQUVoQnpZLG1CQUZnQjtBQUdoQi9nQjtBQUhnQixPQUFqQjtBQUtBO0FBcENGO0FBQUE7QUFBQSwwQ0FzQ3NCO0FBQ3BCLFVBQU1oRixTQUFTLEtBQUs4SSxPQUFMLENBQWE5SSxNQUFiLENBQW9CRixHQUFwQixDQUF3QixjQUF4QixDQUFmOztBQUVBLFVBQU11K0IsY0FDTE4sZ0JBQWdCLzlCLE9BQU9rTyxJQUF2QixFQUE2Qit2QixhQUE3QixDQUREOztBQUdBLFdBQUtRLE1BQUwsR0FBYyxFQUFkOztBQUVBLFdBQUtDLFFBQUwsR0FBZ0IsS0FBS0MsU0FBckI7O0FBRUEsVUFBSU4sWUFBWU8sSUFBaEIsRUFBc0I7QUFDckJQLG1CQUFZTyxJQUFaLENBQWlCbC9CLElBQWpCLENBQXNCLElBQXRCO0FBQ0E7O0FBRUQsVUFBSTIrQixZQUFZUSxRQUFoQixFQUEwQjtBQUN6QlIsbUJBQVlRLFFBQVosQ0FBcUJuL0IsSUFBckIsQ0FBMEIsSUFBMUI7QUFDQTtBQUNEO0FBdkRGO0FBQUE7QUFBQSw0Q0F5RHdCO0FBQ3RCLFdBQUtvL0IsV0FBTCxDQUFpQixLQUFLaHhCLEtBQUwsQ0FBVzlJLEtBQTVCOztBQUVBLFdBQUswNUIsUUFBTCxHQUFnQixLQUFLSSxXQUFyQjtBQUNBO0FBN0RGO0FBQUE7QUFBQSxnQ0ErRFk7QUFDVixhQUFPLEtBQUtoeEIsS0FBTCxDQUFXOUksS0FBbEI7QUFDQTtBQWpFRjtBQUFBO0FBQUEsOEJBbUVVO0FBQ1IsVUFBTWhGLFNBQVMsS0FBSzhJLE9BQUwsQ0FBYTlJLE1BQWIsQ0FBb0JGLEdBQXBCLENBQXdCLGNBQXhCLENBQWY7O0FBRUEsVUFBTWkvQixpQkFDTGhCLGdCQUFnQi85QixPQUFPa08sSUFBdkIsRUFBNkIrdkIsYUFBN0IsRUFDRUcsWUFERixJQUNrQkYsb0JBQW9CdmlCLEtBRnZDOztBQUlBLGFBQ0M7QUFBQTtBQUFBLFNBQUssV0FBVSx1Q0FBZjtBQUNDO0FBQUE7QUFBQTtBQUNDLDBCQUFlLEtBQUsvUyxLQUFMLENBQVd3TSxRQUQzQjtBQUVDLHVCQUFZMnBCLGNBRmI7QUFHQyxvQkFBVSxvQkFIWDtBQUlDLGtCQUFTLEtBQUtuMkIsS0FBTCxDQUFXMk0sY0FKckI7QUFLQyxlQUFLLFVBTE47QUFNQyxtQkFBVSxLQUFLM00sS0FBTCxDQUFXWCxRQU50QjtBQU9DLGdCQUFPODJCLGNBUFI7QUFRQztBQUFBO0FBQUEsV0FBSyxXQUFVLGNBQWY7QUFDQztBQUFBO0FBQUEsWUFBTSxXQUFVLHFDQUFoQjtBQUNFQTtBQURGLFVBREQ7QUFJQyx1Q0FBQyxvQkFBRCxJQUFZLFFBQU8sY0FBbkI7QUFKRDtBQVJELFFBREQ7QUFnQkUsWUFBS24yQixLQUFMLENBQVd3TSxRQUFYLElBQ0E7QUFBQyxnQ0FBRDtBQUFBO0FBQ0Msb0JBQVcsS0FBS3hNLEtBQUwsQ0FBVzJNLGNBRHZCO0FBRUUsYUFBS3lwQixTQUFMO0FBRkY7QUFqQkYsT0FERDtBQXlCQTtBQW5HRjtBQUFBO0FBQUEsaUNBcUdhaDZCLEtBckdiLEVBcUdvQjtBQUNsQixVQUFNaEYsU0FBUyxLQUFLOEksT0FBTCxDQUFhOUksTUFBYixDQUFvQkYsR0FBcEIsQ0FBd0IsY0FBeEIsQ0FBZjs7QUFFQWkrQixzQkFBZ0IvOUIsT0FBT2tPLElBQXZCLEVBQ0MrdkIsYUFERCxFQUVFRyxZQUZGLEdBRWlCcDVCLEtBRmpCO0FBR0E7QUEzR0Y7QUFBQTtBQUFBLGlDQTZHYTtBQUFBOztBQUNYLFVBQU1pNkIsWUFBWSxJQUFsQjs7QUFFQSxVQUFNbHBCLFFBQVEsS0FBSzBvQixNQUFMLENBQVkvcEIsR0FBWixDQUFnQixnQkFBUTtBQUNyQyxXQUFNbFAsWUFDTCx5QkFDQ3dRLEtBQUtoUixLQUFMLEtBQWUsT0FBSzhJLEtBQUwsQ0FBVzlJLEtBQTFCLEdBQWtDLFFBQWxDLEdBQTZDLEVBRDlDLENBREQ7O0FBSUEsY0FDQztBQUFBO0FBQUEsVUFBSSxLQUFLZ1IsS0FBSytQLEtBQWQsRUFBcUIsTUFBSyxRQUExQjtBQUNDO0FBQ0Msb0JBQVd2Z0IsU0FEWjtBQUVDLGtDQUF5QjtBQUN4QjhtQixrQkFBUXRXLEtBQUt3b0I7QUFEVyxVQUYxQjtBQUtDLHVCQUFZeG9CLEtBQUtoUixLQUxsQjtBQU1DLGtCQUFTaTZCLFVBQVVoVDtBQU5wQjtBQURELFFBREQ7QUFZQSxPQWpCYSxDQUFkOztBQW1CQSxhQUFPbFcsS0FBUDtBQUNBO0FBcElGO0FBQUE7QUFBQSwrQkEySlcvUSxLQTNKWCxFQTJKa0I7QUFDaEIsV0FBSzg1QixXQUFMLENBQWlCOTVCLEtBQWpCOztBQUVBLFdBQUt5USxRQUFMLENBQWM7QUFDYnpRO0FBRGEsT0FBZDtBQUdBO0FBaktGOztBQUFBO0FBQUEsS0FBZ0N1RCxnQkFBTVMsU0FBdEMsVUFDUTJFLFdBRFIsR0FDc0JyRix1QkFEdEIsU0FHUW95QixXQUhSLEdBR3NCdUQsYUFIdEIsU0FLUWwxQixHQUxSLEdBS2NrMUIsYUFMZDs7QUFvS0E5N0IsZUFBWTZKLE9BQVosQ0FBb0JpeUIsYUFBcEIsSUFBcUNFLGVBQXJDO0FBQ0E7O0FBRUQsU0FBT0EsZUFBUDtBQUNBLEVBckxEOztBQXVMQTtBQUNBLEtBQUksQ0FBQ2wrQixTQUFTcW5CLE9BQVQsQ0FBaUJ4bkIsR0FBakIsQ0FBcUIsV0FBckIsQ0FBTCxFQUF3QztBQUN2Q0csV0FBU2kvQixZQUFULEdBQXdCLFdBQXhCOztBQUVBai9CLFdBQVNxbkIsT0FBVCxDQUFpQnZmLEdBQWpCLENBQXFCLFdBQXJCLEVBQWtDLEVBQWxDO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQTlILFVBQVNxbkIsT0FBVCxDQUFpQnZmLEdBQWpCLENBQXFCLG9CQUFyQixFQUEyQztBQUMxQzZ5QixZQUFVLENBQUMsYUFBRCxDQURnQzs7QUFHMUM7Ozs7Ozs7QUFPQUMsWUFWMEMsc0JBVS9CNzZCLE1BVitCLEVBVXZCO0FBQ2xCQSxVQUFPODZCLEVBQVAsQ0FBVXFFLFlBQVYsR0FBeUIsVUFDeEJsQixhQUR3QixFQUV4QkMsbUJBRndCLEVBR3ZCO0FBQ0QsU0FBS24yQixHQUFMLENBQ0NrMkIsYUFERCxFQUVDaCtCLFNBQVNpL0IsWUFGVixFQUdDaEIsbUJBSEQ7QUFLQSxJQVREOztBQVdBbCtCLFVBQU84NkIsRUFBUCxDQUFVRSxVQUFWLENBQXFCLzZCLFNBQVNpL0IsWUFBOUIsRUFBNEM7QUFDM0NuM0IsU0FBS2kyQix1QkFEc0M7QUFFM0N0VyxVQUYyQyxrQkFFcEN3VyxtQkFGb0MsRUFFZjtBQUMzQixTQUFNRCxnQkFDTCxxQkFBc0JudEIsS0FBS3lpQixNQUFMLEtBQWdCLEdBQWpCLEtBQTBCLENBQS9DLENBREQ7QUFFQSxTQUFNNEssa0JBQWtCSCx3QkFDdkJDLGFBRHVCLEVBRXZCQyxtQkFGdUIsQ0FBeEI7O0FBS0EsWUFBTyxJQUFJQyxlQUFKLEVBQVA7QUFDQTtBQVgwQyxJQUE1QztBQWFBO0FBbkN5QyxFQUEzQztBQXFDQSxDOzs7Ozs7Ozs7Ozs7OztBQ3RRRDs7Ozs7QUFLQTtBQUNBLElBQUksQ0FBQ2wrQixTQUFTcW5CLE9BQVQsQ0FBaUJ4bkIsR0FBakIsQ0FBcUIsYUFBckIsQ0FBTCxFQUEwQztBQUN6Qzs7Ozs7Ozs7QUFRQUcsVUFBU3FuQixPQUFULENBQWlCdmYsR0FBakIsQ0FBcUIsYUFBckIsRUFBb0M7QUFDbkM7Ozs7OztBQU1BOHlCLFlBUG1DLHNCQU94Qjc2QixNQVB3QixFQU9oQjtBQUNsQixPQUFNby9CLGtCQUFrQnAvQixPQUFPODZCLEVBQVAsQ0FBVS95QixHQUFsQzs7QUFFQS9ILFVBQU84NkIsRUFBUCxDQUFVL3lCLEdBQVYsR0FBZ0IsVUFBU21HLElBQVQsRUFBZWhILElBQWYsRUFBcUIyMEIsVUFBckIsRUFBaUM7QUFDaER1RCxvQkFBZ0IxL0IsSUFBaEIsQ0FBcUIsSUFBckIsRUFBMkJ3TyxJQUEzQixFQUFpQ2hILElBQWpDLEVBQXVDMjBCLFVBQXZDOztBQUVBLFFBQU13RCxjQUFjLEtBQUtoRCxDQUFMLENBQU9pRCxRQUFQLENBQWdCcDRCLElBQWhCLENBQXBCOztBQUVBLFFBQUltNEIsZUFBZUEsWUFBWXQzQixHQUEvQixFQUFvQztBQUNuQ3MzQixpQkFBWXQzQixHQUFaLENBQWdCbUcsSUFBaEIsRUFBc0IydEIsVUFBdEIsRUFBa0M3N0IsTUFBbEM7QUFDQW1DLGlCQUFZc0osb0JBQVosQ0FDQ3lDLElBREQsRUFFQ2xPLE9BQU91L0Isb0JBQVAsQ0FBNEJyK0IsTUFBNUIsQ0FBbUNnTixJQUZwQztBQUlBO0FBQ0QsSUFaRDtBQWFBO0FBdkJrQyxFQUFwQztBQXlCQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hDRDs7Ozs7QUFLQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsU0FBUzBuQixRQUFULENBQWtCN3JCLFFBQWxCLEVBQTRCeTFCLE9BQTVCLEVBQXFDMTJCLE9BQXJDLEVBQXlEO0FBQUEsTUFBWDIyQixJQUFXLHVFQUFKLEVBQUk7O0FBQ3hELE1BQUlDLHVCQUFKOztBQUVBLE1BQU1DLFNBQVMsU0FBVEEsTUFBUyxHQUFzQjtBQUFBLHNDQUFWQyxRQUFVO0FBQVZBLGNBQVU7QUFBQTs7QUFDcEM7QUFDQSxRQUFNQyxjQUFjLzJCLFdBQVcsSUFBL0I7QUFDQTs7QUFFQXVjLGlCQUFhcWEsY0FBYjs7QUFFQUEscUJBQWlCejFCLFdBQVcsWUFBTTtBQUNqQ0YsZUFBUytjLEtBQVQsQ0FBZStZLFdBQWYsWUFBZ0NELFFBQWhDLHFCQUE2Q0gsSUFBN0M7QUFDQSxLQUZnQixFQUVkRCxPQUZjLENBQWpCO0FBR0EsR0FWRDs7QUFZQUcsU0FBT3hJLE1BQVAsR0FBZ0IsWUFBVztBQUMxQjlSLGlCQUFhcWEsY0FBYjtBQUNBLEdBRkQ7O0FBSUEsU0FBT0MsTUFBUDtBQUNBOztBQUVEMS9CLFNBQVN5TyxLQUFULENBQWVrbkIsUUFBZixHQUEwQjMxQixTQUFTeU8sS0FBVCxDQUFla25CLFFBQWYsSUFBMkJBLFFBQXJEOztrQkFFZUEsUTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDZjs7OztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7O1FBRVFBLFEsR0FBQUEsa0IsRUFuQlI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7QUFLQSxJQUFNa0ssd0JBQXdCLE9BQTlCO0FBQ0EsSUFBTUMscUJBQXFCLDhCQUEzQjtBQUNBLElBQU1DLG1CQUFtQiwrQkFBekI7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTL1ksSUFBVCxDQUFjam5CLE1BQWQsRUFBc0JULE1BQXRCLEVBQThCO0FBQzdCLE1BQUsyQyxPQUFMLEdBQWVsQyxNQUFmO0FBQ0EsTUFBS2tuQixjQUFMLEdBQ0MzbkIsVUFBVUEsT0FBTzJuQixjQUFQLEtBQTBCLEtBQXBDLEdBQTRDLEtBQTVDLEdBQW9ELElBRHJEO0FBRUE7O0FBRURELEtBQUt6TyxTQUFMLEdBQWlCO0FBQ2hCL1ksY0FBYXduQixJQURHOztBQUdoQjs7Ozs7Ozs7O0FBU0FZLGlCQVpnQiw0QkFZQ2pqQixJQVpELEVBWU87QUFDdEJBLFNBQU9BLFFBQVEsS0FBSytpQixnQkFBTCxFQUFmOztBQUVBLE1BQU1qYixRQUFRLEtBQUt4SyxPQUFMLENBQWFrQixZQUFiLEdBQTRCbUosU0FBNUIsR0FBd0MsQ0FBeEMsQ0FBZDs7QUFFQSxNQUFJM0gsSUFBSixFQUFVO0FBQ1Q4SCxTQUFNdXpCLG9CQUFOLENBQTJCcjdCLElBQTNCOztBQUVBLE9BQU1zN0IsV0FBV3h6QixNQUFNeXpCLG1CQUFOLEVBQWpCOztBQUVBLE9BQ0NELFlBQ0EsQ0FBQyxLQUFLaCtCLE9BQUwsQ0FBYTRELE9BQWIsQ0FBcUJzNkIsTUFBckIsQ0FBNEJGLFNBQVNHLGlCQUFULENBQTJCejdCLElBQTNCLENBQTVCLENBRkYsRUFHRTtBQUNELFFBQU0wN0IsYUFBYSxLQUFLajBCLElBQUwsQ0FBVTZ6QixTQUFTSyxPQUFULEVBQVYsQ0FBbkI7O0FBRUEsUUFBTUMsU0FBU0YsYUFBYUEsV0FBVzFyQixLQUFYLEdBQW1CLENBQWhDLEdBQW9DLENBQW5EOztBQUVBbEksVUFBTUMsUUFBTixDQUFldXpCLFFBQWYsRUFBeUJNLE1BQXpCO0FBQ0E5ekIsVUFBTUUsTUFBTixDQUFhc3pCLFFBQWIsRUFBdUJNLE1BQXZCO0FBQ0E7QUFDRDs7QUFFRCxPQUFLdCtCLE9BQUwsQ0FBYWtCLFlBQWIsR0FBNEI4SixZQUE1QixDQUF5QyxDQUFDUixLQUFELENBQXpDO0FBQ0EsRUFwQ2U7OztBQXNDaEI7Ozs7Ozs7Ozs7QUFVQWdiLE9BaERnQixrQkFnRFQrWSxHQWhEUyxFQWdESjl3QixLQWhESSxFQWdER3lYLGVBaERILEVBZ0RvQjtBQUNuQyxNQUFNN2pCLFlBQVksS0FBS3JCLE9BQUwsQ0FBYWtCLFlBQWIsRUFBbEI7O0FBRUEsTUFBTXNKLFFBQVFuSixVQUFVZ0osU0FBVixHQUFzQixDQUF0QixDQUFkOztBQUVBLE1BQUlHLE1BQU1nMEIsU0FBVixFQUFxQjtBQUNwQixPQUFNQyxPQUFPLElBQUkxZ0MsU0FBU3dFLEdBQVQsQ0FBYWs4QixJQUFqQixDQUFzQkYsR0FBdEIsRUFBMkIsS0FBS3YrQixPQUFMLENBQWFtQixRQUF4QyxDQUFiO0FBQ0FxSixTQUFNazBCLFVBQU4sQ0FBaUJELElBQWpCO0FBQ0FqMEIsU0FBTW0wQixrQkFBTixDQUF5QkYsSUFBekI7QUFDQTs7QUFFREYsUUFBTSxLQUFLSyxlQUFMLENBQXFCTCxHQUFyQixDQUFOOztBQUVBLE1BQU10WixZQUFZbG5CLFNBQVN5TyxLQUFULENBQWVDLEtBQWYsQ0FDakI7QUFDQywwQkFBdUI4eEIsR0FEeEI7QUFFQzM3QixTQUFNMjdCO0FBRlAsR0FEaUIsRUFLakI5d0IsS0FMaUIsQ0FBbEI7O0FBUUEsTUFBTWQsUUFBUSxJQUFJNU8sU0FBUzRPLEtBQWIsQ0FBbUI7QUFDaEM5SixlQUFZb2lCLFNBRG9CO0FBRWhDcmhCLFlBQVM7QUFGdUIsR0FBbkIsQ0FBZDs7QUFLQStJLFFBQU0zSCxJQUFOLEdBQWFqSCxTQUFTMnNCLFlBQXRCO0FBQ0EvZCxRQUFNa3lCLFlBQU4sQ0FBbUJyMEIsS0FBbkIsRUFBMEIsS0FBS3hLLE9BQS9COztBQUVBLE1BQUlrbEIsbUJBQW1CQSxnQkFBZ0JDLE9BQXZDLEVBQWdEO0FBQy9DLFFBQUtRLGdCQUFMO0FBQ0EsR0FGRCxNQUVPO0FBQ05uYixTQUFNczBCLE1BQU47QUFDQTtBQUNELEVBbEZlOzs7QUFvRmhCOzs7Ozs7OztBQVFBclosaUJBNUZnQiw4QkE0Rkc7QUFDbEIsTUFBTXBrQixZQUFZLEtBQUtyQixPQUFMLENBQWFrQixZQUFiLEVBQWxCOztBQUVBLE1BQU15SixrQkFBa0J0SixVQUFVdUosa0JBQVYsRUFBeEI7O0FBRUEsTUFBSUQsbUJBQW1CQSxnQkFBZ0JvMEIsRUFBaEIsQ0FBbUIsR0FBbkIsQ0FBdkIsRUFBZ0Q7QUFDL0MsVUFBT3AwQixlQUFQO0FBQ0E7O0FBRUQsTUFBSUEsbUJBQW1CNU0sU0FBU2MsR0FBVCxDQUFhQyxFQUFwQyxFQUF3QztBQUN2QyxPQUFNa2YsV0FBV3JULGdCQUFnQnEwQixXQUFoQixFQUFqQjs7QUFFQSxPQUFNQyxRQUFRamhCLFNBQVNpaEIsS0FBVCxFQUFkOztBQUVBLFFBQUssSUFBSXYvQixJQUFJLENBQWIsRUFBZ0JBLElBQUl1L0IsS0FBcEIsRUFBMkJ2L0IsR0FBM0IsRUFBZ0M7QUFDL0IsUUFBTS9CLE9BQU9xZ0IsU0FBU2toQixPQUFULENBQWlCeC9CLENBQWpCLENBQWI7O0FBRUEsUUFBSS9CLEtBQUtvaEMsRUFBTCxDQUFRLEdBQVIsQ0FBSixFQUFrQjtBQUNqQixZQUFPcGhDLElBQVA7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQsTUFBTTZNLFFBQVFuSixVQUFVZ0osU0FBVixHQUFzQixDQUF0QixDQUFkOztBQUVBLE1BQUlHLEtBQUosRUFBVztBQUNWQSxTQUFNMjBCLE1BQU4sQ0FBYXBoQyxTQUFTcWhDLFdBQXRCOztBQUVBLFVBQU8sS0FBS3AvQixPQUFMLENBQ0x3QyxXQURLLENBQ09nSSxNQUFNMnpCLGlCQUFOLEVBRFAsRUFFTDVJLFFBRkssQ0FFSSxHQUZKLEVBRVMsQ0FGVCxDQUFQO0FBR0E7O0FBRUQsU0FBTyxJQUFQO0FBQ0EsRUE5SGU7OztBQWdJaEI7Ozs7Ozs7OztBQVNBdHFCLE9BeklnQixrQkF5SVR2SSxJQXpJUyxFQXlJSHdpQixlQXpJRyxFQXlJYztBQUM3QixNQUFNcG5CLFNBQVMsS0FBS2tDLE9BQXBCOztBQUVBLE1BQUkwQyxJQUFKLEVBQVU7QUFDVCxPQUFJd2lCLG1CQUFtQkEsZ0JBQWdCQyxPQUF2QyxFQUFnRDtBQUMvQyxTQUFLUSxnQkFBTDtBQUNBOztBQUVEampCLFFBQUt1SSxNQUFMLENBQVluTixNQUFaO0FBQ0EsR0FORCxNQU1PO0FBQ04sT0FBTTZPLFFBQVEsSUFBSTVPLFNBQVM0TyxLQUFiLENBQW1CO0FBQ2hDMHlCLHlCQUFxQixDQURXO0FBRWhDejdCLGFBQVMsR0FGdUI7QUFHaENvQixVQUFNakgsU0FBUzJzQjtBQUhpQixJQUFuQixDQUFkOztBQU1BO0FBQ0E7QUFDQTs7QUFFQSxPQUFNcnBCLFlBQVl2RCxPQUFPb0QsWUFBUCxFQUFsQjtBQUNBRyxhQUFVaStCLGFBQVYsQ0FBd0JqK0IsVUFBVTJWLGVBQVYsRUFBeEI7O0FBRUFsWixVQUFPd04sV0FBUCxDQUFtQnFCLEtBQW5CO0FBQ0E7QUFDRCxFQWxLZTs7O0FBb0toQjs7Ozs7Ozs7OztBQVVBNFksT0E5S2dCLGtCQThLVDlYLEtBOUtTLEVBOEtGL0ssSUE5S0UsRUE4S0l3aUIsZUE5S0osRUE4S3FCO0FBQ3BDLE1BQU14TixXQUFXLElBQWpCOztBQUVBaFYsU0FBT0EsUUFBUSxLQUFLK2lCLGdCQUFMLEVBQWY7O0FBRUEsTUFBSSxPQUFPaFksS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM5QixPQUFNOHhCLE1BQU03bkIsU0FBU2tuQixlQUFULENBQXlCbnhCLEtBQXpCLENBQVo7O0FBRUEvSyxRQUFLODhCLGFBQUwsQ0FBbUI7QUFDbEIsMkJBQXVCRCxHQURMO0FBRWxCMzhCLFVBQU0yOEI7QUFGWSxJQUFuQjtBQUlBLEdBUEQsTUFPTyxJQUFJLFFBQU85eEIsS0FBUCx5Q0FBT0EsS0FBUCxPQUFpQixRQUFyQixFQUErQjtBQUNyQyxPQUFNZ3lCLGNBQWMsRUFBcEI7O0FBRUEsT0FBTUMsV0FBVyxFQUFqQjs7QUFFQWxnQyxVQUFPQyxJQUFQLENBQVlnTyxLQUFaLEVBQW1COEksT0FBbkIsQ0FBMkIsZUFBTztBQUNqQyxRQUFJOUksTUFBTTVHLEdBQU4sTUFBZSxJQUFuQixFQUF5QjtBQUN4QixTQUFJQSxRQUFRLE1BQVosRUFBb0I7QUFDbkI0NEIsa0JBQVkvMUIsSUFBWixDQUFpQixxQkFBakI7QUFDQTs7QUFFRCsxQixpQkFBWS8xQixJQUFaLENBQWlCN0MsR0FBakI7QUFDQSxLQU5ELE1BTU87QUFDTixTQUFJQSxRQUFRLE1BQVosRUFBb0I7QUFDbkIsVUFBTTA0QixPQUFNN25CLFNBQVNrbkIsZUFBVCxDQUF5Qm54QixNQUFNNUcsR0FBTixDQUF6QixDQUFaOztBQUVBNjRCLGVBQVMscUJBQVQsSUFBa0NILElBQWxDO0FBQ0FHLGVBQVM3NEIsR0FBVCxJQUFnQjA0QixJQUFoQjtBQUNBLE1BTEQsTUFLTztBQUNORyxlQUFTNzRCLEdBQVQsSUFBZ0I0RyxNQUFNNUcsR0FBTixDQUFoQjtBQUNBO0FBQ0Q7QUFDRCxJQWpCRDs7QUFtQkFuRSxRQUFLaTlCLGdCQUFMLENBQXNCRixXQUF0QjtBQUNBLzhCLFFBQUs4OEIsYUFBTCxDQUFtQkUsUUFBbkI7QUFDQTs7QUFFRCxNQUFJeGEsbUJBQW1CQSxnQkFBZ0JDLE9BQXZDLEVBQWdEO0FBQy9DLFFBQUtRLGdCQUFMLENBQXNCampCLElBQXRCO0FBQ0E7QUFDRCxFQXpOZTs7O0FBMk5oQjs7Ozs7Ozs7Ozs7Ozs7QUFjQWs4QixnQkF6T2dCLDJCQXlPQUwsR0F6T0EsRUF5T0s7QUFDcEIsTUFBSVgsc0JBQXNCMzBCLElBQXRCLENBQTJCczFCLEdBQTNCLENBQUosRUFBcUM7QUFDcEMsVUFBT0EsR0FBUDtBQUNBLEdBRkQsTUFFTyxJQUFJVixtQkFBbUI1MEIsSUFBbkIsQ0FBd0JzMUIsR0FBeEIsQ0FBSixFQUFrQztBQUN4Q0EsU0FBTSxZQUFZQSxHQUFsQjtBQUNBLEdBRk0sTUFFQSxJQUFJLENBQUNULGlCQUFpQjcwQixJQUFqQixDQUFzQnMxQixHQUF0QixDQUFMLEVBQWlDO0FBQ3ZDQSxTQUFNLEtBQUt2WixjQUFMLEdBQXNCLFlBQVl1WixHQUFsQyxHQUF3Q0EsR0FBOUM7QUFDQTs7QUFFRCxTQUFPQSxHQUFQO0FBQ0E7QUFuUGUsQ0FBakI7O0FBc1BBeGdDLFNBQVNnbkIsSUFBVCxHQUFnQmhuQixTQUFTZ25CLElBQVQsSUFBaUJBLElBQWpDLEM7Ozs7Ozs7Ozs7Ozs7O0FDNVFBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU02YSxzQkFBc0IsU0FBdEJBLG1CQUFzQixDQUFTNWdDLE1BQVQsRUFBaUI7QUFDNUMsS0FBTTZnQyxVQUFVLENBQUMsWUFBRCxFQUFlLE1BQWYsRUFBdUIsV0FBdkIsQ0FBaEI7O0FBRUFBLFNBQVF0cEIsT0FBUixDQUFnQixzQkFBYztBQUM3QixNQUFJdlgsT0FBTzhnQyxVQUFQLENBQUosRUFBd0I7QUFDdkI5Z0MsVUFBTzhnQyxVQUFQLElBQXFCL2hDLFNBQVN5TyxLQUFULENBQWV1ekIsUUFBZixDQUNwQi9nQyxPQUFPOGdDLFVBQVAsQ0FEb0IsRUFFcEIsZ0NBQXdCO0FBQ3ZCLFFBQU1FLFVBQVU7QUFDZkMsWUFBT0gsVUFEUTtBQUVmOWdDO0FBRmUsS0FBaEI7O0FBS0EsV0FBTyxVQUFTbEIsTUFBVCxFQUFpQjtBQUN2QkEsWUFBT3UvQixvQkFBUCxHQUE4QjJDLE9BQTlCOztBQUVBO0FBQ0FFLDBCQUFxQjFpQyxJQUFyQixDQUEwQixJQUExQixFQUFnQ00sTUFBaEM7O0FBRUFBLFlBQU91L0Isb0JBQVAsR0FBOEIsSUFBOUI7QUFDQSxLQVBEO0FBUUEsSUFoQm1CLENBQXJCO0FBa0JBO0FBQ0QsRUFyQkQ7QUFzQkEsQ0F6QkQ7O0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU04Qyw2QkFBNkIsU0FBN0JBLDBCQUE2QixDQUFTekgsUUFBVCxFQUFtQjtBQUNyRCxLQUFJLE9BQU9BLFFBQVAsS0FBb0IsUUFBeEIsRUFBa0M7QUFDakNBLGFBQVdBLFNBQVM5ckIsS0FBVCxDQUFlLEdBQWYsQ0FBWDtBQUNBOztBQUVELFFBQU84ckIsU0FBU25tQixNQUFULENBQWdCLG1CQUFXO0FBQ2pDLFNBQU82dEIsWUFBWSxTQUFuQjtBQUNBLEVBRk0sQ0FBUDtBQUdBLENBUkQ7O0FBVUE7Ozs7OztBQU1BOzs7Ozs7Ozs7Ozs7O0FBYUFyaUMsU0FBU3FuQixPQUFULENBQWlCMWMsSUFBakIsR0FBd0IzSyxTQUFTeU8sS0FBVCxDQUFldXpCLFFBQWYsQ0FDdkJoaUMsU0FBU3FuQixPQUFULENBQWlCMWMsSUFETSxFQUV2Qix1QkFBZTtBQUNkO0FBQ0E7QUFDQSxRQUFPLFVBQVMyM0IsS0FBVCxFQUFnQng0QixRQUFoQixFQUEwQnk0QixLQUExQixFQUFpQztBQUN2QztBQUNBQyxjQUFZL2lDLElBQVosQ0FBaUIsSUFBakIsRUFBdUI2aUMsS0FBdkIsRUFBOEIsbUJBQVc7QUFDeEMsT0FBSXg0QixRQUFKLEVBQWM7QUFDYnJJLFdBQU9DLElBQVAsQ0FBWTJsQixPQUFaLEVBQXFCN08sT0FBckIsQ0FBNkIsc0JBQWM7QUFDMUMsU0FBTXZYLFNBQVNvbUIsUUFBUTNiLFVBQVIsQ0FBZjs7QUFFQSxTQUFJekssT0FBTzA1QixRQUFYLEVBQXFCO0FBQ3BCMTVCLGFBQU8wNUIsUUFBUCxHQUFrQnlILDJCQUNqQm5oQyxPQUFPMDVCLFFBRFUsQ0FBbEI7QUFHQTs7QUFFRGtILHlCQUFvQjVnQyxNQUFwQjtBQUNBLEtBVkQ7O0FBWUE2SSxhQUFTckssSUFBVCxDQUFjOGlDLEtBQWQsRUFBcUJsYixPQUFyQjtBQUNBO0FBQ0QsR0FoQkQ7QUFpQkEsRUFuQkQ7QUFvQkEsQ0F6QnNCLENBQXhCLEM7Ozs7Ozs7Ozs7Ozs7O0FDekVBOzs7OztBQUtBLElBQUksQ0FBQ3JuQixTQUFTcW5CLE9BQVQsQ0FBaUJ4bkIsR0FBakIsQ0FBcUIsb0JBQXJCLENBQUwsRUFBaUQ7QUFDaERHLFVBQVN5UCx1QkFBVCxHQUFtQyxDQUFuQztBQUNBelAsVUFBUzJRLHVCQUFULEdBQW1DLENBQW5DO0FBQ0EzUSxVQUFTOFIsdUJBQVQsR0FBbUMsQ0FBbkM7QUFDQTlSLFVBQVMrUix1QkFBVCxHQUFtQyxDQUFuQzs7QUFFQTs7Ozs7Ozs7O0FBU0EsVUFBUzB3QixlQUFULEdBQTJCLENBQUU7O0FBRTdCQSxpQkFBZ0JscUIsU0FBaEIsR0FBNEI7QUFDM0IvWSxlQUFhaWpDLGVBRGM7O0FBRzNCOzs7Ozs7Ozs7QUFTQUMsMEJBWjJCLG9DQVlGN3lCLENBWkUsRUFZQ0UsQ0FaRCxFQVlJO0FBQzlCLFFBQUs0eUIsd0JBQUwsQ0FBOEI5eUIsQ0FBOUIsRUFBaUNFLENBQWpDLEVBQW9DRixDQUFwQyxFQUF1Q0UsQ0FBdkM7QUFDQSxHQWQwQjs7O0FBZ0IzQjs7Ozs7Ozs7Ozs7QUFXQTR5QiwwQkEzQjJCLG9DQTJCRkMsTUEzQkUsRUEyQk1DLE1BM0JOLEVBMkJjQyxJQTNCZCxFQTJCb0JDLElBM0JwQixFQTJCMEI7QUFDcEQsT0FBSUMsWUFBSjtBQUNBLE9BQUlDLHFCQUFKO0FBQ0EsT0FBSUMsa0JBQUo7QUFDQSxPQUFJejJCLGNBQUo7QUFDQSxPQUFJMDJCLGNBQUo7QUFDQSxPQUFJNTJCLHVCQUFKO0FBQ0EsT0FBSTYyQixvQkFBSjs7QUFFQSxPQUFJLE9BQU9oZ0MsU0FBU2lnQyxzQkFBaEIsS0FBMkMsVUFBL0MsRUFBMkQ7QUFDMURGLFlBQVEvL0IsU0FBU2lnQyxzQkFBVCxDQUFnQ1QsTUFBaEMsRUFBd0NDLE1BQXhDLENBQVI7QUFDQUcsVUFBTTUvQixTQUFTaWdDLHNCQUFULENBQWdDUCxJQUFoQyxFQUFzQ0MsSUFBdEMsQ0FBTjs7QUFFQXgyQixxQkFBaUI0MkIsTUFBTUcsVUFBdkI7QUFDQUwsbUJBQWVELElBQUlNLFVBQW5COztBQUVBRixrQkFBY0QsTUFBTTVDLE1BQXBCO0FBQ0EyQyxnQkFBWUYsSUFBSXpDLE1BQWhCOztBQUVBOXpCLFlBQVEsS0FBSzgyQixXQUFMLEVBQVI7QUFDQSxJQVhELE1BV08sSUFBSSxPQUFPbmdDLFNBQVNvZ0MsbUJBQWhCLEtBQXdDLFVBQTVDLEVBQXdEO0FBQzlETCxZQUFRLy9CLFNBQVNvZ0MsbUJBQVQsQ0FBNkJaLE1BQTdCLEVBQXFDQyxNQUFyQyxDQUFSO0FBQ0FHLFVBQU01L0IsU0FBU29nQyxtQkFBVCxDQUE2QlYsSUFBN0IsRUFBbUNDLElBQW5DLENBQU47O0FBRUF4MkIscUJBQWlCNDJCLE1BQU01MkIsY0FBdkI7QUFDQTAyQixtQkFBZUQsSUFBSXoyQixjQUFuQjs7QUFFQTYyQixrQkFBY0QsTUFBTUMsV0FBcEI7QUFDQUYsZ0JBQVlGLElBQUlJLFdBQWhCOztBQUVBMzJCLFlBQVEsS0FBSzgyQixXQUFMLEVBQVI7QUFDQTs7QUFFRCxPQUFJOTJCLFNBQVNySixTQUFTRCxZQUF0QixFQUFvQztBQUNuQ3NKLFVBQU1DLFFBQU4sQ0FDQyxJQUFJMU0sU0FBU3dFLEdBQVQsQ0FBYTVFLElBQWpCLENBQXNCMk0sY0FBdEIsQ0FERCxFQUVDNjJCLFdBRkQ7QUFJQTMyQixVQUFNRSxNQUFOLENBQWEsSUFBSTNNLFNBQVN3RSxHQUFULENBQWE1RSxJQUFqQixDQUFzQnFqQyxZQUF0QixDQUFiLEVBQWtEQyxTQUFsRDs7QUFFQSxTQUFLLy9CLFlBQUwsR0FBb0I4SixZQUFwQixDQUFpQyxDQUFDUixLQUFELENBQWpDO0FBQ0EsSUFSRCxNQVFPLElBQUksT0FBT3JKLFNBQVNxQyxJQUFULENBQWNnK0IsZUFBckIsS0FBeUMsVUFBN0MsRUFBeUQ7QUFDL0QsUUFBTW5nQyxZQUFZLEtBQUtILFlBQUwsRUFBbEI7O0FBRUFHLGNBQVVrSyxNQUFWOztBQUVBZixZQUFRckosU0FBU3FDLElBQVQsQ0FBY2crQixlQUFkLEVBQVI7QUFDQWgzQixVQUFNMkcsV0FBTixDQUFrQnd2QixNQUFsQixFQUEwQkMsTUFBMUI7O0FBRUEsUUFBTWEsV0FBV2ozQixNQUFNazNCLFNBQU4sRUFBakI7QUFDQUQsYUFBU3R3QixXQUFULENBQXFCMHZCLElBQXJCLEVBQTJCQyxJQUEzQjs7QUFFQXQyQixVQUFNbTNCLFdBQU4sQ0FBa0IsVUFBbEIsRUFBOEJGLFFBQTlCO0FBQ0FqM0IsVUFBTXMwQixNQUFOOztBQUVBLFNBQUs1OUIsWUFBTCxHQUFvQm1LLElBQXBCO0FBQ0E7QUFDRCxHQXBGMEI7OztBQXNGM0I7Ozs7Ozs7Ozs7OztBQVlBdTJCLGdCQWxHMkIsNEJBa0dWO0FBQ2hCLE9BQU12Z0MsWUFBWSxLQUFLSCxZQUFMLEVBQWxCOztBQUVBLE9BQUlxTixTQUFTO0FBQ1ppQixZQUFRLENBREk7QUFFWjNCLFVBQU0sQ0FGTTtBQUdab0IsV0FBTyxDQUhLO0FBSVpsQixTQUFLO0FBSk8sSUFBYjs7QUFPQSxPQUFNK1gsWUFBWXprQixVQUFVMGtCLGVBQVYsRUFBbEI7O0FBRUEsT0FBSSxDQUFDRCxVQUFVbm1CLE1BQWYsRUFBdUI7QUFDdEIsV0FBTzRPLE1BQVA7QUFDQTs7QUFFRCxPQUFNc3pCLGlCQUFpQi9iLFVBQVUsQ0FBVixFQUFhZ2MsU0FBYixDQUF1QjFnQyxDQUE5Qzs7QUFFQXlnQyxrQkFBZWwxQixLQUFmLENBQXFCNlYsT0FBckIsR0FBK0IsY0FBL0I7O0FBRUFqVSxZQUFTLElBQUl4USxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUJpK0IsY0FBekIsRUFBeUMxTCxhQUF6QyxFQUFUOztBQUVBMEwsa0JBQWVuaEMsVUFBZixDQUEwQkMsV0FBMUIsQ0FBc0NraEMsY0FBdEM7O0FBRUEsT0FBTUUsWUFBWSxJQUFJaGtDLFNBQVN3RSxHQUFULENBQWF0QixNQUFqQixDQUNqQkEsTUFEaUIsRUFFaEIrZ0MsaUJBRmdCLEVBQWxCOztBQUlBenpCLFVBQU9pQixNQUFQLEdBQWdCdXlCLFVBQVVqMEIsQ0FBVixHQUFjUyxPQUFPaUIsTUFBckM7QUFDQWpCLFVBQU9WLElBQVAsR0FBY2swQixVQUFVbjBCLENBQVYsR0FBY1csT0FBT1YsSUFBbkM7QUFDQVUsVUFBT1UsS0FBUCxHQUFlOHlCLFVBQVVuMEIsQ0FBVixHQUFjVyxPQUFPVSxLQUFwQztBQUNBVixVQUFPUixHQUFQLEdBQWFnMEIsVUFBVWowQixDQUFWLEdBQWNTLE9BQU9SLEdBQWxDOztBQUVBLFVBQU9RLE1BQVA7QUFDQSxHQXBJMEI7OztBQXNJM0I7Ozs7Ozs7Ozs7O0FBV0E0bUIsa0JBakoyQiw4QkFpSlI7QUFDbEIsT0FBTTl6QixZQUFZLEtBQUtILFlBQUwsRUFBbEI7O0FBRUEsT0FBSSxDQUFDRyxVQUFVMEosU0FBVixFQUFMLEVBQTRCO0FBQzNCLFdBQU8sSUFBUDtBQUNBOztBQUVELE9BQU1vWCxTQUFTO0FBQ2R2ZSxhQUFTdkMsVUFBVXVKLGtCQUFWLEVBREs7QUFFZDZ6QixVQUFNcDlCLFVBQVU2dUIsZUFBVjtBQUZRLElBQWY7O0FBS0EvTixVQUFPNVQsTUFBUCxHQUFnQixLQUFLMHpCLGtCQUFMLENBQXdCNWdDLFNBQXhCLENBQWhCOztBQUVBLFVBQU84Z0IsTUFBUDtBQUNBLEdBaEswQjs7O0FBa0szQjs7Ozs7Ozs7Ozs7Ozs7QUFjQThmLG9CQWhMMkIsZ0NBZ0xOO0FBQ3BCLE9BQU0xekIsU0FBUyxLQUFLMnpCLG9CQUFMLEVBQWY7O0FBRUEzekIsVUFBT2hCLFNBQVAsR0FBbUIsS0FBSzQwQixxQkFBTCxFQUFuQjs7QUFFQTV6QixVQUFPMkMsTUFBUCxHQUFnQjNDLE9BQU9pQixNQUFQLEdBQWdCakIsT0FBT1IsR0FBdkM7QUFDQVEsVUFBT1AsS0FBUCxHQUFlTyxPQUFPVSxLQUFQLEdBQWVWLE9BQU9WLElBQXJDOztBQUVBLFVBQU9VLE1BQVA7QUFDQSxHQXpMMEI7OztBQTJMM0I7Ozs7Ozs7O0FBUUE2ekIsa0JBbk0yQiw4QkFtTVI7QUFDbEIsT0FBTS9nQyxZQUFZLEtBQUtILFlBQUwsRUFBbEI7O0FBRUEsT0FBSUcsVUFBVWdoQyxPQUFWLE9BQXdCdGtDLFNBQVN1a0MsY0FBckMsRUFBcUQ7QUFDcEQsV0FBTyxJQUFQO0FBQ0E7O0FBRUQsT0FBTWw0QixTQUFTL0ksVUFBVWdKLFNBQVYsRUFBZjtBQUNBLFVBQU9ELFVBQVVBLE9BQU96SyxNQUFQLEtBQWtCLENBQTVCLElBQWlDeUssT0FBTyxDQUFQLEVBQVVvMEIsU0FBbEQ7QUFDQSxHQTVNMEI7OztBQThNM0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBMEQsc0JBM08yQixrQ0EyT0o7QUFDdEIsT0FBTTdnQyxZQUFZLEtBQUtILFlBQUwsRUFBbEI7QUFDQSxPQUFNcWhDLGtCQUFrQmxoQyxVQUFVMEosU0FBVixFQUF4Qjs7QUFFQSxPQUFNeTNCLGNBQWM7QUFDbkJoekIsWUFBUSxDQURXO0FBRW5CMEIsWUFBUSxDQUZXO0FBR25CckQsVUFBTSxDQUhhO0FBSW5Cb0IsV0FBTyxDQUpZO0FBS25CbEIsU0FBSyxDQUxjO0FBTW5CQyxXQUFPO0FBTlksSUFBcEI7O0FBU0EsT0FBSU8sU0FBUztBQUNaaUIsWUFBUSxDQURJO0FBRVpoQixhQUFTZzBCLFdBRkc7QUFHWjMwQixVQUFNLENBSE07QUFJWm9CLFdBQU8sQ0FKSztBQUtabEIsU0FBSyxDQUxPO0FBTVpVLGVBQVcrekI7QUFOQyxJQUFiOztBQVNBLE9BQUksQ0FBQ0QsZUFBTCxFQUFzQjtBQUNyQixXQUFPaDBCLE1BQVA7QUFDQTs7QUFFRCxPQUFJaUIsU0FBUyxDQUFiO0FBQ0EsT0FBSWl6QixvQkFBSjtBQUNBLE9BQUk1MEIsT0FBTzYwQixRQUFYO0FBQ0EsT0FBSXp6QixRQUFRLENBQUN5ekIsUUFBYjtBQUNBLE9BQUkzMEIsTUFBTTIwQixRQUFWOztBQUVBLE9BQUlILGdCQUFnQmpCLFdBQXBCLEVBQWlDO0FBQ2hDbUIsa0JBQWNGLGdCQUFnQmpCLFdBQWhCLEdBQThCcUIsY0FBOUIsRUFBZDtBQUNBLElBRkQsTUFFTztBQUNORixrQkFDQ0YsZ0JBQWdCSyxVQUFoQixHQUE2QixDQUE3QixHQUNHTCxnQkFBZ0JNLFVBQWhCLENBQTJCLENBQTNCLEVBQThCRixjQUE5QixFQURILEdBRUcsRUFISjtBQUlBOztBQUVELE9BQUlGLFlBQVk5aUMsTUFBWixLQUF1QixDQUEzQixFQUE4QjtBQUM3QjRPLGFBQVMsS0FBS3F6QixjQUFMLEVBQVQ7QUFDQSxJQUZELE1BRU87QUFDTixTQUFLLElBQUlsaUMsSUFBSSxDQUFSLEVBQVdDLFNBQVM4aUMsWUFBWTlpQyxNQUFyQyxFQUE2Q0QsSUFBSUMsTUFBakQsRUFBeURELEdBQXpELEVBQThEO0FBQzdELFNBQU1vVSxPQUFPMnVCLFlBQVkvaUMsQ0FBWixDQUFiOztBQUVBLFNBQUlvVSxLQUFLakcsSUFBTCxHQUFZQSxJQUFoQixFQUFzQjtBQUNyQkEsYUFBT2lHLEtBQUtqRyxJQUFaO0FBQ0E7O0FBRUQsU0FBSWlHLEtBQUs3RSxLQUFMLEdBQWFBLEtBQWpCLEVBQXdCO0FBQ3ZCQSxjQUFRNkUsS0FBSzdFLEtBQWI7QUFDQTs7QUFFRCxTQUFJNkUsS0FBSy9GLEdBQUwsR0FBV0EsR0FBZixFQUFvQjtBQUNuQkEsWUFBTStGLEtBQUsvRixHQUFYO0FBQ0E7O0FBRUQsU0FBSStGLEtBQUt0RSxNQUFMLEdBQWNBLE1BQWxCLEVBQTBCO0FBQ3pCQSxlQUFTc0UsS0FBS3RFLE1BQWQ7QUFDQTtBQUNEOztBQUVELFFBQU11eUIsWUFBWSxJQUFJaGtDLFNBQVN3RSxHQUFULENBQWF0QixNQUFqQixDQUNqQkEsTUFEaUIsRUFFaEIrZ0MsaUJBRmdCLEVBQWxCOztBQUlBenpCLFdBQU9pQixNQUFQLEdBQWdCdXlCLFVBQVVqMEIsQ0FBVixHQUFjMEIsTUFBOUI7QUFDQWpCLFdBQU9WLElBQVAsR0FBY2swQixVQUFVbjBCLENBQVYsR0FBY0MsSUFBNUI7QUFDQVUsV0FBT1UsS0FBUCxHQUFlOHlCLFVBQVVuMEIsQ0FBVixHQUFjcUIsS0FBN0I7QUFDQVYsV0FBT1IsR0FBUCxHQUFhZzBCLFVBQVVqMEIsQ0FBVixHQUFjQyxHQUEzQjs7QUFFQSxRQUFJMDBCLFlBQVk5aUMsTUFBaEIsRUFBd0I7QUFDdkIsU0FBTTZPLFVBQVVpMEIsWUFBWUEsWUFBWTlpQyxNQUFaLEdBQXFCLENBQWpDLENBQWhCO0FBQ0EsU0FBTThPLFlBQVlnMEIsWUFBWSxDQUFaLENBQWxCOztBQUVBbDBCLFlBQU9DLE9BQVAsR0FBaUI7QUFDaEJnQixjQUFRdXlCLFVBQVVqMEIsQ0FBVixHQUFjVSxRQUFRZ0IsTUFEZDtBQUVoQjBCLGNBQVExQyxRQUFRMEMsTUFGQTtBQUdoQnJELFlBQU1rMEIsVUFBVW4wQixDQUFWLEdBQWNZLFFBQVFYLElBSFo7QUFJaEJvQixhQUFPOHlCLFVBQVVuMEIsQ0FBVixHQUFjWSxRQUFRUyxLQUpiO0FBS2hCbEIsV0FBS2cwQixVQUFVajBCLENBQVYsR0FBY1UsUUFBUVQsR0FMWDtBQU1oQkMsYUFBT1EsUUFBUVI7QUFOQyxNQUFqQjs7QUFTQU8sWUFBT0UsU0FBUCxHQUFtQjtBQUNsQmUsY0FBUXV5QixVQUFVajBCLENBQVYsR0FBY1csVUFBVWUsTUFEZDtBQUVsQjBCLGNBQVF6QyxVQUFVeUMsTUFGQTtBQUdsQnJELFlBQU1rMEIsVUFBVW4wQixDQUFWLEdBQWNhLFVBQVVaLElBSFo7QUFJbEJvQixhQUFPOHlCLFVBQVVuMEIsQ0FBVixHQUFjYSxVQUFVUSxLQUpiO0FBS2xCbEIsV0FBS2cwQixVQUFVajBCLENBQVYsR0FBY1csVUFBVVYsR0FMWDtBQU1sQkMsYUFBT1MsVUFBVVQ7QUFOQyxNQUFuQjtBQVFBO0FBQ0Q7O0FBRUQsVUFBT08sTUFBUDtBQUNBLEdBN1UwQjs7O0FBK1UzQjs7Ozs7Ozs7Ozs7QUFXQTR6Qix1QkExVjJCLG1DQTBWSDtBQUN2QixPQUFJNTBCLFlBQVl4UCxTQUFTeVAsdUJBQXpCO0FBQ0EsT0FBTW5NLFlBQVksS0FBS0gsWUFBTCxFQUFsQjtBQUNBLE9BQU1xaEMsa0JBQWtCbGhDLFVBQVUwSixTQUFWLEVBQXhCOztBQUVBLE9BQUksQ0FBQ3czQixlQUFMLEVBQXNCO0FBQ3JCLFdBQU9oMUIsU0FBUDtBQUNBOztBQUVELE9BQUl1MUIsbUJBQUo7O0FBRUEsT0FDQyxDQUFDQSxhQUFhUCxnQkFBZ0JPLFVBQTlCLEtBQ0FBLFdBQVdDLHVCQUZaLEVBR0U7QUFDRCxRQUFNMU0sV0FBV3lNLFdBQVdDLHVCQUFYLENBQ2hCUixnQkFBZ0JTLFNBREEsQ0FBakI7O0FBSUEsUUFDRSxDQUFDM00sUUFBRCxJQUNBa00sZ0JBQWdCVSxZQUFoQixHQUNDVixnQkFBZ0JXLFdBRmxCLElBR0E3TSxhQUFhOE0sS0FBS0MsMkJBSm5CLEVBS0U7QUFDRDcxQixpQkFBWXhQLFNBQVMyUSx1QkFBckI7QUFDQTtBQUNEOztBQUVELFVBQU9uQixTQUFQO0FBQ0E7QUF4WDBCLEVBQTVCOztBQTJYQXhQLFVBQVNxbkIsT0FBVCxDQUFpQnZmLEdBQWpCLENBQXFCLG9CQUFyQixFQUEyQztBQUMxQzYyQixNQUQwQyxnQkFDckM1K0IsTUFEcUMsRUFDN0I7QUFDWixPQUFJdWxDLGFBQUo7QUFDQSxPQUFNekksaUJBQWlCcDdCLE9BQU84VyxTQUFQLENBQWlCc2tCLGNBQXhDOztBQUVBLFFBQUt5SSxJQUFMLElBQWE3QyxnQkFBZ0JscUIsU0FBN0IsRUFBd0M7QUFDdkMsUUFDQ3NrQixlQUFlcDlCLElBQWYsQ0FBb0JnakMsZ0JBQWdCbHFCLFNBQXBDLEVBQStDK3NCLElBQS9DLEtBQ0EsT0FBT3ZsQyxPQUFPdWxDLElBQVAsQ0FBUCxLQUF3QixXQUZ6QixFQUdFO0FBQ0R2bEMsWUFBT3VsQyxJQUFQLElBQWU3QyxnQkFBZ0JscUIsU0FBaEIsQ0FBMEIrc0IsSUFBMUIsQ0FBZjtBQUNBO0FBQ0Q7QUFDRDtBQWJ5QyxFQUEzQztBQWVBLEM7Ozs7Ozs7Ozs7Ozs7O0FDaGFEOzs7OztBQUtBLElBQU1DLG1DQUFtQztBQUN4Q25VLFFBQU8sQ0FEaUM7QUFFeENvVSxNQUFLLENBRm1DO0FBR3hDQyxXQUFVLENBSDhCO0FBSXhDQyxRQUFPLENBSmlDO0FBS3hDQyxLQUFJLENBTG9DO0FBTXhDQyxRQUFPLENBTmlDO0FBT3hDQyxLQUFJLENBUG9DO0FBUXhDQyxRQUFPLENBUmlDO0FBU3hDQyxLQUFJO0FBVG9DLENBQXpDOztBQVlBOzs7Ozs7OztBQVFBLFNBQVM5VyxLQUFULENBQWVsdkIsTUFBZixFQUF1QjtBQUN0QixNQUFLa0MsT0FBTCxHQUFlbEMsTUFBZjtBQUNBOztBQUVEa3ZCLE1BQU0rVyxZQUFOLEdBQXFCLE1BQXJCO0FBQ0EvVyxNQUFNZ1gsV0FBTixHQUFvQixRQUFwQjtBQUNBaFgsTUFBTWlYLFlBQU4sR0FBcUIsTUFBckI7QUFDQWpYLE1BQU1rWCxXQUFOLEdBQW9CLEtBQXBCOztBQUVBbFgsTUFBTTFXLFNBQU4sR0FBa0I7QUFDakIvWSxjQUFheXZCLEtBREk7O0FBR2pCOzs7Ozs7Ozs7QUFTQXhILE9BWmlCLGtCQVlWbm9CLE1BWlUsRUFZRjtBQUNkLE1BQU1TLFNBQVMsS0FBS2tDLE9BQXBCO0FBQ0EsTUFBTW12QixRQUFRLEtBQUtnVixjQUFMLENBQW9CLE9BQXBCLENBQWQ7O0FBRUE5bUMsV0FBU0EsVUFBVSxFQUFuQjs7QUFFQTtBQUNBLE1BQU1vbUMsUUFBUXRVLE1BQU1pVixNQUFOLENBQWEsS0FBS0QsY0FBTCxDQUFvQixPQUFwQixDQUFiLENBQWQ7QUFDQSxNQUFNaFgsT0FBTzl2QixPQUFPOHZCLElBQVAsSUFBZSxDQUE1QjtBQUNBLE1BQU1ELE9BQU83dkIsT0FBTzZ2QixJQUFQLElBQWUsQ0FBNUI7O0FBRUEsT0FBSyxJQUFJeHRCLElBQUksQ0FBYixFQUFnQkEsSUFBSXl0QixJQUFwQixFQUEwQnp0QixHQUExQixFQUErQjtBQUM5QixPQUFNNG9CLE1BQU1tYixNQUFNVyxNQUFOLENBQWEsS0FBS0QsY0FBTCxDQUFvQixJQUFwQixDQUFiLENBQVo7QUFDQSxRQUFLLElBQUlFLElBQUksQ0FBYixFQUFnQkEsSUFBSW5YLElBQXBCLEVBQTBCbVgsR0FBMUIsRUFBK0I7QUFDOUIsUUFBTTFZLE9BQU9yRCxJQUFJOGIsTUFBSixDQUFXLEtBQUtELGNBQUwsQ0FBb0IsSUFBcEIsQ0FBWCxDQUFiOztBQUVBeFksU0FBSzJZLFdBQUw7QUFDQTtBQUNEOztBQUVELE9BQUs5RSxhQUFMLENBQW1CclEsS0FBbkIsRUFBMEI5eEIsT0FBT29RLEtBQWpDO0FBQ0EsT0FBSzgyQixVQUFMLENBQWdCcFYsS0FBaEIsRUFBdUI5eEIsT0FBT21uQyxPQUE5Qjs7QUFFQTtBQUNBMW1DLFNBQU9vZCxhQUFQLENBQXFCaVUsS0FBckI7O0FBRUEsTUFBTXNWLFlBQVksSUFBSTFtQyxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUJ1ckIsTUFBTS90QixDQUFOLENBQVErckIsSUFBUixDQUFhLENBQWIsRUFBZ0J1WCxLQUFoQixDQUFzQixDQUF0QixDQUF6QixDQUFsQjtBQUNBLE1BQU1sNkIsUUFBUTFNLE9BQU93akMsV0FBUCxFQUFkO0FBQ0E5MkIsUUFBTW02QixjQUFOLENBQXFCRixTQUFyQixFQUFnQzFtQyxTQUFTNm1DLG9CQUF6QztBQUNBcDZCLFFBQU1zMEIsTUFBTjs7QUFFQSxTQUFPM1AsS0FBUDtBQUNBLEVBNUNnQjs7O0FBOENqQjs7Ozs7Ozs7QUFRQTFKLGlCQXREaUIsOEJBc0RFO0FBQ2xCLE1BQUkwSixjQUFKO0FBQ0EsTUFBTTl0QixZQUFZLEtBQUtyQixPQUFMLENBQWFrQixZQUFiLEVBQWxCO0FBQ0EsTUFBTXVpQixXQUFXcGlCLFVBQVV1SixrQkFBVixFQUFqQjs7QUFFQSxNQUFJNlksWUFBWUEsU0FBU3NiLEVBQVQsQ0FBWSxPQUFaLENBQWhCLEVBQXNDO0FBQ3JDNVAsV0FBUTFMLFFBQVI7QUFDQSxHQUZELE1BRU87QUFDTixPQUFNclosU0FBUy9JLFVBQVVnSixTQUFWLEVBQWY7O0FBRUEsT0FBSUQsT0FBT3pLLE1BQVAsR0FBZ0IsQ0FBcEIsRUFBdUI7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLFFBQUk1QixTQUFTYyxHQUFULENBQWFnbUMsTUFBakIsRUFBeUI7QUFDeEJ6NkIsWUFBTyxDQUFQLEVBQVUrMEIsTUFBVixDQUFpQnBoQyxTQUFTK21DLFlBQTFCO0FBQ0E7O0FBRUQzVixZQUFRLEtBQUtudkIsT0FBTCxDQUNOd0MsV0FETSxDQUNNNEgsT0FBTyxDQUFQLEVBQVUrekIsaUJBQVYsQ0FBNEIsSUFBNUIsQ0FETixFQUVONUksUUFGTSxDQUVHLE9BRkgsRUFFWSxDQUZaLENBQVI7QUFHQTtBQUNEOztBQUVELFNBQU9wRyxLQUFQO0FBQ0EsRUFoRmdCOzs7QUFrRmpCOzs7Ozs7Ozs7Ozs7Ozs7QUFlQTRWLFdBakdpQixzQkFpR04vcEIsRUFqR00sRUFpR0Y7QUFDZCxNQUFJLENBQUNqZCxTQUFTYyxHQUFULENBQWFDLEVBQWQsSUFBb0IsQ0FBQ2tjLEdBQUcrakIsRUFBSCxDQUFNdUUsZ0NBQU4sQ0FBekIsRUFBa0U7QUFDakUsVUFBTyxDQUFDdG9CLEdBQUdncUIsVUFBSCxFQUFSO0FBQ0E7O0FBRUQsTUFBSWhxQixHQUFHaXFCLFlBQUgsQ0FBZ0IsaUJBQWhCLENBQUosRUFBd0M7QUFDdkMsVUFBT2pxQixHQUFHdkUsWUFBSCxDQUFnQixpQkFBaEIsTUFBdUMsT0FBOUM7QUFDQTs7QUFFRCxTQUFPLEtBQUtzdUIsVUFBTCxDQUFnQi9wQixHQUFHa3FCLFNBQUgsRUFBaEIsQ0FBUDtBQUNBLEVBM0dnQjs7O0FBNkdqQjs7Ozs7Ozs7O0FBU0EvVyxXQXRIaUIsc0JBc0hOZ0IsS0F0SE0sRUFzSEM7QUFDakJBLFVBQVFBLFNBQVMsS0FBSzFKLGdCQUFMLEVBQWpCOztBQUVBLE1BQUksQ0FBQzBKLEtBQUwsRUFBWTtBQUNYLFVBQU8sSUFBUDtBQUNBOztBQUVELE1BQU1nVyxxQkFBcUJoVyxNQUFNL3RCLENBQU4sQ0FBUWdrQyxLQUFSLEtBQWtCLElBQTdDOztBQUVBLE1BQUlDLHFCQUFxQixJQUF6Qjs7QUFFQTtBQUNBLE9BQUssSUFBSS9jLE1BQU0sQ0FBZixFQUFrQkEsTUFBTTZHLE1BQU0vdEIsQ0FBTixDQUFRK3JCLElBQVIsQ0FBYXh0QixNQUFyQyxFQUE2QzJvQixLQUE3QyxFQUFvRDtBQUNuRDtBQUNBLE9BQU1xRCxPQUFPd0QsTUFBTS90QixDQUFOLENBQVErckIsSUFBUixDQUFhN0UsR0FBYixFQUFrQm9jLEtBQWxCLENBQXdCLENBQXhCLENBQWI7O0FBRUEsT0FBSS9ZLFFBQVFBLEtBQUsyWixRQUFMLENBQWNoOUIsV0FBZCxPQUFnQyxJQUE1QyxFQUFrRDtBQUNqRCs4Qix5QkFBcUIsS0FBckI7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQsTUFBSUUsa0JBQWtCdlksTUFBTWlYLFlBQTVCOztBQUVBLE1BQUlrQixrQkFBSixFQUF3QjtBQUN2QkkscUJBQWtCdlksTUFBTWtYLFdBQXhCO0FBQ0E7O0FBRUQsTUFBSW1CLGtCQUFKLEVBQXdCO0FBQ3ZCRSxxQkFDQ0Esb0JBQW9CdlksTUFBTWtYLFdBQTFCLEdBQ0dsWCxNQUFNK1csWUFEVCxHQUVHL1csTUFBTWdYLFdBSFY7QUFJQTs7QUFFRCxTQUFPdUIsZUFBUDtBQUNBLEVBMUpnQjs7O0FBNEpqQjs7Ozs7Ozs7QUFRQXQ2QixPQXBLaUIsa0JBb0tWa2tCLEtBcEtVLEVBb0tIO0FBQ2IsTUFBTXJ4QixTQUFTLEtBQUtrQyxPQUFwQjs7QUFFQSxNQUFJbXZCLEtBQUosRUFBVztBQUNWQSxTQUFNbGtCLE1BQU47QUFDQSxHQUZELE1BRU87QUFDTmtrQixXQUFRcnhCLE9BQU8wRSxXQUFQLEdBQXFCK3lCLFFBQXJCLENBQThCLE9BQTlCLEVBQXVDLENBQXZDLENBQVI7O0FBRUEsT0FBSXBHLEtBQUosRUFBVztBQUNWO0FBQ0EsUUFBTXFXLFNBQVNyVyxNQUFNK1YsU0FBTixFQUFmO0FBQ0EsUUFBTTdsQyxXQUFXdkIsT0FBT3VCLFFBQVAsRUFBakI7O0FBRUEsUUFDQ21tQyxPQUFPQyxhQUFQLE9BQTJCLENBQTNCLElBQ0EsQ0FBQ0QsT0FBT3pHLEVBQVAsQ0FBVSxJQUFWLEVBQWdCLElBQWhCLENBREQsSUFFQSxDQUFDeUcsT0FBT3RILE1BQVAsQ0FBYzcrQixRQUFkLENBSEYsRUFJRTtBQUNEOHZCLGFBQVFxVyxNQUFSO0FBQ0E7O0FBRUQsUUFBTWg3QixRQUFRMU0sT0FBT3dqQyxXQUFQLEVBQWQ7QUFDQTkyQixVQUFNbTZCLGNBQU4sQ0FBcUJ4VixLQUFyQixFQUE0QnB4QixTQUFTMm5DLHFCQUFyQztBQUNBdlcsVUFBTWxrQixNQUFOO0FBQ0E7QUFDRDtBQUNELEVBOUxnQjs7O0FBZ01qQjs7Ozs7Ozs7O0FBU0F1MEIsY0F6TWlCLHlCQXlNSHJRLEtBek1HLEVBeU1JMWhCLEtBek1KLEVBeU1XO0FBQzNCLE1BQUlBLEtBQUosRUFBVztBQUNWak8sVUFBT0MsSUFBUCxDQUFZZ08sS0FBWixFQUFtQjhJLE9BQW5CLENBQTJCLGdCQUFRO0FBQ2xDNFksVUFBTXR4QixZQUFOLENBQW1Cd2xDLElBQW5CLEVBQXlCNTFCLE1BQU00MUIsSUFBTixDQUF6QjtBQUNBLElBRkQ7QUFHQTtBQUNELEVBL01nQjs7O0FBaU5qQjs7Ozs7Ozs7O0FBU0FrQixXQTFOaUIsc0JBME5OcFYsS0ExTk0sRUEwTkNxVixPQTFORCxFQTBOVTtBQUMxQnJWLFVBQVFBLFNBQVMsS0FBSzFKLGdCQUFMLEVBQWpCOztBQUVBLE1BQUkvbEIsVUFBSjtBQUNBLE1BQUlpbUMsZ0JBQUo7QUFDQSxNQUFJQyxrQkFBSjtBQUNBLE1BQU1DLFlBQVkxVyxNQUFNMlcsZ0JBQU4sQ0FBdUIsT0FBdkIsRUFBZ0M1RyxPQUFoQyxDQUF3QyxDQUF4QyxDQUFsQjs7QUFFQSxNQUFJNkcsZUFBZSxLQUFLNVgsVUFBTCxDQUFnQmdCLEtBQWhCLENBQW5CO0FBQ0EsTUFBTTZXLGdCQUNMRCxpQkFBaUIvWSxNQUFNZ1gsV0FBdkIsSUFDQStCLGlCQUFpQi9ZLE1BQU0rVyxZQUZ4Qjs7QUFJQSxNQUFNa0MsaUJBQ0x6QixZQUFZeFgsTUFBTWdYLFdBQWxCLElBQWlDUSxZQUFZeFgsTUFBTStXLFlBRHBEO0FBRUEsTUFBTW1DLGlCQUNMMUIsWUFBWXhYLE1BQU1rWCxXQUFsQixJQUFpQ00sWUFBWXhYLE1BQU0rVyxZQURwRDs7QUFHQTtBQUNBO0FBQ0EsTUFBSSxDQUFDNVUsTUFBTS90QixDQUFOLENBQVFna0MsS0FBVCxJQUFrQmMsY0FBdEIsRUFBc0M7QUFDckMsT0FBTUMsZ0JBQWdCTixVQUFVQyxnQkFBVixDQUEyQixJQUEzQixFQUFpQzVHLE9BQWpDLENBQXlDLENBQXpDLENBQXRCO0FBQ0EsT0FBTWtILDBCQUEwQkQsY0FBY1YsYUFBZCxFQUFoQzs7QUFFQTtBQUNBLFFBQUsvbEMsSUFBSSxDQUFULEVBQVlBLElBQUkwbUMsdUJBQWhCLEVBQXlDMW1DLEdBQXpDLEVBQThDO0FBQzdDLFFBQU1pc0IsT0FBT3dhLGNBQWNFLFFBQWQsQ0FBdUIzbUMsQ0FBdkIsQ0FBYjs7QUFFQTtBQUNBLFFBQ0Npc0IsS0FBSzNtQixJQUFMLEtBQWNqSCxTQUFTK21DLFlBQXZCLElBQ0EsQ0FBQ25aLEtBQUs5cEIsSUFBTCxDQUFVLGNBQVYsQ0FGRixFQUdFO0FBQ0Q4cEIsVUFBSzJhLFVBQUwsQ0FBZ0IsSUFBaEI7QUFDQTNhLFVBQUs5dEIsWUFBTCxDQUFrQixPQUFsQixFQUEyQixLQUEzQjtBQUNBO0FBQ0Q7O0FBRUQrbkMsZUFBWSxLQUFLekIsY0FBTCxDQUFvQmhWLE1BQU0vdEIsQ0FBTixDQUFRbWxDLFdBQVIsRUFBcEIsQ0FBWjtBQUNBWCxhQUFVeEIsTUFBVixDQUFpQitCLGNBQWNsN0IsTUFBZCxFQUFqQjtBQUNBOztBQUVEO0FBQ0E7QUFDQSxNQUFJa2tCLE1BQU0vdEIsQ0FBTixDQUFRZ2tDLEtBQVIsS0FBa0IsSUFBbEIsSUFBMEIsQ0FBQ2MsY0FBL0IsRUFBK0M7QUFDOUM7QUFDQU4sZUFBWSxLQUFLekIsY0FBTCxDQUFvQmhWLE1BQU0vdEIsQ0FBTixDQUFRZ2tDLEtBQTVCLENBQVo7O0FBRUEsT0FBTW9CLG1CQUFtQlgsVUFBVVksUUFBVixFQUF6Qjs7QUFFQSxVQUFPYixVQUFVSCxhQUFWLEtBQTRCLENBQW5DLEVBQXNDO0FBQ3JDLFFBQU1pQixjQUFjZCxVQUFVYSxRQUFWLEVBQXBCO0FBQ0EsUUFBTUUsd0JBQXdCRCxZQUFZakIsYUFBWixFQUE5Qjs7QUFFQSxTQUFLL2xDLElBQUksQ0FBVCxFQUFZQSxJQUFJaW5DLHFCQUFoQixFQUF1Q2puQyxHQUF2QyxFQUE0QztBQUMzQ2ltQyxlQUFVZSxZQUFZTCxRQUFaLENBQXFCM21DLENBQXJCLENBQVY7O0FBRUEsU0FBSWltQyxRQUFRM2dDLElBQVIsS0FBaUJqSCxTQUFTK21DLFlBQTlCLEVBQTRDO0FBQzNDYSxjQUFRVyxVQUFSLENBQW1CLElBQW5CO0FBQ0FYLGNBQVFpQixlQUFSLENBQXdCLE9BQXhCO0FBQ0E7QUFDRDs7QUFFREYsZ0JBQVlHLFlBQVosQ0FBeUJMLGdCQUF6QjtBQUNBOztBQUVEWixhQUFVMzZCLE1BQVY7QUFDQTs7QUFFRDg2QixpQkFBZSxLQUFLNVgsVUFBTCxDQUFnQmdCLEtBQWhCLENBQWY7QUFDQSxNQUFNMlgsZ0JBQ0xmLGlCQUFpQi9ZLE1BQU1nWCxXQUF2QixJQUNBK0IsaUJBQWlCL1ksTUFBTStXLFlBRnhCOztBQUlBO0FBQ0E7QUFDQSxNQUFJLENBQUMrQyxhQUFELElBQWtCYixjQUF0QixFQUFzQztBQUNyQyxRQUFLdm1DLElBQUksQ0FBVCxFQUFZQSxJQUFJeXZCLE1BQU0vdEIsQ0FBTixDQUFRK3JCLElBQVIsQ0FBYXh0QixNQUE3QixFQUFxQ0QsR0FBckMsRUFBMEM7QUFDekMsUUFBSXl2QixNQUFNL3RCLENBQU4sQ0FBUStyQixJQUFSLENBQWF6dEIsQ0FBYixFQUFnQmdsQyxLQUFoQixDQUFzQixDQUF0QixFQUF5QlksUUFBekIsQ0FBa0NoOUIsV0FBbEMsT0FBb0QsSUFBeEQsRUFBOEQ7QUFDN0RxOUIsZUFBVSxJQUFJNW5DLFNBQVN3RSxHQUFULENBQWFxQixPQUFqQixDQUNUdXJCLE1BQU0vdEIsQ0FBTixDQUFRK3JCLElBQVIsQ0FBYXp0QixDQUFiLEVBQWdCZ2xDLEtBQWhCLENBQXNCLENBQXRCLENBRFMsQ0FBVjtBQUdBaUIsYUFBUVcsVUFBUixDQUFtQixJQUFuQjtBQUNBWCxhQUFROW5DLFlBQVIsQ0FBcUIsT0FBckIsRUFBOEIsS0FBOUI7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE1BQUltb0MsaUJBQWlCLENBQUNDLGNBQXRCLEVBQXNDO0FBQ3JDLFFBQUt2bUMsSUFBSSxDQUFULEVBQVlBLElBQUl5dkIsTUFBTS90QixDQUFOLENBQVErckIsSUFBUixDQUFheHRCLE1BQTdCLEVBQXFDRCxHQUFyQyxFQUEwQztBQUN6QyxRQUFNNG9CLE1BQU0sSUFBSXZxQixTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUJ1ckIsTUFBTS90QixDQUFOLENBQVErckIsSUFBUixDQUFhenRCLENBQWIsQ0FBekIsQ0FBWjs7QUFFQSxRQUFJNG9CLElBQUk0YyxTQUFKLEdBQWdCcjZCLE9BQWhCLE9BQThCLE9BQWxDLEVBQTJDO0FBQzFDODZCLGVBQVUsSUFBSTVuQyxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUIwa0IsSUFBSWxuQixDQUFKLENBQU1zakMsS0FBTixDQUFZLENBQVosQ0FBekIsQ0FBVjtBQUNBaUIsYUFBUVcsVUFBUixDQUFtQixJQUFuQjtBQUNBWCxhQUFRaUIsZUFBUixDQUF3QixPQUF4QjtBQUNBO0FBQ0Q7QUFDRDtBQUNELEVBL1RnQjs7O0FBaVVqQjs7Ozs7Ozs7OztBQVVBekMsZUEzVWlCLDBCQTJVRm40QixJQTNVRSxFQTJVSTtBQUNwQixTQUFPLElBQUlqTyxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUJvSSxJQUF6QixFQUErQixLQUFLaE0sT0FBTCxDQUFhbUIsUUFBNUMsQ0FBUDtBQUNBO0FBN1VnQixDQUFsQjs7QUFnVkFwRCxTQUFTMEQsRUFBVCxDQUFZLGVBQVosRUFBNkIsaUJBQVM7QUFDckMsS0FBTXNsQyxrQkFBa0IsQ0FDdkIvWixNQUFNaVgsWUFEaUIsRUFFdkJqWCxNQUFNa1gsV0FGaUIsRUFHdkJsWCxNQUFNZ1gsV0FIaUIsRUFJdkJoWCxNQUFNK1csWUFKaUIsQ0FBeEI7O0FBT0EsS0FBTWhYLGFBQWEsSUFBSUMsS0FBSixDQUFVcnJCLE1BQU03RCxNQUFoQixDQUFuQjs7QUFFQWlwQyxpQkFBZ0J4d0IsT0FBaEIsQ0FBd0IsbUJBQVc7QUFDbEM1VSxRQUFNN0QsTUFBTixDQUFhZ0MsVUFBYixDQUF3QixpQkFBaUIwa0MsT0FBekMsRUFBa0Q7QUFDakRyNkIsT0FEaUQsZ0JBQzVDbkssT0FENEMsRUFDbkM7QUFDYitzQixlQUFXd1gsVUFBWCxDQUFzQixJQUF0QixFQUE0QkMsT0FBNUI7QUFDQTtBQUhnRCxHQUFsRDtBQUtBLEVBTkQ7QUFPQSxDQWpCRDs7QUFtQkF6bUMsU0FBU2l2QixLQUFULEdBQWlCanZCLFNBQVNpdkIsS0FBVCxJQUFrQkEsS0FBbkMsQzs7Ozs7Ozs7Ozs7Ozs7QUNyWUE7Ozs7O0FBS0E7Ozs7OztBQU1BOzs7Ozs7Ozs7Ozs7OztBQWNBanZCLFNBQVN5TyxLQUFULENBQWV3NkIsS0FBZixHQUF1QixVQUN0QkMsV0FEc0IsRUFFdEJDLFNBRnNCLEVBR3RCci9CLFFBSHNCLEVBSXRCcy9CLGFBSnNCLEVBS3JCO0FBQ0QsS0FBTUMsY0FBY3JwQyxTQUFTeU8sS0FBVCxDQUFlNjZCLGFBQWYsRUFBcEI7O0FBRUFILGFBQVlBLGFBQWEsRUFBekI7QUFDQUEsV0FBVXIvQixRQUFWLEdBQXFCLCtCQUErQnUvQixXQUEvQixHQUE2QyxHQUFsRTs7QUFFQSxLQUFJLENBQUNycEMsU0FBU284QixDQUFULENBQVdtTixjQUFoQixFQUFnQztBQUMvQnZwQyxXQUFTbzhCLENBQVQsQ0FBV21OLGNBQVgsR0FBNEIsRUFBNUI7QUFDQTs7QUFFRHZwQyxVQUFTbzhCLENBQVQsQ0FBV21OLGNBQVgsQ0FBMEJGLFdBQTFCLElBQXlDLFVBQVNHLFFBQVQsRUFBbUI7QUFDM0R4L0IsYUFBVyxZQUFNO0FBQ2hCeS9COztBQUVBMy9CLFlBQVMwL0IsUUFBVDtBQUNBLEdBSkQ7QUFLQSxFQU5EOztBQVFBLEtBQUlFLGdCQUFnQixJQUFJMXBDLFNBQVN3RSxHQUFULENBQWFxQixPQUFqQixDQUF5QixRQUF6QixDQUFwQjtBQUNBNmpDLGVBQWM1cEMsWUFBZCxDQUEyQixLQUEzQixFQUFrQ29wQyxZQUFZblMsTUFBWixDQUFtQm9TLFNBQW5CLENBQWxDO0FBQ0FPLGVBQWNobUMsRUFBZCxDQUFpQixPQUFqQixFQUEwQixZQUFNO0FBQy9CK2xDOztBQUVBLE1BQUlMLGFBQUosRUFBbUI7QUFDbEJBO0FBQ0E7QUFDRCxFQU5EOztBQVFBLFVBQVNLLE9BQVQsR0FBbUI7QUFDbEIsTUFBSUMsYUFBSixFQUFtQjtBQUNsQkEsaUJBQWN4OEIsTUFBZDtBQUNBLFVBQU9sTixTQUFTbzhCLENBQVQsQ0FBV21OLGNBQVgsQ0FBMEJGLFdBQTFCLENBQVA7QUFDQUssbUJBQWdCLElBQWhCO0FBQ0E7QUFDRDs7QUFFRDFwQyxVQUFTb0QsUUFBVCxDQUFrQnVtQyxPQUFsQixHQUE0QnRELE1BQTVCLENBQW1DcUQsYUFBbkM7O0FBRUEsUUFBTztBQUNORSxVQUFRSCxPQURGO0FBRU4xaUMsTUFBSXNpQztBQUZFLEVBQVA7QUFJQSxDQS9DRDs7QUFpREE7Ozs7Ozs7Ozs7Ozs7QUFhQXJwQyxTQUFTeU8sS0FBVCxDQUFlQyxLQUFmLEdBQ0MxTyxTQUFTeU8sS0FBVCxDQUFlQyxLQUFmLElBQ0EsWUFBa0I7QUFDakIsS0FBTTBWLFNBQVMsRUFBZjs7QUFEaUIsbUNBQU5vYixJQUFNO0FBQU5BLE1BQU07QUFBQTs7QUFHakIsTUFBSyxJQUFJNzlCLElBQUksQ0FBYixFQUFnQkEsSUFBSTY5QixLQUFLNTlCLE1BQXpCLEVBQWlDLEVBQUVELENBQW5DLEVBQXNDO0FBQ3JDLE1BQU1zVCxNQUFNdXFCLEtBQUs3OUIsQ0FBTCxDQUFaOztBQUVBLE9BQUssSUFBTW1ILEdBQVgsSUFBa0JtTSxHQUFsQixFQUF1QjtBQUN0QixPQUFJeFQsT0FBTzhXLFNBQVAsQ0FBaUJza0IsY0FBakIsQ0FBZ0NwOUIsSUFBaEMsQ0FBcUN3VixHQUFyQyxFQUEwQ25NLEdBQTFDLENBQUosRUFBb0Q7QUFDbkRzYixXQUFPdGIsR0FBUCxJQUFjbU0sSUFBSW5NLEdBQUosQ0FBZDtBQUNBO0FBQ0Q7QUFDRDs7QUFFRCxRQUFPc2IsTUFBUDtBQUNBLENBaEJGOztBQWtCQTs7Ozs7Ozs7O0FBU0Fwa0IsU0FBU3lPLEtBQVQsQ0FBZW83QixRQUFmLEdBQTBCLFVBQVNoa0MsT0FBVCxFQUFrQmpDLEtBQWxCLEVBQXlCO0FBQ2xELEtBQU1rbUMsZ0JBQWdCMW1DLFNBQVMybUMsV0FBVCxDQUFxQixRQUFyQixDQUF0QjtBQUNBRCxlQUFjRSxTQUFkLENBQXdCcG1DLEtBQXhCLEVBQStCLElBQS9CLEVBQXFDLEtBQXJDO0FBQ0FpQyxTQUFRb2tDLGFBQVIsQ0FBc0JILGFBQXRCO0FBQ0EsQ0FKRCxDOzs7Ozs7Ozs7Ozs7OztBQ2xIQTs7Ozs7QUFLQSxJQUFJLENBQUM5cEMsU0FBU3FuQixPQUFULENBQWlCeG5CLEdBQWpCLENBQXFCLFdBQXJCLENBQUwsRUFBd0M7QUFDdkM7Ozs7Ozs7Ozs7OztBQVlBOzs7Ozs7Ozs7Ozs7O0FBYUE7Ozs7Ozs7OztBQVNBOzs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7QUFVQUcsVUFBU3FuQixPQUFULENBQWlCdmYsR0FBakIsQ0FBcUIsV0FBckIsRUFBa0M7QUFDakM7Ozs7Ozs7O0FBUUE2MkIsTUFUaUMsZ0JBUzVCNStCLE1BVDRCLEVBU3BCO0FBQ1osT0FBSW1xQyxZQUFZLEVBQWhCOztBQUVBLE9BQU1DLGNBQWMsS0FBS0Msa0JBQUwsQ0FBd0JycUMsT0FBT2dILEVBQS9CLENBQXBCOztBQUVBLE9BQU1zakMsaUJBQWlCdHFDLE9BQU9ULE1BQVAsQ0FBY2dyQyxNQUFkLEdBQ3BCdnFDLE9BQU9ULE1BQVAsQ0FBY2dyQyxNQUFkLENBQXFCL0ssT0FERCxHQUVwQixFQUZIOztBQUlBLE9BQU1nTCxXQUFXdnFDLFNBQVN5TyxLQUFULENBQWVrbkIsUUFBZixDQUF3QixpQkFBUztBQUNqRHVVLGdCQUFZLEVBQVo7O0FBRUEsUUFDQ3RtQyxNQUFNcUssSUFBTixLQUFlLE9BQWYsSUFDQXJLLE1BQU1FLElBQU4sQ0FBV1QsQ0FBWCxDQUFhc1UsT0FBYixLQUF5QixFQUR6QixJQUVBNVgsT0FBT1QsTUFBUCxDQUFja3JDLFFBSGYsRUFJRTtBQUNELFNBQU1wNkIsZ0JBQWdCclEsT0FBT3EzQixnQkFBUCxFQUF0Qjs7QUFFQSxTQUFJaG5CLGFBQUosRUFBbUI7QUFDbEJyUSxhQUFPdUUsSUFBUCxDQUFZLG1CQUFaLEVBQWlDO0FBQ2hDK0wsb0JBQWF6TSxNQUFNRSxJQUFOLENBQVdULENBRFE7QUFFaEMrTTtBQUZnQyxPQUFqQztBQUlBO0FBQ0Q7QUFDRCxJQWpCZ0IsRUFpQmRpNkIsY0FqQmMsQ0FBakI7O0FBbUJBLE9BQU1JLGFBQWF6cUMsU0FBU3lPLEtBQVQsQ0FBZWtuQixRQUFmLENBQXdCLGtCQUFVO0FBQ3BEd1UsZ0JBQVlPLFNBQVosR0FBd0JSLFVBQVVsVCxJQUFWLENBQWUsSUFBZixDQUF4QjtBQUNBLElBRmtCLEVBRWhCcVQsY0FGZ0IsQ0FBbkI7O0FBSUEsT0FBTU0sbUJBQW1CM3FDLFNBQVN5TyxLQUFULENBQWVrbkIsUUFBZixDQUF3QixpQkFBUztBQUN6RCxRQUFNaVYsWUFBWXhuQyxTQUFTaVYsZ0JBQVQsQ0FBMEIsUUFBMUIsQ0FBbEI7O0FBRUEsUUFBSXd5QixjQUFKOztBQUVBLFNBQUssSUFBSWxwQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlpcEMsVUFBVWhwQyxNQUE5QixFQUFzQ0QsR0FBdEMsRUFBMkM7QUFDMUMsU0FBSWlwQyxVQUFVanBDLENBQVYsRUFBYTYxQixRQUFiLENBQXNCNXpCLE1BQU1FLElBQU4sQ0FBV1QsQ0FBWCxDQUFheW5DLGFBQW5DLENBQUosRUFBdUQ7QUFDdERELGNBQVEsSUFBUjtBQUNBO0FBQ0E7QUFDRDs7QUFFRCxRQUFJLENBQUNBLEtBQUwsRUFBWTtBQUNYTixjQUFTM21DLEtBQVQ7QUFDQTtBQUNELElBZndCLEVBZXRCeW1DLGNBZnNCLENBQXpCOztBQWlCQXRxQyxVQUFPMkQsRUFBUCxDQUFVLFlBQVYsRUFBd0IsaUJBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQXdtQyxjQUFVditCLElBQVYsQ0FBZS9ILE1BQU1FLElBQU4sQ0FBV2d5QixPQUExQjs7QUFFQTJVO0FBQ0EsSUFWRDs7QUFZQTFxQyxVQUFPcUIsSUFBUCxDQUFZLFlBQVosRUFBMEIsWUFBTTtBQUMvQixRQUFNRSxXQUFXdkIsT0FBT3VCLFFBQVAsRUFBakI7O0FBRUEsUUFBTXlwQyxlQUFlenBDLFNBQVMwcEMsY0FBVCxDQUNwQjFwQyxRQURvQixFQUVwQixPQUZvQixFQUdwQixpQkFBUztBQUNSeXBDLGtCQUFhRSxjQUFiOztBQUVBM3BDLGNBQVMwcEMsY0FBVCxDQUF3QjFwQyxRQUF4QixFQUFrQyxPQUFsQyxFQUEyQ2lwQyxRQUEzQztBQUNBanBDLGNBQVMwcEMsY0FBVCxDQUF3QjFwQyxRQUF4QixFQUFrQyxTQUFsQyxFQUE2Q2lwQyxRQUE3QztBQUNBanBDLGNBQVMwcEMsY0FBVCxDQUNDMXBDLFFBREQsRUFFQyxZQUZELEVBR0NxcEMsZ0JBSEQ7O0FBTUFKLGNBQVMzbUMsS0FBVDtBQUNBLEtBZm1CLENBQXJCO0FBaUJBLElBcEJEOztBQXNCQTdELFVBQU8yRCxFQUFQLENBQVUsU0FBVixFQUFxQixrQkFBVTtBQUM5QnltQyxnQkFBWXhuQyxVQUFaLENBQXVCQyxXQUF2QixDQUFtQ3VuQyxXQUFuQzs7QUFFQUksYUFBU3JULE1BQVQ7QUFDQSxJQUpEO0FBS0EsR0FqR2dDOzs7QUFtR2pDOzs7Ozs7Ozs7QUFTQWtULG9CQTVHaUMsOEJBNEdkcmpDLEVBNUdjLEVBNEdWO0FBQ3RCLE9BQU1ta0MsZ0JBQWdCOW5DLFNBQVNrQyxhQUFULENBQXVCLEtBQXZCLENBQXRCOztBQUVBNGxDLGlCQUFjM2xDLFNBQWQsR0FBMEIsWUFBMUI7O0FBRUEybEMsaUJBQWNwckMsWUFBZCxDQUEyQixXQUEzQixFQUF3QyxRQUF4QztBQUNBb3JDLGlCQUFjcHJDLFlBQWQsQ0FBMkIsTUFBM0IsRUFBbUMsUUFBbkM7QUFDQW9yQyxpQkFBY3ByQyxZQUFkLENBQTJCLElBQTNCLEVBQWlDaUgsS0FBSyxZQUF0Qzs7QUFFQTNELFlBQVNxQyxJQUFULENBQWNDLFdBQWQsQ0FBMEJ3bEMsYUFBMUI7O0FBRUEsVUFBT0EsYUFBUDtBQUNBO0FBeEhnQyxFQUFsQztBQTBIQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqTEQ7Ozs7OztvTUFMQTs7Ozs7QUFPQTs7Ozs7O0FBTUEsU0FBU3AvQixTQUFULENBQW1CeE0sTUFBbkIsRUFBMkI7QUFDMUIsTUFBSzZyQyxVQUFMLEdBQWtCN3JDLFVBQVUsRUFBNUI7QUFDQSxNQUFLOHJDLFNBQUwsR0FBaUIsRUFBakI7QUFDQTs7QUFFRHQvQixVQUFVeU0sU0FBVixHQUFzQjtBQUNyQi9ZLGNBQWFzTSxTQURROztBQUdyQjs7Ozs7Ozs7O0FBU0FqTSxJQVpxQixlQVlqQnlsQyxJQVppQixFQVlYO0FBQ1QsTUFBTStGLGNBQWMsS0FBSzdyQyxXQUFMLENBQWlCK0csS0FBakIsQ0FBdUIrK0IsSUFBdkIsQ0FBcEI7O0FBRUEsTUFBSSxDQUFDK0YsV0FBTCxFQUFrQjtBQUNqQjtBQUNBOztBQUVELE1BQUksQ0FBQyxLQUFLQyxjQUFMLENBQW9CaEcsSUFBcEIsQ0FBTCxFQUFnQztBQUMvQixRQUFLaUcsS0FBTCxDQUFXakcsSUFBWDtBQUNBOztBQUVELE1BQUlrRyxXQUFXLEtBQUtKLFNBQUwsQ0FBZTlGLElBQWYsQ0FBZjs7QUFFQSxNQUFJK0YsWUFBWTVqQyxNQUFoQixFQUF3QjtBQUN2QitqQyxjQUFXLEtBQUtDLHFCQUFMLENBQTJCSixZQUFZNWpDLE1BQXZDLEVBQStDK2pDLFFBQS9DLENBQVg7QUFDQTs7QUFFRCxTQUFPQSxRQUFQO0FBQ0EsRUE5Qm9COzs7QUFnQ3JCOzs7Ozs7Ozs7QUFTQUUsSUF6Q3FCLGVBeUNqQnBHLElBekNpQixFQXlDWHZnQyxLQXpDVyxFQXlDSjtBQUNoQixNQUFNc21DLGNBQWMsS0FBSzdyQyxXQUFMLENBQWlCK0csS0FBakIsQ0FBdUIrK0IsSUFBdkIsQ0FBcEI7O0FBRUEsTUFBSSxDQUFDK0YsV0FBTCxFQUFrQjtBQUNqQjtBQUNBOztBQUVELE1BQUksQ0FBQyxLQUFLQyxjQUFMLENBQW9CaEcsSUFBcEIsQ0FBTCxFQUFnQztBQUMvQixRQUFLaUcsS0FBTCxDQUFXakcsSUFBWDtBQUNBOztBQUVELE1BQUkrRixZQUFZbG5DLFFBQWhCLEVBQTBCO0FBQ3pCO0FBQ0E7O0FBRUQsTUFBSWtuQyxZQUFZNWtDLFNBQVosSUFBeUIsS0FBSzZrQyxjQUFMLENBQW9CaEcsSUFBcEIsQ0FBN0IsRUFBd0Q7QUFDdkQ7QUFDQTs7QUFFRCxNQUNDK0YsWUFBWTdrQyxTQUFaLElBQ0EsQ0FBQyxLQUFLaWxDLHFCQUFMLENBQTJCSixZQUFZN2tDLFNBQXZDLEVBQWtEekIsS0FBbEQsQ0FGRixFQUdFO0FBQ0Q7QUFDQTs7QUFFRCxNQUFJc21DLFlBQVl4akMsTUFBaEIsRUFBd0I7QUFDdkI5QyxXQUFRLEtBQUswbUMscUJBQUwsQ0FBMkJKLFlBQVl4akMsTUFBdkMsRUFBK0M5QyxLQUEvQyxDQUFSO0FBQ0E7O0FBRUQsT0FBS3FtQyxTQUFMLENBQWU5RixJQUFmLElBQXVCdmdDLEtBQXZCO0FBQ0EsRUF4RW9COzs7QUEwRXJCOzs7Ozs7Ozs7Ozs7O0FBYUEwbUMsc0JBdkZxQixpQ0F1RkNFLGdCQXZGRCxFQXVGbUJuTSxJQXZGbkIsRUF1RnlCO0FBQzdDLE1BQUlwYixTQUFTLElBQWI7O0FBRUEsTUFBSSxDQUFDeGpCLGVBQUtrRyxPQUFMLENBQWEwNEIsSUFBYixDQUFMLEVBQXlCO0FBQ3hCQSxVQUFPLENBQUNBLElBQUQsQ0FBUDtBQUNBOztBQUVELE1BQ0M1K0IsZUFBS29GLFFBQUwsQ0FBYzJsQyxnQkFBZCxLQUNBL3FDLGVBQUsrRixVQUFMLENBQWdCLEtBQUtnbEMsZ0JBQUwsQ0FBaEIsQ0FGRCxFQUdFO0FBQ0R2bkIsWUFBUyxLQUFLdW5CLGdCQUFMLGlDQUEwQm5NLElBQTFCLEVBQVQ7QUFDQSxHQUxELE1BS08sSUFBSTUrQixlQUFLK0YsVUFBTCxDQUFnQmdsQyxnQkFBaEIsQ0FBSixFQUF1QztBQUM3Q3ZuQixZQUFTdW5CLGlCQUFpQjlrQixLQUFqQixDQUF1QixJQUF2QixFQUE2QjJZLElBQTdCLENBQVQ7QUFDQTs7QUFFRCxTQUFPcGIsTUFBUDtBQUNBLEVBeEdvQjs7O0FBMEdyQjs7Ozs7Ozs7OztBQVVBbW5CLE1BcEhxQixpQkFvSGZqRyxJQXBIZSxFQW9IVDtBQUNYLE1BQUl2Z0MsY0FBSjs7QUFFQSxNQUFNc21DLGNBQWMsS0FBSzdyQyxXQUFMLENBQWlCK0csS0FBakIsQ0FBdUIrK0IsSUFBdkIsQ0FBcEI7O0FBRUE7QUFDQSxNQUFNc0csa0JBQWtCbnFDLE9BQU84VyxTQUFQLENBQWlCc2tCLGNBQWpCLENBQWdDcDlCLElBQWhDLENBQ3ZCNHJDLFdBRHVCLEVBRXZCLE9BRnVCLENBQXhCO0FBSUEsTUFBTVEsMEJBQTBCcHFDLE9BQU84VyxTQUFQLENBQWlCc2tCLGNBQWpCLENBQWdDcDlCLElBQWhDLENBQy9CLEtBQUswckMsVUFEMEIsRUFFL0I3RixJQUYrQixDQUFoQzs7QUFLQTtBQUNBLE1BQUkrRixZQUFZUyxPQUFoQixFQUF5QjtBQUN4Qi9tQyxXQUFRLEtBQUswbUMscUJBQUwsQ0FBMkJKLFlBQVlTLE9BQXZDLEVBQWdEL21DLEtBQWhELENBQVI7O0FBRUEsUUFBS3FtQyxTQUFMLENBQWU5RixJQUFmLElBQXVCdmdDLEtBQXZCO0FBQ0E7QUFDRDtBQUNBO0FBTkEsT0FPSyxJQUFJc21DLFlBQVlsbkMsUUFBaEIsRUFBMEI7QUFDOUJZLFlBQVFzbUMsWUFBWXRtQyxLQUFwQjtBQUNBO0FBQ0Q7QUFDQTtBQUpLLFFBS0EsSUFBSXNtQyxZQUFZNWtDLFNBQWhCLEVBQTJCO0FBQy9CLFNBQUlvbEMsdUJBQUosRUFBNkI7QUFDNUI5bUMsY0FBUSxLQUFLb21DLFVBQUwsQ0FBZ0I3RixJQUFoQixDQUFSO0FBQ0EsTUFGRCxNQUVPLElBQUlzRyxlQUFKLEVBQXFCO0FBQzNCN21DLGNBQVFzbUMsWUFBWXRtQyxLQUFwQjtBQUNBLE1BRk0sTUFFQTtBQUNOO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7QUFWSyxTQVdBLElBQUk4bUMsdUJBQUosRUFBNkI7QUFDakM5bUMsY0FBUSxLQUFLb21DLFVBQUwsQ0FBZ0I3RixJQUFoQixDQUFSO0FBQ0EsTUFGSSxNQUVFLElBQUlzRyxlQUFKLEVBQXFCO0FBQzNCN21DLGNBQVFzbUMsWUFBWXRtQyxLQUFwQjtBQUNBOztBQUVEO0FBQ0E7QUFDQTtBQUNBLE1BQ0NzbUMsWUFBWTdrQyxTQUFaLElBQ0FxbEMsdUJBREEsSUFFQSxDQUFDLEtBQUtKLHFCQUFMLENBQTJCSixZQUFZN2tDLFNBQXZDLEVBQWtEekIsS0FBbEQsQ0FIRixFQUlFO0FBQ0QsT0FBSTZtQyxlQUFKLEVBQXFCO0FBQ3BCN21DLFlBQVFzbUMsWUFBWXRtQyxLQUFwQjtBQUNBLElBRkQsTUFFTztBQUNOO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsTUFBSXNtQyxZQUFZeGpDLE1BQVosSUFBc0Jna0MsdUJBQTFCLEVBQW1EO0FBQ2xEOW1DLFdBQVEsS0FBSzBtQyxxQkFBTCxDQUEyQkosWUFBWXhqQyxNQUF2QyxFQUErQzlDLEtBQS9DLENBQVI7QUFDQTs7QUFFRDtBQUNBLE9BQUtxbUMsU0FBTCxDQUFlOUYsSUFBZixJQUF1QnZnQyxLQUF2QjtBQUNBLEVBeExvQjs7O0FBMExyQjs7Ozs7Ozs7Ozs7O0FBWUF1bUMsZUF0TXFCLDBCQXNNTmhHLElBdE1NLEVBc01BO0FBQ3BCLFNBQU83akMsT0FBTzhXLFNBQVAsQ0FBaUJza0IsY0FBakIsQ0FBZ0NwOUIsSUFBaEMsQ0FBcUMsS0FBSzJyQyxTQUExQyxFQUFxRDlGLElBQXJELENBQVA7QUFDQTtBQXhNb0IsQ0FBdEI7O2tCQTJNZXg1QixTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4TmY7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQTs7Ozs7O0FBTUEsU0FBU3BNLElBQVQsQ0FBY0osTUFBZCxFQUFzQjtBQUNyQkksTUFBS0gsVUFBTCxDQUFnQkMsV0FBaEIsQ0FBNEJDLElBQTVCLENBQWlDLElBQWpDLEVBQXVDSCxNQUF2Qzs7QUFFQSxNQUFLcS9CLElBQUwsQ0FBVXIvQixNQUFWO0FBQ0EsQyxDQW5CRDs7Ozs7QUFxQkEsbUJBQU9JLElBQVAsRUFBYW9NLG1CQUFiLEVBQXdCO0FBQ3ZCOzs7Ozs7Ozs7QUFTQTZ5QixLQVZ1QixnQkFVbEJyL0IsTUFWa0IsRUFVVjtBQUNaLE9BQUt5c0MsVUFBTCxDQUFnQixhQUFoQixFQUErQnpzQyxNQUEvQjtBQUNBLEVBWnNCOzs7QUFjdkI7Ozs7Ozs7QUFPQTBELFFBckJ1QixxQkFxQmI7QUFDVCxPQUFLK29DLFVBQUwsQ0FBZ0IsWUFBaEI7QUFDQSxFQXZCc0I7OztBQXlCdkI7Ozs7Ozs7Ozs7QUFVQUEsV0FuQ3VCLHNCQW1DWkMsR0FuQ1ksRUFtQ1B4TSxJQW5DTyxFQW1DRDtBQUNyQixNQUFJeU0sTUFBTSxFQUFWOztBQUVBLE1BQUlDLE9BQU8sS0FBSzFzQyxXQUFoQjs7QUFFQSxTQUFPMHNDLElBQVAsRUFBYTtBQUNaLE9BQUl0ckMsZUFBSytGLFVBQUwsQ0FBZ0J1bEMsS0FBSzN6QixTQUFMLENBQWV5ekIsR0FBZixDQUFoQixDQUFKLEVBQTBDO0FBQ3pDQyxRQUFJdGdDLElBQUosQ0FBU3VnQyxLQUFLM3pCLFNBQUwsQ0FBZXl6QixHQUFmLENBQVQ7QUFDQTs7QUFFREUsVUFBT0EsS0FBSzNzQyxVQUFMLEdBQWtCMnNDLEtBQUszc0MsVUFBTCxDQUFnQkMsV0FBbEMsR0FBZ0QsSUFBdkQ7QUFDQTs7QUFFRHlzQyxRQUFNQSxJQUFJRSxPQUFKLEVBQU47O0FBRUEzTSxTQUFPNStCLGVBQUtrRyxPQUFMLENBQWEwNEIsSUFBYixJQUFxQkEsSUFBckIsR0FBNEIsQ0FBQ0EsSUFBRCxDQUFuQzs7QUFFQSxPQUFLLElBQUk3OUIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJc3FDLElBQUlycUMsTUFBeEIsRUFBZ0NELEdBQWhDLEVBQXFDO0FBQ3BDLE9BQU1vVSxPQUFPazJCLElBQUl0cUMsQ0FBSixDQUFiOztBQUVBb1UsUUFBSzhRLEtBQUwsQ0FBVyxJQUFYLEVBQWlCMlksSUFBakI7QUFDQTtBQUNEO0FBekRzQixDQUF4Qjs7a0JBNERlOS9CLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakZmOzs7OztBQUtBOzs7OztBQUtBLElBQU1rQixPQUFPO0FBQ1o7Ozs7Ozs7OztBQVNBa0csUUFWWSxtQkFVSi9CLEtBVkksRUFVRztBQUNkLFNBQU90RCxPQUFPOFcsU0FBUCxDQUFpQmdiLFFBQWpCLENBQTBCOXpCLElBQTFCLENBQStCc0YsS0FBL0IsTUFBMEMsZ0JBQWpEO0FBQ0EsRUFaVzs7O0FBY1o7Ozs7Ozs7OztBQVNBcUIsVUF2QlkscUJBdUJGckIsS0F2QkUsRUF1Qks7QUFDaEIsU0FBTyxPQUFPQSxLQUFQLEtBQWlCLFNBQXhCO0FBQ0EsRUF6Qlc7OztBQTJCWjs7Ozs7Ozs7O0FBU0E0QixXQXBDWSxzQkFvQ0Q1QixLQXBDQyxFQW9DTTtBQUNqQixTQUFPLE9BQU9BLEtBQVAsS0FBaUIsVUFBeEI7QUFDQSxFQXRDVzs7O0FBd0NaOzs7Ozs7Ozs7QUFTQXVCLE9BakRZLGtCQWlETHZCLEtBakRLLEVBaURFO0FBQ2IsU0FBT0EsVUFBVSxJQUFqQjtBQUNBLEVBbkRXOzs7QUFxRFo7Ozs7Ozs7OztBQVNBc0MsU0E5RFksb0JBOERIdEMsS0E5REcsRUE4REk7QUFDZixTQUFPLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJxbkMsU0FBU3JuQyxLQUFULENBQXBDO0FBQ0EsRUFoRVc7OztBQWtFWjs7Ozs7Ozs7O0FBU0FvQixTQTNFWSxvQkEyRUhwQixLQTNFRyxFQTJFSTtBQUNmLE1BQU1zbkMsbUJBQW1CdG5DLEtBQW5CLHlDQUFtQkEsS0FBbkIsQ0FBTjs7QUFFQSxTQUFPQSxVQUFVc25DLGNBQWMsUUFBZCxJQUEwQnpyQyxLQUFLK0YsVUFBTCxDQUFnQjVCLEtBQWhCLENBQXBDLENBQVA7QUFDQSxFQS9FVzs7O0FBaUZaOzs7Ozs7Ozs7QUFTQWlCLFNBMUZZLG9CQTBGSGpCLEtBMUZHLEVBMEZJO0FBQ2YsU0FBTyxPQUFPQSxLQUFQLEtBQWlCLFFBQXhCO0FBQ0EsRUE1Rlc7OztBQThGWjs7Ozs7Ozs7Ozs7QUFXQWxFLElBekdZLGVBeUdSeXJDLFFBekdRLEVBeUdFQyxRQXpHRixFQXlHWTtBQUN2QixNQUFNMVAsaUJBQWlCcDdCLE9BQU84VyxTQUFQLENBQWlCc2tCLGNBQXhDOztBQUVBLE9BQUssSUFBTS96QixHQUFYLElBQWtCeWpDLFFBQWxCLEVBQTRCO0FBQzNCLE9BQUkxUCxlQUFlcDlCLElBQWYsQ0FBb0I4c0MsUUFBcEIsRUFBOEJ6akMsR0FBOUIsQ0FBSixFQUF3QztBQUN2Q3dqQyxhQUFTeGpDLEdBQVQsSUFBZ0J5akMsU0FBU3pqQyxHQUFULENBQWhCO0FBQ0E7QUFDRDtBQUNELEVBakhXOzs7QUFtSFo7Ozs7Ozs7OztBQVNBZ1EsTUE1SFksaUJBNEhOL1QsS0E1SE0sRUE0SEM7QUFDWixTQUFPeU8sU0FBU3pPLEtBQVQsRUFBZ0IsRUFBaEIsQ0FBUDtBQUNBO0FBOUhXLENBQWI7O2tCQWlJZW5FLEk7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RJZjs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQSxJQUFNaUwsU0FBUyxTQUFUQSxNQUFTLENBQVN5Z0MsUUFBVCxFQUFtQkMsUUFBbkIsRUFBNkJDLFVBQTdCLEVBQXlDQyxXQUF6QyxFQUFzRDtBQUNwRSxLQUFJLENBQUNGLFFBQUQsSUFBYSxDQUFDRCxRQUFsQixFQUE0QjtBQUMzQixRQUFNLElBQUl6aUMsS0FBSixDQUFVLG9DQUFWLENBQU47QUFDQTs7QUFFRCxLQUFNNmlDLGdCQUFnQkgsU0FBU2gwQixTQUEvQjs7QUFFQSxLQUFNbzBCLGdCQUFnQmxyQyxPQUFPZ21CLE1BQVAsQ0FBY2lsQixhQUFkLENBQXRCO0FBQ0FKLFVBQVMvekIsU0FBVCxHQUFxQm8wQixhQUFyQjs7QUFFQUEsZUFBY250QyxXQUFkLEdBQTRCOHNDLFFBQTVCO0FBQ0FBLFVBQVMvc0MsVUFBVCxHQUFzQm10QyxhQUF0Qjs7QUFFQTtBQUNBLEtBQ0NILGFBQWE5cUMsTUFBYixJQUNBaXJDLGNBQWNsdEMsV0FBZCxLQUE4QmlDLE9BQU84VyxTQUFQLENBQWlCL1ksV0FGaEQsRUFHRTtBQUNEa3RDLGdCQUFjbHRDLFdBQWQsR0FBNEIrc0MsUUFBNUI7QUFDQTs7QUFFRDtBQUNBLEtBQUlDLFVBQUosRUFBZ0I7QUFDZjVyQyxpQkFBS0MsR0FBTCxDQUFTOHJDLGFBQVQsRUFBd0JILFVBQXhCO0FBQ0E7O0FBRUQ7QUFDQSxLQUFJQyxXQUFKLEVBQWlCO0FBQ2hCN3JDLGlCQUFLQyxHQUFMLENBQVN5ckMsUUFBVCxFQUFtQkcsV0FBbkI7QUFDQTs7QUFFRCxRQUFPSCxRQUFQO0FBQ0EsQ0FoQ0QsQyxDQXBCQTs7Ozs7a0JBc0RlemdDLE07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0RGY7Ozs7O0lBS00rZ0MsUztBQUNMLG9CQUFZMXBDLE1BQVosRUFBb0JFLFFBQXBCLEVBQThCO0FBQUE7O0FBQzdCLE9BQUtBLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsT0FBS0YsTUFBTCxHQUFjQSxNQUFkOztBQUVBLE9BQUsycEMsTUFBTCxHQUFjO0FBQ2JDLFlBQVMsS0FBS0EsT0FBTCxDQUFhenFDLElBQWIsQ0FBa0IsSUFBbEIsQ0FESTtBQUViMHFDLGNBQVcsS0FBS0EsU0FBTCxDQUFlMXFDLElBQWYsQ0FBb0IsSUFBcEIsQ0FGRTtBQUdiMnFDLFlBQVMsS0FBS0EsT0FBTCxDQUFhM3FDLElBQWIsQ0FBa0IsSUFBbEI7QUFISSxHQUFkO0FBS0E7Ozs7d0JBRUt1QixLLEVBQU87QUFDWkEsU0FBTVEsY0FBTjtBQUNBUixTQUFNa1QsZUFBTjs7QUFFQSxRQUFLOVIsTUFBTCxHQUFjcEIsTUFBTW9CLE1BQXBCOztBQUVBLFFBQUtPLFNBQUwsR0FBaUIsS0FBS1AsTUFBTCxDQUFZTyxTQUE3Qjs7QUFFQSxRQUFLMG5DLFFBQUwsR0FBZ0I7QUFDZnA5QixPQUFHak0sTUFBTXNwQyxPQURNO0FBRWZuOUIsT0FBR25NLE1BQU11cEM7QUFGTSxJQUFoQjs7QUFLQSxRQUFLM2xCLE1BQUwsQ0FBWTVqQixLQUFaOztBQUVBLFFBQUtSLFFBQUwsQ0FBY29hLGdCQUFkLENBQStCLFNBQS9CLEVBQTBDLEtBQUtxdkIsTUFBTCxDQUFZQyxPQUF0RCxFQUErRCxLQUEvRDtBQUNBLFFBQUsxcEMsUUFBTCxDQUFjb2EsZ0JBQWQsQ0FDQyxXQURELEVBRUMsS0FBS3F2QixNQUFMLENBQVlFLFNBRmIsRUFHQyxLQUhEO0FBS0EsUUFBSzNwQyxRQUFMLENBQWNvYSxnQkFBZCxDQUErQixTQUEvQixFQUEwQyxLQUFLcXZCLE1BQUwsQ0FBWUcsT0FBdEQsRUFBK0QsS0FBL0Q7O0FBRUEsUUFBSzVwQyxRQUFMLENBQWNxQyxJQUFkLENBQW1CMm5DLFNBQW5CLENBQTZCdGxDLEdBQTdCLGVBQTZDLEtBQUt2QyxTQUFsRDs7QUFFQSxPQUFJLE9BQU8sS0FBSzhuQyxPQUFaLEtBQXdCLFVBQTVCLEVBQXdDO0FBQ3ZDLFNBQUtBLE9BQUw7QUFDQTtBQUNEOzs7eUJBRU16cEMsSyxFQUFPO0FBQ2IsUUFBSzBwQyxVQUFMLEdBQWtCO0FBQ2pCejlCLE9BQUdqTSxNQUFNc3BDLE9BRFE7QUFFakJuOUIsT0FBR25NLE1BQU11cEM7QUFGUSxJQUFsQjs7QUFLQSxRQUFLSSxLQUFMLEdBQWE7QUFDWjE5QixPQUFHak0sTUFBTXNwQyxPQUFOLEdBQWdCLEtBQUtELFFBQUwsQ0FBY3A5QixDQURyQjtBQUVaRSxPQUFHbk0sTUFBTXVwQyxPQUFOLEdBQWdCLEtBQUtGLFFBQUwsQ0FBY2w5QjtBQUZyQixJQUFiOztBQUtBLFFBQUtyTyxJQUFMLEdBQVk7QUFDWDhyQyxTQUFLNXBDLE1BQU0wekIsTUFEQTtBQUVYbVcsVUFBTTdwQyxNQUFNSSxPQUZEO0FBR1hnTCxXQUFPcEwsTUFBTThwQztBQUhGLElBQVo7QUFLQTs7OzRCQUVTOXBDLEssRUFBTztBQUNoQixRQUFLNGpCLE1BQUwsQ0FBWTVqQixLQUFaOztBQUVBLE9BQUksT0FBTyxLQUFLK3BDLE1BQVosS0FBdUIsVUFBM0IsRUFBdUM7QUFDdEMsU0FBS0EsTUFBTDtBQUNBOztBQUVELE9BQUkvcEMsTUFBTWdxQyxLQUFOLEtBQWdCLENBQXBCLEVBQXVCO0FBQ3RCLFNBQUtaLE9BQUwsQ0FBYXBwQyxLQUFiO0FBQ0E7QUFDRDs7OzBCQUVPQSxLLEVBQU87QUFDZCxPQUFJQSxNQUFNK1QsT0FBTixLQUFrQixFQUF0QixFQUEwQjtBQUN6QixTQUFLazJCLE9BQUw7QUFDQTtBQUNEOzs7MEJBRU9qcUMsSyxFQUFPO0FBQ2QsUUFBSzRqQixNQUFMLENBQVk1akIsS0FBWjs7QUFFQSxRQUFLaXFDLE9BQUw7O0FBRUEsT0FBSSxPQUFPLEtBQUtDLFVBQVosS0FBMkIsVUFBL0IsRUFBMkM7QUFDMUMsU0FBS0EsVUFBTDtBQUNBO0FBQ0Q7Ozs0QkFFUztBQUNULFFBQUsxcUMsUUFBTCxDQUFjcUMsSUFBZCxDQUFtQjJuQyxTQUFuQixDQUE2QmxnQyxNQUE3QixlQUFnRCxLQUFLM0gsU0FBckQ7O0FBRUEsUUFBS25DLFFBQUwsQ0FBYzZ6QixtQkFBZCxDQUNDLFNBREQsRUFFQyxLQUFLNFYsTUFBTCxDQUFZQyxPQUZiLEVBR0MsS0FIRDtBQUtBLFFBQUsxcEMsUUFBTCxDQUFjNnpCLG1CQUFkLENBQ0MsV0FERCxFQUVDLEtBQUs0VixNQUFMLENBQVlFLFNBRmIsRUFHQyxLQUhEO0FBS0EsUUFBSzNwQyxRQUFMLENBQWM2ekIsbUJBQWQsQ0FDQyxTQURELEVBRUMsS0FBSzRWLE1BQUwsQ0FBWUcsT0FGYixFQUdDLEtBSEQ7O0FBTUEsT0FBSSxPQUFPLEtBQUtlLFNBQVosS0FBMEIsVUFBOUIsRUFBMEM7QUFDekMsU0FBS0EsU0FBTDtBQUNBO0FBQ0Q7Ozs7OztRQUdNbkIsUyxHQUFBQSxTO2tCQUNPQSxTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FqQkN2SGY7Ozs7O0FBS0E7Ozs7Ozs7O0FBRUEsSUFBTW9CLGdCQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixDQUF0Qjs7QUFFQSxJQUFNQyxzQkFBc0I7QUFDM0JDLEdBRDJCLGNBQ3hCQyxNQUR3QixFQUNoQnIrQixJQURnQixFQUNWRSxHQURVLEVBQ0xvK0IsR0FESyxFQUNBO0FBQzFCQyxrQkFBZ0JGLE1BQWhCLEVBQXdCLENBQUMsQ0FBRCxHQUFLcitCLElBQTdCLEVBQW1DcytCLElBQUlqN0IsTUFBSixHQUFhLENBQWIsR0FBaUJuRCxHQUFwRDtBQUNBLEVBSDBCO0FBSTNCcytCLEdBSjJCLGNBSXhCSCxNQUp3QixFQUloQnIrQixJQUpnQixFQUlWRSxHQUpVLEVBSUxvK0IsR0FKSyxFQUlBO0FBQzFCQyxrQkFBZ0JGLE1BQWhCLEVBQXdCQyxJQUFJbitCLEtBQUosR0FBWSxDQUFaLEdBQWdCSCxJQUF4QyxFQUE4Q3MrQixJQUFJajdCLE1BQUosR0FBYSxDQUFiLEdBQWlCbkQsR0FBL0Q7QUFDQSxFQU4wQjtBQU8zQnUrQixHQVAyQixjQU94QkosTUFQd0IsRUFPaEJyK0IsSUFQZ0IsRUFPVkUsR0FQVSxFQU9MbytCLEdBUEssRUFPQTtBQUMxQkMsa0JBQ0NGLE1BREQsRUFFQ0MsSUFBSW4rQixLQUFKLEdBQVksQ0FBWixHQUFnQkgsSUFGakIsRUFHQ2UsS0FBSzI5QixLQUFMLENBQVdKLElBQUlqN0IsTUFBSixHQUFhLENBQXhCLElBQTZCLENBQTdCLEdBQWlDbkQsR0FIbEM7QUFLQSxFQWIwQjtBQWMzQnkrQixHQWQyQixjQWN4Qk4sTUFkd0IsRUFjaEJyK0IsSUFkZ0IsRUFjVkUsR0FkVSxFQWNMMCtCLElBZEssRUFjQztBQUMzQkwsa0JBQWdCRixNQUFoQixFQUF3QnIrQixPQUFPLENBQS9CLEVBQWtDRSxNQUFNLENBQXhDO0FBQ0EsRUFoQjBCO0FBaUIzQisxQixHQWpCMkIsY0FpQnhCb0ksTUFqQndCLEVBaUJoQnIrQixJQWpCZ0IsRUFpQlZFLEdBakJVLEVBaUJMbytCLEdBakJLLEVBaUJBO0FBQzFCQyxrQkFBZ0JGLE1BQWhCLEVBQXdCQyxJQUFJbitCLEtBQUosR0FBWSxDQUFaLEdBQWdCSCxJQUF4QyxFQUE4QyxDQUFDLENBQUQsR0FBS0UsR0FBbkQ7QUFDQTtBQW5CMEIsQ0FBNUI7O0FBc0JBLElBQU1xK0Isa0JBQWtCLFNBQWxCQSxlQUFrQixDQUFDcHhCLEVBQUQsRUFBS25OLElBQUwsRUFBV0UsR0FBWCxFQUFtQjtBQUMxQ2lOLElBQUdyTyxLQUFILENBQVNrQixJQUFULEdBQW1CQSxJQUFuQjtBQUNBbU4sSUFBR3JPLEtBQUgsQ0FBU29CLEdBQVQsR0FBa0JBLEdBQWxCO0FBQ0EsQ0FIRDs7QUFLQSxJQUFNMitCLGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBQ3pyQyxNQUFELEVBQVMrWixFQUFULEVBQWdCO0FBQ3RDLEtBQU0yeEIsT0FBTzN4QixHQUFHNHhCLHFCQUFILEVBQWI7O0FBRUEsUUFBTztBQUNOMTdCLFVBQVF5N0IsS0FBS3o3QixNQURQO0FBRU5yRCxRQUFNOCtCLEtBQUs5K0IsSUFBTCxHQUFZNU0sT0FBTzRyQyxXQUZuQjtBQUdOOStCLE9BQUs0K0IsS0FBSzUrQixHQUFMLEdBQVc5TSxPQUFPNnJDLFdBSGpCO0FBSU45K0IsU0FBTzIrQixLQUFLMytCO0FBSk4sRUFBUDtBQU1BLENBVEQ7O0lBV00rK0IsTztBQUNMLGtCQUFZanZDLE1BQVosRUFBOEI7QUFBQSxNQUFWMlUsR0FBVSx1RUFBSixFQUFJOztBQUFBOztBQUM3QixPQUFLQSxHQUFMLEdBQVdBLEdBQVg7QUFDQSxPQUFLM1UsTUFBTCxHQUFjQSxNQUFkOztBQUVBLE9BQUtxRCxRQUFMLEdBQWdCckQsT0FBT3FELFFBQVAsR0FBa0JyRCxPQUFPcUQsUUFBUCxDQUFnQkMsQ0FBbEMsR0FBc0NELFFBQXREO0FBQ0EsT0FBS0YsTUFBTCxHQUFjbkQsT0FBT21ELE1BQVAsR0FBZ0JuRCxPQUFPbUQsTUFBUCxDQUFjRyxDQUE5QixHQUFrQ0gsTUFBaEQ7O0FBRUEsT0FBS2tyQyxHQUFMLEdBQVcsSUFBWDtBQUNBLE9BQUthLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxPQUFLQyxPQUFMLEdBQWUsRUFBZjtBQUNBLE9BQUszUSxPQUFMLEdBQWUsSUFBZjtBQUNBLE9BQUs0USxVQUFMLEdBQWtCLElBQWxCO0FBQ0EsT0FBSy9xQixNQUFMLEdBQWMsSUFBZDs7QUFFQSxPQUFLdWEsSUFBTDtBQUNBOzs7O3lCQUVNO0FBQUE7O0FBQ04sUUFBS3NRLFNBQUwsR0FBaUIsS0FBSzdyQyxRQUFMLENBQWNrQyxhQUFkLENBQTRCLEtBQTVCLENBQWpCO0FBQ0EsUUFBSzJwQyxTQUFMLENBQWVsb0MsRUFBZixHQUFvQixVQUFwQjs7QUFFQSxRQUFLdzNCLE9BQUwsR0FBZSxLQUFLbjdCLFFBQUwsQ0FBY2tDLGFBQWQsQ0FBNEIsTUFBNUIsQ0FBZjs7QUFFQSxRQUFLMnBDLFNBQUwsQ0FBZXZwQyxXQUFmLENBQTJCLEtBQUs2NEIsT0FBaEM7O0FBRUEsUUFBSzJRLE9BQUwsR0FBZSxFQUFmOztBQUVBbEIsaUJBQWN4MUIsT0FBZCxDQUFzQixzQkFBYztBQUNuQyxVQUFLMDJCLE9BQUwsQ0FBYUUsVUFBYixJQUEyQixNQUFLQyxZQUFMLENBQWtCRCxVQUFsQixDQUEzQjtBQUNBLElBRkQ7O0FBSUEsT0FBTTF0QyxPQUFPRCxPQUFPQyxJQUFQLENBQVksS0FBS3d0QyxPQUFqQixDQUFiOztBQUVBLFFBQUssSUFBSXZ0QyxJQUFJLENBQWIsRUFBZ0JBLElBQUlELEtBQUtFLE1BQXpCLEVBQWlDRCxHQUFqQyxFQUFzQztBQUNyQyxTQUFLc3RDLFNBQUwsQ0FBZXZwQyxXQUFmLENBQTJCLEtBQUt3cEMsT0FBTCxDQUFheHRDLEtBQUtDLENBQUwsQ0FBYixDQUEzQjtBQUNBO0FBQ0Q7OzsrQkFFWXNNLEksRUFBTTtBQUNsQixPQUFNZ1AsS0FBSyxLQUFLN1osUUFBTCxDQUFja0MsYUFBZCxDQUE0QixHQUE1QixDQUFYOztBQUVBMlgsTUFBR213QixTQUFILENBQWF0bEMsR0FBYixDQUFpQm1HLElBQWpCOztBQUVBLFVBQU9nUCxFQUFQO0FBQ0E7OzsyQkFFUUEsRSxFQUFJO0FBQ1osT0FBTXZiLE9BQU9ELE9BQU9DLElBQVAsQ0FBWSxLQUFLd3RDLE9BQWpCLENBQWI7O0FBRUEsT0FBSTlxQixTQUFTLEtBQWI7O0FBRUEsUUFBSyxJQUFJemlCLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsS0FBS0UsTUFBekIsRUFBaUNELEdBQWpDLEVBQXNDO0FBQ3JDLFFBQUksS0FBS3V0QyxPQUFMLENBQWF4dEMsS0FBS0MsQ0FBTCxDQUFiLE1BQTBCc2IsRUFBOUIsRUFBa0M7QUFDakNtSCxjQUFTLElBQVQ7QUFDQTtBQUNEOztBQUVELFVBQU9BLE1BQVA7QUFDQTs7O3VCQUVJbkgsRSxFQUFJO0FBQ1IsT0FBTXpYLFNBQVMsS0FBS3pGLE1BQUwsQ0FBWVQsTUFBWixDQUFtQmtHLE1BQW5CLElBQTZCcEMsU0FBU3FDLElBQXJEOztBQUVBLFFBQUt3WCxFQUFMLEdBQVVBLEVBQVY7O0FBRUEsUUFBS214QixHQUFMLEdBQVdPLGVBQWUsS0FBS3pyQyxNQUFwQixFQUE0QixLQUFLK1osRUFBakMsQ0FBWDs7QUFFQW94QixtQkFDQyxLQUFLWSxTQUROLEVBRUMsS0FBS2IsR0FBTCxDQUFTdCtCLElBRlYsRUFHQyxLQUFLcytCLEdBQUwsQ0FBU3ArQixHQUFULEdBQWV4SyxPQUFPZ04sU0FIdkI7O0FBTUFoTixVQUFPRSxXQUFQLENBQW1CLEtBQUt1cEMsU0FBeEI7O0FBRUEsUUFBS2h5QixFQUFMLENBQVFtd0IsU0FBUixDQUFrQnRsQyxHQUFsQixDQUFzQixVQUF0Qjs7QUFFQSxRQUFLd25DLFdBQUw7QUFDQTs7O3lCQUVNO0FBQ04sT0FBTUMsV0FBVyxLQUFLbnNDLFFBQUwsQ0FBY29zQyxzQkFBZCxDQUFxQyxVQUFyQyxDQUFqQjs7QUFFQSxRQUFLLElBQUk3dEMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNHRDLFNBQVMzdEMsTUFBN0IsRUFBcUNELEdBQXJDLEVBQTBDO0FBQ3pDNHRDLGFBQVM1dEMsQ0FBVCxFQUFZeXJDLFNBQVosQ0FBc0JsZ0MsTUFBdEIsQ0FBNkIsVUFBN0I7QUFDQTs7QUFFRCxRQUFLdWlDLFdBQUw7O0FBRUEsT0FBSSxLQUFLUixTQUFMLENBQWV0c0MsVUFBbkIsRUFBK0I7QUFDOUIsU0FBS3NzQyxTQUFMLENBQWV0c0MsVUFBZixDQUEwQkMsV0FBMUIsQ0FBc0MsS0FBS3FzQyxTQUEzQztBQUNBO0FBQ0Q7OzsyQkFFUXJyQyxLLEVBQU87QUFBQTs7QUFDZixPQUFJQSxNQUFNc1EsTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUN2QjtBQUNBOztBQUVELE9BQU13N0IsT0FBTyxJQUFJOUMsbUJBQUosQ0FBYyxLQUFLMXBDLE1BQW5CLEVBQTJCLEtBQUtFLFFBQWhDLENBQWI7O0FBRUFzc0MsUUFBS3JDLE9BQUwsR0FBZSxZQUFNO0FBQ3BCLFdBQUtzQyxXQUFMOztBQUVBLFdBQUtDLFVBQUwsR0FBa0IsSUFBbEI7O0FBRUEsV0FBSzd2QyxNQUFMLENBQVlvRCxZQUFaLEdBQTJCbUssSUFBM0I7QUFDQSxJQU5EOztBQVFBb2lDLFFBQUsvQixNQUFMLEdBQWMsWUFBTTtBQUNuQixXQUFLa0MsYUFBTCxDQUFtQkgsSUFBbkI7O0FBRUEsUUFBTUksZUFBZSxPQUFLL3ZDLE1BQUwsQ0FBWThGLE9BQVosQ0FBb0J4QyxDQUFwQixDQUFzQndyQyxxQkFBdEIsRUFBckI7O0FBRUEsUUFBSSxPQUFLTSxVQUFMLENBQWdCbC9CLEtBQWhCLElBQXlCNi9CLGFBQWE3L0IsS0FBMUMsRUFBaUQ7QUFDaEQ7QUFDQTs7QUFFRCxXQUFLOC9CLGFBQUw7O0FBRUEsUUFBTTNCLE1BQU0sT0FBS2UsVUFBakI7O0FBRUEsV0FBS2EsYUFBTCxDQUFtQjVCLEdBQW5CLEVBQXdCQSxJQUFJdCtCLElBQTVCLEVBQWtDcytCLElBQUlwK0IsR0FBdEM7QUFDQSxJQWREOztBQWdCQTAvQixRQUFLM0IsU0FBTCxHQUFpQixZQUFNO0FBQ3RCLFdBQUtrQyxXQUFMOztBQUVBLFdBQUtMLFVBQUwsR0FBa0IsS0FBbEI7O0FBRUEsV0FBS3BTLElBQUw7O0FBRUEsV0FBS3o5QixNQUFMLENBQVlvRCxZQUFaLEdBQTJCcUssTUFBM0I7O0FBRUEsV0FBS3pOLE1BQUwsQ0FBWXVFLElBQVosQ0FBaUIsY0FBakI7QUFDQSxJQVZEOztBQVlBb3JDLFFBQUs1QixVQUFMLEdBQWtCLFlBQU07QUFDdkIsV0FBS29DLGNBQUw7O0FBRUEsV0FBS253QyxNQUFMLENBQVl1RSxJQUFaLENBQWlCLGNBQWpCO0FBQ0EsSUFKRDs7QUFNQW9yQyxRQUFLdk0sS0FBTCxDQUFXdi9CLEtBQVg7QUFDQTs7O2dDQUVhd3FDLEcsRUFBd0I7QUFBQSxPQUFuQnQrQixJQUFtQix1RUFBWixDQUFZO0FBQUEsT0FBVEUsR0FBUyx1RUFBSCxDQUFHOztBQUNyQyxPQUFNdE8sT0FBT0QsT0FBT0MsSUFBUCxDQUFZLEtBQUt3dEMsT0FBakIsQ0FBYjs7QUFFQSxRQUFLLElBQUl2dEMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRCxLQUFLRSxNQUF6QixFQUFpQ0QsR0FBakMsRUFBc0M7QUFDckNzc0Msd0JBQW9CdnNDLEtBQUtDLENBQUwsQ0FBcEIsRUFBNkIsS0FBS3V0QyxPQUFMLENBQWF4dEMsS0FBS0MsQ0FBTCxDQUFiLENBQTdCLEVBQW9EbU8sSUFBcEQsRUFBMERFLEdBQTFELEVBQStEbytCLEdBQS9EO0FBQ0E7QUFDRDs7O2dDQUVhO0FBQ2IsUUFBSzRCLGFBQUwsQ0FBbUIsS0FBSzVCLEdBQXhCOztBQUVBLE9BQU0xc0MsT0FBT0QsT0FBT0MsSUFBUCxDQUFZLEtBQUt3dEMsT0FBakIsQ0FBYjs7QUFFQSxRQUFLLElBQUl2dEMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRCxLQUFLRSxNQUF6QixFQUFpQ0QsR0FBakMsRUFBc0M7QUFDckMsU0FBS3V0QyxPQUFMLENBQWF4dEMsS0FBS0MsQ0FBTCxDQUFiLEVBQXNCaU4sS0FBdEIsQ0FBNEI2VixPQUE1QixHQUFzQyxPQUF0QztBQUNBO0FBQ0Q7OztnQ0FFYTtBQUNiLE9BQU0vaUIsT0FBT0QsT0FBT0MsSUFBUCxDQUFZLEtBQUt3dEMsT0FBakIsQ0FBYjs7QUFFQSxRQUFLLElBQUl2dEMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRCxLQUFLRSxNQUF6QixFQUFpQ0QsR0FBakMsRUFBc0M7QUFDckMsU0FBS3V0QyxPQUFMLENBQWF4dEMsS0FBS0MsQ0FBTCxDQUFiLEVBQXNCaU4sS0FBdEIsQ0FBNEI2VixPQUE1QixHQUFzQyxNQUF0QztBQUNBO0FBQ0Q7OztnQ0FFYTtBQUNiLFFBQUtvckIsYUFBTDs7QUFFQSxRQUFLRSxhQUFMOztBQUVBLFFBQUt4UixPQUFMLENBQWEzdkIsS0FBYixDQUFtQjZWLE9BQW5CLEdBQTZCLE9BQTdCO0FBQ0E7OztrQ0FFZTtBQUNmNHBCLG1CQUNDLEtBQUs5UCxPQUROLEVBRUMsS0FBSzRRLFVBQUwsQ0FBZ0JyL0IsSUFGakIsRUFHQyxLQUFLcS9CLFVBQUwsQ0FBZ0JuL0IsR0FIakI7O0FBTUEsUUFBS3V1QixPQUFMLENBQWEzdkIsS0FBYixDQUFtQnVFLE1BQW5CLEdBQStCLEtBQUtnOEIsVUFBTCxDQUFnQmg4QixNQUEvQztBQUNBLFFBQUtvckIsT0FBTCxDQUFhM3ZCLEtBQWIsQ0FBbUJxQixLQUFuQixHQUE4QixLQUFLay9CLFVBQUwsQ0FBZ0JsL0IsS0FBOUM7QUFDQTs7O2dDQUVhO0FBQ2IsT0FBTW0rQixNQUFNTyxlQUFlLEtBQUt6ckMsTUFBcEIsRUFBNEIsS0FBS3E3QixPQUFqQyxDQUFaOztBQUVBLFFBQUtuYSxNQUFMLEdBQWM7QUFDYmpSLFlBQVFpN0IsSUFBSWo3QixNQURDO0FBRWJsRCxXQUFPbStCLElBQUluK0I7QUFGRSxJQUFkOztBQUtBLFFBQUtzdUIsT0FBTCxDQUFhM3ZCLEtBQWIsQ0FBbUI2VixPQUFuQixHQUE2QixNQUE3QjtBQUNBOzs7Z0NBRWEzZ0IsSSxFQUFNO0FBQ25CLFFBQUtxckMsVUFBTCxHQUFrQjtBQUNqQmg4QixZQUFRLEtBQUtpN0IsR0FBTCxDQUFTajdCLE1BREE7QUFFakJyRCxVQUFNLENBRlc7QUFHakJFLFNBQUssQ0FIWTtBQUlqQkMsV0FBTyxLQUFLbStCLEdBQUwsQ0FBU24rQjtBQUpDLElBQWxCOztBQU9BLE9BQUksQ0FBQ25NLElBQUwsRUFBVztBQUNWO0FBQ0E7O0FBRUQsT0FBTXlCLFlBQVl6QixLQUFLa0IsTUFBTCxDQUFZTyxTQUE5Qjs7QUFFQSxPQUFJQSxVQUFVb0UsT0FBVixDQUFrQixHQUFsQixLQUEwQixDQUE5QixFQUFpQztBQUNoQyxTQUFLd2xDLFVBQUwsQ0FBZ0JsL0IsS0FBaEIsR0FBd0JZLEtBQUtFLEdBQUwsQ0FBUyxFQUFULEVBQWEsS0FBS3E5QixHQUFMLENBQVNuK0IsS0FBVCxHQUFpQm5NLEtBQUt5cEMsS0FBTCxDQUFXMTlCLENBQXpDLENBQXhCO0FBQ0E7O0FBRUQsT0FBSXRLLFVBQVVvRSxPQUFWLENBQWtCLEdBQWxCLEtBQTBCLENBQTlCLEVBQWlDO0FBQ2hDLFNBQUt3bEMsVUFBTCxDQUFnQmg4QixNQUFoQixHQUF5QnRDLEtBQUtFLEdBQUwsQ0FDeEIsRUFEd0IsRUFFeEIsS0FBS3E5QixHQUFMLENBQVNqN0IsTUFBVCxHQUFrQnJQLEtBQUt5cEMsS0FBTCxDQUFXeDlCLENBRkwsQ0FBekI7QUFJQTs7QUFFRCxPQUFJeEssVUFBVW9FLE9BQVYsQ0FBa0IsR0FBbEIsS0FBMEIsQ0FBOUIsRUFBaUM7QUFDaEMsU0FBS3dsQyxVQUFMLENBQWdCbC9CLEtBQWhCLEdBQXdCWSxLQUFLRSxHQUFMLENBQVMsRUFBVCxFQUFhLEtBQUtxOUIsR0FBTCxDQUFTbitCLEtBQVQsR0FBaUJuTSxLQUFLeXBDLEtBQUwsQ0FBVzE5QixDQUF6QyxDQUF4QjtBQUNBOztBQUVELE9BQUl0SyxVQUFVb0UsT0FBVixDQUFrQixHQUFsQixLQUEwQixDQUE5QixFQUFpQztBQUNoQyxTQUFLd2xDLFVBQUwsQ0FBZ0JoOEIsTUFBaEIsR0FBeUJ0QyxLQUFLRSxHQUFMLENBQ3hCLEVBRHdCLEVBRXhCLEtBQUtxOUIsR0FBTCxDQUFTajdCLE1BQVQsR0FBa0JyUCxLQUFLeXBDLEtBQUwsQ0FBV3g5QixDQUZMLENBQXpCO0FBSUE7O0FBRUQsT0FBSXhLLFVBQVVvRSxPQUFWLENBQWtCLEdBQWxCLElBQXlCLENBQXpCLElBQThCLENBQUM3RixLQUFLcEMsSUFBTCxDQUFVc04sS0FBN0MsRUFBb0Q7QUFDbkQsUUFBTW1oQyxRQUFRLEtBQUsvQixHQUFMLENBQVNuK0IsS0FBVCxHQUFpQixLQUFLbStCLEdBQUwsQ0FBU2o3QixNQUF4Qzs7QUFFQSxRQUFJLEtBQUtnOEIsVUFBTCxDQUFnQmwvQixLQUFoQixHQUF3QixLQUFLay9CLFVBQUwsQ0FBZ0JoOEIsTUFBeEMsR0FBaURnOUIsS0FBckQsRUFBNEQ7QUFDM0QsVUFBS2hCLFVBQUwsQ0FBZ0JoOEIsTUFBaEIsR0FBeUJ0QyxLQUFLMjlCLEtBQUwsQ0FDeEIsS0FBS1csVUFBTCxDQUFnQmwvQixLQUFoQixHQUF3QmtnQyxLQURBLENBQXpCO0FBR0EsS0FKRCxNQUlPO0FBQ04sVUFBS2hCLFVBQUwsQ0FBZ0JsL0IsS0FBaEIsR0FBd0JZLEtBQUsyOUIsS0FBTCxDQUN2QixLQUFLVyxVQUFMLENBQWdCaDhCLE1BQWhCLEdBQXlCZzlCLEtBREYsQ0FBeEI7QUFHQTtBQUNEOztBQUVELE9BQUk1cUMsVUFBVW9FLE9BQVYsQ0FBa0IsR0FBbEIsS0FBMEIsQ0FBOUIsRUFBaUM7QUFDaEMsU0FBS3dsQyxVQUFMLENBQWdCci9CLElBQWhCLEdBQXVCLEtBQUtzK0IsR0FBTCxDQUFTbitCLEtBQVQsR0FBaUIsS0FBS2svQixVQUFMLENBQWdCbC9CLEtBQXhEO0FBQ0E7O0FBRUQsT0FBSTFLLFVBQVVvRSxPQUFWLENBQWtCLEdBQWxCLEtBQTBCLENBQTlCLEVBQWlDO0FBQ2hDLFNBQUt3bEMsVUFBTCxDQUFnQm4vQixHQUFoQixHQUFzQixLQUFLbytCLEdBQUwsQ0FBU2o3QixNQUFULEdBQWtCLEtBQUtnOEIsVUFBTCxDQUFnQmg4QixNQUF4RDtBQUNBO0FBQ0Q7OzttQ0FFZ0I7QUFDaEIsUUFBS3VCLEdBQUwsQ0FBU281QixVQUFULENBQW9CLEtBQUs3d0IsRUFBekIsRUFBNkIsS0FBS21ILE1BQUwsQ0FBWW5VLEtBQXpDLEVBQWdELEtBQUttVSxNQUFMLENBQVlqUixNQUE1RDtBQUNBOzs7Ozs7UUFHTTY3QixPLEdBQUFBLE87a0JBQ09BLE87Ozs7Ozs7Ozs7Ozs7O0FDM1RmOzs7OztBQUtBLElBQU1vQixPQUFPcHdDLFNBQVNjLEdBQVQsQ0FBYUMsRUFBMUI7O0FBRUEsSUFBSSxDQUFDZixTQUFTcW5CLE9BQVQsQ0FBaUJ4bkIsR0FBakIsQ0FBcUIsY0FBckIsQ0FBTCxFQUEyQztBQUMxQzs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7OztBQVNBOzs7Ozs7Ozs7O0FBVUFHLFVBQVNxbkIsT0FBVCxDQUFpQnZmLEdBQWpCLENBQXFCLGNBQXJCLEVBQXFDO0FBQ3BDOzs7Ozs7Ozs7QUFTQTYyQixNQVZvQyxnQkFVL0I1K0IsTUFWK0IsRUFVdkI7QUFBQTs7QUFDWkEsVUFBT3FCLElBQVAsQ0FBWSxZQUFaLEVBQTBCLFlBQU07QUFDL0IsUUFBTUUsV0FBV3ZCLE9BQU91QixRQUFQLEVBQWpCOztBQUVBQSxhQUFTMHBDLGNBQVQsQ0FDQzFwQyxRQURELEVBRUMsV0FGRCxFQUdDLE1BQUsrdUMsWUFITixFQUlDLEtBSkQsRUFLQztBQUNDdHdDO0FBREQsS0FMRDs7QUFVQXVCLGFBQVMwcEMsY0FBVCxDQUNDMXBDLFFBREQsRUFFQyxVQUZELEVBR0MsTUFBS2d2QyxXQUhOLEVBSUMsS0FKRCxFQUtDO0FBQ0N2d0M7QUFERCxLQUxEOztBQVVBdUIsYUFBUzBwQyxjQUFULENBQ0MxcEMsUUFERCxFQUVDLE1BRkQsRUFHQyxNQUFLaXZDLFdBSE4sRUFJQyxLQUpELEVBS0M7QUFDQ3h3QztBQURELEtBTEQ7O0FBVUF1QixhQUFTMHBDLGNBQVQsQ0FDQzFwQyxRQURELEVBRUMsT0FGRCxFQUdDLE1BQUtrdkMsUUFITixFQUlDLEtBSkQsRUFLQztBQUNDendDO0FBREQsS0FMRDtBQVNBLElBMUNEO0FBMkNBLEdBdERtQzs7O0FBd0RwQzs7Ozs7Ozs7Ozs7O0FBWUEwd0MsY0FwRW9DLHdCQW9FdkIxc0IsS0FwRXVCLEVBb0VoQmhrQixNQXBFZ0IsRUFvRVI7QUFDM0IsT0FBSW1rQixhQUFKO0FBQ0EsT0FBSXZpQixVQUFKOztBQUVBLE9BQU0waUIsYUFBYSxFQUFuQjs7QUFFQSxRQUFLMWlCLElBQUksQ0FBVCxFQUFZQSxJQUFJb2lCLE1BQU1uaUIsTUFBdEIsRUFBOEJELEdBQTlCLEVBQW1DO0FBQ2xDdWlCLFdBQU9ILE1BQU1waUIsQ0FBTixDQUFQOztBQUVBLFFBQUl1aUIsS0FBS2pkLElBQUwsQ0FBVTBDLE9BQVYsQ0FBa0IsT0FBbEIsTUFBK0IsQ0FBbkMsRUFBc0M7QUFDckMwYSxnQkFBVzFZLElBQVgsQ0FBZ0J1WSxJQUFoQjtBQUNBO0FBQ0Q7O0FBRUQsT0FBTUUsU0FBU3JrQixPQUFPdUUsSUFBUCxDQUFZLGdCQUFaLEVBQThCO0FBQzVDK2Y7QUFENEMsSUFBOUIsQ0FBZjs7QUFJQSxPQUFJRCxNQUFKLEVBQVk7QUFDWCxTQUFLemlCLElBQUksQ0FBVCxFQUFZQSxJQUFJMGlCLFdBQVd6aUIsTUFBM0IsRUFBbUNELEdBQW5DLEVBQXdDO0FBQ3ZDdWlCLFlBQU9HLFdBQVcxaUIsQ0FBWCxDQUFQOztBQUVBLFVBQUsrdUMsWUFBTCxDQUFrQnhzQixJQUFsQixFQUF3Qm5rQixNQUF4QjtBQUNBO0FBQ0Q7O0FBRUQsVUFBTyxLQUFQO0FBQ0EsR0EvRm1DOzs7QUFpR3BDOzs7Ozs7Ozs7OztBQVdBd3dDLGFBNUdvQyx1QkE0R3hCM3NDLEtBNUd3QixFQTRHakI7QUFDbEIsT0FBTXlNLGNBQWN6TSxNQUFNRSxJQUFOLENBQVdULENBQS9COztBQUVBLE9BQU1zdEMsZ0JBQWdCdGdDLFlBQVl1Z0MsWUFBWixDQUF5QjdzQixLQUEvQzs7QUFFQSxPQUFJNHNCLGNBQWMvdUMsTUFBZCxHQUF1QixDQUEzQixFQUE4QjtBQUM3QixRQUFJNUIsU0FBU3dFLEdBQVQsQ0FBYVosS0FBakIsQ0FBdUJ5TSxXQUF2QixFQUFvQ2pNLGNBQXBDOztBQUVBLFFBQU1yRSxTQUFTNkQsTUFBTVMsWUFBTixDQUFtQnRFLE1BQWxDOztBQUVBNkQsVUFBTVMsWUFBTixDQUFtQnRFLE1BQW5CLENBQTBCMmlDLHdCQUExQixDQUNDcnlCLFlBQVk2OEIsT0FEYixFQUVDNzhCLFlBQVk4OEIsT0FGYjs7QUFLQSxTQUFLc0QsWUFBTCxDQUFrQkUsYUFBbEIsRUFBaUM1d0MsTUFBakM7QUFDQTtBQUNELEdBN0htQzs7O0FBK0hwQzs7Ozs7Ozs7O0FBU0Fzd0MsY0F4SW9DLHdCQXdJdkJ6c0MsS0F4SXVCLEVBd0loQjtBQUNuQixPQUFJd3NDLElBQUosRUFBVTtBQUNULFNBQUtTLGFBQUwsQ0FBbUJqdEMsS0FBbkI7QUFDQTtBQUNELEdBNUltQzs7O0FBOElwQzs7Ozs7Ozs7O0FBU0Ewc0MsYUF2Sm9DLHVCQXVKeEIxc0MsS0F2SndCLEVBdUpqQjtBQUNsQixPQUFJd3NDLElBQUosRUFBVTtBQUNULFNBQUtTLGFBQUwsQ0FBbUJqdEMsS0FBbkI7QUFDQTtBQUNELEdBM0ptQzs7O0FBNkpwQzs7Ozs7Ozs7OztBQVVBNHNDLFVBdktvQyxvQkF1SzNCNXNDLEtBdksyQixFQXVLcEI7QUFDZixPQUNDQSxNQUFNRSxJQUFOLElBQ0FGLE1BQU1FLElBQU4sQ0FBV1QsQ0FEWCxJQUVBTyxNQUFNRSxJQUFOLENBQVdULENBQVgsQ0FBYXl0QyxhQUZiLElBR0FsdEMsTUFBTUUsSUFBTixDQUFXVCxDQUFYLENBQWF5dEMsYUFBYixDQUEyQmg3QixLQUgzQixJQUlBbFMsTUFBTUUsSUFBTixDQUFXVCxDQUFYLENBQWF5dEMsYUFBYixDQUEyQmg3QixLQUEzQixDQUFpQ2xVLE1BQWpDLEdBQTBDLENBTDNDLEVBTUU7QUFDRCxRQUFNbXZDLGFBQWFudEMsTUFBTUUsSUFBTixDQUFXVCxDQUFYLENBQWF5dEMsYUFBYixDQUEyQmg3QixLQUEzQixDQUFpQyxDQUFqQyxDQUFuQjs7QUFFQSxRQUFJaTdCLFdBQVc5cEMsSUFBWCxDQUFnQjBDLE9BQWhCLENBQXdCLE9BQXhCLE1BQXFDLENBQXpDLEVBQTRDO0FBQzNDLFNBQU1xbkMsWUFBWUQsV0FBV0UsU0FBWCxFQUFsQjs7QUFFQSxVQUFLUCxZQUFMLENBQWtCTSxTQUFsQixFQUE2QnB0QyxNQUFNUyxZQUFOLENBQW1CdEUsTUFBaEQ7QUFDQTtBQUNEO0FBQ0QsR0F2TG1DOzs7QUF5THBDOzs7Ozs7Ozs7QUFTQTh3QyxlQWxNb0MseUJBa010Qmp0QyxLQWxNc0IsRUFrTWY7QUFDcEJBLFdBQVEsSUFBSTVELFNBQVN3RSxHQUFULENBQWFaLEtBQWpCLENBQXVCQSxNQUFNRSxJQUFOLENBQVdULENBQWxDLENBQVI7O0FBRUFPLFNBQU1RLGNBQU47QUFDQVIsU0FBTWtULGVBQU47QUFDQSxHQXZNbUM7OztBQXlNcEM7Ozs7Ozs7Ozs7O0FBV0E0NUIsY0FwTm9DLHdCQW9OdkJ4c0IsSUFwTnVCLEVBb05qQm5rQixNQXBOaUIsRUFvTlQ7QUFDMUIsT0FBTWlrQixTQUFTLElBQUlDLFVBQUosRUFBZjs7QUFFQUQsVUFBT3hHLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DLFlBQU07QUFDeEMsUUFBTTB6QixNQUFNbHRCLE9BQU9JLE1BQW5COztBQUVBLFFBQU1uSCxLQUFLamQsU0FBU3dFLEdBQVQsQ0FBYXFCLE9BQWIsQ0FBcUJxWCxjQUFyQixDQUNWLGVBQWVnMEIsR0FBZixHQUFxQixJQURYLENBQVg7O0FBSUFueEMsV0FBT29kLGFBQVAsQ0FBcUJGLEVBQXJCOztBQUVBLFFBQU1xSCxZQUFZO0FBQ2pCckgsV0FEaUI7QUFFakJpSDtBQUZpQixLQUFsQjs7QUFLQW5rQixXQUFPdUUsSUFBUCxDQUFZLFVBQVosRUFBd0JnZ0IsU0FBeEI7QUFDQSxJQWZEOztBQWlCQU4sVUFBT08sYUFBUCxDQUFxQkwsSUFBckI7QUFDQTtBQXpPbUMsRUFBckM7QUEyT0EsQzs7Ozs7Ozs7Ozs7Ozs7QUMvUUQ7Ozs7O0FBS0EsSUFBSSxDQUFDbGtCLFNBQVNxbkIsT0FBVCxDQUFpQnhuQixHQUFqQixDQUFxQixhQUFyQixDQUFMLEVBQTBDO0FBQ3pDO0FBQ0E7QUFDQSxLQUFJLHVDQUF1Q3FMLElBQXZDLENBQTRDZCxVQUFVK21DLFNBQXRELENBQUosRUFBc0U7QUFDckUvdEMsV0FBUzJLLFdBQVQsQ0FBcUIsZUFBckIsRUFBc0MsS0FBdEMsRUFBNkMsS0FBN0M7QUFDQTs7QUFFRCxLQUFNcWpDLFdBQVcsQ0FBakI7O0FBRUEsS0FBTUMsWUFBWSxHQUFsQjs7QUFFQSxLQUFNbnhCLFlBQVksRUFBbEI7O0FBRUEsS0FBTW94QixnQkFBZ0IsR0FBdEI7O0FBRUEsS0FBTUMsWUFBWSxFQUFsQjs7QUFFQSxLQUFNQyxhQUFhLENBQUNILFNBQUQsRUFBWW54QixTQUFaLEVBQXVCb3hCLGFBQXZCLEVBQXNDQyxTQUF0QyxDQUFuQjs7QUFFQSxLQUFNRSxrQkFBa0IsV0FBeEI7O0FBRUE7QUFDQSxLQUFNQyxZQUNMLHNCQUFzQjtBQUN0QixtREFEQSxHQUNxRDtBQUNyRCw4QkFGQSxHQUVnQztBQUNoQyxrQ0FIQSxHQUdvQztBQUNwQywyQkFKQSxHQUk2QjtBQUM3QixxQkFORDs7QUFRQSxLQUFNQyxjQUFjLGdEQUFwQjs7QUFFQTs7Ozs7O0FBTUEzeEMsVUFBU3FuQixPQUFULENBQWlCdmYsR0FBakIsQ0FBcUIsYUFBckIsRUFBb0M7QUFDbkM7Ozs7Ozs7OztBQVNBNjJCLE1BVm1DLGdCQVU5QjUrQixNQVY4QixFQVV0QjtBQUFBOztBQUNaQSxVQUFPcUIsSUFBUCxDQUFZLFlBQVosRUFBMEIsWUFBTTtBQUMvQixRQUFNRSxXQUFXdkIsT0FBT3VCLFFBQVAsRUFBakI7O0FBRUFBLGFBQVMwcEMsY0FBVCxDQUNDMXBDLFFBREQsRUFFQyxPQUZELEVBR0MsTUFBS3N3QyxRQUhOLEVBSUMsS0FKRCxFQUtDO0FBQ0M3eEM7QUFERCxLQUxEO0FBU0EsSUFaRDs7QUFjQUEsVUFBTzJELEVBQVAsQ0FBVSxPQUFWLEVBQW1CLGlCQUFTO0FBQzNCLFFBQUlFLE1BQU1FLElBQU4sQ0FBVyt0QyxNQUFYLEtBQXNCLE9BQTFCLEVBQW1DO0FBQ2xDLFNBQ0NqdUMsTUFBTUUsSUFBTixDQUFXZ3VDLFNBQVgsQ0FBcUJub0MsT0FBckIsQ0FBNkIsR0FBN0IsSUFBb0MsQ0FBQyxDQUFyQyxJQUNBL0YsTUFBTUUsSUFBTixDQUFXZ3VDLFNBQVgsQ0FBcUJub0MsT0FBckIsQ0FBNkIsTUFBN0IsSUFBdUMsQ0FBQyxDQUZ6QyxFQUdFO0FBQ0QsVUFDQy9GLE1BQU1FLElBQU4sQ0FBV2d1QyxTQUFYLENBQXFCbm9DLE9BQXJCLENBQTZCLGtCQUE3QixJQUNBLENBQUMsQ0FGRixFQUdFO0FBQ0QvRixhQUFNRSxJQUFOLENBQVdndUMsU0FBWCxHQUF1Qmx1QyxNQUFNRSxJQUFOLENBQVdndUMsU0FBWCxDQUFxQjN3QyxPQUFyQixDQUN0Qix5Q0FEc0IsRUFFdEIsRUFGc0IsQ0FBdkI7QUFJQTtBQUNEO0FBQ0E7O0FBRUQsU0FBTXdZLFdBQVcsS0FBakI7O0FBRUEvVixXQUFNRSxJQUFOLENBQVdndUMsU0FBWCxHQUF1Qmx1QyxNQUFNRSxJQUFOLENBQVdndUMsU0FBWCxDQUFxQjN3QyxPQUFyQixDQUN0QjR3QyxPQUFPTCxTQUFQLEVBQWtCLEtBQWxCLENBRHNCLEVBRXRCLGVBQU87QUFDTixVQUFJLzNCLFNBQVNxNEIsV0FBVCxDQUFxQnh4QixHQUFyQixDQUFKLEVBQStCO0FBQzlCLFdBQUk3RyxTQUFTczRCLGFBQVQsQ0FBdUJ6eEIsR0FBdkIsQ0FBSixFQUFpQztBQUNoQyxlQUNDLHFCQUNBQSxHQURBLEdBRUEsSUFGQSxHQUdBQSxHQUhBLEdBSUEsTUFMRDtBQU9BLFFBUkQsTUFRTztBQUNOLGVBQ0MsY0FBY0EsR0FBZCxHQUFvQixJQUFwQixHQUEyQkEsR0FBM0IsR0FBaUMsTUFEbEM7QUFHQTtBQUNEO0FBQ0QsTUFsQnFCLENBQXZCO0FBb0JBO0FBQ0QsSUF6Q0Q7QUEwQ0EsR0FuRWtDOzs7QUFxRW5DOzs7Ozs7Ozs7O0FBVUEweEIsY0EvRW1DLHdCQStFdEJueUMsTUEvRXNCLEVBK0VkO0FBQ3BCLE9BQU0wTSxRQUFRMU0sT0FBT29ELFlBQVAsR0FBc0JtSixTQUF0QixHQUFrQyxDQUFsQyxDQUFkOztBQUVBLE9BQUksQ0FBQ0csS0FBTCxFQUFZO0FBQ1g7QUFDQTs7QUFFRCxPQUFNOHpCLFNBQVM5ekIsTUFBTTIyQixXQUFyQjs7QUFFQSxPQUFJK08sZUFBZSxFQUFuQjs7QUFFQTtBQUNBLE9BQUksS0FBS0MsZUFBTCxLQUF5Qmx5QixTQUE3QixFQUF3QztBQUN2QyxRQUFJbXlCLGVBQWU1bEMsTUFBTUYsY0FBTixDQUFxQitsQyxXQUFyQixFQUFuQjs7QUFFQSxRQUFJQyxrQkFBSjs7QUFFQSxRQUFJRixZQUFKLEVBQWtCO0FBQ2pCO0FBQ0E7QUFDQSxZQUFPLENBQUNBLGFBQWFHLE9BQXJCLEVBQThCO0FBQzdCSCxxQkFBZUEsYUFBYUMsV0FBYixFQUFmO0FBQ0E7O0FBRURDLGlCQUFZRixhQUFhRyxPQUFiLEVBQVo7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBT0QsYUFBYSxDQUFDQSxVQUFValMsT0FBVixFQUFyQixFQUEwQztBQUN6Q2lTLGtCQUFZQSxVQUFVRCxXQUFWLEVBQVo7QUFDQTtBQUNEOztBQUVEO0FBQ0EsUUFBSSxFQUFFQyxhQUFhQSxVQUFVbHZDLENBQVYsQ0FBWXdCLElBQTNCLENBQUosRUFBc0M7QUFDckMsVUFBSzR0QyxlQUFMLEdBQXVCRixTQUF2QjtBQUNBSixvQkFBZUksWUFBWUEsVUFBVWpTLE9BQVYsRUFBWixHQUFrQyxFQUFqRDtBQUNBLFVBQUtvUyxPQUFMLEdBQWVQLGFBQWF2d0MsTUFBNUI7QUFDQTtBQUNELElBNUJELE1BNEJPO0FBQ04sU0FBSzZ3QyxlQUFMLEdBQXVCaG1DLE1BQU1GLGNBQTdCOztBQUVBO0FBQ0E0bEMsbUJBQWUsS0FBS00sZUFBTCxDQUNiblMsT0FEYSxHQUVibE8sU0FGYSxDQUVILENBRkcsRUFFQW1PLFNBQVMsQ0FGVCxDQUFmOztBQUlBLFNBQUttUyxPQUFMLEdBQWVuUyxTQUFTLENBQXhCO0FBQ0E7O0FBRUQsT0FBSW9TLFdBQVcsRUFBZjs7QUFFQSxPQUFNbnBDLFFBQVEyb0MsYUFBYTNvQyxLQUFiLENBQW1CaW9DLGVBQW5CLENBQWQ7O0FBRUEsT0FBSWpvQyxLQUFKLEVBQVc7QUFDVm1wQyxlQUFXbnBDLE1BQU02Z0IsR0FBTixFQUFYO0FBQ0E7O0FBRUQsVUFBT3NvQixRQUFQO0FBQ0EsR0EzSWtDOzs7QUE2SW5DOzs7Ozs7Ozs7O0FBVUFWLGVBdkptQyx5QkF1SnJCVyxLQXZKcUIsRUF1SmQ7QUFDcEIsVUFBT2pCLFlBQVl6bUMsSUFBWixDQUFpQjBuQyxLQUFqQixDQUFQO0FBQ0EsR0F6SmtDOzs7QUEySm5DOzs7Ozs7Ozs7O0FBVUFaLGFBckttQyx1QkFxS3ZCcnRDLElBckt1QixFQXFLakI7QUFDakIsVUFBT290QyxPQUFPTCxTQUFQLEVBQWtCLEdBQWxCLEVBQXVCeG1DLElBQXZCLENBQTRCdkcsSUFBNUIsQ0FBUDtBQUNBLEdBdktrQzs7O0FBeUtuQzs7Ozs7Ozs7OztBQVVBa3VDLFlBbkxtQyxzQkFtTHhCanZDLEtBbkx3QixFQW1MakI7QUFDakIsT0FBTXlNLGNBQWN6TSxNQUFNRSxJQUFOLENBQVdULENBQS9COztBQUVBLE9BQU10RCxTQUFTNkQsTUFBTVMsWUFBTixDQUFtQnRFLE1BQWxDOztBQUVBLE9BQU11QixXQUFXdkIsT0FBT3VCLFFBQVAsRUFBakI7O0FBRUFBLFlBQVMycEMsY0FBVCxDQUF3QixTQUF4QixFQUFtQyxLQUFLNEgsVUFBeEM7O0FBRUEsT0FBSXhpQyxZQUFZc0gsT0FBWixLQUF3Qnk1QixRQUE1QixFQUFzQztBQUNyQ3h0QyxVQUFNZ21DLE1BQU47QUFDQWhtQyxVQUFNRSxJQUFOLENBQVdNLGNBQVg7O0FBRUEsU0FBSzBqQixXQUFMLENBQWlCL25CLE1BQWpCO0FBQ0E7O0FBRUQsUUFBSyt5QyxPQUFMLEdBQWUsSUFBZjtBQUNBLEdBcE1rQzs7O0FBc01uQzs7Ozs7Ozs7OztBQVVBbEIsVUFoTm1DLG9CQWdOMUJodUMsS0FoTjBCLEVBZ05uQjtBQUNmLE9BQU15TSxjQUFjek0sTUFBTUUsSUFBTixDQUFXVCxDQUEvQjs7QUFFQSxRQUFLK3VDLGVBQUwsR0FBdUIvaEMsWUFBWXNILE9BQW5DOztBQUVBLE9BQUk2NUIsV0FBVzduQyxPQUFYLENBQW1CLEtBQUt5b0MsZUFBeEIsTUFBNkMsQ0FBQyxDQUFsRCxFQUFxRDtBQUNwRCxRQUFNcnlDLFNBQVM2RCxNQUFNUyxZQUFOLENBQW1CdEUsTUFBbEM7O0FBRUEsUUFBTTR5QyxXQUFXLEtBQUtULFlBQUwsQ0FBa0JueUMsTUFBbEIsQ0FBakI7O0FBRUEsUUFBSSxLQUFLaXlDLFdBQUwsQ0FBaUJXLFFBQWpCLENBQUosRUFBZ0M7QUFDL0IsVUFBS0kscUJBQUwsQ0FBMkJoekMsTUFBM0IsRUFBbUM0eUMsUUFBbkM7QUFDQTtBQUNEO0FBQ0QsR0E5TmtDOzs7QUFnT25DOzs7Ozs7Ozs7O0FBVUFJLHVCQTFPbUMsaUNBME9iaHpDLE1BMU9hLEVBME9MaXpDLE9BMU9LLEVBME9JO0FBQ3RDLE9BQUl2bUMsUUFBUTFNLE9BQU93akMsV0FBUCxFQUFaO0FBQ0EsT0FBTTNqQyxPQUFPSSxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBYixDQUFxQmhHLEdBQXJCLENBQXlCLEtBQUs0eUMsZUFBOUIsQ0FBYjtBQUNBLE9BQU1sUyxTQUFTLEtBQUttUyxPQUFwQjs7QUFFQTtBQUNBam1DLFNBQU1DLFFBQU4sQ0FBZTlNLElBQWYsRUFBcUIyZ0MsU0FBU3lTLFFBQVFweEMsTUFBdEM7QUFDQTZLLFNBQU1FLE1BQU4sQ0FBYS9NLElBQWIsRUFBbUIyZ0MsTUFBbkI7QUFDQTl6QixTQUFNczBCLE1BQU47O0FBRUEsT0FBTWtTLFNBQVMsSUFBSWp6QyxTQUFTZ25CLElBQWIsQ0FBa0JqbkIsTUFBbEIsQ0FBZjtBQUNBa3pDLFVBQU94ckIsTUFBUCxDQUFjdXJCLE9BQWQ7QUFDQSxRQUFLRixPQUFMLEdBQWVHLE1BQWY7O0FBRUEsT0FBTUMsV0FBV0QsT0FBT3ZyQixnQkFBUCxFQUFqQjtBQUNBM25CLFVBQU91RSxJQUFQLENBQVksYUFBWixFQUEyQjR1QyxRQUEzQjs7QUFFQSxRQUFLQyxvQkFBTCxDQUEwQnB6QyxNQUExQjs7QUFFQTtBQUNBO0FBQ0EwTSxXQUFRMU0sT0FBT29ELFlBQVAsR0FBc0JtSixTQUF0QixHQUFrQyxDQUFsQyxDQUFSOztBQUVBO0FBQ0E7QUFDQSxPQUFJLEtBQUs4bEMsZUFBTCxLQUF5Qmx5QixTQUE3QixFQUF3QztBQUN2QyxRQUFNa3pCLG1CQUFtQjNtQyxNQUFNeXpCLG1CQUFOLEVBQXpCOztBQUVBenpCLFVBQU1DLFFBQU4sQ0FBZTBtQyxnQkFBZixFQUFpQyxDQUFqQztBQUNBM21DLFVBQU1FLE1BQU4sQ0FBYXltQyxnQkFBYixFQUErQixDQUEvQjtBQUNBLElBTEQsTUFLTztBQUNOLFFBQU1DLGVBQWU1bUMsTUFBTTZtQyxlQUFOLEVBQXJCOztBQUVBN21DLFVBQU1DLFFBQU4sQ0FBZTJtQyxZQUFmLEVBQTZCLENBQTdCO0FBQ0E1bUMsVUFBTUUsTUFBTixDQUFhMG1DLFlBQWIsRUFBMkIsQ0FBM0I7QUFDQTs7QUFFRDVtQyxTQUFNczBCLE1BQU47QUFDQSxHQWhSa0M7OztBQWtSbkM7Ozs7Ozs7O0FBUUE7Ozs7Ozs7O0FBUUFqWixhQWxTbUMsdUJBa1N2Qi9uQixNQWxTdUIsRUFrU2Y7QUFDbkIsT0FBTTBNLFFBQVExTSxPQUFPb0QsWUFBUCxHQUFzQm1KLFNBQXRCLEdBQWtDLENBQWxDLENBQWQ7QUFDQSxPQUFNaW5DLGNBQWM5bUMsTUFBTTIyQixXQUExQjs7QUFFQTtBQUNBLE9BQU04UCxXQUNMLEtBQUtULGVBQUwsQ0FBcUJlLE9BQXJCLE1BQWtDLEtBQUtmLGVBRHhDOztBQUdBLE9BQU1nQixXQUFXMXpDLE9BQU93akMsV0FBUCxFQUFqQjtBQUNBa1EsWUFBUy9tQyxRQUFULENBQWtCd21DLFFBQWxCLEVBQTRCLENBQTVCO0FBQ0FPLFlBQVNDLFdBQVQsQ0FBcUJSLFFBQXJCO0FBQ0FPLFlBQVMxUyxNQUFUOztBQUVBLFFBQUsrUixPQUFMLENBQWE1bEMsTUFBYjs7QUFFQTtBQUNBVCxTQUFNRSxNQUFOLENBQWFGLE1BQU1GLGNBQW5CLEVBQW1DZ25DLFdBQW5DO0FBQ0E5bUMsU0FBTUMsUUFBTixDQUFlRCxNQUFNRixjQUFyQixFQUFxQ2duQyxXQUFyQzs7QUFFQTltQyxTQUFNczBCLE1BQU47QUFDQSxHQXRUa0M7OztBQXdUbkM7Ozs7Ozs7O0FBUUFvUyxzQkFoVW1DLGdDQWdVZHB6QyxNQWhVYyxFQWdVTjtBQUM1QixPQUFNdUIsV0FBV3ZCLE9BQU91QixRQUFQLEVBQWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBQSxZQUFTMHBDLGNBQVQsQ0FDQzFwQyxRQURELEVBRUMsU0FGRCxFQUdDLEtBQUt1eEMsVUFITixFQUlDLElBSkQsRUFLQztBQUNDOXlDO0FBREQsSUFMRCxFQVFDLENBUkQ7QUFVQTtBQWhWa0MsRUFBcEM7QUFrVkEsQzs7Ozs7Ozs7Ozs7Ozs7QUM3WEQ7Ozs7O0FBS0EsSUFBSSxDQUFDQyxTQUFTcW5CLE9BQVQsQ0FBaUJ4bkIsR0FBakIsQ0FBcUIsYUFBckIsQ0FBTCxFQUEwQztBQUN6QyxLQUFNdXhDLFdBQVcsQ0FBakI7O0FBRUEsS0FBTUcsWUFBWSxFQUFsQjs7QUFFQSxLQUFNb0MsaUJBQWlCLENBQ3RCO0FBQ0NDLFNBQU8sTUFEUjtBQUVDM3NDLFFBQU07QUFGUCxFQURzQixFQUt0QjtBQUNDMnNDLFNBQU8sT0FEUjtBQUVDM3NDLFFBQU07QUFGUCxFQUxzQixDQUF2Qjs7QUFXQTs7Ozs7O0FBTUFqSCxVQUFTcW5CLE9BQVQsQ0FBaUJ2ZixHQUFqQixDQUFxQixhQUFyQixFQUFvQztBQUNuQzs7Ozs7Ozs7O0FBU0E2MkIsTUFWbUMsZ0JBVTlCNStCLE1BVjhCLEVBVXRCO0FBQUE7O0FBQ1pBLFVBQU9xQixJQUFQLENBQVksWUFBWixFQUEwQixZQUFNO0FBQy9CLFFBQU1FLFdBQVd2QixPQUFPdUIsUUFBUCxFQUFqQjs7QUFFQUEsYUFBUzBwQyxjQUFULENBQ0MxcEMsUUFERCxFQUVDLFNBRkQsRUFHQyxNQUFLdXhDLFVBSE4sRUFJQyxLQUpELEVBS0M7QUFDQzl5QztBQURELEtBTEQ7QUFTQSxJQVpEO0FBYUEsR0F4QmtDOzs7QUEwQm5DOzs7Ozs7Ozs7QUFTQTh6QywyQkFuQ21DLHFDQW1DVGp3QyxLQW5DUyxFQW1DRjtBQUNoQyxPQUFNN0QsU0FBUzZELE1BQU1TLFlBQU4sQ0FBbUJ0RSxNQUFsQzs7QUFFQSxPQUFNc1EsY0FBY3pNLE1BQU1FLElBQU4sQ0FBV1QsQ0FBL0I7O0FBRUEsT0FBTS9CLFdBQVd2QixPQUFPdUIsUUFBUCxFQUFqQjs7QUFFQUEsWUFBUzJwQyxjQUFULENBQXdCLFNBQXhCLEVBQW1DLEtBQUs0SSx5QkFBeEM7O0FBRUEsT0FBSXhqQyxZQUFZc0gsT0FBWixLQUF3Qnk1QixRQUE1QixFQUFzQztBQUNyQ3J4QyxXQUFPZ08sV0FBUCxDQUFtQixNQUFuQjtBQUNBaE8sV0FBTyt6QyxVQUFQLENBQWtCbHdDLE1BQU1TLFlBQU4sQ0FBbUIwdkMsTUFBbkIsR0FBNEIsUUFBOUM7QUFDQW53QyxVQUFNRSxJQUFOLENBQVdNLGNBQVg7QUFDQTtBQUNELEdBakRrQzs7O0FBbURuQzs7Ozs7Ozs7OztBQVVBNHZDLGdCQTdEbUMsMEJBNkRwQmowQyxNQTdEb0IsRUE2RFo7QUFDdEIsT0FBTWswQyxjQUFjbDBDLE9BQU9ULE1BQVAsQ0FBYzQwQyxRQUFkLElBQTBCUCxjQUE5Qzs7QUFFQSxPQUFNbG5DLFFBQVExTSxPQUFPb0QsWUFBUCxHQUFzQm1KLFNBQXRCLEdBQWtDLENBQWxDLENBQWQ7O0FBRUEsT0FBTTZuQyxnQkFBZ0IxbkMsTUFBTXcyQixZQUFOLENBQW1CM0MsT0FBbkIsRUFBdEI7O0FBRUEsT0FBTXlULFNBQVNJLGNBQWMvaEIsU0FBZCxDQUF3QixDQUF4QixFQUEyQjNsQixNQUFNMjJCLFdBQWpDLENBQWY7O0FBRUEsT0FBTTFDLE9BQU95VCxjQUFjL2hCLFNBQWQsQ0FDWjNsQixNQUFNMjJCLFdBRE0sRUFFWitRLGNBQWN2eUMsTUFGRixDQUFiOztBQUtBLE9BQUkrUyxRQUFRLENBQVo7O0FBRUEsT0FBTXkvQixXQUFXSCxZQUFZcnlDLE1BQTdCOztBQUVBLE9BQUl5eUMsY0FBYyxJQUFsQjs7QUFFQSxVQUFPLENBQUNBLFdBQUQsSUFBZ0JELFdBQVd6L0IsS0FBbEMsRUFBeUM7QUFDeEMsUUFBTTIvQixZQUFZTCxZQUFZdC9CLEtBQVosQ0FBbEI7O0FBRUEsUUFBSTIvQixVQUFVVixLQUFWLENBQWdCMW9DLElBQWhCLENBQXFCNm9DLE1BQXJCLENBQUosRUFBa0M7QUFDakNNLG1CQUFjO0FBQ2JOLG9CQURhO0FBRWJoMEMsb0JBRmE7QUFHYjJnQyxnQkFIYTtBQUliejVCLFlBQU1xdEMsVUFBVXJ0QztBQUpILE1BQWQ7O0FBT0E7QUFDQTs7QUFFRDBOO0FBQ0E7O0FBRUQsVUFBTzAvQixXQUFQO0FBQ0EsR0FuR2tDOzs7QUFxR25DOzs7Ozs7Ozs7QUFTQUUsYUE5R21DLHVCQThHdkJDLFVBOUd1QixFQThHWDtBQUN2QixPQUFNejBDLFNBQVN5MEMsV0FBV3owQyxNQUExQjs7QUFFQSxPQUFNME0sUUFBUTFNLE9BQU9vRCxZQUFQLEdBQXNCbUosU0FBdEIsR0FBa0MsQ0FBbEMsQ0FBZDs7QUFFQUcsU0FBTXcyQixZQUFOLENBQW1Cd1IsT0FBbkIsQ0FBMkJELFdBQVc5VCxJQUF0QztBQUNBM2dDLFVBQU9nTyxXQUFQLENBQW1CeW1DLFdBQVd2dEMsSUFBOUI7O0FBRUEsT0FBTTNGLFdBQVd2QixPQUFPdUIsUUFBUCxFQUFqQjs7QUFFQTtBQUNBO0FBQ0FBLFlBQVMwcEMsY0FBVCxDQUNDMXBDLFFBREQsRUFFQyxTQUZELEVBR0MsS0FBS3V5Qyx5QkFITixFQUlDLElBSkQsRUFLQztBQUNDOXpDLGtCQUREO0FBRUNnMEMsWUFBUVMsV0FBV1Q7QUFGcEIsSUFMRCxFQVNDLENBVEQ7QUFXQSxHQXJJa0M7OztBQXVJbkM7Ozs7Ozs7Ozs7QUFVQWxCLFlBakptQyxzQkFpSnhCanZDLEtBakp3QixFQWlKakI7QUFDakIsT0FBTXlNLGNBQWN6TSxNQUFNRSxJQUFOLENBQVdULENBQS9COztBQUVBLE9BQUlnTixZQUFZc0gsT0FBWixLQUF3QjQ1QixTQUE1QixFQUF1QztBQUN0QyxRQUFNaUQsYUFBYSxLQUFLUixjQUFMLENBQ2xCcHdDLE1BQU1TLFlBQU4sQ0FBbUJ0RSxNQURELENBQW5COztBQUlBLFFBQUl5MEMsVUFBSixFQUFnQjtBQUNmNXdDLFdBQU1FLElBQU4sQ0FBV00sY0FBWDtBQUNBLFVBQUttd0MsV0FBTCxDQUFpQkMsVUFBakI7QUFDQTtBQUNEO0FBQ0Q7QUE5SmtDLEVBQXBDO0FBZ0tBLEM7Ozs7Ozs7Ozs7Ozs7O0FDM0xEOzs7OztBQUtBOzs7Ozs7OztBQVFBLElBQUksQ0FBQ3gwQyxTQUFTcW5CLE9BQVQsQ0FBaUJ4bkIsR0FBakIsQ0FBcUIsZUFBckIsQ0FBTCxFQUE0QztBQUMzQyxLQUFNbXVDLGdCQUFnQjtBQUNyQjBHLFFBQU0sQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0IsRUFBcUMsSUFBckMsRUFBMkMsSUFBM0MsQ0FEZTtBQUVyQnZoQyxVQUFRLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLEVBQStCLElBQS9CLENBRmE7QUFHckJ3aEMsU0FBTyxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixDQUhjO0FBSXJCMWtDLFNBQU8sQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0I7QUFKYyxFQUF0Qjs7QUFPQSxLQUFNZytCLHNCQUFzQjtBQUMzQkMsSUFEMkIsY0FDeEJDLE1BRHdCLEVBQ2hCcitCLElBRGdCLEVBQ1ZFLEdBRFUsRUFDTG8rQixHQURLLEVBQ0E7QUFDMUJDLG1CQUFnQkYsTUFBaEIsRUFBd0IsQ0FBQyxDQUFELEdBQUtyK0IsSUFBN0IsRUFBbUNzK0IsSUFBSWo3QixNQUFKLEdBQWEsQ0FBYixHQUFpQm5ELEdBQXBEO0FBQ0EsR0FIMEI7QUFJM0I0a0MsSUFKMkIsY0FJeEJ6RyxNQUp3QixFQUloQnIrQixJQUpnQixFQUlWRSxHQUpVLEVBSUxvK0IsR0FKSyxFQUlBO0FBQzFCQyxtQkFDQ0YsTUFERCxFQUVDdDlCLEtBQUsyOUIsS0FBTCxDQUFXSixJQUFJbitCLEtBQUosR0FBWSxDQUF2QixJQUE0QixDQUE1QixHQUFnQ0gsSUFGakMsRUFHQ3MrQixJQUFJajdCLE1BQUosR0FBYSxDQUFiLEdBQWlCbkQsR0FIbEI7QUFLQSxHQVYwQjtBQVczQnMrQixJQVgyQixjQVd4QkgsTUFYd0IsRUFXaEJyK0IsSUFYZ0IsRUFXVkUsR0FYVSxFQVdMbytCLEdBWEssRUFXQTtBQUMxQkMsbUJBQWdCRixNQUFoQixFQUF3QkMsSUFBSW4rQixLQUFKLEdBQVksQ0FBWixHQUFnQkgsSUFBeEMsRUFBOENzK0IsSUFBSWo3QixNQUFKLEdBQWEsQ0FBYixHQUFpQm5ELEdBQS9EO0FBQ0EsR0FiMEI7QUFjM0I2a0MsSUFkMkIsY0FjeEIxRyxNQWR3QixFQWNoQnIrQixJQWRnQixFQWNWRSxHQWRVLEVBY0xvK0IsR0FkSyxFQWNBO0FBQzFCQyxtQkFDQ0YsTUFERCxFQUVDLENBQUMsQ0FBRCxHQUFLcitCLElBRk4sRUFHQ2UsS0FBSzI5QixLQUFMLENBQVdKLElBQUlqN0IsTUFBSixHQUFhLENBQXhCLElBQTZCLENBQTdCLEdBQWlDbkQsR0FIbEM7QUFLQSxHQXBCMEI7QUFxQjNCeStCLElBckIyQixjQXFCeEJOLE1BckJ3QixFQXFCaEJyK0IsSUFyQmdCLEVBcUJWRSxHQXJCVSxFQXFCTDArQixJQXJCSyxFQXFCQztBQUMzQkwsbUJBQWdCRixNQUFoQixFQUF3QnIrQixPQUFPLENBQS9CLEVBQWtDRSxNQUFNLENBQXhDO0FBQ0EsR0F2QjBCO0FBd0IzQjhrQyxJQXhCMkIsY0F3QnhCM0csTUF4QndCLEVBd0JoQnIrQixJQXhCZ0IsRUF3QlZFLEdBeEJVLEVBd0JMbytCLEdBeEJLLEVBd0JBO0FBQzFCQyxtQkFDQ0YsTUFERCxFQUVDdDlCLEtBQUsyOUIsS0FBTCxDQUFXSixJQUFJbitCLEtBQUosR0FBWSxDQUF2QixJQUE0QixDQUE1QixHQUFnQ0gsSUFGakMsRUFHQyxDQUFDLENBQUQsR0FBS0UsR0FITjtBQUtBLEdBOUIwQjtBQStCM0IrMUIsSUEvQjJCLGNBK0J4Qm9JLE1BL0J3QixFQStCaEJyK0IsSUEvQmdCLEVBK0JWRSxHQS9CVSxFQStCTG8rQixHQS9CSyxFQStCQTtBQUMxQkMsbUJBQWdCRixNQUFoQixFQUF3QkMsSUFBSW4rQixLQUFKLEdBQVksQ0FBWixHQUFnQkgsSUFBeEMsRUFBOEMsQ0FBQyxDQUFELEdBQUtFLEdBQW5EO0FBQ0EsR0FqQzBCO0FBa0MzQnUrQixJQWxDMkIsY0FrQ3hCSixNQWxDd0IsRUFrQ2hCcitCLElBbENnQixFQWtDVkUsR0FsQ1UsRUFrQ0xvK0IsR0FsQ0ssRUFrQ0E7QUFDMUJDLG1CQUNDRixNQURELEVBRUNDLElBQUluK0IsS0FBSixHQUFZLENBQVosR0FBZ0JILElBRmpCLEVBR0NlLEtBQUsyOUIsS0FBTCxDQUFXSixJQUFJajdCLE1BQUosR0FBYSxDQUF4QixJQUE2QixDQUE3QixHQUFpQ25ELEdBSGxDO0FBS0E7QUF4QzBCLEVBQTVCOztBQTJDQSxLQUFNK2tDLHFCQUFxQixDQUEzQjs7QUFFQSxLQUFNQyxZQUFZLG1CQUFtQjV4QyxTQUFTNnhDLGVBQVQsQ0FBeUJybUMsS0FBOUQ7O0FBRUEsS0FBTXNtQyxXQUFXLHNCQUFzQjl4QyxTQUFTNnhDLGVBQVQsQ0FBeUJybUMsS0FBaEU7O0FBRUEsS0FBTXVtQyxlQUFlRCxZQUFZRixTQUFqQzs7QUFFQSxLQUFJRyxZQUFKLEVBQWtCO0FBQ2pCO0FBQ0FuMUMsV0FBU28xQyxNQUFULENBQ0MsMGdDQUREO0FBR0E7O0FBRUQ7OztBQUdBcDFDLFVBQVNxbkIsT0FBVCxDQUFpQnZmLEdBQWpCLENBQXFCLGVBQXJCLEVBQXNDO0FBQ3JDdXRDLFFBRHFDLG9CQUM1QjtBQUNSLE9BQUksQ0FBQ0YsWUFBTCxFQUFtQjtBQUNsQjtBQUNBO0FBQ0QsR0FMb0M7QUFNckN4VyxNQU5xQyxnQkFNaEM1K0IsTUFOZ0MsRUFNeEI7QUFDWixPQUFJLENBQUNvMUMsWUFBTCxFQUFtQjtBQUNsQjtBQUNBOztBQUVEcDFDLFVBQU9xQixJQUFQLENBQVksWUFBWixFQUEwQixnQkFBUTtBQUNqQ3U5QixVQUFLNStCLE1BQUw7QUFDQSxJQUZEO0FBR0E7QUFkb0MsRUFBdEM7O0FBaUJBLFVBQVM0K0IsS0FBVCxDQUFjNStCLE1BQWQsRUFBc0I7QUFDckIsTUFBTW1ELFNBQVNuRCxPQUFPbUQsTUFBUCxDQUFjRyxDQUE3Qjs7QUFFQSxNQUFNRCxXQUFXckQsT0FBT3FELFFBQVAsQ0FBZ0JDLENBQWpDOztBQUVBLE1BQUkyeEMsU0FBSixFQUFlO0FBQ2Q7QUFDQTV4QyxZQUFTMkssV0FBVCxDQUFxQixzQkFBckIsRUFBNkMsS0FBN0MsRUFBb0QsS0FBcEQ7QUFDQTs7QUFFRCxNQUFNdW5DLGFBQ0wsT0FBT1Asa0JBQVAsS0FBOEIsV0FBOUIsR0FDRyxJQURILEdBRUdBLGtCQUhKOztBQUtBaDFDLFNBQU9ULE1BQVAsQ0FBY2kyQyxnQkFBZCxHQUNDeDFDLE9BQU9ULE1BQVAsQ0FBY2kyQyxnQkFBZCxJQUFrQyxNQURuQzs7QUFHQSxNQUFNQyxVQUFVLElBQUl4RyxPQUFKLENBQVlqdkMsTUFBWixFQUFvQjtBQUNuQ3cxQyxxQkFBa0J4MUMsT0FBT1QsTUFBUCxDQUFjaTJDLGdCQURHO0FBRW5DRDtBQUZtQyxHQUFwQixDQUFoQjs7QUFLQSxNQUFNRyxvQkFBb0IsU0FBcEJBLGlCQUFvQixDQUFTQyxDQUFULEVBQVk7QUFDckMsT0FBSUYsUUFBUUcsUUFBUixDQUFpQkQsRUFBRTF3QyxNQUFuQixDQUFKLEVBQWdDO0FBQy9Cd3dDLFlBQVFJLFFBQVIsQ0FBaUJGLENBQWpCO0FBQ0E7QUFDRCxHQUpEOztBQU1BdHlDLFdBQVNvYSxnQkFBVCxDQUEwQixXQUExQixFQUF1Q2k0QixpQkFBdkMsRUFBMEQsS0FBMUQ7O0FBRUEsV0FBU3RpQixlQUFULEdBQTJCO0FBQzFCLE9BQU03dkIsWUFBWXZELE9BQU9vRCxZQUFQLEVBQWxCOztBQUVBLE9BQUksQ0FBQ0csU0FBTCxFQUFnQjtBQUNoQjtBQUNBLE9BQ0NBLFVBQVVnaEMsT0FBVixPQUF3QnRrQyxTQUFTdWtDLGNBQWpDLElBQ0FqaEMsVUFBVTJWLGVBQVYsR0FBNEIrbkIsRUFBNUIsQ0FBK0IsS0FBL0IsQ0FGRCxFQUdFO0FBQ0Q7QUFDQSxRQUNDLENBQUM5OUIsT0FBT1UsS0FBUixJQUNBLENBQUNWLE9BQU9VLEtBQVAsQ0FBYXNRLE1BRGQsSUFFQWhSLE9BQU9VLEtBQVAsQ0FBYXNRLE1BQWIsS0FBd0IsQ0FIekIsRUFJRTtBQUNEc2hDLGFBQVF4Z0IsSUFBUixDQUFhMXhCLFVBQVUyVixlQUFWLEdBQTRCNVYsQ0FBekM7QUFDQTtBQUNELElBWkQsTUFZTztBQUNObXlDLFlBQVFoWSxJQUFSO0FBQ0E7QUFDRDs7QUFFRHo5QixTQUFPMkQsRUFBUCxDQUFVLGlCQUFWLEVBQTZCeXZCLGVBQTdCOztBQUVBcHpCLFNBQU8yRCxFQUFQLENBQVUsU0FBVixFQUFxQixhQUFLO0FBQ3pCLE9BQUlteUMsT0FBT0gsRUFBRTV4QyxJQUFGLENBQU9ndUMsU0FBUCxJQUFvQixFQUEvQjtBQUNBK0QsVUFBT0EsS0FBSzEwQyxPQUFMLENBQWEsc0NBQWIsRUFBcUQsRUFBckQsQ0FBUDtBQUNBMDBDLFVBQU9BLEtBQUsxMEMsT0FBTCxDQUFhLGlCQUFiLEVBQWdDLEVBQWhDLENBQVA7QUFDQXUwQyxLQUFFNXhDLElBQUYsQ0FBT2d1QyxTQUFQLEdBQW1CK0QsSUFBbkI7QUFDQSxHQUxEOztBQU9BOTFDLFNBQU8yRCxFQUFQLENBQVUsaUJBQVYsRUFBNkIsWUFBTTtBQUNsQztBQUNBOHhDLFdBQVFoWSxJQUFSO0FBQ0EsR0FIRDs7QUFLQXo5QixTQUFPMkQsRUFBUCxDQUFVLGdCQUFWLEVBQTRCLFlBQU07QUFDakM7QUFDQXl2QjtBQUNBLEdBSEQ7O0FBS0FwekIsU0FBTzJELEVBQVAsQ0FBVSxNQUFWLEVBQWtCLFlBQU07QUFDdkI7QUFDQTh4QyxXQUFRaFksSUFBUjtBQUNBLEdBSEQ7O0FBS0F6OUIsU0FBTzJELEVBQVAsQ0FBVSxrQkFBVixFQUE4QixTQUFTb3lDLElBQVQsR0FBZ0I7QUFDN0MvMUMsVUFBT2tyQyxjQUFQLENBQXNCLGtCQUF0QixFQUEwQzZLLElBQTFDO0FBQ0FOLFdBQVFoWSxJQUFSO0FBQ0EsR0FIRDs7QUFLQXo5QixTQUFPMkQsRUFBUCxDQUFVLFNBQVYsRUFBcUIsWUFBTTtBQUMxQixPQUFNcXlDLGdCQUFnQjN5QyxTQUFTNkMsY0FBVCxDQUF3QixVQUF4QixDQUF0Qjs7QUFFQSxPQUFJOHZDLGFBQUosRUFBbUI7QUFDbEJBLGtCQUFjN29DLE1BQWQ7QUFDQTs7QUFFRCxPQUFJOG5DLFNBQUosRUFBZTtBQUNkNXhDLGFBQVMySyxXQUFULENBQXFCLHNCQUFyQixFQUE2QyxLQUE3QyxFQUFvRCxJQUFwRDtBQUNBOztBQUVEM0ssWUFBUzZ6QixtQkFBVCxDQUE2QixXQUE3QixFQUEwQ3dlLGlCQUExQztBQUNBLEdBWkQ7O0FBY0E7QUFDQSxNQUFJTyxzQkFBSjtBQUNBajJDLFNBQU9tRCxNQUFQLENBQWNRLEVBQWQsQ0FBaUIsUUFBakIsRUFBMkIsWUFBTTtBQUNoQztBQUNBMGhCLGdCQUFhNHdCLGFBQWI7QUFDQTtBQUNBQSxtQkFBZ0Joc0MsV0FBV21wQixlQUFYLEVBQTRCLEVBQTVCLENBQWhCO0FBQ0EsR0FMRDtBQU1BOztBQUVELFVBQVM2YixPQUFULENBQWlCanZDLE1BQWpCLEVBQXlCMlUsR0FBekIsRUFBOEI7QUFDN0IsT0FBSzNVLE1BQUwsR0FBY0EsTUFBZDtBQUNBLE9BQUttRCxNQUFMLEdBQWNuRCxPQUFPbUQsTUFBUCxDQUFjRyxDQUE1QjtBQUNBLE9BQUtELFFBQUwsR0FBZ0JyRCxPQUFPcUQsUUFBUCxDQUFnQkMsQ0FBaEM7QUFDQSxPQUFLcVIsR0FBTCxHQUFXQSxPQUFPLEVBQWxCO0FBQ0EsT0FBS2lxQixJQUFMO0FBQ0E7O0FBRURxUSxTQUFRejJCLFNBQVIsR0FBb0I7QUFDbkJvbUIsTUFEbUIsa0JBQ1o7QUFDTixPQUFNaGxCLFdBQVcsSUFBakI7O0FBRUEsT0FBTXMxQixZQUFhLEtBQUtBLFNBQUwsR0FBaUIsS0FBSzdyQyxRQUFMLENBQWNrQyxhQUFkLENBQ25DLEtBRG1DLENBQXBDOztBQUlBMnBDLGFBQVVsb0MsRUFBVixHQUFlLFVBQWY7QUFDQSxRQUFLdzNCLE9BQUwsR0FBZSxLQUFLbjdCLFFBQUwsQ0FBY2tDLGFBQWQsQ0FBNEIsTUFBNUIsQ0FBZjtBQUNBMnBDLGFBQVV2cEMsV0FBVixDQUFzQixLQUFLNjRCLE9BQTNCOztBQUVBLE9BQU0yUSxVQUFXLEtBQUtBLE9BQUwsR0FBZSxFQUFoQzs7QUFFQWxCLGlCQUFjLEtBQUt0NUIsR0FBTCxDQUFTNmdDLGdCQUF2QixFQUF5Qy84QixPQUF6QyxDQUFpRCxzQkFBYztBQUM5RDAyQixZQUFRRSxVQUFSLElBQXNCejFCLFNBQVN1MUIsT0FBVCxDQUNyQkUsVUFEcUIsSUFFbEJ6MUIsU0FBUzAxQixZQUFULENBQXNCRCxVQUF0QixDQUZKO0FBR0EsSUFKRDs7QUFNQSxRQUFLLElBQU02RyxDQUFYLElBQWdCL0csT0FBaEIsRUFBeUI7QUFDeEIsUUFBSXp0QyxPQUFPOFcsU0FBUCxDQUFpQnNrQixjQUFqQixDQUFnQ3A5QixJQUFoQyxDQUFxQ3l2QyxPQUFyQyxFQUE4QytHLENBQTlDLENBQUosRUFBc0Q7QUFDckRoSCxlQUFVdnBDLFdBQVYsQ0FBc0J3cEMsUUFBUStHLENBQVIsQ0FBdEI7QUFDQTtBQUNEO0FBQ0QsR0F6QmtCO0FBMEJuQjVHLGNBMUJtQix3QkEwQk5waEMsSUExQk0sRUEwQkE7QUFDbEIsT0FBTWdQLEtBQUssS0FBSzdaLFFBQUwsQ0FBY2tDLGFBQWQsQ0FBNEIsR0FBNUIsQ0FBWDtBQUNBMlgsTUFBR213QixTQUFILENBQWF0bEMsR0FBYixDQUFpQm1HLElBQWpCO0FBQ0EsVUFBT2dQLEVBQVA7QUFDQSxHQTlCa0I7QUErQm5CMDRCLFVBL0JtQixvQkErQlYxNEIsRUEvQlUsRUErQk47QUFDWixPQUFNaXlCLFVBQVUsS0FBS0EsT0FBckI7QUFDQSxRQUFLLElBQU0rRyxDQUFYLElBQWdCL0csT0FBaEIsRUFBeUI7QUFDeEIsUUFBSUEsUUFBUStHLENBQVIsTUFBZWg1QixFQUFuQixFQUF1QjtBQUN0QixZQUFPLElBQVA7QUFDQTtBQUNEO0FBQ0QsVUFBTyxLQUFQO0FBQ0EsR0F2Q2tCO0FBd0NuQitYLE1BeENtQixnQkF3Q2QvWCxFQXhDYyxFQXdDVjtBQUNSLE9BQUl6WCxTQUFTLEtBQUt6RixNQUFMLENBQVlULE1BQVosQ0FBbUJrRyxNQUFoQzs7QUFFQSxPQUFNZ04sWUFBWWhOLFNBQVNBLE9BQU9nTixTQUFoQixHQUE0QixDQUE5Qzs7QUFFQSxRQUFLeUssRUFBTCxHQUFVQSxFQUFWO0FBQ0EsT0FBSSxLQUFLdkksR0FBTCxDQUFTNGdDLFVBQWIsRUFBeUI7QUFDeEIsU0FBS1ksV0FBTCxHQUFtQkMsUUFDbEIsS0FBSy95QyxRQUFMLENBQWNtRyxvQkFBZCxDQUFtQyxLQUFuQyxDQURrQixDQUFuQjtBQUdBLFNBQUsyc0MsV0FBTCxDQUFpQkUsTUFBakIsQ0FBd0IsS0FBS0YsV0FBTCxDQUFpQnZzQyxPQUFqQixDQUF5QnNULEVBQXpCLENBQXhCLEVBQXNELENBQXREO0FBQ0E7QUFDRCxPQUFNbXhCLE1BQU8sS0FBS0EsR0FBTCxHQUFXTyxlQUFlLEtBQUt6ckMsTUFBcEIsRUFBNEIrWixFQUE1QixDQUF4QjtBQUNBb3hCLG1CQUFnQixLQUFLWSxTQUFyQixFQUFnQ2IsSUFBSXQrQixJQUFwQyxFQUEwQ3MrQixJQUFJcCtCLEdBQUosR0FBVXdDLFNBQXBEOztBQUVBaE4sWUFBU0EsVUFBVXBDLFNBQVNxQyxJQUE1Qjs7QUFFQUQsVUFBT0UsV0FBUCxDQUFtQixLQUFLdXBDLFNBQXhCOztBQUVBLFFBQUtoeUIsRUFBTCxDQUFRbXdCLFNBQVIsQ0FBa0J0bEMsR0FBbEIsQ0FBc0IsVUFBdEI7QUFDQSxRQUFLd25DLFdBQUw7QUFDQSxHQTdEa0I7QUE4RG5COVIsTUE5RG1CLGtCQThEWjtBQUNOO0FBQ0EsT0FBTStSLFdBQVcsS0FBS25zQyxRQUFMLENBQWNvc0Msc0JBQWQsQ0FBcUMsVUFBckMsQ0FBakI7QUFDQSxRQUFLLElBQUk3dEMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNHRDLFNBQVMzdEMsTUFBN0IsRUFBcUMsRUFBRUQsQ0FBdkMsRUFBMEM7QUFDekM0dEMsYUFBUzV0QyxDQUFULEVBQVl5ckMsU0FBWixDQUFzQmxnQyxNQUF0QixDQUE2QixVQUE3QjtBQUNBO0FBQ0QsUUFBS3VpQyxXQUFMO0FBQ0EsT0FBSSxLQUFLUixTQUFMLENBQWV0c0MsVUFBbkIsRUFBK0I7QUFDOUIsU0FBS3NzQyxTQUFMLENBQWV0c0MsVUFBZixDQUEwQkMsV0FBMUIsQ0FBc0MsS0FBS3FzQyxTQUEzQztBQUNBO0FBQ0QsR0F4RWtCO0FBeUVuQjJHLFVBekVtQixvQkF5RVZGLENBekVVLEVBeUVQO0FBQ1gsT0FBSUEsRUFBRXhoQyxNQUFGLEtBQWEsQ0FBakIsRUFBb0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0QsT0FBTXNoQyxVQUFVLElBQWhCO0FBQ0EsT0FBTTlGLE9BQU8sSUFBSTlDLFNBQUosQ0FBYyxLQUFLMXBDLE1BQW5CLEVBQTJCLEtBQUtFLFFBQWhDLENBQWI7QUFDQXNzQyxRQUFLckMsT0FBTCxHQUFlLFlBQVc7QUFDekJtSSxZQUFRN0YsV0FBUjtBQUNBNkYsWUFBUTVGLFVBQVIsR0FBcUIsSUFBckI7QUFDQTRGLFlBQVF6MUMsTUFBUixDQUFlb0QsWUFBZixHQUE4Qm1LLElBQTlCO0FBQ0EsSUFKRDtBQUtBb2lDLFFBQUsvQixNQUFMLEdBQWMsWUFBVztBQUN4QjZILFlBQVEzRixhQUFSLENBQXNCLElBQXRCO0FBQ0EyRixZQUFRekYsYUFBUjtBQUNBLFFBQU0zQixNQUFNb0gsUUFBUXJHLFVBQXBCO0FBQ0FxRyxZQUFReEYsYUFBUixDQUFzQjVCLEdBQXRCLEVBQTJCQSxJQUFJdCtCLElBQS9CLEVBQXFDcytCLElBQUlwK0IsR0FBekM7QUFDQSxJQUxEO0FBTUEwL0IsUUFBSzNCLFNBQUwsR0FBaUIsWUFBVztBQUMzQnlILFlBQVE1RixVQUFSLEdBQXFCLEtBQXJCO0FBQ0E0RixZQUFRdkYsV0FBUjtBQUNBdUYsWUFBUWhZLElBQVI7QUFDQWdZLFlBQVF6MUMsTUFBUixDQUFlb0QsWUFBZixHQUE4QnFLLE1BQTlCO0FBQ0E7QUFDQWdvQyxZQUFRejFDLE1BQVIsQ0FBZXVFLElBQWYsQ0FBb0IsY0FBcEI7QUFDQSxJQVBEO0FBUUFvckMsUUFBSzVCLFVBQUwsR0FBa0IsWUFBVztBQUM1QjBILFlBQVF0RixjQUFSO0FBQ0E7QUFDQXNGLFlBQVF6MUMsTUFBUixDQUFldUUsSUFBZixDQUFvQixjQUFwQjtBQUNBLElBSkQ7QUFLQW9yQyxRQUFLdk0sS0FBTCxDQUFXdVMsQ0FBWDtBQUNBLEdBekdrQjtBQTBHbkIxRixlQTFHbUIseUJBMEdMNUIsR0ExR0ssRUEwR0F0K0IsSUExR0EsRUEwR01FLEdBMUdOLEVBMEdXO0FBQzdCRixVQUFPQSxRQUFRLENBQWY7QUFDQUUsU0FBTUEsT0FBTyxDQUFiO0FBQ0EsT0FBTWsvQixVQUFVLEtBQUtBLE9BQXJCOztBQUVBLFFBQUssSUFBTWYsTUFBWCxJQUFxQmUsT0FBckIsRUFBOEI7QUFDN0IsUUFBSXp0QyxPQUFPOFcsU0FBUCxDQUFpQnNrQixjQUFqQixDQUFnQ3A5QixJQUFoQyxDQUFxQ3l2QyxPQUFyQyxFQUE4Q2YsTUFBOUMsQ0FBSixFQUEyRDtBQUMxREYseUJBQW9CRSxNQUFwQixFQUNDZSxRQUFRZixNQUFSLENBREQsRUFFQ3IrQixJQUZELEVBR0NFLEdBSEQsRUFJQ28rQixHQUpEO0FBTUE7QUFDRDtBQUNELEdBekhrQjtBQTBIbkJrQixhQTFIbUIseUJBMEhMO0FBQ2IsT0FBTUosVUFBVSxLQUFLQSxPQUFyQjtBQUNBLFFBQUtjLGFBQUwsQ0FBbUIsS0FBSzVCLEdBQXhCO0FBQ0EsUUFBSyxJQUFNNkgsQ0FBWCxJQUFnQi9HLE9BQWhCLEVBQXlCO0FBQ3hCLFFBQUl6dEMsT0FBTzhXLFNBQVAsQ0FBaUJza0IsY0FBakIsQ0FBZ0NwOUIsSUFBaEMsQ0FBcUN5dkMsT0FBckMsRUFBOEMrRyxDQUE5QyxDQUFKLEVBQXNEO0FBQ3JEL0csYUFBUStHLENBQVIsRUFBV3JuQyxLQUFYLENBQWlCNlYsT0FBakIsR0FBMkIsT0FBM0I7QUFDQTtBQUNEO0FBQ0QsR0FsSWtCO0FBbUluQmdyQixhQW5JbUIseUJBbUlMO0FBQ2IsT0FBTVAsVUFBVSxLQUFLQSxPQUFyQjtBQUNBLFFBQUssSUFBTStHLENBQVgsSUFBZ0IvRyxPQUFoQixFQUF5QjtBQUN4QixRQUFJenRDLE9BQU84VyxTQUFQLENBQWlCc2tCLGNBQWpCLENBQWdDcDlCLElBQWhDLENBQXFDeXZDLE9BQXJDLEVBQThDK0csQ0FBOUMsQ0FBSixFQUFzRDtBQUNyRC9HLGFBQVErRyxDQUFSLEVBQVdybkMsS0FBWCxDQUFpQjZWLE9BQWpCLEdBQTJCLE1BQTNCO0FBQ0E7QUFDRDtBQUNELEdBMUlrQjtBQTJJbkJrckIsYUEzSW1CLHlCQTJJTDtBQUNiLFFBQUtwUixPQUFMLENBQWEzdkIsS0FBYixDQUFtQjByQixlQUFuQixHQUFxQyxVQUFVLEtBQUtyZCxFQUFMLENBQVF4VCxHQUFsQixHQUF3QixJQUE3RDtBQUNBLFFBQUtvbUMsYUFBTDtBQUNBLFFBQUtFLGFBQUw7QUFDQSxRQUFLeFIsT0FBTCxDQUFhM3ZCLEtBQWIsQ0FBbUI2VixPQUFuQixHQUE2QixPQUE3QjtBQUNBLEdBaEprQjtBQWlKbkJzckIsZUFqSm1CLDJCQWlKSDtBQUNmLE9BQU0zQixNQUFNLEtBQUtlLFVBQWpCO0FBQ0FkLG1CQUFnQixLQUFLOVAsT0FBckIsRUFBOEI2UCxJQUFJdCtCLElBQWxDLEVBQXdDcytCLElBQUlwK0IsR0FBNUM7QUFDQSxRQUFLdXVCLE9BQUwsQ0FBYTN2QixLQUFiLENBQW1CcUIsS0FBbkIsR0FBMkIsS0FBS2svQixVQUFMLENBQWdCbC9CLEtBQWhCLEdBQXdCLElBQW5EO0FBQ0EsUUFBS3N1QixPQUFMLENBQWEzdkIsS0FBYixDQUFtQnVFLE1BQW5CLEdBQTRCLEtBQUtnOEIsVUFBTCxDQUFnQmg4QixNQUFoQixHQUF5QixJQUFyRDtBQUNBLEdBdEprQjtBQXVKbkI4OEIsYUF2Sm1CLHlCQXVKTDtBQUNiLE9BQU03QixNQUFNTyxlQUFlLEtBQUt6ckMsTUFBcEIsRUFBNEIsS0FBS3E3QixPQUFqQyxDQUFaO0FBQ0EsUUFBS25hLE1BQUwsR0FBYztBQUNiblUsV0FBT20rQixJQUFJbitCLEtBREU7QUFFYmtELFlBQVFpN0IsSUFBSWo3QjtBQUZDLElBQWQ7QUFJQSxRQUFLb3JCLE9BQUwsQ0FBYTN2QixLQUFiLENBQW1CNlYsT0FBbkIsR0FBNkIsTUFBN0I7QUFDQSxHQTlKa0I7QUErSm5Cb3JCLGVBL0ptQix5QkErSkwvckMsSUEvSkssRUErSkM7QUFDbkIsT0FBTXNxQyxNQUFPLEtBQUtlLFVBQUwsR0FBa0I7QUFDOUJuL0IsU0FBSyxDQUR5QjtBQUU5QkYsVUFBTSxDQUZ3QjtBQUc5QkcsV0FBTyxLQUFLbStCLEdBQUwsQ0FBU24rQixLQUhjO0FBSTlCa0QsWUFBUSxLQUFLaTdCLEdBQUwsQ0FBU2o3QjtBQUphLElBQS9COztBQU9BLE9BQUksQ0FBQ3JQLElBQUwsRUFBVzs7QUFFWCxPQUFNd2hDLE9BQU94aEMsS0FBS2tCLE1BQUwsQ0FBWU8sU0FBekI7O0FBRUEsT0FBSSxDQUFDKy9CLEtBQUszN0IsT0FBTCxDQUFhLEdBQWIsQ0FBTCxFQUF3QjtBQUN2QnlrQyxRQUFJbitCLEtBQUosR0FBWVksS0FBS0UsR0FBTCxDQUFTLEVBQVQsRUFBYSxLQUFLcTlCLEdBQUwsQ0FBU24rQixLQUFULEdBQWlCbk0sS0FBS3lwQyxLQUFMLENBQVcxOUIsQ0FBekMsQ0FBWjtBQUNBO0FBQ0QsT0FBSSxDQUFDeTFCLEtBQUszN0IsT0FBTCxDQUFhLEdBQWIsQ0FBTCxFQUF3QjtBQUN2QnlrQyxRQUFJajdCLE1BQUosR0FBYXRDLEtBQUtFLEdBQUwsQ0FBUyxFQUFULEVBQWEsS0FBS3E5QixHQUFMLENBQVNqN0IsTUFBVCxHQUFrQnJQLEtBQUt5cEMsS0FBTCxDQUFXeDlCLENBQTFDLENBQWI7QUFDQTtBQUNELE9BQUksQ0FBQ3UxQixLQUFLMzdCLE9BQUwsQ0FBYSxHQUFiLENBQUwsRUFBd0I7QUFDdkJ5a0MsUUFBSW4rQixLQUFKLEdBQVlZLEtBQUtFLEdBQUwsQ0FBUyxFQUFULEVBQWEsS0FBS3E5QixHQUFMLENBQVNuK0IsS0FBVCxHQUFpQm5NLEtBQUt5cEMsS0FBTCxDQUFXMTlCLENBQXpDLENBQVo7QUFDQTtBQUNELE9BQUksQ0FBQ3kxQixLQUFLMzdCLE9BQUwsQ0FBYSxHQUFiLENBQUwsRUFBd0I7QUFDdkJ5a0MsUUFBSWo3QixNQUFKLEdBQWF0QyxLQUFLRSxHQUFMLENBQVMsRUFBVCxFQUFhLEtBQUtxOUIsR0FBTCxDQUFTajdCLE1BQVQsR0FBa0JyUCxLQUFLeXBDLEtBQUwsQ0FBV3g5QixDQUExQyxDQUFiO0FBQ0E7QUFDRDtBQUNBLE9BQUl1MUIsS0FBSzM3QixPQUFMLENBQWEsR0FBYixJQUFvQixDQUFwQixJQUF5QixDQUFDN0YsS0FBS3BDLElBQUwsQ0FBVXNOLEtBQXhDLEVBQStDO0FBQzlDLFFBQU1taEMsUUFBUSxLQUFLL0IsR0FBTCxDQUFTbitCLEtBQVQsR0FBaUIsS0FBS20rQixHQUFMLENBQVNqN0IsTUFBeEM7QUFDQSxRQUFJaTdCLElBQUluK0IsS0FBSixHQUFZbStCLElBQUlqN0IsTUFBaEIsR0FBeUJnOUIsS0FBN0IsRUFBb0M7QUFDbkMvQixTQUFJajdCLE1BQUosR0FBYXRDLEtBQUsyOUIsS0FBTCxDQUFXSixJQUFJbitCLEtBQUosR0FBWWtnQyxLQUF2QixDQUFiO0FBQ0EsS0FGRCxNQUVPO0FBQ04vQixTQUFJbitCLEtBQUosR0FBWVksS0FBSzI5QixLQUFMLENBQVdKLElBQUlqN0IsTUFBSixHQUFhZzlCLEtBQXhCLENBQVo7QUFDQTtBQUNEOztBQUVELE9BQU1tRixhQUFhLEtBQUs1Z0MsR0FBTCxDQUFTNGdDLFVBQTVCOztBQUVBLE9BQUlBLFVBQUosRUFBZ0I7QUFDZixRQUFNZSxTQUFTLEtBQUtILFdBQXBCO0FBQ0EsU0FBSyxJQUFJdjBDLElBQUksQ0FBYixFQUFnQkEsSUFBSTAwQyxPQUFPejBDLE1BQTNCLEVBQW1DRCxHQUFuQyxFQUF3QztBQUN2QyxTQUFNMjBDLFFBQVEzSCxlQUFlLEtBQUt6ckMsTUFBcEIsRUFBNEJtekMsT0FBTzEwQyxDQUFQLENBQTVCLENBQWQ7QUFDQSxTQUNDa1AsS0FBS08sR0FBTCxDQUFTZzlCLElBQUluK0IsS0FBSixHQUFZcW1DLE1BQU1ybUMsS0FBM0IsS0FBcUNxbEMsVUFBckMsSUFDQXprQyxLQUFLTyxHQUFMLENBQVNnOUIsSUFBSWo3QixNQUFKLEdBQWFtakMsTUFBTW5qQyxNQUE1QixLQUF1Q21pQyxVQUZ4QyxFQUdFO0FBQ0RsSCxVQUFJbitCLEtBQUosR0FBWXFtQyxNQUFNcm1DLEtBQWxCO0FBQ0FtK0IsVUFBSWo3QixNQUFKLEdBQWFtakMsTUFBTW5qQyxNQUFuQjtBQUNBO0FBQ0E7QUFDRDtBQUNEOztBQUVEO0FBQ0EsT0FBSSxDQUFDbXlCLEtBQUszN0IsT0FBTCxDQUFhLEdBQWIsQ0FBTCxFQUF3QjtBQUN2QnlrQyxRQUFJdCtCLElBQUosR0FBVyxLQUFLcytCLEdBQUwsQ0FBU24rQixLQUFULEdBQWlCbStCLElBQUluK0IsS0FBaEM7QUFDQTtBQUNELE9BQUksQ0FBQ3ExQixLQUFLMzdCLE9BQUwsQ0FBYSxHQUFiLENBQUwsRUFBd0I7QUFDdkJ5a0MsUUFBSXArQixHQUFKLEdBQVUsS0FBS28rQixHQUFMLENBQVNqN0IsTUFBVCxHQUFrQmk3QixJQUFJajdCLE1BQWhDO0FBQ0E7QUFDRCxHQXpOa0I7QUEwTm5CKzhCLGdCQTFObUIsNEJBME5GO0FBQ2hCNkYsaUJBQWN0MkMsSUFBZCxDQUNDLElBREQsRUFFQyxLQUFLd2QsRUFGTixFQUdDLEtBQUttSCxNQUFMLENBQVluVSxLQUhiLEVBSUMsS0FBS21VLE1BQUwsQ0FBWWpSLE1BSmI7QUFNQTtBQWpPa0IsRUFBcEI7O0FBb09BLFVBQVN5NUIsU0FBVCxDQUFtQjFwQyxNQUFuQixFQUEyQkUsUUFBM0IsRUFBcUM7QUFDcEMsT0FBS0YsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsT0FBS0UsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxPQUFLeXBDLE1BQUwsR0FBYztBQUNiRSxjQUFXMXFDLEtBQUssS0FBSzBxQyxTQUFWLEVBQXFCLElBQXJCLENBREU7QUFFYkQsWUFBU3pxQyxLQUFLLEtBQUt5cUMsT0FBVixFQUFtQixJQUFuQixDQUZJO0FBR2JFLFlBQVMzcUMsS0FBSyxLQUFLMnFDLE9BQVYsRUFBbUIsSUFBbkI7QUFISSxHQUFkO0FBS0E7O0FBRURKLFdBQVVyMEIsU0FBVixHQUFzQjtBQUNyQjRxQixPQURxQixpQkFDZnVTLENBRGUsRUFDWjtBQUNSQSxLQUFFdHhDLGNBQUY7QUFDQXN4QyxLQUFFNStCLGVBQUY7QUFDQSxRQUFLOVIsTUFBTCxHQUFjMHdDLEVBQUUxd0MsTUFBaEI7QUFDQSxRQUFLc2dDLElBQUwsR0FBWW9RLEVBQUUxd0MsTUFBRixDQUFTTyxTQUFyQjtBQUNBLFFBQUswbkMsUUFBTCxHQUFnQjtBQUNmcDlCLE9BQUc2bEMsRUFBRXhJLE9BRFU7QUFFZm45QixPQUFHMmxDLEVBQUV2STtBQUZVLElBQWhCO0FBSUEsUUFBSzNsQixNQUFMLENBQVlrdUIsQ0FBWjtBQUNBLE9BQU03SSxTQUFTLEtBQUtBLE1BQXBCO0FBQ0EsUUFBS3pwQyxRQUFMLENBQWNvYSxnQkFBZCxDQUNDLFdBREQsRUFFQ3F2QixPQUFPRSxTQUZSLEVBR0MsS0FIRDtBQUtBLFFBQUszcEMsUUFBTCxDQUFjb2EsZ0JBQWQsQ0FBK0IsU0FBL0IsRUFBMENxdkIsT0FBT0MsT0FBakQsRUFBMEQsS0FBMUQ7QUFDQSxRQUFLMXBDLFFBQUwsQ0FBY29hLGdCQUFkLENBQStCLFNBQS9CLEVBQTBDcXZCLE9BQU9HLE9BQWpELEVBQTBELEtBQTFEO0FBQ0EsUUFBSzVwQyxRQUFMLENBQWNxQyxJQUFkLENBQW1CMm5DLFNBQW5CLENBQTZCdGxDLEdBQTdCLENBQWlDLGNBQWMsS0FBS3c5QixJQUFwRDtBQUNBLE9BQUksS0FBSytILE9BQVQsRUFBa0I7QUFDakIsU0FBS0EsT0FBTDtBQUNBO0FBQ0QsR0F2Qm9CO0FBd0JyQjdsQixRQXhCcUIsa0JBd0Jka3VCLENBeEJjLEVBd0JYO0FBQ1QsUUFBS3BJLFVBQUwsR0FBa0I7QUFDakJ6OUIsT0FBRzZsQyxFQUFFeEksT0FEWTtBQUVqQm45QixPQUFHMmxDLEVBQUV2STtBQUZZLElBQWxCO0FBSUEsUUFBS0ksS0FBTCxHQUFhO0FBQ1oxOUIsT0FBRzZsQyxFQUFFeEksT0FBRixHQUFZLEtBQUtELFFBQUwsQ0FBY3A5QixDQURqQjtBQUVaRSxPQUFHMmxDLEVBQUV2SSxPQUFGLEdBQVksS0FBS0YsUUFBTCxDQUFjbDlCO0FBRmpCLElBQWI7QUFJQSxRQUFLck8sSUFBTCxHQUFZO0FBQ1hzTixXQUFPMG1DLEVBQUVoSSxRQURFO0FBRVhELFVBQU1pSSxFQUFFMXhDLE9BRkc7QUFHWHdwQyxTQUFLa0ksRUFBRXBlO0FBSEksSUFBWjtBQUtBLEdBdENvQjtBQXVDckJ5VixXQXZDcUIscUJBdUNYMkksQ0F2Q1csRUF1Q1I7QUFDWixRQUFLbHVCLE1BQUwsQ0FBWWt1QixDQUFaO0FBQ0EsT0FBSSxLQUFLL0gsTUFBVCxFQUFpQjtBQUNoQixTQUFLQSxNQUFMO0FBQ0E7QUFDRCxPQUFJK0gsRUFBRTlILEtBQUYsS0FBWSxDQUFoQixFQUFtQjtBQUNsQjtBQUNBLFNBQUtaLE9BQUwsQ0FBYTBJLENBQWI7QUFDQTtBQUNELEdBaERvQjtBQWlEckI1SSxTQWpEcUIsbUJBaURiNEksQ0FqRGEsRUFpRFY7QUFDVjtBQUNBLE9BQUlBLEVBQUUvOUIsT0FBRixLQUFjLEVBQWxCLEVBQXNCO0FBQ3JCLFNBQUtrMkIsT0FBTDtBQUNBO0FBQ0QsR0F0RG9CO0FBdURyQmIsU0F2RHFCLG1CQXVEYjBJLENBdkRhLEVBdURWO0FBQ1YsUUFBS2x1QixNQUFMLENBQVlrdUIsQ0FBWjtBQUNBLFFBQUs3SCxPQUFMO0FBQ0EsT0FBSSxLQUFLQyxVQUFULEVBQXFCO0FBQ3BCLFNBQUtBLFVBQUw7QUFDQTtBQUNELEdBN0RvQjtBQThEckJELFNBOURxQixxQkE4RFg7QUFDVCxRQUFLenFDLFFBQUwsQ0FBY3FDLElBQWQsQ0FBbUIybkMsU0FBbkIsQ0FBNkJsZ0MsTUFBN0IsQ0FBb0MsY0FBYyxLQUFLbzRCLElBQXZEO0FBQ0EsT0FBTXVILFNBQVMsS0FBS0EsTUFBcEI7QUFDQSxRQUFLenBDLFFBQUwsQ0FBYzZ6QixtQkFBZCxDQUNDLFdBREQsRUFFQzRWLE9BQU9FLFNBRlIsRUFHQyxLQUhEO0FBS0EsUUFBSzNwQyxRQUFMLENBQWM2ekIsbUJBQWQsQ0FBa0MsU0FBbEMsRUFBNkM0VixPQUFPQyxPQUFwRCxFQUE2RCxLQUE3RDtBQUNBLFFBQUsxcEMsUUFBTCxDQUFjNnpCLG1CQUFkLENBQWtDLFNBQWxDLEVBQTZDNFYsT0FBT0csT0FBcEQsRUFBNkQsS0FBN0Q7QUFDQSxPQUFJLEtBQUtlLFNBQVQsRUFBb0I7QUFDbkIsU0FBS0EsU0FBTDtBQUNBO0FBQ0Q7QUEzRW9CLEVBQXRCOztBQThFQTtBQUNBLFVBQVNvSSxPQUFULENBQWlCbGhDLEdBQWpCLEVBQXNCO0FBQ3JCLE1BQU1zaEMsTUFBTXRoQyxJQUFJclQsTUFBaEI7O0FBRUEsTUFBTXFxQyxNQUFNLElBQUk5M0IsS0FBSixDQUFVb2lDLEdBQVYsQ0FBWjtBQUNBLE9BQUssSUFBSTUwQyxJQUFJLENBQWIsRUFBZ0JBLElBQUk0MEMsR0FBcEIsRUFBeUI1MEMsR0FBekIsRUFBOEI7QUFDN0JzcUMsT0FBSXRxQyxDQUFKLElBQVNzVCxJQUFJdFQsQ0FBSixDQUFUO0FBQ0E7QUFDRCxTQUFPc3FDLEdBQVA7QUFDQTs7QUFFRCxVQUFTNXBDLElBQVQsQ0FBYzhMLEVBQWQsRUFBa0Jxb0MsR0FBbEIsRUFBdUI7QUFDdEIsTUFBSXJvQyxHQUFHOUwsSUFBUCxFQUFhO0FBQ1osVUFBTzhMLEdBQUc5TCxJQUFILENBQVFtMEMsR0FBUixDQUFQO0FBQ0E7QUFDRCxTQUFPLFlBQWtCO0FBQUEscUNBQU5oWCxJQUFNO0FBQU5BLFFBQU07QUFBQTs7QUFDeEJyeEIsTUFBRzBZLEtBQUgsQ0FBUzJ2QixHQUFULEVBQWNoWCxJQUFkO0FBQ0EsR0FGRDtBQUdBOztBQUVELFVBQVM2TyxlQUFULENBQXlCcHhCLEVBQXpCLEVBQTZCbk4sSUFBN0IsRUFBbUNFLEdBQW5DLEVBQXdDO0FBQ3ZDaU4sS0FBR3JPLEtBQUgsQ0FBU2tCLElBQVQsR0FBZ0IybUMsT0FBTzNtQyxJQUFQLElBQWUsSUFBL0I7QUFDQW1OLEtBQUdyTyxLQUFILENBQVNvQixHQUFULEdBQWV5bUMsT0FBT3ptQyxHQUFQLElBQWMsSUFBN0I7QUFDQTs7QUFFRCxVQUFTK2xDLGFBQVQsQ0FBdUI5NEIsRUFBdkIsRUFBMkJoTixLQUEzQixFQUFrQ2tELE1BQWxDLEVBQTBDO0FBQ3pDLE1BQU1vaUMsbUJBQW1CLEtBQUt4MUMsTUFBTCxDQUFZVCxNQUFaLENBQW1CaTJDLGdCQUE1QztBQUNBLE1BQUlBLHFCQUFxQixNQUF6QixFQUFpQztBQUNoQ3Q0QixNQUFHbmQsWUFBSCxDQUFnQixPQUFoQixFQUF5QjIyQyxPQUFPeG1DLEtBQVAsQ0FBekI7QUFDQWdOLE1BQUdyTyxLQUFILENBQVNxQixLQUFULEdBQWlCd21DLE9BQU94bUMsS0FBUCxJQUFnQixJQUFqQztBQUNBZ04sTUFBR25kLFlBQUgsQ0FBZ0IsUUFBaEIsRUFBMEIyMkMsT0FBT3RqQyxNQUFQLENBQTFCO0FBQ0E4SixNQUFHck8sS0FBSCxDQUFTdUUsTUFBVCxHQUFrQnNqQyxPQUFPdGpDLE1BQVAsSUFBaUIsSUFBbkM7QUFDQSxHQUxELE1BS08sSUFDTm9pQyxxQkFBcUIsT0FBckIsSUFDQUEscUJBQXFCLE9BRmYsRUFHTDtBQUNEdDRCLE1BQUc0ckIsZUFBSCxDQUFtQixRQUFuQjtBQUNBNXJCLE1BQUdyTyxLQUFILENBQVN1RSxNQUFULEdBQWtCLE1BQWxCO0FBQ0E4SixNQUFHbmQsWUFBSCxDQUFnQixPQUFoQixFQUF5QjIyQyxPQUFPeG1DLEtBQVAsQ0FBekI7QUFDQWdOLE1BQUdyTyxLQUFILENBQVNxQixLQUFULEdBQWlCd21DLE9BQU94bUMsS0FBUCxJQUFnQixJQUFqQztBQUNBLEdBUk0sTUFRQSxJQUFJc2xDLHFCQUFxQixRQUF6QixFQUFtQztBQUN6Q3Q0QixNQUFHbmQsWUFBSCxDQUFnQixRQUFoQixFQUEwQjIyQyxPQUFPdGpDLE1BQVAsQ0FBMUI7QUFDQThKLE1BQUdyTyxLQUFILENBQVN1RSxNQUFULEdBQWtCc2pDLE9BQU90akMsTUFBUCxJQUFpQixJQUFuQztBQUNBOEosTUFBRzRyQixlQUFILENBQW1CLE9BQW5CO0FBQ0E1ckIsTUFBR3JPLEtBQUgsQ0FBU3FCLEtBQVQsR0FBaUIsTUFBakI7QUFDQTtBQUNEOztBQUVELFVBQVMwK0IsY0FBVCxDQUF3QnpyQyxNQUF4QixFQUFnQytaLEVBQWhDLEVBQW9DO0FBQ25DLE1BQU0yeEIsT0FBTzN4QixHQUFHNHhCLHFCQUFILEVBQWI7QUFDQSxTQUFPO0FBQ04vK0IsU0FBTTgrQixLQUFLOStCLElBQUwsR0FBWTVNLE9BQU80ckMsV0FEbkI7QUFFTjkrQixRQUFLNCtCLEtBQUs1K0IsR0FBTCxHQUFXOU0sT0FBTzZyQyxXQUZqQjtBQUdOOStCLFVBQU8yK0IsS0FBSzMrQixLQUhOO0FBSU5rRCxXQUFReTdCLEtBQUt6N0I7QUFKUCxHQUFQO0FBTUE7QUFDRCxDOzs7Ozs7Ozs7Ozs7OztBQzFrQkQ7Ozs7O0FBS0E7Ozs7QUFJQSxJQUFJLENBQUNuVCxTQUFTcW5CLE9BQVQsQ0FBaUJ4bkIsR0FBakIsQ0FBcUIsa0JBQXJCLENBQUwsRUFBK0M7QUFDOUMsS0FBTTYyQyxnQkFBZ0I7QUFDckJDLFVBQVEsQ0FEYTtBQUVyQjdtQyxRQUFNLENBRmU7QUFHckJvQixTQUFPO0FBSGMsRUFBdEI7O0FBTUE7Ozs7QUFJQSxLQUFNMGxDLFNBQVM7QUFDZGxDLFFBQU0sYUFEUTtBQUVkdmhDLFVBQVEsV0FGTTtBQUdkd2hDLFNBQU8sYUFITztBQUlkMWtDLFNBQU87QUFKTyxFQUFmOztBQU9BLEtBQU00bUMsZUFBZSxpQkFBckI7O0FBRUEsS0FBTTNnQixXQUFXLHVCQUFqQjs7QUFFQWwyQixVQUFTcW5CLE9BQVQsQ0FBaUJ2ZixHQUFqQixDQUFxQixrQkFBckIsRUFBeUM7QUFDeENndkMsU0FBTyxJQURpQzs7QUFHeENDLFNBQU8sT0FIaUM7O0FBS3hDcFksTUFMd0MsZ0JBS25DNStCLE1BTG1DLEVBSzNCO0FBQ1osT0FBTWlhLFFBQVFnOUIsVUFBVWozQyxNQUFWLENBQWQ7O0FBRUE7QUFDQUEsVUFBT2szQyxPQUFQLENBQWVudkMsR0FBZixDQUFtQixPQUFuQixFQUE0QmtTLEtBQTVCO0FBQ0EsR0FWdUM7QUFZeENxN0IsUUFad0Msb0JBWS9CO0FBQ1JyMUMsWUFBU28xQyxNQUFULENBQ0Msb0NBQ0Msc0JBREQsR0FFQyxHQUZELEdBR0MsK0JBSEQsR0FJQyxvQkFKRCxHQUtDLEdBTEQsR0FNQyxpQ0FORCxHQU9DLHNCQVBELEdBUUMsR0FSRCxHQVNDLCtCQVRELEdBVUMsb0JBVkQsR0FXQyxHQVhELEdBWUMsdUJBWkQ7QUFhQztBQUNBO0FBQ0Esa0JBZkQsR0FnQkMsR0FoQkQsR0FpQkMscUJBakJELEdBa0JDLGVBbEJELEdBbUJDLG9CQW5CRCxHQW9CQyxhQXBCRCxHQXFCQyxjQXJCRCxHQXNCQyxjQXRCRCxHQXVCQyxhQXZCRCxHQXdCQyxrQkF4QkQsR0F5QkMseUJBekJEO0FBMEJDO0FBQ0EsbUJBM0JELEdBNEJDLHFCQTVCRCxHQTZCQyxHQTdCRCxHQThCQyw2QkE5QkQsR0ErQkMsb0JBL0JELEdBZ0NDLHVCQWhDRCxHQWlDQyxnQkFqQ0QsR0FrQ0MsR0FsQ0QsR0FtQ0MsK0NBbkNELEdBb0NDLHdDQXBDRCxHQXFDQyxlQXJDRCxHQXNDQyxHQXZDRjtBQXlDQSxHQXREdUM7OztBQXdEeEN6YSxZQUFVO0FBeEQ4QixFQUF6Qzs7QUEyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVNxYyxTQUFULENBQW1CajNDLE1BQW5CLEVBQTJCO0FBQzFCQSxTQUFPVCxNQUFQLENBQWNpMkMsZ0JBQWQsR0FDQ3gxQyxPQUFPVCxNQUFQLENBQWNpMkMsZ0JBQWQsSUFBa0MsTUFEbkM7O0FBR0F4MUMsU0FBTzJELEVBQVAsQ0FBVSxVQUFWLEVBQXNCLHFCQUFhO0FBQ2xDM0QsVUFBT2szQyxPQUFQLENBQWVDLE1BQWYsQ0FBc0I1eUIsVUFBVXhnQixJQUFWLENBQWVtWixFQUFyQyxFQUF5QyxPQUF6QztBQUNBLEdBRkQ7O0FBSUEsTUFBTWs2QixlQUFlcDNDLE9BQU9ULE1BQVAsQ0FBYzgzQyxtQkFBbkM7O0FBRUEsTUFBTUMsaUJBQWlCdDNDLE9BQU9ULE1BQVAsQ0FBY2c0QyxxQkFBckM7O0FBRUEsU0FBTztBQUNOM1ksT0FETSxrQkFDQztBQUNOLFFBQU00WSxVQUFVdjNDLFNBQVNxbkIsT0FBVCxDQUFpQm13QixNQUFqQzs7QUFFQSxRQUFNeDlCLFFBQVEsS0FBSzFQLEtBQUwsQ0FBVzBQLEtBQXpCOztBQUVBLFFBQU1sVyxPQUFPO0FBQ1owcEMsVUFBS3h6QixNQUFNdEIsWUFBTixDQUFtQixLQUFuQixLQUE2QixFQUR0QjtBQUVaKytCLGlCQUFZLENBQUMsQ0FBQyxLQUFLbnRDLEtBQUwsQ0FBV290QyxPQUZiO0FBR1p2a0MsYUFBUTZHLE1BQU10QixZQUFOLENBQW1CLFFBQW5CLEtBQWdDLEVBSDVCO0FBSVo7QUFDQXBMLFdBQU0sS0FBS3FxQyxLQUFMLEdBQ0hKLFFBQVFLLG9CQUFSLENBQTZCNTlCLEtBQTdCLENBREcsR0FFSCxJQVBTO0FBUVp2USxVQUFLdVEsTUFBTXRCLFlBQU4sQ0FBbUIsS0FBbkIsQ0FSTztBQVNaekksWUFBTytKLE1BQU10QixZQUFOLENBQW1CLE9BQW5CLEtBQStCO0FBVDFCLEtBQWI7O0FBWUE7QUFDQTtBQUNBO0FBQ0EsUUFBTS9ULE9BQU9xVixNQUFNOEcsWUFBTixDQUFtQixHQUFuQixDQUFiOztBQUVBLFFBQUluYyxRQUFRLEtBQUtrekMsT0FBTCxDQUFhcmdCLFFBQWIsQ0FBc0I3eUIsSUFBdEIsQ0FBWixFQUF5QztBQUN4QyxVQUFLMkYsS0FBTCxDQUFXM0YsSUFBWCxHQUFrQkEsSUFBbEI7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUksQ0FBQ2IsS0FBS2cwQyxLQUFWLEVBQWlCO0FBQ2hCLFNBQU1DLGVBQWVqMEMsS0FBSzJ6QyxVQUFMLEdBQWtCLEtBQUs1eEMsT0FBdkIsR0FBaUNtVSxLQUF0RDs7QUFFQTtBQUNBLFNBQUltOUIsWUFBSixFQUFrQjtBQUNqQixVQUFJWSxhQUFhOWxDLFFBQWIsQ0FBc0JrbEMsYUFBYSxDQUFiLENBQXRCLENBQUosRUFBNEM7QUFDM0NyekMsWUFBS2cwQyxLQUFMLEdBQWEsTUFBYjtBQUNBLE9BRkQsTUFFTyxJQUFJQyxhQUFhOWxDLFFBQWIsQ0FBc0JrbEMsYUFBYSxDQUFiLENBQXRCLENBQUosRUFBNEM7QUFDbERyekMsWUFBS2cwQyxLQUFMLEdBQWEsT0FBYjtBQUNBOztBQUVELFVBQUloMEMsS0FBS2cwQyxLQUFULEVBQWdCO0FBQ2ZDLG9CQUFhajFDLFdBQWIsQ0FDQ3EwQyxhQUFhVCxjQUFjNXlDLEtBQUtnMEMsS0FBbkIsQ0FBYixDQUREO0FBR0EsT0FKRCxNQUlPO0FBQ05oMEMsWUFBS2cwQyxLQUFMLEdBQWEsTUFBYjtBQUNBO0FBQ0Q7QUFDRDtBQWZBLFVBZ0JLO0FBQ0poMEMsWUFBS2cwQyxLQUFMLEdBQWFDLGFBQWExcUMsUUFBYixDQUFzQixPQUF0QixLQUFrQyxNQUEvQztBQUNBMHFDLG9CQUFheHFDLFdBQWIsQ0FBeUIsT0FBekI7QUFDQTtBQUNEOztBQUVEO0FBQ0E7QUFDQSxTQUFLc3FDLE9BQUwsQ0FBYSxDQUFDL3pDLEtBQUsyekMsVUFBTCxHQUFrQixRQUFsQixHQUE2QixLQUE5QixJQUF1QyxPQUFwRCxFQUNDLHFCQUREOztBQUlBLFNBQUtPLE9BQUwsQ0FBYWwwQyxJQUFiOztBQUVBLFFBQUkvRCxPQUFPVCxNQUFQLENBQWMyNEMscUJBQWQsS0FBd0MsSUFBNUMsRUFBa0Q7QUFDakRDLGtCQUFhLElBQWI7QUFDQTtBQUNELElBcEVLOzs7QUFzRU47QUFDQTtBQUNBbDJDLFdBeEVNLG9CQXdFR3VELFNBeEVILEVBd0VjO0FBQ25CNHlDLHdCQUFvQixJQUFwQixFQUEwQm4yQyxRQUExQixDQUFtQ3VELFNBQW5DO0FBQ0EsSUExRUs7OztBQTRFTnJGLG1CQUFnQms0Qyx3QkFBd0JyNEMsTUFBeEIsQ0E1RVY7O0FBOEVOO0FBQ0FzNEMsMkJBQXdCLENBQUMsQ0FBQyw2QkFBRCxDQUFELENBL0VsQjs7QUFpRk52MEMsT0FqRk0sa0JBaUZDO0FBQ04sUUFBTXcwQyxXQUFXLEtBQUtBLFFBQXRCOztBQUVBO0FBQ0EsUUFDQyxLQUFLeDBDLElBQUwsQ0FBVTJ6QyxVQUFWLElBQ0EsQ0FBQzEzQyxPQUFPeVUsTUFBUCxDQUFjK2pDLFlBQWQsQ0FBMkJELFNBQVNaLE9BQXBDLENBRkYsRUFHRTtBQUNELFVBQUs1ekMsSUFBTCxDQUFVMnpDLFVBQVYsR0FBdUIsS0FBdkI7QUFDQTs7QUFFRDtBQUNBLFFBQ0MsS0FBSzN6QyxJQUFMLENBQVVnMEMsS0FBVixJQUFtQixNQUFuQixJQUNBLENBQUMvM0MsT0FBT3lVLE1BQVAsQ0FBYytqQyxZQUFkLENBQTJCRCxTQUFTUixLQUFwQyxDQUZGLEVBR0U7QUFDRCxVQUFLaDBDLElBQUwsQ0FBVWcwQyxLQUFWLEdBQWtCLE1BQWxCO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBLFFBQUksQ0FBQyxLQUFLaDBDLElBQUwsQ0FBVWEsSUFBZixFQUFxQjtBQUNwQixTQUFJLEtBQUsyRixLQUFMLENBQVczRixJQUFmLEVBQXFCO0FBQ3BCLGFBQU8sS0FBSzJGLEtBQUwsQ0FBVzNGLElBQWxCO0FBQ0E7QUFDRCxLQUpELE1BSU87QUFDTixTQUFJLENBQUMsS0FBSzJGLEtBQUwsQ0FBVzNGLElBQWhCLEVBQXNCO0FBQ3JCLFdBQUsyRixLQUFMLENBQVczRixJQUFYLEdBQWtCLEtBQUsyRixLQUFMLENBQVcwUCxLQUFYLENBQWlCbXRCLFNBQWpCLEVBQWxCO0FBQ0E7QUFDRDs7QUFFRCxTQUFLNzhCLEtBQUwsQ0FBVzBQLEtBQVgsQ0FBaUJ5bkIsYUFBakIsQ0FBK0I7QUFDOUIrTCxVQUFLLEtBQUsxcEMsSUFBTCxDQUFVMHBDLEdBRGU7O0FBRzlCZ0wsc0JBQWlCLEtBQUtsdUMsS0FBTCxDQUFXMFAsS0FBWCxDQUFpQnRCLFlBQWpCLENBQ2hCLGlCQURnQixJQUdkLEtBQUtwTyxLQUFMLENBQVcwUCxLQUFYLENBQWlCdEIsWUFBakIsQ0FBOEIsaUJBQTlCLENBSGMsR0FJZCxJQVAyQjs7QUFTOUI7QUFDQSwyQkFBc0IsS0FBSzVVLElBQUwsQ0FBVTJGLEdBVkY7O0FBWTlCQSxVQUFLLEtBQUszRixJQUFMLENBQVUyRjtBQVplLEtBQS9COztBQWVBO0FBQ0E7QUFDQSxRQUNDLEtBQUtndkMsT0FBTCxJQUNBLENBQUMsS0FBS0EsT0FBTCxDQUFhaEIsVUFEZCxJQUVBLEtBQUszekMsSUFBTCxDQUFVMnpDLFVBSFgsRUFJRTtBQUNELFVBQUssSUFBTWlCLENBQVgsSUFBZ0IsS0FBSzUwQyxJQUFMLENBQVU2MEMsT0FBMUIsRUFBbUM7QUFDbEMsVUFDQ2wzQyxPQUFPOFcsU0FBUCxDQUFpQnNrQixjQUFqQixDQUFnQ3A5QixJQUFoQyxDQUNDLEtBQUtxRSxJQUFMLENBQVU2MEMsT0FEWCxFQUVDRCxDQUZELENBREQsRUFLRTtBQUNELFlBQUtwdUMsS0FBTCxDQUFXMFAsS0FBWCxDQUFpQmxYLFdBQWpCLENBQTZCNDFDLENBQTdCO0FBQ0E7QUFDRDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxRQUFJMzRDLE9BQU95VSxNQUFQLENBQWMrakMsWUFBZCxDQUEyQkQsU0FBU00sU0FBcEMsQ0FBSixFQUFvRDtBQUNuREMsbUJBQWMsSUFBZDtBQUNBOztBQUVEO0FBQ0EsU0FBS0osT0FBTCxHQUFlejRDLFNBQVN5TyxLQUFULENBQWU1QyxNQUFmLENBQXNCLEVBQXRCLEVBQTBCLEtBQUsvSCxJQUEvQixDQUFmO0FBQ0EsSUExSks7OztBQTRKTmcxQyxhQUFVQyxzQkFBc0JoNUMsTUFBdEIsQ0E1Sko7O0FBOEpOaTVDLGNBQVcsS0E5Skw7O0FBZ0tOO0FBQ0FDLGNBQVc7QUFDVnZCLGFBQVM7QUFDUndCLGVBQVUsWUFERjtBQUVSaDVDLHFCQUFnQjtBQUZSO0FBREMsSUFqS0w7O0FBd0tObzRDLGFBQVVhLGtCQUFrQnA1QyxNQUFsQixDQXhLSjs7QUEwS047QUFDQTtBQUNBcTVDLGVBQWEsWUFBVztBQUN2QixRQUFNQyxhQUFhLElBQUl0SCxNQUFKLENBQ2xCLE9BQ0MsR0FBR3htQyxNQUFILENBQVU4ckMsY0FBVixFQUEwQkYsWUFBMUIsRUFBd0NuZ0IsSUFBeEMsQ0FBNkMsR0FBN0MsQ0FERCxHQUVDLElBSGlCLENBQW5COztBQU1BLFdBQU8sWUFBVztBQUNqQixTQUFNMmhCLFVBQVUsS0FBS1csVUFBTCxDQUFnQkMsbUJBQWhCLENBQ2ZwQixvQkFBb0IsSUFBcEIsRUFBMEJ6L0IsWUFBMUIsQ0FBdUMsT0FBdkMsQ0FEZSxDQUFoQjs7QUFJQTtBQUNBO0FBQ0EsVUFBSyxJQUFNZ2dDLENBQVgsSUFBZ0JDLE9BQWhCLEVBQXlCO0FBQ3hCLFVBQUlVLFdBQVdudUMsSUFBWCxDQUFnQnd0QyxDQUFoQixDQUFKLEVBQXdCO0FBQ3ZCLGNBQU9DLFFBQVFELENBQVIsQ0FBUDtBQUNBO0FBQ0Q7O0FBRUQsWUFBT0MsT0FBUDtBQUNBLEtBZEQ7QUFlQSxJQXRCVyxFQTVLTjs7QUFvTU5hLFdBcE1NLHNCQW9NSztBQUNWLFFBQU05OUIsUUFBUSxDQUFDLEtBQUs1WCxJQUFMLENBQVUwcEMsR0FBVixJQUFpQixFQUFsQixJQUF3QixHQUF4QixHQUE4QixLQUFLaU0sUUFBakQ7O0FBRUEsV0FBTy85QixLQUFQO0FBQ0EsSUF4TUs7OztBQTBNTjtBQUNBO0FBQ0F6SixXQTVNTSxvQkE0TUcxTSxTQTVNSCxFQTRNYztBQUNuQixXQUFPNHlDLG9CQUFvQixJQUFwQixFQUEwQmxtQyxRQUExQixDQUFtQzFNLFNBQW5DLENBQVA7QUFDQSxJQTlNSzs7O0FBZ05OK0UsVUFBTztBQUNOb3RDLGFBQVMsWUFESDtBQUVOMTlCLFdBQU87QUFGRCxJQWhORDs7QUFxTk47QUFDQTtBQUNBbFgsY0F2Tk0sdUJBdU5NeUMsU0F2Tk4sRUF1TmlCO0FBQ3RCNHlDLHdCQUFvQixJQUFwQixFQUEwQnIxQyxXQUExQixDQUFzQ3lDLFNBQXRDO0FBQ0EsSUF6Tks7OztBQTJOTm0wQyxvQkFBaUIsY0EzTlg7O0FBNk5OQyxzQkFBbUIsWUE3TmI7O0FBK05OO0FBQ0F6akIscUJBaE9NOztBQWtPTjBqQixXQUFRQyxvQkFBb0I5NUMsTUFBcEI7QUFsT0YsR0FBUDtBQW9PQTs7QUFFRDs7Ozs7O0FBTUFDLFVBQVNxbkIsT0FBVCxDQUFpQm13QixNQUFqQixHQUEwQjtBQUN6Qjs7Ozs7OztBQU9BSSxzQkFSeUIsZ0NBUUo1OUIsS0FSSSxFQVFHO0FBQzNCLE9BQU0zVyxJQUFJMlcsTUFBTTNXLENBQWhCOztBQUVBLE9BQU15MkMsVUFBVSxLQUFLQyxVQUFMLENBQWdCLy9CLEtBQWhCLENBQWhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFDQ25KLEtBQUsyOUIsS0FBTCxDQUFZbnJDLEVBQUV1USxXQUFGLEdBQWdCa21DLFFBQVE3cEMsS0FBekIsR0FBa0M2cEMsUUFBUTNtQyxNQUFyRCxLQUNDOVAsRUFBRTIyQyxZQURILElBRUFucEMsS0FBSzI5QixLQUFMLENBQVluckMsRUFBRTIyQyxZQUFGLEdBQWlCRixRQUFRM21DLE1BQTFCLEdBQW9DMm1DLFFBQVE3cEMsS0FBdkQsS0FDQzVNLEVBQUV1USxXQUpKO0FBTUEsR0F2QndCOzs7QUF5QnpCOzs7Ozs7OztBQVFBbW1DLFlBakN5QixzQkFpQ2QvL0IsS0FqQ2MsRUFpQ1A7QUFDakIsT0FBSWlnQyxtQkFBSjs7QUFFQSxPQUFJamdDLE1BQU0zVyxDQUFOLENBQVE2MkMsWUFBWixFQUEwQjtBQUN6QkQsaUJBQWE7QUFDWjltQyxhQUFRNkcsTUFBTTNXLENBQU4sQ0FBUTgyQyxZQURKO0FBRVpscUMsWUFBTytKLE1BQU0zVyxDQUFOLENBQVE2MkM7QUFGSCxLQUFiO0FBSUEsSUFMRCxNQUtPO0FBQ04sUUFBTUUsTUFBTSxJQUFJQyxLQUFKLEVBQVo7O0FBRUFELFFBQUkzd0MsR0FBSixHQUFVdVEsTUFBTXRCLFlBQU4sQ0FBbUIsS0FBbkIsQ0FBVjs7QUFFQXVoQyxpQkFBYTtBQUNaOW1DLGFBQVFpbkMsSUFBSUUsS0FEQTtBQUVacnFDLFlBQU9tcUMsSUFBSW5xQztBQUZDLEtBQWI7QUFJQTs7QUFFRCxVQUFPZ3FDLFVBQVA7QUFDQTtBQXJEd0IsRUFBMUI7O0FBd0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTSixtQkFBVCxDQUE2Qjk1QyxNQUE3QixFQUFxQztBQUNwQyxNQUFNdzZDLGtCQUFrQkMscUJBQXFCejZDLE1BQXJCLENBQXhCOztBQUVBLE1BQU1zM0MsaUJBQWlCdDNDLE9BQU9ULE1BQVAsQ0FBY2c0QyxxQkFBckM7O0FBRUE7QUFDQTtBQUNBLFNBQU8sVUFBU3I2QixFQUFULEVBQWFuWixJQUFiLEVBQW1CO0FBQ3pCLE9BQU1tMkMsYUFBYTtBQUNsQjltQyxZQUFRLENBRFU7QUFFbEJsRCxXQUFPO0FBRlcsSUFBbkI7O0FBS0EsT0FBTWhDLE9BQU9nUCxHQUFHaFAsSUFBaEI7O0FBRUEsT0FBSStMLGNBQUo7O0FBRUE7QUFDQSxPQUFJaUQsR0FBR25ZLFVBQUgsQ0FBYyxzQkFBZCxDQUFKLEVBQTJDO0FBQzFDO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBSXkxQyxnQkFBZ0J0OUIsRUFBaEIsQ0FBSixFQUF5QjtBQUN4QixRQUFJaFAsUUFBUSxLQUFaLEVBQW1CO0FBQ2xCLFNBQU13c0MsU0FBU3g5QixHQUFHeXJCLFFBQUgsQ0FBWSxRQUFaLENBQWY7O0FBRUE7QUFDQSxTQUFJK1IsTUFBSixFQUFZO0FBQ1h4OUIsU0FBR3k5QixXQUFILENBQWVELE1BQWY7QUFDQXg5QixXQUFLdzlCLE1BQUw7QUFDQTtBQUNEO0FBQ0Q7O0FBRUE7QUFDQTMyQyxTQUFLZzBDLEtBQUwsR0FBYSxRQUFiOztBQUVBO0FBQ0E5OUIsWUFBUWlELEdBQUd5ckIsUUFBSCxDQUFZLEtBQVosS0FBc0J6ckIsR0FBR3lyQixRQUFILENBQVksR0FBWixFQUFpQkEsUUFBakIsQ0FBMEIsS0FBMUIsQ0FBOUI7QUFDQTs7QUFFRDtBQW5CQSxRQW9CSyxJQUFJejZCLFFBQVEsUUFBUixJQUFvQmdQLEdBQUdoTCxRQUFILENBQVlvbEMsY0FBWixDQUF4QixFQUFxRDtBQUN6RHI5QixhQUFRaUQsR0FBR3lyQixRQUFILENBQVksS0FBWixLQUFzQnpyQixHQUFHeXJCLFFBQUgsQ0FBWSxHQUFaLEVBQWlCQSxRQUFqQixDQUEwQixLQUExQixDQUE5Qjs7QUFFQTtBQUNBLEtBSkksTUFJRSxJQUFJaVMsMEJBQTBCMTlCLEVBQTFCLENBQUosRUFBbUM7QUFDekNqRCxhQUFRaUQsR0FBR2hQLElBQUgsSUFBVyxHQUFYLEdBQWlCZ1AsR0FBR2dELFFBQUgsQ0FBWSxDQUFaLENBQWpCLEdBQWtDaEQsRUFBMUM7QUFDQTs7QUFFRCxPQUFJLENBQUNqRCxLQUFMLEVBQVk7QUFDWDtBQUNBOztBQUVEO0FBQ0E7QUFDQSxRQUFLLElBQU00Z0MsQ0FBWCxJQUFnQlgsVUFBaEIsRUFBNEI7QUFDM0IsUUFBSXg0QyxPQUFPOFcsU0FBUCxDQUFpQnNrQixjQUFqQixDQUFnQ3A5QixJQUFoQyxDQUFxQ3c2QyxVQUFyQyxFQUFpRFcsQ0FBakQsQ0FBSixFQUF5RDtBQUN4RCxTQUFNaEMsWUFBWTUrQixNQUFNbFYsVUFBTixDQUFpQjgxQyxDQUFqQixDQUFsQjs7QUFFQSxTQUFJaEMsYUFBYUEsVUFBVXB2QyxLQUFWLENBQWdCcXRDLFlBQWhCLENBQWpCLEVBQWdEO0FBQy9DLGFBQU83OEIsTUFBTWxWLFVBQU4sQ0FBaUI4MUMsQ0FBakIsQ0FBUDtBQUNBO0FBQ0Q7QUFDRDs7QUFFRCxVQUFPMzlCLEVBQVA7QUFDQSxHQXhFRDtBQXlFQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM4N0IscUJBQVQsQ0FBK0JoNUMsTUFBL0IsRUFBdUM7QUFDdEMsTUFBTW8zQyxlQUFlcDNDLE9BQU9ULE1BQVAsQ0FBYzgzQyxtQkFBbkM7O0FBRUE7QUFDQSxTQUFPLFVBQVNuNkIsRUFBVCxFQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFNNDlCLGNBQWM1OUIsR0FBR2hQLElBQUgsSUFBVyxHQUFYLEdBQWlCZ1AsR0FBR3lyQixRQUFILEVBQWpCLEdBQWlDenJCLEVBQXJEOztBQUVBLFVBQU80OUIsWUFBWS8xQyxVQUFaLENBQXVCMHpDLGVBQTlCOztBQUVBLE9BQU05b0MsUUFBUW1yQyxZQUFZLzFDLFVBQTFCOztBQUVBLE9BQU1nekMsUUFBUSxLQUFLaDBDLElBQUwsQ0FBVWcwQyxLQUF4Qjs7QUFFQTtBQUNBO0FBQ0EsT0FBSSxDQUFDLEtBQUs3M0MsTUFBVixFQUFrQjtBQUNqQixRQUFNNjZDLGdCQUFnQjc5QixHQUFHeXJCLFFBQUgsQ0FBWSxNQUFaLENBQXRCOztBQUVBLFFBQUlvUyxhQUFKLEVBQW1CO0FBQ2xCQSxtQkFBY0osV0FBZCxDQUNDSSxjQUFjcFMsUUFBZCxDQUF1QjtBQUN0Qjl2QixTQUFHLENBRG1CO0FBRXRCd2hDLFdBQUs7QUFGaUIsTUFBdkIsQ0FERDtBQU1BO0FBQ0Q7O0FBRUQsT0FBSXRDLFNBQVNBLFNBQVMsTUFBdEIsRUFBOEI7QUFDN0IsUUFBTTd2QyxTQUFTakksU0FBU3lPLEtBQVQsQ0FBZXNzQyxZQUFmLENBQTRCcnJDLE1BQU1kLEtBQU4sSUFBZSxFQUEzQyxDQUFmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUlrcEMsU0FBUyxRQUFULElBQXFCNzZCLEdBQUdoUCxJQUFILElBQVcsUUFBcEMsRUFBOEM7QUFDN0NnUCxVQUFLQSxHQUFHKzlCLFFBQUgsQ0FDSixJQUFJaDdDLFNBQVNpN0MsVUFBVCxDQUFvQnAxQyxPQUF4QixDQUNDLEtBREQsRUFFQ3N4QyxlQUNHO0FBQ0EzOEIsYUFBTzI4QixhQUFhLENBQWI7QUFEUCxNQURILEdBSUc7QUFDQXZvQyxhQUFPO0FBRFAsTUFOSixDQURJLENBQUw7QUFZQTs7QUFFRDtBQWZBLFNBZ0JLLElBQ0prcEMsU0FDQTtBQUNDaG9DLFlBQU0sQ0FEUDtBQUVDb0IsYUFBTztBQUZSLE1BRkksRUFNSDtBQUNELFVBQUlpbUMsWUFBSixFQUFrQjtBQUNqQjBELG1CQUFZNzRDLFFBQVosQ0FDQ20xQyxhQUFhVCxjQUFjb0IsS0FBZCxDQUFiLENBREQ7QUFHQSxPQUpELE1BSU87QUFDTjd2QyxjQUFPLE9BQVAsSUFBa0I2dkMsS0FBbEI7QUFDQTtBQUNEOztBQUVEO0FBQ0EsUUFBSSxDQUFDWCxZQUFELElBQWlCLENBQUNuM0MsU0FBU3lPLEtBQVQsQ0FBZXlzQyxPQUFmLENBQXVCanpDLE1BQXZCLENBQXRCLEVBQXNEO0FBQ3JEeUgsV0FBTWQsS0FBTixHQUFjNU8sU0FBU3lPLEtBQVQsQ0FBZTBzQyxZQUFmLENBQTRCbHpDLE1BQTVCLENBQWQ7QUFDQTtBQUNEOztBQUVELFVBQU9nVixFQUFQO0FBQ0EsR0FoRkQ7QUFpRkE7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTdTlCLG9CQUFULENBQThCejZDLE1BQTlCLEVBQXNDO0FBQ3JDLE1BQU1zM0MsaUJBQWlCdDNDLE9BQU9ULE1BQVAsQ0FBY2c0QyxxQkFBckM7O0FBRUEsTUFBTUgsZUFBZXAzQyxPQUFPVCxNQUFQLENBQWM4M0MsbUJBQW5DOztBQUVBLE1BQU1nRSxnQkFBZ0I7QUFDckJ4aUMsTUFBRyxDQURrQjtBQUVyQjZoQyxXQUFRLENBRmE7QUFHckJMLFFBQUs7QUFIZ0IsR0FBdEI7O0FBTUEsU0FBTyxVQUFTbjlCLEVBQVQsRUFBYTtBQUNuQjtBQUNBLE9BQ0MsRUFDQ0EsR0FBR2hQLElBQUgsSUFDQTtBQUNDb3RDLFNBQUssQ0FETjtBQUVDQyxPQUFHO0FBRkosSUFGRCxDQURELEVBUUU7QUFDRCxXQUFPLEtBQVA7QUFDQTs7QUFFRCxPQUFNcjdCLFdBQVdoRCxHQUFHZ0QsUUFBcEI7O0FBRUE7QUFDQSxPQUFJQSxTQUFTcmUsTUFBVCxLQUFvQixDQUF4QixFQUEyQjtBQUMxQixXQUFPLEtBQVA7QUFDQTs7QUFFRCxPQUFNMjVDLFFBQVF0N0IsU0FBUyxDQUFULENBQWQ7O0FBRUE7QUFDQTtBQUNBLE9BQUksRUFBRXM3QixNQUFNdHRDLElBQU4sSUFBY210QyxhQUFoQixDQUFKLEVBQW9DO0FBQ25DLFdBQU8sS0FBUDtBQUNBOztBQUVEO0FBQ0E7QUFDQSxPQUFJbitCLEdBQUdoUCxJQUFILElBQVcsR0FBZixFQUFvQjtBQUNuQixRQUFJLENBQUMwc0MsMEJBQTBCWSxLQUExQixDQUFMLEVBQXVDO0FBQ3RDLFlBQU8sS0FBUDtBQUNBO0FBQ0Q7QUFDRDtBQUxBLFFBTUs7QUFDSjtBQUNBO0FBQ0EsU0FBSUEsTUFBTXR0QyxJQUFOLElBQWMsUUFBbEIsRUFBNEI7QUFDM0IsVUFBSSxDQUFDc3RDLE1BQU10cEMsUUFBTixDQUFlb2xDLGNBQWYsQ0FBTCxFQUFxQztBQUNwQyxjQUFPLEtBQVA7QUFDQTtBQUNELE1BSkQsTUFJTztBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBSXQzQyxPQUFPeTdDLFNBQVAsSUFBb0J4N0MsU0FBU3k3QyxPQUFqQyxFQUEwQztBQUN6QyxjQUFPLEtBQVA7QUFDQTs7QUFFRDtBQUNBO0FBQ0EsVUFBSSxDQUFDZCwwQkFBMEJZLEtBQTFCLENBQUwsRUFBdUM7QUFDdEMsY0FBTyxLQUFQO0FBQ0E7QUFDRDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxPQUNDcEUsZUFDR2w2QixHQUFHaEwsUUFBSCxDQUFZa2xDLGFBQWEsQ0FBYixDQUFaLENBREgsR0FFR24zQyxTQUFTeU8sS0FBVCxDQUFlc3NDLFlBQWYsQ0FDQTk5QixHQUFHblksVUFBSCxDQUFjOEosS0FBZCxJQUF1QixFQUR2QixFQUVBLElBRkEsRUFHRSxZQUhGLEtBR21CLFFBTnZCLEVBT0U7QUFDRCxXQUFPLElBQVA7QUFDQTs7QUFFRCxVQUFPLEtBQVA7QUFDQSxHQTNFRDtBQTRFQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxVQUFTK3JDLHlCQUFULENBQW1DMTlCLEVBQW5DLEVBQXVDO0FBQ3RDLE1BQUlBLEdBQUdoUCxJQUFILElBQVcsS0FBZixFQUFzQjtBQUNyQixVQUFPLElBQVA7QUFDQSxHQUZELE1BRU8sSUFBSWdQLEdBQUdoUCxJQUFILElBQVcsR0FBZixFQUFvQjtBQUMxQixVQUFPZ1AsR0FBR2dELFFBQUgsQ0FBWXJlLE1BQVosSUFBc0IsQ0FBdEIsSUFBMkJxYixHQUFHeXJCLFFBQUgsQ0FBWSxLQUFaLENBQWxDO0FBQ0E7O0FBRUQsU0FBTyxLQUFQO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsVUFBU21RLGFBQVQsQ0FBdUI2QyxNQUF2QixFQUErQjtBQUM5QixNQUFNNTNDLE9BQU80M0MsT0FBTzUzQyxJQUFwQjs7QUFFQSxNQUFNbTJDLGFBQWE7QUFDbEI5bUMsV0FBUXJQLEtBQUtxUCxNQURLO0FBRWxCbEQsVUFBT25NLEtBQUttTTtBQUZNLEdBQW5COztBQUtBLE1BQU0rSixRQUFRMGhDLE9BQU9weEMsS0FBUCxDQUFhMFAsS0FBM0I7O0FBRUEsT0FBSyxJQUFNNGdDLENBQVgsSUFBZ0JYLFVBQWhCLEVBQTRCO0FBQzNCLE9BQUlBLFdBQVdXLENBQVgsQ0FBSixFQUFtQjtBQUNsQjVnQyxVQUFNbGEsWUFBTixDQUFtQjg2QyxDQUFuQixFQUFzQlgsV0FBV1csQ0FBWCxDQUF0QjtBQUNBLElBRkQsTUFFTztBQUNONWdDLFVBQU02dUIsZUFBTixDQUFzQitSLENBQXRCO0FBQ0E7QUFDRDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFVBQVMxQyxZQUFULENBQXNCd0QsTUFBdEIsRUFBOEI7QUFDN0IsTUFBTTM3QyxTQUFTMjdDLE9BQU8zN0MsTUFBdEI7O0FBRUEsTUFBTXVCLFdBQVd2QixPQUFPdUIsUUFBUCxFQUFqQjs7QUFFQSxNQUFNcTZDLE1BQU01N0MsT0FBT3FELFFBQW5COztBQUVBO0FBQ0EsTUFBTW95QyxVQUFXa0csT0FBT2xHLE9BQVAsR0FBaUJtRyxJQUFJcjJDLGFBQUosQ0FBa0IsTUFBbEIsQ0FBbEM7O0FBRUFrd0MsVUFBUXh6QyxRQUFSLENBQWlCLG1CQUFqQjtBQUNBd3pDLFVBQVF4ekMsUUFBUixDQUNDLHVCQUF1QjQwQyxPQUFPNzJDLE9BQU9ULE1BQVAsQ0FBY2kyQyxnQkFBckIsQ0FEeEI7QUFHQUMsVUFBUW5QLE1BQVIsQ0FBZSxJQUFJcm1DLFNBQVN3RSxHQUFULENBQWFrOEIsSUFBakIsQ0FBc0IsUUFBdEIsRUFBZ0NpYixHQUFoQyxDQUFmOztBQUVBO0FBQ0EsTUFBSSxDQUFDRCxPQUFPejdDLE1BQVosRUFBb0I7QUFDbkIsT0FBTTI3QyxjQUFjRixPQUFPcHhDLEtBQVAsQ0FBYTNGLElBQWIsSUFBcUIrMkMsT0FBT3B4QyxLQUFQLENBQWEwUCxLQUF0RDs7QUFFQSxPQUFNNmhDLG1CQUFtQkQsWUFBWXpVLFNBQVosRUFBekI7O0FBRUEsT0FBTTJULGdCQUFnQmEsSUFBSXIyQyxhQUFKLENBQWtCLE1BQWxCLENBQXRCOztBQUVBdzFDLGlCQUFjOTRDLFFBQWQsQ0FBdUIsMkJBQXZCO0FBQ0E4NEMsaUJBQWN6VSxNQUFkLENBQXFCdVYsV0FBckI7QUFDQWQsaUJBQWN6VSxNQUFkLENBQXFCbVAsT0FBckI7QUFDQWtHLFVBQU83MUMsT0FBUCxDQUFld2dDLE1BQWYsQ0FBc0J5VSxhQUF0QixFQUFxQyxJQUFyQzs7QUFFQTtBQUNBO0FBQ0EsT0FBSWUsaUJBQWlCN2EsRUFBakIsQ0FBb0IsTUFBcEIsQ0FBSixFQUFpQztBQUNoQzZhLHFCQUFpQjN1QyxNQUFqQjtBQUNBO0FBQ0QsR0FqQkQsTUFpQk87QUFDTnd1QyxVQUFPN0QsT0FBUCxDQUFleFIsTUFBZixDQUFzQm1QLE9BQXRCO0FBQ0E7O0FBRUQ7QUFDQUEsVUFBUTl4QyxFQUFSLENBQVcsV0FBWCxFQUF3QixlQUFPO0FBQzlCLE9BQU1zVyxRQUFRMGhDLE9BQU9weEMsS0FBUCxDQUFhMFAsS0FBM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTThoQyxTQUFTSixPQUFPNTNDLElBQVAsQ0FBWWcwQyxLQUFaLElBQXFCLE9BQXJCLEdBQStCLENBQUMsQ0FBaEMsR0FBb0MsQ0FBbkQ7O0FBRUE7QUFDQTtBQUNBLE9BQU1sVixTQUFTbVosSUFBSWo0QyxJQUFKLENBQVNULENBQVQsQ0FBVzI0QyxPQUExQjs7QUFFQSxPQUFNblosU0FBU2taLElBQUlqNEMsSUFBSixDQUFTVCxDQUFULENBQVc0NEMsT0FBMUI7O0FBRUE7QUFDQSxPQUFNQyxhQUFhbGlDLE1BQU0zVyxDQUFOLENBQVF1USxXQUEzQjs7QUFFQSxPQUFNdW9DLGNBQWNuaUMsTUFBTTNXLENBQU4sQ0FBUTIyQyxZQUE1Qjs7QUFFQSxPQUFNb0MsWUFBWSxFQUFsQjs7QUFFQTtBQUNBLE9BQU1DLGNBQWMsaUJBQWlCLENBQUMsQ0FBQ1AsTUFBRixHQUFXLEdBQVgsR0FBaUIsR0FBbEMsQ0FBcEI7O0FBRUEsT0FBSVEsa0JBQUo7QUFDQSxPQUFJQyxpQkFBSjtBQUNBLE9BQUlDLGtCQUFKO0FBQ0EsT0FBSUMsbUJBQUo7O0FBRUEsT0FBSUMsa0JBQUo7QUFDQSxPQUFJQyxrQkFBSjs7QUFFQTtBQUNBNThDLFVBQU91RSxJQUFQLENBQVksY0FBWjs7QUFFQTtBQUNBczRDLHFCQUFrQixXQUFsQixFQUErQkMsV0FBL0IsRUFBNENULFNBQTVDOztBQUVBO0FBQ0FRLHFCQUFrQixTQUFsQixFQUE2QkUsU0FBN0IsRUFBd0NWLFNBQXhDOztBQUVBO0FBQ0E5NkMsWUFBU1UsUUFBVCxDQUFrQnE2QyxXQUFsQjs7QUFFQTtBQUNBN0csV0FBUXh6QyxRQUFSLENBQWlCLG9CQUFqQjs7QUFFQTtBQUNBO0FBQ0EsWUFBUzQ2QyxpQkFBVCxDQUEyQjN1QyxJQUEzQixFQUFpQ25FLFFBQWpDLEVBQTJDaXpDLFVBQTNDLEVBQXVEO0FBQ3RELFFBQU1DLFlBQVloOUMsU0FBU29ELFFBQTNCOztBQUVBLFFBQU1nNUMsWUFBWSxFQUFsQjs7QUFFQSxRQUFJLENBQUNULElBQUl4YixNQUFKLENBQVc2YyxTQUFYLENBQUwsRUFBNEI7QUFDM0JaLGVBQVV6d0MsSUFBVixDQUFlcXhDLFVBQVV0NUMsRUFBVixDQUFhdUssSUFBYixFQUFtQm5FLFFBQW5CLENBQWY7QUFDQTs7QUFFRHN5QyxjQUFVendDLElBQVYsQ0FBZWd3QyxJQUFJajRDLEVBQUosQ0FBT3VLLElBQVAsRUFBYW5FLFFBQWIsQ0FBZjs7QUFFQSxRQUFJaXpDLFVBQUosRUFBZ0I7QUFDZixVQUFLLElBQUlwN0MsSUFBSXk2QyxVQUFVeDZDLE1BQXZCLEVBQStCRCxHQUEvQixHQUFzQztBQUNyQ283QyxpQkFBV3B4QyxJQUFYLENBQWdCeXdDLFVBQVUveEIsR0FBVixFQUFoQjtBQUNBO0FBQ0Q7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFTd3lCLFdBQVQsQ0FBcUJkLEdBQXJCLEVBQTBCO0FBQ3pCLFFBQU14RyxtQkFBbUJ4MUMsT0FBT1QsTUFBUCxDQUFjaTJDLGdCQUF2Qzs7QUFFQStHLGdCQUFZUCxJQUFJajRDLElBQUosQ0FBU1QsQ0FBckI7O0FBRUE7QUFDQXE1QyxnQkFBWUosVUFBVU4sT0FBVixHQUFvQnBaLE1BQWhDO0FBQ0ErWixnQkFBWTlaLFNBQVN5WixVQUFVTCxPQUEvQjs7QUFFQSxRQUNDMUcscUJBQXFCLE9BQXJCLElBQ0FBLHFCQUFxQixNQURyQixJQUVBQSxxQkFBcUIsT0FIdEIsRUFJRTtBQUNEZ0gsZ0JBQVdMLGFBQWFKLFNBQVNZLFNBQWpDO0FBQ0E7O0FBRUQsUUFDQ25ILHFCQUFxQixRQUFyQixJQUNBQSxxQkFBcUIsTUFGdEIsRUFHRTtBQUNEaUgsaUJBQVlMLGNBQWNRLFNBQTFCO0FBQ0E7O0FBRUQsUUFBSXBILHFCQUFxQixPQUF6QixFQUFrQztBQUNqQ2lILGlCQUFZLE1BQVo7QUFDQTs7QUFFREQsZUFBV0EsWUFBWUwsVUFBdkI7QUFDQU0sZ0JBQVlBLGFBQWFMLFdBQXpCOztBQUVBO0FBQ0E7QUFDQSxRQUNDSSxZQUFZLEVBQVosS0FDQ0MsYUFBYSxFQUFiLElBQW1CQSxjQUFjLE1BRGxDLENBREQsRUFHRTtBQUNEeGlDLFdBQU0zVyxDQUFOLENBQVF1TCxLQUFSLENBQWNxQixLQUFkLEdBQXNCc3NDLFdBQVcsSUFBakM7QUFDQXZpQyxXQUFNM1csQ0FBTixDQUFRdUwsS0FBUixDQUFjdUUsTUFBZCxHQUF1QnFwQyxZQUFZLElBQW5DOztBQUVBQyxrQkFBYSxJQUFiO0FBQ0EsS0FSRCxNQVFPO0FBQ05BLGtCQUFhLEtBQWI7QUFDQTtBQUNEOztBQUVELFlBQVNLLFNBQVQsR0FBcUI7QUFDcEIsUUFBSUcsVUFBSjs7QUFFQSxXQUFRQSxJQUFJYixVQUFVL3hCLEdBQVYsRUFBWixFQUE4QjtBQUM3QjR5QixPQUFFaFMsY0FBRjtBQUNBOztBQUVEO0FBQ0EzcEMsYUFBU3dCLFdBQVQsQ0FBcUJ1NUMsV0FBckI7O0FBRUE7QUFDQTdHLFlBQVExeUMsV0FBUixDQUFvQixvQkFBcEI7O0FBRUEsUUFBSTI1QyxVQUFKLEVBQWdCO0FBQ2ZmLFlBQU8xRCxPQUFQLENBQWU7QUFDZDdrQyxjQUFRcXBDLFNBRE07QUFFZHZzQyxhQUFPc3NDO0FBRk8sTUFBZjs7QUFLQTtBQUNBeDhDLFlBQU91RSxJQUFQLENBQVksY0FBWjtBQUNBOztBQUVEO0FBQ0FtNEMsaUJBQWEsS0FBYjtBQUNBO0FBQ0QsR0E1SkQ7O0FBOEpBO0FBQ0FmLFNBQU9oNEMsRUFBUCxDQUFVLE1BQVYsRUFBa0IsWUFBTTtBQUN2Qjh4QyxXQUFRa0csT0FBTzUzQyxJQUFQLENBQVlnMEMsS0FBWixJQUFxQixPQUFyQixHQUErQixVQUEvQixHQUE0QyxhQUFwRCxFQUNDLHdCQUREO0FBR0EsR0FKRDs7QUFNQTRELFNBQU9weEMsS0FBUCxDQUFhMFAsS0FBYixDQUFtQnRXLEVBQW5CLENBQXNCLE9BQXRCLEVBQStCLFlBQU07QUFDcEMsT0FBTUosWUFBWXZELE9BQU9vRCxZQUFQLEVBQWxCOztBQUVBLE9BQUlHLFNBQUosRUFBZTtBQUNkLFFBQU11QyxVQUFVdkMsVUFBVTJWLGVBQVYsRUFBaEI7O0FBRUEsUUFBSXBULE9BQUosRUFBYTtBQUNaLFNBQU1xM0MsZ0JBQWdCcjNDLFFBQVF1VCxPQUFSLENBQWdCLEtBQWhCLENBQXRCOztBQUVBLFNBQUk4akMsYUFBSixFQUFtQjtBQUNsQixVQUFNMXNDLFNBQVMzSyxRQUFRdXlCLGFBQVIsRUFBZjs7QUFFQSxVQUFNK2tCLGlCQUFpQixJQUFJbjlDLFNBQVN3RSxHQUFULENBQWF0QixNQUFqQixDQUN0QkEsTUFEc0IsRUFFckIrZ0MsaUJBRnFCLEVBQXZCO0FBR0F6ekIsYUFBT1YsSUFBUCxJQUFlcXRDLGVBQWV0dEMsQ0FBOUI7QUFDQVcsYUFBT1IsR0FBUCxJQUFjbXRDLGVBQWVwdEMsQ0FBN0I7O0FBRUFTLGFBQU9oQixTQUFQLEdBQW1CeFAsU0FBUzJRLHVCQUE1Qjs7QUFFQTVRLGFBQU91RSxJQUFQLENBQVksbUJBQVosRUFBaUM7QUFDaEMrTCxvQkFBYXpNLEtBRG1CO0FBRWhDd00sc0JBQWU7QUFDZHZLLGlCQUFTcTNDLGFBREs7QUFFZDFzQztBQUZjO0FBRmlCLE9BQWpDO0FBT0E7QUFDRDtBQUNEO0FBQ0QsR0E5QkQ7QUErQkE7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzRuQyx1QkFBVCxDQUFpQ3I0QyxNQUFqQyxFQUF5QztBQUN4QyxNQUFNcTlDLFFBQVE7QUFDYkMsZUFBWSxJQURDO0FBRWI1QyxXQUFRO0FBQ1A5QixhQUFTLE1BQU01NEMsT0FBT1QsTUFBUCxDQUFjZzRDO0FBRHRCLElBRks7QUFLYjhDLFFBQUs7QUFDSnQxQyxnQkFBWTtBQURSO0FBTFEsR0FBZDs7QUFVQSxTQUFPczRDLEtBQVA7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVNqRSxpQkFBVCxDQUEyQnA1QyxNQUEzQixFQUFtQztBQUNsQyxNQUFNbzNDLGVBQWVwM0MsT0FBT1QsTUFBUCxDQUFjODNDLG1CQUFuQzs7QUFFQSxNQUFNa0IsV0FBVztBQUNoQlIsVUFBTztBQUNONEIscUJBQ0MsU0FDQ3ZDLGVBQWUsTUFBTUEsYUFBYSxDQUFiLENBQU4sR0FBd0IsR0FBdkMsR0FBNkMsU0FEOUM7QUFGSyxJQURTO0FBTWhCTyxZQUFTO0FBQ1JnQyxxQkFBaUI7QUFEVCxJQU5PO0FBU2hCZCxjQUFXO0FBQ1ZjLHFCQUFpQjtBQURQO0FBVEssR0FBakI7O0FBY0EsU0FBT3BCLFFBQVA7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTSCxtQkFBVCxDQUE2QnVELE1BQTdCLEVBQXFDO0FBQ3BDLFNBQU9BLE9BQU81M0MsSUFBUCxDQUFZMnpDLFVBQVosR0FBeUJpRSxPQUFPNzFDLE9BQWhDLEdBQTBDNjFDLE9BQU9weEMsS0FBUCxDQUFhMFAsS0FBOUQ7QUFDQTtBQUNEOztBQUVEaGEsU0FBU1YsTUFBVCxDQUFnQmc0QyxxQkFBaEIsR0FBd0MsT0FBeEMsQzs7Ozs7Ozs7Ozs7Ozs7QUNsa0NBOzs7OztBQUtBOzs7OztBQUtBLENBQUMsWUFBVztBQUNYLEtBQUl0M0MsU0FBU3FuQixPQUFULENBQWlCeG5CLEdBQWpCLENBQXFCLG9CQUFyQixDQUFKLEVBQWdEO0FBQy9DO0FBQ0E7O0FBRUQsS0FBTXEyQixXQUFXLHVCQUFqQjs7QUFFQSxLQUFNb25CLGdCQUFnQixJQUFJdDlDLFNBQVNrMkIsUUFBYixDQUNyQixzQ0FDQ0EsUUFERCxHQUVDLCtDQUZELEdBR0MsV0FKb0IsQ0FBdEI7O0FBT0EsS0FBTXdnQixnQkFBZ0IsRUFBQzVtQyxNQUFNLENBQVAsRUFBVTZtQyxRQUFRLENBQWxCLEVBQXFCemxDLE9BQU8sQ0FBNUIsRUFBdEI7O0FBRUEsS0FBTTJsQyxlQUFlLGlCQUFyQjs7QUFFQTcyQyxVQUFTcW5CLE9BQVQsQ0FBaUJ2ZixHQUFqQixDQUFxQixvQkFBckIsRUFBMkM7QUFDMUM2eUIsWUFBVSxRQURnQztBQUUxQzBhLFFBRjBDLG9CQUVqQztBQUNScjFDLFlBQVNvMUMsTUFBVCxDQUNDO0FBQ0M7QUFDQTtBQUNBLGtCQUhELEdBSUMsR0FKRCxHQUtDLHVGQUxELEdBTUMsdUZBTkQsR0FPQyx1RkFQRCxHQVFDLHVGQVJELEdBU0MscUJBVEQsR0FVQyxlQVZELEdBV0Msb0JBWEQsR0FZQyxhQVpELEdBYUMsY0FiRCxHQWNDLGtCQWRELEdBZUMseUJBZkQ7QUFnQkM7QUFDQSxtQkFqQkQsR0FrQkMsbUJBbEJELEdBbUJDLEdBbkJELEdBb0JDLDZCQXBCRCxHQXFCQyxvQkFyQkQsR0FzQkMsdUJBdEJELEdBdUJDLGdCQXZCRCxHQXdCQyxHQXhCRDtBQXlCQztBQUNBLDZDQTFCRCxHQTJCQyxtQkEzQkQsR0E0QkMsWUE1QkQsR0E2QkMsYUE3QkQsR0E4QkMsV0E5QkQsR0ErQkMsR0EvQkQ7QUFnQ0M7QUFDQSw2Q0FqQ0QsR0FrQ0MsbUJBbENELEdBbUNDLFlBbkNELEdBb0NDLGFBcENELEdBcUNDLFdBckNELEdBc0NDLEdBdENEO0FBdUNDO0FBQ0EsNkNBeENELEdBeUNDLGNBekNELEdBMENDLG1CQTFDRCxHQTJDQyxZQTNDRCxHQTRDQyxhQTVDRCxHQTZDQyxHQTdDRDtBQThDQztBQUNBLDZDQS9DRCxHQWdEQyxjQWhERCxHQWlEQyxtQkFqREQsR0FrREMsWUFsREQsR0FtREMsYUFuREQsR0FvREMsR0FwREQsR0FxREMsK0NBckRELEdBc0RDLHlDQXRERCxHQXVEQyxlQXZERCxHQXdEQyxHQXhERDtBQXlEQztBQUNBLDJCQTFERCxHQTJEQyxzQkEzREQsR0E0REMsR0E3REY7QUErREEsR0FsRXlDO0FBb0UxQ3pXLE1BcEUwQyxnQkFvRXJDNStCLE1BcEVxQyxFQW9FN0I7QUFDWjtBQUNBOztBQUVBLE9BQU1pYSxRQUFRZzlCLFVBQVVqM0MsTUFBVixDQUFkOztBQUVBO0FBQ0FBLFVBQU9rM0MsT0FBUCxDQUFlbnZDLEdBQWYsQ0FBbUIsT0FBbkIsRUFBNEJrUyxLQUE1Qjs7QUFFQTtBQUNBO0FBQ0FqYSxVQUFPMkQsRUFBUCxDQUFVLGlCQUFWLEVBQTZCLGtCQUFVO0FBQ3RDLFFBQU1KLFlBQVl2RCxPQUFPb0QsWUFBUCxFQUFsQjs7QUFFQSxRQUFJRyxTQUFKLEVBQWU7QUFDZCxTQUFNdUMsVUFBVXZDLFVBQVV1SixrQkFBVixFQUFoQjs7QUFFQSxTQUFJaEgsT0FBSixFQUFhO0FBQ1osVUFBTXEzQyxnQkFBZ0JyM0MsUUFBUXVULE9BQVIsQ0FBZ0IsS0FBaEIsQ0FBdEI7O0FBRUEsVUFBSThqQyxhQUFKLEVBQW1CO0FBQ2xCLFdBQU0xc0MsU0FBUzNLLFFBQVF1eUIsYUFBUixFQUFmOztBQUVBLFdBQU0ra0IsaUJBQWlCLElBQUluOUMsU0FBU3dFLEdBQVQsQ0FBYXRCLE1BQWpCLENBQ3RCQSxNQURzQixFQUVyQitnQyxpQkFGcUIsRUFBdkI7QUFHQXp6QixjQUFPVixJQUFQLElBQWVxdEMsZUFBZXR0QyxDQUE5QjtBQUNBVyxjQUFPUixHQUFQLElBQWNtdEMsZUFBZXB0QyxDQUE3Qjs7QUFFQVMsY0FBT2hCLFNBQVAsR0FBbUJ4UCxTQUFTMlEsdUJBQTVCOztBQUVBNVEsY0FBT3VFLElBQVAsQ0FBWSxtQkFBWixFQUFpQztBQUNoQytMLHFCQUFhLEVBRG1CO0FBRWhDRCx1QkFBZTtBQUNkdkssa0JBQVNxM0MsYUFESztBQUVkMXNDO0FBRmM7QUFGaUIsUUFBakM7QUFPQTtBQUNEO0FBQ0Q7QUFDRCxJQTlCRDtBQStCQSxHQTlHeUM7QUFnSDFDK3NDLFdBaEgwQyxxQkFnSGhDeDlDLE1BaEhnQyxFQWdIeEI7QUFDakI7QUFDQSxPQUFNKzNDLFFBQVEsRUFBQ2hvQyxNQUFNLENBQVAsRUFBVW9CLE9BQU8sQ0FBakIsRUFBb0J5bEMsUUFBUSxDQUE1QixFQUErQmpaLE9BQU8sQ0FBdEMsRUFBZDs7QUFFQSxPQUFNOGYsWUFBWUMsdUJBQXVCMTlDLE1BQXZCLENBQWxCOztBQUVBLFFBQUssSUFBTWdGLEtBQVgsSUFBb0IreUMsS0FBcEIsRUFBMkI7QUFDMUIsUUFBSXIyQyxPQUFPOFcsU0FBUCxDQUFpQnNrQixjQUFqQixDQUFnQ3A5QixJQUFoQyxDQUFxQ3E0QyxLQUFyQyxFQUE0Qy95QyxLQUE1QyxDQUFKLEVBQXdEO0FBQ3ZEeTRDLGVBQVV6NEMsS0FBVjtBQUNBO0FBQ0Q7QUFDRDtBQTNIeUMsRUFBM0M7O0FBOEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTaXlDLFNBQVQsQ0FBbUJqM0MsTUFBbkIsRUFBMkI7QUFDMUIsTUFBTW8zQyxlQUFlcDNDLE9BQU9ULE1BQVAsQ0FBY28rQywrQkFBbkM7O0FBRUEsTUFBTXJHLGlCQUFpQnQzQyxPQUFPVCxNQUFQLENBQWNxK0MsaUNBQXJDOztBQUVBLFdBQVNDLE9BQVQsR0FBbUI7QUFDbEIsT0FBSSxLQUFLQyxRQUFULEVBQW1COztBQUVuQjtBQUNBLE9BQUk5OUMsT0FBT2szQyxPQUFQLENBQWU2RyxPQUFmLElBQTBCLEtBQUtwQyxNQUFuQyxFQUEyQyxLQUFLb0MsT0FBTCxHQUFlLElBQWY7O0FBRTNDLzlDLFVBQU9rM0MsT0FBUCxDQUFlajBDLE9BQWYsQ0FBdUIsS0FBSzA0QyxNQUE1Qjs7QUFFQTtBQUNBLFFBQUttQyxRQUFMLEdBQWdCLElBQWhCO0FBQ0E7O0FBRUQsV0FBU0UsT0FBVCxHQUFtQjtBQUNsQixPQUFNejhDLFdBQVd2QixPQUFPdUIsUUFBUCxFQUFqQjs7QUFFQSxPQUFNcTZDLE1BQU01N0MsT0FBT3FELFFBQW5COztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQUksS0FBS3k2QyxRQUFULEVBQW1CO0FBQ2xCLFNBQUtuQyxNQUFMLEdBQWMzN0MsT0FBT2szQyxPQUFQLENBQWVDLE1BQWYsQ0FDYixLQUFLcnhDLE9BRFEsRUFFYixPQUZhLEVBR2IsS0FBSzYxQyxNQUFMLENBQVk1M0MsSUFIQyxDQUFkOztBQU1BO0FBQ0E7QUFDQTtBQUNBLFFBQ0MsS0FBSzQzQyxNQUFMLENBQVl6N0MsTUFBWixJQUNBLENBQUMsSUFBSUQsU0FBU3dFLEdBQVQsQ0FBYUMsV0FBakIsQ0FBNkIsS0FBS2kzQyxNQUFMLENBQVk3RCxPQUF6QyxFQUFrRHYyQyxRQUFsRCxFQUNDbzhCLEtBSEgsRUFJRTtBQUNELFNBQU1BLFFBQVFpZSxJQUFJcjJDLGFBQUosQ0FDYnZGLE9BQU9pK0MsZUFBUCxJQUEwQmgrQyxTQUFTeTdDLE9BQW5DLEdBQTZDLEdBQTdDLEdBQW1ELEtBRHRDLENBQWQ7QUFHQS9kLFdBQU12OEIsT0FBTixDQUFjLEtBQUt1NkMsTUFBTCxDQUFZN0QsT0FBMUI7QUFDQSxVQUFLNkQsTUFBTCxDQUFZN0QsT0FBWixDQUFvQm9HLElBQXBCLENBQXlCdmdCLEtBQXpCO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBLFFBQUksS0FBS29nQixPQUFULEVBQWtCO0FBQ2pCLFVBQUtwQyxNQUFMLENBQVlobUMsS0FBWjtBQUNBLFlBQU8sS0FBS29vQyxPQUFaO0FBQ0E7O0FBRUQsV0FBTyxLQUFLRCxRQUFaO0FBQ0E7O0FBRUQ7QUFDQTtBQWpDQSxRQWtDSztBQUNKSyxxQkFBZ0IsS0FBS3hDLE1BQXJCLEVBQTZCdkUsWUFBN0I7QUFDQTtBQUNEOztBQUVELFNBQU87QUFDTmozQyxtQkFBZ0JrNEMsd0JBQXdCcjRDLE1BQXhCLENBRFY7O0FBR04yNUMsb0JBQWlCLGNBSFg7O0FBS05wQixhQUFVYSxrQkFBa0JwNUMsTUFBbEIsQ0FMSjs7QUFPTjQ1QyxzQkFBbUIsWUFQYjs7QUFTTjtBQUNBdEIsMkJBQXdCLENBQUMsQ0FBQyw2QkFBRCxDQUFELENBVmxCOztBQVlOO0FBQ0FZLGNBQVc7QUFDVnZCLGFBQVM7QUFDUndCLGVBQVUsWUFERjtBQUVSaDVDLHFCQUFnQjtBQUZSO0FBREMsSUFiTDs7QUFvQk5vSyxVQUFPO0FBQ04wUCxXQUFPLEtBREQ7QUFFTjA5QixhQUFTO0FBQ1Q7QUFITSxJQXBCRDs7QUEwQk47QUFDQXhoQixxQkEzQk07O0FBNkJOcHlCLE9BN0JNLGtCQTZCQztBQUNOLFFBQU13MEMsV0FBVyxLQUFLQSxRQUF0Qjs7QUFFQTtBQUNBLFFBQ0MsS0FBS3gwQyxJQUFMLENBQVUyekMsVUFBVixJQUNBLENBQUMxM0MsT0FBT3lVLE1BQVAsQ0FBYytqQyxZQUFkLENBQTJCRCxTQUFTWixPQUFwQyxDQUZGLEVBSUMsS0FBSzV6QyxJQUFMLENBQVUyekMsVUFBVixHQUF1QixLQUF2Qjs7QUFFRDtBQUNBLFFBQ0MsS0FBSzN6QyxJQUFMLENBQVVnMEMsS0FBVixJQUFtQixNQUFuQixJQUNBLENBQUMvM0MsT0FBT3lVLE1BQVAsQ0FBYytqQyxZQUFkLENBQTJCRCxTQUFTUixLQUFwQyxDQUZGLEVBSUMsS0FBS2gwQyxJQUFMLENBQVVnMEMsS0FBVixHQUFrQixNQUFsQjs7QUFFRDtBQUNBLFNBQUtxRyxVQUFMLENBQWdCO0FBQ2Z6QyxhQUFRLElBRE87QUFFZjcxQyxjQUFTLEtBQUtBLE9BRkM7QUFHZjR5QyxjQUFTLEtBQUtBLE9BSEM7QUFJZjJGLGNBQVMsS0FBS3Q2QyxJQUpDO0FBS2Y4NUMscUJBTGU7QUFNZkc7QUFOZSxLQUFoQjs7QUFTQTtBQUNBO0FBQ0EsUUFBSSxDQUFDLEtBQUtqNkMsSUFBTCxDQUFVYSxJQUFmLEVBQXFCO0FBQ3BCLFNBQUksS0FBSzJGLEtBQUwsQ0FBVzNGLElBQWYsRUFBcUIsT0FBTyxLQUFLMkYsS0FBTCxDQUFXM0YsSUFBbEI7QUFDckIsS0FGRCxNQUVPO0FBQ04sU0FBSSxDQUFDLEtBQUsyRixLQUFMLENBQVczRixJQUFoQixFQUNDLEtBQUsyRixLQUFMLENBQVczRixJQUFYLEdBQWtCLEtBQUsyRixLQUFMLENBQVcwUCxLQUFYLENBQWlCbXRCLFNBQWpCLEVBQWxCO0FBQ0Q7O0FBRUQsU0FBSzc4QixLQUFMLENBQVcwUCxLQUFYLENBQWlCeW5CLGFBQWpCLENBQStCO0FBQzlCaDRCLFVBQUssS0FBSzNGLElBQUwsQ0FBVTJGLEdBRGU7O0FBRzlCO0FBQ0EsMkJBQXNCLEtBQUszRixJQUFMLENBQVUyRixHQUpGOztBQU05QitqQyxVQUFLLEtBQUsxcEMsSUFBTCxDQUFVMHBDO0FBTmUsS0FBL0I7O0FBU0E7QUFDQTtBQUNBLFFBQ0MsS0FBS2lMLE9BQUwsSUFDQSxDQUFDLEtBQUtBLE9BQUwsQ0FBYWhCLFVBRGQsSUFFQSxLQUFLM3pDLElBQUwsQ0FBVTJ6QyxVQUhYLEVBSUU7QUFDRCxVQUFLLElBQU1pQixDQUFYLElBQWdCLEtBQUs1MEMsSUFBTCxDQUFVNjBDLE9BQTFCLEVBQW1DO0FBQ2xDLFVBQ0NsM0MsT0FBTzhXLFNBQVAsQ0FBaUJza0IsY0FBakIsQ0FBZ0NwOUIsSUFBaEMsQ0FDQyxLQUFLcUUsSUFBTCxDQUFVNjBDLE9BRFgsRUFFQ0QsQ0FGRCxDQURELEVBS0U7QUFDRCxZQUFLcHVDLEtBQUwsQ0FBVzBQLEtBQVgsQ0FBaUJsWCxXQUFqQixDQUE2QjQxQyxDQUE3QjtBQUNBO0FBQ0Q7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsUUFBSTM0QyxPQUFPeVUsTUFBUCxDQUFjK2pDLFlBQWQsQ0FBMkJELFNBQVNNLFNBQXBDLENBQUosRUFDQ0MsY0FBYyxJQUFkOztBQUVEO0FBQ0EsU0FBS0osT0FBTCxHQUFlejRDLFNBQVN5TyxLQUFULENBQWU1QyxNQUFmLENBQXNCLEVBQXRCLEVBQTBCLEtBQUsvSCxJQUEvQixDQUFmO0FBQ0EsSUFwR0s7QUFzR042NkIsT0F0R00sa0JBc0dDO0FBQ04sUUFBTTRZLFVBQVV2M0MsU0FBU3FuQixPQUFULENBQWlCZzNCLGtCQUFqQzs7QUFFQSxRQUFNcmtDLFFBQVEsS0FBSzFQLEtBQUwsQ0FBVzBQLEtBQXpCOztBQUVBLFFBQU1sVyxPQUFPO0FBQ1oyekMsaUJBQVksQ0FBQyxDQUFDLEtBQUtudEMsS0FBTCxDQUFXb3RDLE9BRGI7QUFFWmp1QyxVQUFLdVEsTUFBTXRCLFlBQU4sQ0FBbUIsS0FBbkIsQ0FGTztBQUdaODBCLFVBQUt4ekIsTUFBTXRCLFlBQU4sQ0FBbUIsS0FBbkIsS0FBNkIsRUFIdEI7QUFJWnpJLFlBQU8rSixNQUFNdEIsWUFBTixDQUFtQixPQUFuQixLQUErQixFQUoxQjtBQUtadkYsYUFBUTZHLE1BQU10QixZQUFOLENBQW1CLFFBQW5CLEtBQWdDLEVBTDVCOztBQU9aO0FBQ0FwTCxXQUFNLEtBQUtxcUMsS0FBTCxHQUNISixRQUFRSyxvQkFBUixDQUE2QjU5QixLQUE3QixDQURHLEdBRUg7QUFWUyxLQUFiOztBQWFBO0FBQ0E7QUFDQTtBQUNBLFFBQU1yVixPQUFPcVYsTUFBTThHLFlBQU4sQ0FBbUIsR0FBbkIsQ0FBYjs7QUFFQSxRQUFJbmMsUUFBUSxLQUFLa3pDLE9BQUwsQ0FBYXJnQixRQUFiLENBQXNCN3lCLElBQXRCLENBQVosRUFBeUMsS0FBSzJGLEtBQUwsQ0FBVzNGLElBQVgsR0FBa0JBLElBQWxCOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUksQ0FBQ2IsS0FBS2cwQyxLQUFWLEVBQWlCO0FBQ2hCLFNBQU1DLGVBQWVqMEMsS0FBSzJ6QyxVQUFMLEdBQWtCLEtBQUs1eEMsT0FBdkIsR0FBaUNtVSxLQUF0RDs7QUFFQTtBQUNBLFNBQUltOUIsWUFBSixFQUFrQjtBQUNqQixVQUFJWSxhQUFhOWxDLFFBQWIsQ0FBc0JrbEMsYUFBYSxDQUFiLENBQXRCLENBQUosRUFBNEM7QUFDM0NyekMsWUFBS2cwQyxLQUFMLEdBQWEsTUFBYjtBQUNBLE9BRkQsTUFFTyxJQUFJQyxhQUFhOWxDLFFBQWIsQ0FBc0JrbEMsYUFBYSxDQUFiLENBQXRCLENBQUosRUFBNEM7QUFDbERyekMsWUFBS2cwQyxLQUFMLEdBQWEsT0FBYjtBQUNBOztBQUVELFVBQUloMEMsS0FBS2cwQyxLQUFULEVBQWdCO0FBQ2ZDLG9CQUFhajFDLFdBQWIsQ0FDQ3EwQyxhQUFhVCxjQUFjNXlDLEtBQUtnMEMsS0FBbkIsQ0FBYixDQUREO0FBR0EsT0FKRCxNQUlPO0FBQ05oMEMsWUFBS2cwQyxLQUFMLEdBQWEsTUFBYjtBQUNBO0FBQ0Q7QUFDRDtBQWZBLFVBZ0JLO0FBQ0poMEMsWUFBS2cwQyxLQUFMLEdBQWFDLGFBQWExcUMsUUFBYixDQUFzQixPQUF0QixLQUFrQyxNQUEvQztBQUNBMHFDLG9CQUFheHFDLFdBQWIsQ0FBeUIsT0FBekI7QUFDQTtBQUNEOztBQUVEO0FBQ0EsUUFBSXhOLE9BQU9zbkIsT0FBUCxDQUFlMWlCLElBQWYsSUFBdUIsS0FBSzJGLEtBQUwsQ0FBVzNGLElBQXRDLEVBQTRDO0FBQzNDYixVQUFLYSxJQUFMLEdBQVk0eUMsUUFBUStHLHVCQUFSLEdBQ1h2K0MsTUFEVyxFQUVYLEtBQUt1SyxLQUFMLENBQVczRixJQUZBLENBQVo7O0FBS0E7QUFDQTtBQUNBLFNBQU00NUMsV0FBV3o2QyxLQUFLYSxJQUFMLENBQVU0NUMsUUFBM0I7QUFDQSxTQUFJQSxZQUFZQSxTQUFTQyxhQUF6QixFQUF3QztBQUN2Q0QsZUFBU0MsYUFBVCxHQUF5QngrQyxTQUFTeU8sS0FBVCxDQUFlZ3dDLElBQWYsQ0FDeEJGLFNBQVNDLGFBQVQsQ0FBdUJyOUMsT0FBdkIsQ0FBK0IsU0FBL0IsRUFBMEMsRUFBMUMsQ0FEd0IsQ0FBekI7QUFHQTtBQUNEOztBQUVEO0FBQ0E7QUFDQSxTQUFLMDJDLE9BQUwsQ0FBYSxDQUFDL3pDLEtBQUsyekMsVUFBTCxHQUFrQixRQUFsQixHQUE2QixLQUE5QixJQUF1QyxPQUFwRCxFQUNDLHFCQUREOztBQUlBLFNBQUtPLE9BQUwsQ0FBYWwwQyxJQUFiOztBQUVBO0FBQ0E7QUFDQSxRQUNDL0QsT0FBT3lVLE1BQVAsQ0FBYytqQyxZQUFkLENBQTJCLEtBQUtELFFBQUwsQ0FBY00sU0FBekMsS0FDQTc0QyxPQUFPVCxNQUFQLENBQWNvL0MsaUNBQWQsS0FBb0QsSUFGckQsRUFJQ3hHLGFBQWEsSUFBYjs7QUFFRCxRQUFNeUcsbUJBQW1CLEtBQUtDLG9CQUFMLENBQTBCdjdDLENBQTFCLENBQTRCdUwsS0FBckQ7QUFDQSt2QyxxQkFBaUI3K0MsWUFBakIsQ0FDQyxpQkFERCxFQUVDLHVCQUZEO0FBSUE2K0MscUJBQWlCNytDLFlBQWpCLENBQThCLFNBQTlCLEVBQXlDLEdBQXpDOztBQUVBLFNBQUtxK0MsVUFBTCxHQUFrQjVHLFFBQVFzSCxZQUFSLENBQXFCLEtBQUs5K0MsTUFBMUIsQ0FBbEI7O0FBRUE7QUFDQSxTQUFLMkQsRUFBTCxDQUFRLGFBQVIsRUFBdUIsVUFBU3E0QyxHQUFULEVBQWM7QUFDcENBLFNBQUlqNEMsSUFBSixDQUFTa1csS0FBVCxHQUFpQmhhLFNBQVM4K0MsWUFBMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBSSxLQUFLeDBDLEtBQUwsQ0FBVzNGLElBQVgsSUFBbUIsS0FBS2t6QyxPQUFMLENBQWEvMkIsWUFBYixDQUEwQixHQUExQixDQUF2QixFQUNDaTdCLElBQUlqNEMsSUFBSixDQUFTYSxJQUFULEdBQWdCbzNDLElBQUlqNEMsSUFBSixDQUFTaTdDLE1BQVQsR0FBa0IvK0MsU0FBUzgrQyxZQUEzQztBQUNELEtBUkQ7QUFTQSxJQWpOSzs7O0FBbU5OO0FBQ0E7QUFDQTk4QyxXQXJOTSxvQkFxTkd1RCxTQXJOSCxFQXFOYztBQUNuQjR5Qyx3QkFBb0IsSUFBcEIsRUFBMEJuMkMsUUFBMUIsQ0FBbUN1RCxTQUFuQztBQUNBLElBdk5LOzs7QUF5Tk47QUFDQTtBQUNBME0sV0EzTk0sb0JBMk5HMU0sU0EzTkgsRUEyTmM7QUFDbkIsV0FBTzR5QyxvQkFBb0IsSUFBcEIsRUFBMEJsbUMsUUFBMUIsQ0FBbUMxTSxTQUFuQyxDQUFQO0FBQ0EsSUE3Tks7OztBQStOTjtBQUNBO0FBQ0F6QyxjQWpPTSx1QkFpT015QyxTQWpPTixFQWlPaUI7QUFDdEI0eUMsd0JBQW9CLElBQXBCLEVBQTBCcjFDLFdBQTFCLENBQXNDeUMsU0FBdEM7QUFDQSxJQW5PSzs7O0FBcU9OO0FBQ0E7QUFDQTZ6QyxlQUFhLFlBQVc7QUFDdkIsUUFBTUMsYUFBYSxJQUFJdEgsTUFBSixDQUNsQixPQUNDLEdBQUd4bUMsTUFBSCxDQUFVOHJDLGNBQVYsRUFBMEJGLFlBQTFCLEVBQXdDbmdCLElBQXhDLENBQTZDLEdBQTdDLENBREQsR0FFQyxJQUhpQixDQUFuQjs7QUFNQSxXQUFPLFlBQVc7QUFDakIsU0FBTTJoQixVQUFVLEtBQUtXLFVBQUwsQ0FBZ0JDLG1CQUFoQixDQUNmcEIsb0JBQW9CLElBQXBCLEVBQTBCei9CLFlBQTFCLENBQXVDLE9BQXZDLENBRGUsQ0FBaEI7O0FBSUE7QUFDQTtBQUNBLFVBQUssSUFBTWdnQyxDQUFYLElBQWdCQyxPQUFoQixFQUF5QjtBQUN4QixVQUFJVSxXQUFXbnVDLElBQVgsQ0FBZ0J3dEMsQ0FBaEIsQ0FBSixFQUF3QixPQUFPQyxRQUFRRCxDQUFSLENBQVA7QUFDeEI7O0FBRUQsWUFBT0MsT0FBUDtBQUNBLEtBWkQ7QUFhQSxJQXBCVyxFQXZPTjs7QUE2UE5pQixXQUFRQyxvQkFBb0I5NUMsTUFBcEIsQ0E3UEY7QUE4UE4rNEMsYUFBVUMsc0JBQXNCaDVDLE1BQXRCLENBOVBKOztBQWdRTnk1QyxXQWhRTSxzQkFnUUs7QUFDVixRQUFNOTlCLFFBQVEsQ0FBQyxLQUFLNVgsSUFBTCxDQUFVMHBDLEdBQVYsSUFBaUIsRUFBbEIsSUFBd0IsR0FBeEIsR0FBOEIsS0FBS2lNLFFBQWpEOztBQUVBLFdBQU8sS0FBSzE1QyxNQUFMLENBQVl5SyxJQUFaLENBQWlCa3hDLE1BQWpCLENBQXdCaGdDLEtBQXhCLENBQThCdmEsT0FBOUIsQ0FBc0MsSUFBdEMsRUFBNEN1YSxLQUE1QyxDQUFQO0FBQ0E7QUFwUUssR0FBUDtBQXNRQTs7QUFFRDs7Ozs7O0FBTUExYixVQUFTcW5CLE9BQVQsQ0FBaUJnM0Isa0JBQWpCLEdBQXNDO0FBQ3JDUSxjQURxQyx3QkFDeEI5K0MsTUFEd0IsRUFDaEI7QUFDcEI7QUFDQSxPQUFNNDdDLE1BQU01N0MsT0FBT3FELFFBQW5COztBQUVBLE9BQU0rekMsZUFBZXAzQyxPQUFPVCxNQUFQLENBQWNvK0MsK0JBQW5DOztBQUVBLE9BQU1yRyxpQkFDTHQzQyxPQUFPVCxNQUFQLENBQWNxK0MsaUNBRGY7O0FBR0EsT0FBTXI4QyxXQUFXdkIsT0FBT3VCLFFBQVAsRUFBakI7O0FBRUE7O0FBRUEsT0FBTTA5QyxhQUFhLENBQUMsWUFBRCxFQUFlLE9BQWYsRUFBd0IsTUFBeEIsQ0FBbkI7O0FBRUE7QUFDQSxPQUFNQyxlQUFlO0FBQ3BCbkgsU0FEb0IsaUJBQ2Q5b0MsS0FEYyxFQUNQa3dDLFFBRE8sRUFDRzdnQixRQURILEVBQ2E7QUFDaEMsU0FBTXBoQixLQUFLak8sTUFBTW5KLE9BQWpCOztBQUVBO0FBQ0EsU0FDQ21KLE1BQU1td0MsT0FBTixDQUFjckgsS0FBZCxJQUNDNzZCLEdBQUc1WixDQUFILENBQUt1TCxLQUFMLENBQVd3d0MsVUFBWCxLQUEwQixNQUExQixJQUNBbmlDLEdBQUc1WixDQUFILENBQUt1TCxLQUFMLENBQVd5d0MsV0FBWCxLQUEyQixNQUg3QixFQUlFO0FBQ0Q7QUFDQSxVQUFJLENBQUNyd0MsTUFBTW92QyxPQUFOLENBQWMzRyxVQUFuQixFQUErQjtBQUM5QjtBQUNBLFdBQ0NwWixZQUFZLFFBQVosSUFDQ3BoQixHQUFHNVosQ0FBSCxDQUFLdUwsS0FBTCxDQUFXd3dDLFVBQVgsS0FBMEIsTUFBMUIsSUFDQW5pQyxHQUFHNVosQ0FBSCxDQUFLdUwsS0FBTCxDQUFXeXdDLFdBQVgsS0FBMkIsTUFIN0IsRUFJRTtBQUNEcndDLGNBQU00dUMsT0FBTjtBQUNBNXVDLGNBQU1uSixPQUFOLEdBQWdCeTVDLGdCQUFnQnYvQyxNQUFoQixFQUF3QmtkLEVBQXhCLENBQWhCO0FBQ0E7O0FBRUQ7QUFDQSxXQUNDLENBQUNqTyxNQUFNbXdDLE9BQU4sQ0FBYzFILFVBQWYsSUFDQXlILFlBQVksUUFEWixJQUVBN2dCLFlBQVksUUFIYixFQUlFO0FBQ0RydkIsY0FBTTR1QyxPQUFOO0FBQ0E1dUMsY0FBTW5KLE9BQU4sR0FBZ0IwNUMsb0JBQW9CdGlDLEVBQXBCLENBQWhCO0FBQ0E7QUFDRDtBQUNEOztBQUVEO0FBN0JBLFVBOEJLLElBQ0pvaEIsWUFBWSxRQUFaLElBQ0FydkIsTUFBTW13QyxPQUFOLENBQWMxSCxVQURkLElBRUEsQ0FBQ3pvQyxNQUFNb3ZDLE9BQU4sQ0FBYzNHLFVBSFgsRUFJSDtBQUNEem9DLGFBQU00dUMsT0FBTjtBQUNBNXVDLGFBQU1uSixPQUFOLEdBQWdCeTVDLGdCQUFnQnYvQyxNQUFoQixFQUF3QmtkLEVBQXhCLENBQWhCO0FBQ0E7O0FBRUQ7QUFDQSxTQUFJLENBQUNrNkIsWUFBRCxJQUFpQmw2QixHQUFHK2pCLEVBQUgsQ0FBTSxRQUFOLENBQXJCLEVBQXNDO0FBQ3JDLFVBQUkzQyxZQUFZLFFBQWhCLEVBQ0NwaEIsR0FBR3VpQyxRQUFILENBQVksU0FBWixFQUF1QixjQUF2QixFQURELEtBRUt2aUMsR0FBRzFQLFdBQUgsQ0FBZSxTQUFmO0FBQ0w7QUFDRCxLQWxEbUI7QUFvRHBCa3FDLGNBcERvQixzQkFvRFR6b0MsS0FwRFMsRUFvREZrd0MsUUFwREUsRUFvRFE3Z0IsUUFwRFIsRUFvRGtCO0FBQ3JDO0FBQ0EsU0FBSSxDQUFDcnZCLE1BQU1td0MsT0FBTixDQUFjMUgsVUFBbkIsRUFBK0I7O0FBRS9CO0FBQ0E7QUFDQSxTQUFJbUUsb0JBQUo7QUFDQSxTQUFJNXNDLE1BQU1uSixPQUFOLENBQWNtN0IsRUFBZCxDQUFpQixFQUFDb1osS0FBSyxDQUFOLEVBQVN4aEMsR0FBRyxDQUFaLEVBQWpCLENBQUosRUFDQ2dqQyxjQUFjNXNDLE1BQU1uSixPQUFwQixDQURELEtBRUsrMUMsY0FBYzVzQyxNQUFNbkosT0FBTixDQUFjdVQsT0FBZCxDQUFzQixPQUF0QixDQUFkOztBQUVMO0FBQ0FwSyxXQUFNNHVDLE9BQU47O0FBRUE7QUFDQSxTQUFJdmYsUUFBSixFQUFjO0FBQ2I7QUFDQSxVQUFNb2MsU0FBU3o2QyxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBYixDQUFxQnFYLGNBQXJCLENBQ2RvZ0MsY0FBY3ZtQixNQUFkLENBQXFCO0FBQ3BCc2dCLHFDQURvQjtBQUVwQm9JLDJCQUNDMS9DLE9BQU95SyxJQUFQLENBQVk2ekMsa0JBQVosQ0FDRW9CO0FBSmlCLE9BQXJCLENBRGMsRUFPZDlELEdBUGMsQ0FBZjs7QUFVQTtBQUNBK0Qsb0JBQWNqRixNQUFkLEVBQXNCenJDLE1BQU1uSixPQUE1Qjs7QUFFQTtBQUNBO0FBQ0ErMUMsa0JBQVl6NkMsT0FBWixDQUFvQnM1QyxPQUFPcmhDLE9BQVAsQ0FBZSxLQUFmLENBQXBCOztBQUVBO0FBQ0FwSyxZQUFNbkosT0FBTixHQUFnQjQwQyxNQUFoQjtBQUNBOztBQUVEO0FBdkJBLFVBd0JLO0FBQ0o7QUFDQW1CLG1CQUFZejZDLE9BQVosQ0FBb0I2TixNQUFNbkosT0FBMUI7O0FBRUE7QUFDQW1KLGFBQU1uSixPQUFOLEdBQWdCKzFDLFdBQWhCO0FBQ0E7QUFDRCxLQWxHbUI7QUFvR3BCajNDLFFBcEdvQixnQkFvR2ZxSyxLQXBHZSxFQW9HUmt3QyxRQXBHUSxFQW9HRTdnQixRQXBHRixFQW9HWTtBQUMvQixTQUFJcnZCLE1BQU1td0MsT0FBTixDQUFjeDZDLElBQWxCLEVBQXdCO0FBQ3ZCLFVBQU15MUMsTUFBTXByQyxNQUFNbkosT0FBTixDQUFjbTdCLEVBQWQsQ0FBaUIsS0FBakIsSUFDVGh5QixNQUFNbkosT0FERyxHQUVUbUosTUFBTW5KLE9BQU4sQ0FBY3VULE9BQWQsQ0FBc0IsS0FBdEIsQ0FGSDs7QUFJQSxVQUFNelUsT0FBT3FLLE1BQU1uSixPQUFOLENBQWNtN0IsRUFBZCxDQUFpQixHQUFqQixJQUNWaHlCLE1BQU1uSixPQURJLEdBRVZtSixNQUFNbkosT0FBTixDQUFjdVQsT0FBZCxDQUFzQixHQUF0QixDQUZIOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBTXVtQyxlQUNKM3dDLE1BQU1uSixPQUFOLENBQWNtN0IsRUFBZCxDQUFpQixHQUFqQixLQUF5QixDQUFDM0MsUUFBM0IsSUFDQ3J2QixNQUFNbkosT0FBTixDQUFjbTdCLEVBQWQsQ0FBaUIsS0FBakIsS0FBMkIzQyxRQUY3Qjs7QUFJQSxVQUFJdWhCLGNBQUo7O0FBRUEsVUFBSUQsWUFBSixFQUFrQjN3QyxNQUFNNHVDLE9BQU47O0FBRWxCO0FBQ0EsVUFBSSxDQUFDdmYsUUFBTCxFQUFldWhCLFFBQVFDLGVBQWVsN0MsSUFBZixDQUFSLENBQWYsS0FDSztBQUNKO0FBQ0EsV0FBSSxDQUFDdTZDLFFBQUwsRUFDQ1UsUUFBUUUsV0FBVzFGLEdBQVgsRUFBZ0JwckMsTUFBTW92QyxPQUFOLENBQWN6NUMsSUFBOUIsQ0FBUjs7QUFFRDtBQUNBLFdBQU1HLGFBQWE5RSxTQUFTcW5CLE9BQVQsQ0FBaUJnM0Isa0JBQWpCLENBQW9DMEIsdUJBQXBDLEdBQ2xCaGdELE1BRGtCLEVBRWxCcytCLFFBRmtCLENBQW5COztBQUtBLFdBQUksQ0FBQ3IrQixTQUFTeU8sS0FBVCxDQUFleXNDLE9BQWYsQ0FBdUJwMkMsV0FBVzRtQyxHQUFsQyxDQUFMLEVBQ0MsQ0FBQ2tVLFNBQVNqN0MsSUFBVixFQUFnQjg4QixhQUFoQixDQUE4QjM4QixXQUFXNG1DLEdBQXpDOztBQUVELFdBQUk1bUMsV0FBV2s3QyxPQUFYLENBQW1CcCtDLE1BQXZCLEVBQ0MsQ0FBQ2crQyxTQUFTajdDLElBQVYsRUFBZ0JpOUIsZ0JBQWhCLENBQ0M5OEIsV0FBV2s3QyxPQURaO0FBR0Q7O0FBRUQsVUFBSUwsWUFBSixFQUFrQjN3QyxNQUFNbkosT0FBTixHQUFnQis1QyxLQUFoQjtBQUNsQjtBQUNEO0FBcEptQixJQUFyQjs7QUF1SkEsWUFBU04sZUFBVCxDQUF5QnYvQyxNQUF6QixFQUFpQzhGLE9BQWpDLEVBQTBDO0FBQ3pDLFFBQU1vNkMsbUJBQW1CLEVBQXpCOztBQUVBLFFBQUk5SSxZQUFKLEVBQ0M4SSxpQkFBaUJuN0MsVUFBakIsR0FBOEIsRUFBQzBWLE9BQU8yOEIsYUFBYSxDQUFiLENBQVIsRUFBOUIsQ0FERCxLQUVLOEksaUJBQWlCaDRDLE1BQWpCLEdBQTBCLEVBQUMsY0FBYyxRQUFmLEVBQTFCOztBQUVMO0FBQ0E7QUFDQSxRQUFNMHVDLFNBQVNnRixJQUFJcjJDLGFBQUosQ0FDZHZGLE9BQU9pK0MsZUFBUCxJQUEwQmgrQyxTQUFTeTdDLE9BQW5DLEdBQTZDLEdBQTdDLEdBQW1ELEtBRHJDLEVBRWR3RSxnQkFGYyxDQUFmOztBQUtBO0FBQ0FQLGtCQUFjL0ksTUFBZCxFQUFzQjl3QyxPQUF0QjtBQUNBQSxZQUFRbzRDLElBQVIsQ0FBYXRILE1BQWI7O0FBRUEsV0FBT0EsTUFBUDtBQUNBOztBQUVELFlBQVM0SSxtQkFBVCxDQUE2QjE1QyxPQUE3QixFQUFzQztBQUNyQyxRQUFNKzFDLGNBQWMvMUMsUUFBUXVULE9BQVIsQ0FBZ0IsT0FBaEIsQ0FBcEI7O0FBRUF3aUMsZ0JBQVl6NkMsT0FBWixDQUFvQjBFLE9BQXBCOztBQUVBLFdBQU8rMUMsV0FBUDtBQUNBOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVNrRSxVQUFULENBQW9CMUYsR0FBcEIsRUFBeUI4RixRQUF6QixFQUFtQztBQUNsQyxRQUFNdjdDLE9BQU9nM0MsSUFBSXIyQyxhQUFKLENBQWtCLEdBQWxCLEVBQXVCO0FBQ25DUixpQkFBWTtBQUNYRCxZQUFNcTdDLFNBQVMxL0I7QUFESjtBQUR1QixLQUF2QixDQUFiOztBQU1BN2IsU0FBS3hELE9BQUwsQ0FBYWk1QyxHQUFiO0FBQ0FBLFFBQUk2RCxJQUFKLENBQVN0NUMsSUFBVDs7QUFFQSxXQUFPQSxJQUFQO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVNrN0MsY0FBVCxDQUF3Qmw3QyxJQUF4QixFQUE4QjtBQUM3QixRQUFNeTFDLE1BQU16MUMsS0FBS3lVLE9BQUwsQ0FBYSxLQUFiLENBQVo7O0FBRUFnaEMsUUFBSWo1QyxPQUFKLENBQVl3RCxJQUFaOztBQUVBLFdBQU95MUMsR0FBUDtBQUNBOztBQUVELFlBQVNzRixhQUFULENBQXVCUyxTQUF2QixFQUFrQ0MsUUFBbEMsRUFBNEM7QUFDM0MsUUFBSUEsU0FBU2paLFNBQVQsRUFBSixFQUEwQjtBQUN6QixTQUFNMTZCLFFBQVExTSxPQUFPd2pDLFdBQVAsRUFBZDs7QUFFQTkyQixXQUFNbTZCLGNBQU4sQ0FDQ3daLFFBREQsRUFFQ3BnRCxTQUFTMm5DLHFCQUZWOztBQUtBO0FBQ0E7QUFDQTtBQUNBeVksY0FBU2x6QyxNQUFUOztBQUVBNUwsY0FBUysrQyxzQkFBVCxDQUFnQ0YsU0FBaEMsRUFBMkMxekMsS0FBM0M7QUFDQSxLQWRELE1BY087QUFDTjB6QyxlQUFVaC9DLE9BQVYsQ0FBa0JpL0MsUUFBbEI7QUFDQTtBQUNEOztBQUVELFVBQU8sVUFBU3B4QyxLQUFULEVBQWdCO0FBQ3RCLFFBQUlmLGFBQUo7QUFDQSxRQUFJdE0sVUFBSjs7QUFFQXFOLFVBQU1td0MsT0FBTixHQUFnQixFQUFoQjs7QUFFQSxTQUFLeDlDLElBQUksQ0FBVCxFQUFZQSxJQUFJcTlDLFdBQVdwOUMsTUFBM0IsRUFBbUNELEdBQW5DLEVBQXdDO0FBQ3ZDc00sWUFBTyt3QyxXQUFXcjlDLENBQVgsQ0FBUDs7QUFFQXFOLFdBQU1td0MsT0FBTixDQUFjbHhDLElBQWQsSUFBc0JlLE1BQU15cEMsT0FBTixHQUNuQnpwQyxNQUFNeXBDLE9BQU4sQ0FBY3hxQyxJQUFkLE1BQXdCZSxNQUFNb3ZDLE9BQU4sQ0FBY253QyxJQUFkLENBREwsR0FFbkIsS0FGSDtBQUdBOztBQUVEO0FBQ0EsU0FBS3RNLElBQUksQ0FBVCxFQUFZQSxJQUFJcTlDLFdBQVdwOUMsTUFBM0IsRUFBbUNELEdBQW5DLEVBQXdDO0FBQ3ZDc00sWUFBTyt3QyxXQUFXcjlDLENBQVgsQ0FBUDs7QUFFQXM5QyxrQkFBYWh4QyxJQUFiLEVBQ0NlLEtBREQsRUFFQ0EsTUFBTXlwQyxPQUFOLEdBQWdCenBDLE1BQU15cEMsT0FBTixDQUFjeHFDLElBQWQsQ0FBaEIsR0FBc0MsSUFGdkMsRUFHQ2UsTUFBTW92QyxPQUFOLENBQWNud0MsSUFBZCxDQUhEO0FBS0E7O0FBRURlLFVBQU0rdUMsT0FBTjtBQUNBLElBMUJEO0FBMkJBLEdBcFJvQzs7O0FBc1JyQzs7Ozs7OztBQU9Bbkcsc0JBN1JxQyxnQ0E2UmhCNTlCLEtBN1JnQixFQTZSVDtBQUMzQixPQUFNM1csSUFBSTJXLE1BQU0zVyxDQUFoQjs7QUFFQSxPQUFNeTJDLFVBQVUsS0FBS0MsVUFBTCxDQUFnQi8vQixLQUFoQixDQUFoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQ0NuSixLQUFLMjlCLEtBQUwsQ0FBWW5yQyxFQUFFdVEsV0FBRixHQUFnQmttQyxRQUFRN3BDLEtBQXpCLEdBQWtDNnBDLFFBQVEzbUMsTUFBckQsS0FDQzlQLEVBQUUyMkMsWUFESCxJQUVBbnBDLEtBQUsyOUIsS0FBTCxDQUFZbnJDLEVBQUUyMkMsWUFBRixHQUFpQkYsUUFBUTNtQyxNQUExQixHQUFvQzJtQyxRQUFRN3BDLEtBQXZELEtBQ0M1TSxFQUFFdVEsV0FKSjtBQU1BLEdBNVNvQzs7O0FBOFNyQzs7Ozs7Ozs7QUFRQW1tQyxZQXRUcUMsc0JBc1QxQi8vQixLQXRUMEIsRUFzVG5CO0FBQ2pCLE9BQUlpZ0MsbUJBQUo7O0FBRUEsT0FBSWpnQyxNQUFNM1csQ0FBTixDQUFRNjJDLFlBQVosRUFBMEI7QUFDekJELGlCQUFhO0FBQ1pocUMsWUFBTytKLE1BQU0zVyxDQUFOLENBQVE2MkMsWUFESDtBQUVaL21DLGFBQVE2RyxNQUFNM1csQ0FBTixDQUFRaTlDO0FBRkosS0FBYjtBQUlBLElBTEQsTUFLTztBQUNOLFFBQU1sRyxNQUFNLElBQUlDLEtBQUosRUFBWjtBQUNBRCxRQUFJM3dDLEdBQUosR0FBVXVRLE1BQU10QixZQUFOLENBQW1CLEtBQW5CLENBQVY7O0FBRUF1aEMsaUJBQWE7QUFDWmhxQyxZQUFPbXFDLElBQUlucUMsS0FEQztBQUVaa0QsYUFBUWluQyxJQUFJam5DO0FBRkEsS0FBYjtBQUlBOztBQUVELFVBQU84bUMsVUFBUDtBQUNBLEdBelVvQzs7O0FBMlVyQzs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQThGLHlCQTNWcUMscUNBMlZYO0FBQ3pCO0FBQ0EsVUFBTy8vQyxTQUFTcW5CLE9BQVQsQ0FBaUIxaUIsSUFBakIsQ0FBc0I0N0MsaUJBQTdCO0FBQ0EsR0E5Vm9DOzs7QUFnV3JDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBakMseUJBblhxQyxxQ0FtWFg7QUFDekI7QUFDQSxVQUFPdCtDLFNBQVNxbkIsT0FBVCxDQUFpQjFpQixJQUFqQixDQUFzQjY3QyxtQkFBN0I7QUFDQTtBQXRYb0MsRUFBdEM7O0FBeVhBLFVBQVN0QyxlQUFULENBQXlCeEMsTUFBekIsRUFBaUN2RSxZQUFqQyxFQUErQztBQUM5QyxNQUFNVSxVQUFVNkQsT0FBTzdELE9BQXZCOztBQUVBLE1BQU1DLFFBQVE0RCxPQUFPNTNDLElBQVAsQ0FBWWcwQyxLQUExQjs7QUFFQSxNQUFNTCxhQUFhaUUsT0FBTzUzQyxJQUFQLENBQVkyekMsVUFBL0I7O0FBRUEsTUFBSU4sWUFBSixFQUFrQjtBQUNqQjtBQUNBLFFBQUssSUFBSXgxQyxJQUFJLENBQWIsRUFBZ0JBLEdBQWhCO0FBQXVCazJDLFlBQVEvMEMsV0FBUixDQUFvQnEwQyxhQUFheDFDLENBQWIsQ0FBcEI7QUFBdkIsSUFFQSxJQUFJbTJDLFNBQVMsUUFBYixFQUF1QjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSUwsVUFBSixFQUFnQjtBQUNmSSxhQUFRNzFDLFFBQVIsQ0FBaUJtMUMsYUFBYSxDQUFiLENBQWpCO0FBQ0E7QUFDRCxJQVpELE1BWU8sSUFBSVcsU0FBUyxNQUFiLEVBQXFCO0FBQzNCRCxZQUFRNzFDLFFBQVIsQ0FBaUJtMUMsYUFBYVQsY0FBY29CLEtBQWQsQ0FBYixDQUFqQjtBQUNBO0FBQ0QsR0FuQkQsTUFtQk87QUFDTixPQUFJQSxTQUFTLFFBQWIsRUFBdUI7QUFDdEIsUUFBSUwsVUFBSixFQUFnQkksUUFBUTJILFFBQVIsQ0FBaUIsWUFBakIsRUFBK0IsUUFBL0IsRUFBaEIsS0FDSzNILFFBQVF0cUMsV0FBUixDQUFvQixZQUFwQjs7QUFFTHNxQyxZQUFRdHFDLFdBQVIsQ0FBb0IsT0FBcEI7QUFDQSxJQUxELE1BS087QUFDTixRQUFJdXFDLFNBQVMsTUFBYixFQUFxQkQsUUFBUXRxQyxXQUFSLENBQW9CLE9BQXBCLEVBQXJCLEtBQ0tzcUMsUUFBUTJILFFBQVIsQ0FBaUIsT0FBakIsRUFBMEIxSCxLQUExQjs7QUFFTEQsWUFBUXRxQyxXQUFSLENBQW9CLFlBQXBCO0FBQ0E7O0FBRUQsT0FBTXlNLFFBQVE2OUIsUUFBUXgwQyxDQUFSLENBQVVvOUMsYUFBVixDQUF3QixLQUF4QixDQUFkOztBQUVBLE9BQU1DLGNBQWMxbUMsTUFBTXRCLFlBQU4sQ0FBbUIsT0FBbkIsQ0FBcEI7O0FBRUEsT0FBSWdvQyxXQUFKLEVBQWlCO0FBQ2hCLFFBQUl6NEMsU0FBUyxFQUFiOztBQUVBLFFBQU0wNEMsZUFBZSxnQkFBZ0J2MEMsSUFBaEIsQ0FBcUJzMEMsV0FBckIsQ0FBckI7QUFDQSxRQUFJQyxZQUFKLEVBQWtCO0FBQ2pCMTRDLGVBQVUwNEMsYUFBYSxDQUFiLENBQVY7QUFDQTs7QUFFRCxRQUFNQyxjQUFjLGVBQWV4MEMsSUFBZixDQUFvQnMwQyxXQUFwQixDQUFwQjtBQUNBLFFBQUlFLFdBQUosRUFBaUI7QUFDaEIzNEMsZUFBVTI0QyxZQUFZLENBQVosQ0FBVjtBQUNBOztBQUVENW1DLFVBQU1sYSxZQUFOLENBQW1CLE9BQW5CLEVBQTRCbUksTUFBNUI7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM0eEMsbUJBQVQsQ0FBNkI5NUMsTUFBN0IsRUFBcUM7QUFDcEMsTUFBTXc2QyxrQkFBa0JDLHFCQUFxQno2QyxNQUFyQixDQUF4Qjs7QUFFQSxNQUFNczNDLGlCQUFpQnQzQyxPQUFPVCxNQUFQLENBQWNxK0MsaUNBQXJDOztBQUVBO0FBQ0E7QUFDQSxTQUFPLFVBQVMxZ0MsRUFBVCxFQUFhblosSUFBYixFQUFtQjtBQUN6QixPQUFNbTJDLGFBQWEsRUFBQ2hxQyxPQUFPLENBQVIsRUFBV2tELFFBQVEsQ0FBbkIsRUFBbkI7O0FBRUEsT0FBTWxGLE9BQU9nUCxHQUFHaFAsSUFBaEI7O0FBRUEsT0FBSStMLGNBQUo7O0FBRUE7QUFDQSxPQUFJaUQsR0FBR25ZLFVBQUgsQ0FBYyxzQkFBZCxDQUFKLEVBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFJeTFDLGdCQUFnQnQ5QixFQUFoQixDQUFKLEVBQXlCO0FBQ3hCLFFBQUloUCxRQUFRLEtBQVosRUFBbUI7QUFDbEIsU0FBTXdzQyxTQUFTeDlCLEdBQUd5ckIsUUFBSCxDQUFZLFFBQVosQ0FBZjs7QUFFQTtBQUNBLFNBQUkrUixNQUFKLEVBQVk7QUFDWHg5QixTQUFHeTlCLFdBQUgsQ0FBZUQsTUFBZjtBQUNBeDlCLFdBQUt3OUIsTUFBTDtBQUNBO0FBQ0Q7QUFDRDs7QUFFQTtBQUNBMzJDLFNBQUtnMEMsS0FBTCxHQUFhLFFBQWI7O0FBRUE7QUFDQTk5QixZQUFRaUQsR0FBR3lyQixRQUFILENBQVksS0FBWixLQUFzQnpyQixHQUFHeXJCLFFBQUgsQ0FBWSxHQUFaLEVBQWlCQSxRQUFqQixDQUEwQixLQUExQixDQUE5QjtBQUNBOztBQUVEO0FBbkJBLFFBb0JLLElBQUl6NkIsUUFBUSxRQUFSLElBQW9CZ1AsR0FBR2hMLFFBQUgsQ0FBWW9sQyxjQUFaLENBQXhCLEVBQXFEO0FBQ3pEcjlCLGFBQVFpRCxHQUFHeXJCLFFBQUgsQ0FBWSxLQUFaLEtBQXNCenJCLEdBQUd5ckIsUUFBSCxDQUFZLEdBQVosRUFBaUJBLFFBQWpCLENBQTBCLEtBQTFCLENBQTlCOztBQUVBO0FBQ0EsS0FKSSxNQUlFLElBQUlpUywwQkFBMEIxOUIsRUFBMUIsQ0FBSixFQUFtQztBQUN6Q2pELGFBQVFpRCxHQUFHaFAsSUFBSCxJQUFXLEdBQVgsR0FBaUJnUCxHQUFHZ0QsUUFBSCxDQUFZLENBQVosQ0FBakIsR0FBa0NoRCxFQUExQztBQUNBOztBQUVELE9BQUksQ0FBQ2pELEtBQUwsRUFBWTs7QUFFWjtBQUNBO0FBQ0EsUUFBSyxJQUFNNGdDLENBQVgsSUFBZ0JYLFVBQWhCLEVBQTRCO0FBQzNCLFFBQUl4NEMsT0FBTzhXLFNBQVAsQ0FBaUJza0IsY0FBakIsQ0FBZ0NwOUIsSUFBaEMsQ0FBcUN3NkMsVUFBckMsRUFBaURXLENBQWpELENBQUosRUFBeUQ7QUFDeEQsU0FBTWhDLFlBQVk1K0IsTUFBTWxWLFVBQU4sQ0FBaUI4MUMsQ0FBakIsQ0FBbEI7QUFDQSxTQUFJaEMsYUFBYUEsVUFBVXB2QyxLQUFWLENBQWdCcXRDLFlBQWhCLENBQWpCLEVBQ0MsT0FBTzc4QixNQUFNbFYsVUFBTixDQUFpQjgxQyxDQUFqQixDQUFQO0FBQ0Q7QUFDRDs7QUFFRCxVQUFPMzlCLEVBQVA7QUFDQSxHQS9ERDtBQWdFQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM4N0IscUJBQVQsQ0FBK0JoNUMsTUFBL0IsRUFBdUM7QUFDdEMsTUFBTW8zQyxlQUFlcDNDLE9BQU9ULE1BQVAsQ0FBY28rQywrQkFBbkM7O0FBRUE7QUFDQSxTQUFPLFVBQVN6Z0MsRUFBVCxFQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFNNDlCLGNBQWM1OUIsR0FBR2hQLElBQUgsSUFBVyxHQUFYLEdBQWlCZ1AsR0FBR3lyQixRQUFILEVBQWpCLEdBQWlDenJCLEVBQXJEOztBQUVBLE9BQU12TixRQUFRbXJDLFlBQVkvMUMsVUFBMUI7O0FBRUEsT0FBTWd6QyxRQUFRLEtBQUtoMEMsSUFBTCxDQUFVZzBDLEtBQXhCOztBQUVBO0FBQ0E7QUFDQSxPQUFJLENBQUMsS0FBSzczQyxNQUFWLEVBQWtCO0FBQ2pCLFFBQU02NkMsZ0JBQWdCNzlCLEdBQUd5ckIsUUFBSCxDQUFZLE1BQVosQ0FBdEI7O0FBRUEsUUFBSW9TLGFBQUosRUFDQ0EsY0FBY0osV0FBZCxDQUNDSSxjQUFjcFMsUUFBZCxDQUF1QixFQUFDMFIsS0FBSyxDQUFOLEVBQVN4aEMsR0FBRyxDQUFaLEVBQXZCLENBREQ7QUFHRDs7QUFFRCxPQUFJay9CLFNBQVNBLFNBQVMsTUFBdEIsRUFBOEI7QUFDN0IsUUFBTTd2QyxTQUFTakksU0FBU3lPLEtBQVQsQ0FBZXNzQyxZQUFmLENBQTRCcnJDLE1BQU1kLEtBQU4sSUFBZSxFQUEzQyxDQUFmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUlrcEMsU0FBUyxRQUFULElBQXFCNzZCLEdBQUdoUCxJQUFILElBQVcsUUFBcEMsRUFBOEM7QUFDN0NnUCxVQUFLQSxHQUFHKzlCLFFBQUgsQ0FDSixJQUFJaDdDLFNBQVNpN0MsVUFBVCxDQUFvQnAxQyxPQUF4QixDQUNDLEtBREQsRUFFQ3N4QyxlQUNHLEVBQUMzOEIsT0FBTzI4QixhQUFhLENBQWIsQ0FBUixFQURILEdBRUcsRUFBQ3ZvQyxPQUFPLG1CQUFSLEVBSkosQ0FESSxDQUFMO0FBUUE7O0FBRUQ7QUFYQSxTQVlLLElBQUlrcEMsU0FBUyxFQUFDaG9DLE1BQU0sQ0FBUCxFQUFVb0IsT0FBTyxDQUFqQixFQUFiLEVBQWtDO0FBQ3RDLFVBQUlpbUMsWUFBSixFQUNDMEQsWUFBWTc0QyxRQUFaLENBQ0NtMUMsYUFBYVQsY0FBY29CLEtBQWQsQ0FBYixDQURELEVBREQsS0FJSzd2QyxPQUFPLE9BQVAsSUFBa0I2dkMsS0FBbEI7QUFDTDs7QUFFRDtBQUNBLFFBQUksQ0FBQ1gsWUFBRCxJQUFpQixDQUFDbjNDLFNBQVN5TyxLQUFULENBQWV5c0MsT0FBZixDQUF1Qmp6QyxNQUF2QixDQUF0QixFQUNDeUgsTUFBTWQsS0FBTixHQUFjNU8sU0FBU3lPLEtBQVQsQ0FBZTBzQyxZQUFmLENBQTRCbHpDLE1BQTVCLElBQXNDLEdBQXBEO0FBQ0Q7O0FBRUQsVUFBT2dWLEVBQVA7QUFDQSxHQTdERDtBQThEQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVN1OUIsb0JBQVQsQ0FBOEJ6NkMsTUFBOUIsRUFBc0M7QUFDckMsTUFBTXMzQyxpQkFBaUJ0M0MsT0FBT1QsTUFBUCxDQUFjcStDLGlDQUFyQzs7QUFFQSxNQUFNeEcsZUFBZXAzQyxPQUFPVCxNQUFQLENBQWNvK0MsK0JBQW5DOztBQUVBLE1BQU10QyxnQkFBZ0IsRUFBQ1gsUUFBUSxDQUFULEVBQVk3aEMsR0FBRyxDQUFmLEVBQWtCd2hDLEtBQUssQ0FBdkIsRUFBdEI7O0FBRUEsU0FBTyxVQUFTbjlCLEVBQVQsRUFBYTtBQUNuQjtBQUNBLE9BQUksRUFBRUEsR0FBR2hQLElBQUgsSUFBVyxFQUFDb3RDLEtBQUssQ0FBTixFQUFTQyxHQUFHLENBQVosRUFBYixDQUFKLEVBQWtDLE9BQU8sS0FBUDs7QUFFbEMsT0FBTXI3QixXQUFXaEQsR0FBR2dELFFBQXBCOztBQUVBO0FBQ0EsT0FBSUEsU0FBU3JlLE1BQVQsS0FBb0IsQ0FBeEIsRUFBMkIsT0FBTyxLQUFQOztBQUUzQixPQUFNMjVDLFFBQVF0N0IsU0FBUyxDQUFULENBQWQ7O0FBRUE7QUFDQTtBQUNBLE9BQUksRUFBRXM3QixNQUFNdHRDLElBQU4sSUFBY210QyxhQUFoQixDQUFKLEVBQW9DLE9BQU8sS0FBUDs7QUFFcEM7QUFDQTtBQUNBLE9BQUluK0IsR0FBR2hQLElBQUgsSUFBVyxHQUFmLEVBQW9CO0FBQ25CLFFBQUksQ0FBQzBzQywwQkFBMEJZLEtBQTFCLENBQUwsRUFBdUMsT0FBTyxLQUFQO0FBQ3ZDO0FBQ0Q7QUFIQSxRQUlLO0FBQ0o7QUFDQTtBQUNBLFNBQUlBLE1BQU10dEMsSUFBTixJQUFjLFFBQWxCLEVBQTRCO0FBQzNCLFVBQUksQ0FBQ3N0QyxNQUFNdHBDLFFBQU4sQ0FBZW9sQyxjQUFmLENBQUwsRUFBcUMsT0FBTyxLQUFQO0FBQ3JDLE1BRkQsTUFFTztBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBSXQzQyxPQUFPeTdDLFNBQVAsSUFBb0J4N0MsU0FBU3k3QyxPQUFqQyxFQUEwQyxPQUFPLEtBQVA7O0FBRTFDO0FBQ0E7QUFDQSxVQUFJLENBQUNkLDBCQUEwQlksS0FBMUIsQ0FBTCxFQUF1QyxPQUFPLEtBQVA7QUFDdkM7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsT0FDQ3BFLGVBQ0dsNkIsR0FBR2hMLFFBQUgsQ0FBWWtsQyxhQUFhLENBQWIsQ0FBWixDQURILEdBRUduM0MsU0FBU3lPLEtBQVQsQ0FBZXNzQyxZQUFmLENBQ0E5OUIsR0FBR25ZLFVBQUgsQ0FBYzhKLEtBQWQsSUFBdUIsRUFEdkIsRUFFQSxJQUZBLEVBR0UsWUFIRixLQUdtQixRQU52QixFQVFDLE9BQU8sSUFBUDs7QUFFRCxVQUFPLEtBQVA7QUFDQSxHQXBERDtBQXFEQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxVQUFTK3JDLHlCQUFULENBQW1DMTlCLEVBQW5DLEVBQXVDO0FBQ3RDLE1BQUlBLEdBQUdoUCxJQUFILElBQVcsS0FBZixFQUFzQixPQUFPLElBQVAsQ0FBdEIsS0FDSyxJQUFJZ1AsR0FBR2hQLElBQUgsSUFBVyxHQUFmLEVBQ0osT0FBT2dQLEdBQUdnRCxRQUFILENBQVlyZSxNQUFaLElBQXNCLENBQXRCLElBQTJCcWIsR0FBR3lyQixRQUFILENBQVksS0FBWixDQUFsQzs7QUFFRCxTQUFPLEtBQVA7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxVQUFTbVEsYUFBVCxDQUF1QjZDLE1BQXZCLEVBQStCO0FBQzlCLE1BQU01M0MsT0FBTzQzQyxPQUFPNTNDLElBQXBCOztBQUVBLE1BQU1tMkMsYUFBYSxFQUFDaHFDLE9BQU9uTSxLQUFLbU0sS0FBYixFQUFvQmtELFFBQVFyUCxLQUFLcVAsTUFBakMsRUFBbkI7O0FBRUEsTUFBTTZHLFFBQVEwaEMsT0FBT3B4QyxLQUFQLENBQWEwUCxLQUEzQjs7QUFFQSxPQUFLLElBQU00Z0MsQ0FBWCxJQUFnQlgsVUFBaEIsRUFBNEI7QUFDM0IsT0FBSUEsV0FBV1csQ0FBWCxDQUFKLEVBQW1CNWdDLE1BQU1sYSxZQUFOLENBQW1CODZDLENBQW5CLEVBQXNCWCxXQUFXVyxDQUFYLENBQXRCLEVBQW5CLEtBQ0s1Z0MsTUFBTTZ1QixlQUFOLENBQXNCK1IsQ0FBdEI7QUFDTDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFVBQVMxQyxZQUFULENBQXNCd0QsTUFBdEIsRUFBOEI7QUFDN0IsTUFBTTM3QyxTQUFTMjdDLE9BQU8zN0MsTUFBdEI7O0FBRUEsTUFBTXVCLFdBQVd2QixPQUFPdUIsUUFBUCxFQUFqQjs7QUFFQSxNQUFNcTZDLE1BQU01N0MsT0FBT3FELFFBQW5COztBQUVBOztBQUVBLE1BQU1veUMsVUFBV2tHLE9BQU9sRyxPQUFQLEdBQWlCbUcsSUFBSXIyQyxhQUFKLENBQWtCLE1BQWxCLENBQWxDOztBQUVBOztBQUVBLE1BQU11N0MsWUFBWWxGLElBQUlyMkMsYUFBSixDQUFrQixNQUFsQixDQUFsQjs7QUFFQSxNQUFNdzdDLFlBQVluRixJQUFJcjJDLGFBQUosQ0FBa0IsTUFBbEIsQ0FBbEI7O0FBRUEsTUFBTXk3QyxZQUFZcEYsSUFBSXIyQyxhQUFKLENBQWtCLE1BQWxCLENBQWxCOztBQUVBLE1BQU0wN0MsWUFBWXJGLElBQUlyMkMsYUFBSixDQUFrQixNQUFsQixDQUFsQjs7QUFFQXU3QyxZQUFVNytDLFFBQVYsQ0FBbUIsbUJBQW5CO0FBQ0E2K0MsWUFBVTcrQyxRQUFWLENBQW1CLHNCQUFuQjs7QUFFQTgrQyxZQUFVOStDLFFBQVYsQ0FBbUIsbUJBQW5CO0FBQ0E4K0MsWUFBVTkrQyxRQUFWLENBQW1CLHNCQUFuQjs7QUFFQSsrQyxZQUFVLytDLFFBQVYsQ0FBbUIsbUJBQW5CO0FBQ0ErK0MsWUFBVS8rQyxRQUFWLENBQW1CLHNCQUFuQjs7QUFFQWcvQyxZQUFVaC9DLFFBQVYsQ0FBbUIsbUJBQW5CO0FBQ0FnL0MsWUFBVWgvQyxRQUFWLENBQW1CLHNCQUFuQjs7QUFFQTtBQUNBd3pDLFVBQVFuUCxNQUFSLENBQWV3YSxTQUFmO0FBQ0FyTCxVQUFRblAsTUFBUixDQUFleWEsU0FBZjtBQUNBdEwsVUFBUW5QLE1BQVIsQ0FBZTBhLFNBQWY7QUFDQXZMLFVBQVFuUCxNQUFSLENBQWUyYSxTQUFmOztBQUVBO0FBQ0F4TCxVQUFRblAsTUFBUixDQUFlLElBQUlybUMsU0FBU3dFLEdBQVQsQ0FBYWs4QixJQUFqQixDQUFzQixRQUF0QixFQUFnQ2liLEdBQWhDLENBQWY7O0FBRUE7QUFDQSxNQUFJLENBQUNELE9BQU96N0MsTUFBWixFQUFvQjtBQUNuQixPQUFNMjdDLGNBQWNGLE9BQU9weEMsS0FBUCxDQUFhM0YsSUFBYixJQUFxQisyQyxPQUFPcHhDLEtBQVAsQ0FBYTBQLEtBQXREOztBQUVBLE9BQU02aEMsbUJBQW1CRCxZQUFZelUsU0FBWixFQUF6Qjs7QUFFQSxPQUFNMlQsZ0JBQWdCYSxJQUFJcjJDLGFBQUosQ0FBa0IsTUFBbEIsQ0FBdEI7O0FBRUF3MUMsaUJBQWM5NEMsUUFBZCxDQUF1QiwyQkFBdkI7QUFDQTg0QyxpQkFBY3pVLE1BQWQsQ0FBcUJ1VixXQUFyQjtBQUNBZCxpQkFBY3pVLE1BQWQsQ0FBcUJtUCxPQUFyQjtBQUNBa0csVUFBTzcxQyxPQUFQLENBQWV3Z0MsTUFBZixDQUFzQnlVLGFBQXRCLEVBQXFDLElBQXJDOztBQUVBO0FBQ0E7QUFDQSxPQUFJZSxpQkFBaUI3YSxFQUFqQixDQUFvQixNQUFwQixDQUFKLEVBQWlDNmEsaUJBQWlCM3VDLE1BQWpCO0FBQ2pDLEdBZkQsTUFlTztBQUNOd3VDLFVBQU83RCxPQUFQLENBQWV4UixNQUFmLENBQXNCbVAsT0FBdEI7QUFDQTs7QUFFRDtBQUNBQSxVQUFROXhDLEVBQVIsQ0FBVyxXQUFYLEVBQXdCLGVBQU87QUFDOUIsT0FBTXNXLFFBQVEwaEMsT0FBT3B4QyxLQUFQLENBQWEwUCxLQUEzQjs7QUFFQTtBQUNBOztBQUVBLE9BQU00b0IsU0FBU21aLElBQUlqNEMsSUFBSixDQUFTVCxDQUFULENBQVcyNEMsT0FBMUI7O0FBRUEsT0FBTW5aLFNBQVNrWixJQUFJajRDLElBQUosQ0FBU1QsQ0FBVCxDQUFXNDRDLE9BQTFCOztBQUVBOztBQUVBLE9BQU1DLGFBQWFsaUMsTUFBTTNXLENBQU4sQ0FBUXVRLFdBQTNCOztBQUVBLE9BQU11b0MsY0FBY25pQyxNQUFNM1csQ0FBTixDQUFRMjJDLFlBQTVCOztBQUVBLE9BQU03SixRQUFRK0wsYUFBYUMsV0FBM0I7O0FBRUEsT0FBTUMsWUFBWSxFQUFsQjs7QUFFQSxPQUFNcDNDLFNBQVMrMkMsSUFBSWo0QyxJQUFKLENBQVNZLFNBQVQsRUFBZjs7QUFFQSxPQUFJdThDLGdCQUFKOztBQUVBLE9BQUlDLGdCQUFKOztBQUVBLE9BQUl4RSxrQkFBSjs7QUFFQSxPQUFJQyxrQkFBSjs7QUFFQSxPQUFJTCxrQkFBSjs7QUFFQSxPQUFJRSxrQkFBSjs7QUFFQSxPQUFJRCxpQkFBSjs7QUFFQSxPQUFJRSxtQkFBSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFJejNDLE9BQU9pTixRQUFQLENBQWdCLHNCQUFoQixDQUFKLEVBQTZDO0FBQzVDZ3ZDLGNBQVUsQ0FBVjtBQUNBQyxjQUFVLENBQVY7QUFDQSxJQUhELE1BR08sSUFBSWw4QyxPQUFPaU4sUUFBUCxDQUFnQixzQkFBaEIsQ0FBSixFQUE2QztBQUNuRGd2QyxjQUFVLENBQUMsQ0FBWDtBQUNBQyxjQUFVLENBQVY7QUFDQSxJQUhNLE1BR0EsSUFBSWw4QyxPQUFPaU4sUUFBUCxDQUFnQixzQkFBaEIsQ0FBSixFQUE2QztBQUNuRGd2QyxjQUFVLENBQVY7QUFDQUMsY0FBVSxDQUFDLENBQVg7QUFDQSxJQUhNLE1BR0EsSUFBSWw4QyxPQUFPaU4sUUFBUCxDQUFnQixzQkFBaEIsQ0FBSixFQUE2QztBQUNuRGd2QyxjQUFVLENBQUMsQ0FBWDtBQUNBQyxjQUFVLENBQUMsQ0FBWDtBQUNBOztBQUVEO0FBQ0EsT0FBTTdFLGNBQ0wsZ0JBQ0MsQ0FBQyxDQUFDNkUsT0FBRixHQUFZLEdBQVosR0FBa0IsR0FEbkIsS0FFQyxDQUFDLENBQUNELE9BQUYsR0FBWSxHQUFaLEdBQWtCLEdBRm5CLENBREQ7O0FBS0E7QUFDQWxoRCxVQUFPdUUsSUFBUCxDQUFZLGNBQVo7O0FBRUE7QUFDQXM0QyxxQkFBa0IsV0FBbEIsRUFBK0JDLFdBQS9CLEVBQTRDVCxTQUE1Qzs7QUFFQTtBQUNBUSxxQkFBa0IsU0FBbEIsRUFBNkJFLFNBQTdCLEVBQXdDVixTQUF4Qzs7QUFFQTtBQUNBOTZDLFlBQVNVLFFBQVQsQ0FBa0JxNkMsV0FBbEI7O0FBRUE7QUFDQTdHLFdBQVF4ekMsUUFBUixDQUFpQixvQkFBakI7O0FBRUE7QUFDQTtBQUNBLFlBQVM0NkMsaUJBQVQsQ0FBMkIzdUMsSUFBM0IsRUFBaUNuRSxRQUFqQyxFQUEyQ2l6QyxVQUEzQyxFQUF1RDtBQUN0RCxRQUFNQyxZQUFZaDlDLFNBQVNvRCxRQUEzQjs7QUFFQSxRQUFNZzVDLFlBQVksRUFBbEI7O0FBRUEsUUFBSSxDQUFDVCxJQUFJeGIsTUFBSixDQUFXNmMsU0FBWCxDQUFMLEVBQ0NaLFVBQVV6d0MsSUFBVixDQUFlcXhDLFVBQVV0NUMsRUFBVixDQUFhdUssSUFBYixFQUFtQm5FLFFBQW5CLENBQWY7O0FBRURzeUMsY0FBVXp3QyxJQUFWLENBQWVnd0MsSUFBSWo0QyxFQUFKLENBQU91SyxJQUFQLEVBQWFuRSxRQUFiLENBQWY7O0FBRUEsUUFBSWl6QyxVQUFKLEVBQWdCO0FBQ2YsVUFBSyxJQUFJcDdDLElBQUl5NkMsVUFBVXg2QyxNQUF2QixFQUErQkQsR0FBL0I7QUFDQ283QyxpQkFBV3B4QyxJQUFYLENBQWdCeXdDLFVBQVUveEIsR0FBVixFQUFoQjtBQUREO0FBRUE7QUFDRDs7QUFFRDtBQUNBLFlBQVM4MkIsU0FBVCxHQUFxQjtBQUNwQjVFLGVBQVdMLGFBQWErRSxVQUFVdkUsU0FBbEM7QUFDQUYsZ0JBQVkzckMsS0FBSzI5QixLQUFMLENBQVcrTixXQUFXcE0sS0FBdEIsQ0FBWjtBQUNBOztBQUVEO0FBQ0EsWUFBU2lSLFNBQVQsR0FBcUI7QUFDcEI1RSxnQkFBWUwsY0FBYytFLFVBQVV2RSxTQUFwQztBQUNBSixlQUFXMXJDLEtBQUsyOUIsS0FBTCxDQUFXZ08sWUFBWXJNLEtBQXZCLENBQVg7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVMwTSxXQUFULENBQXFCZCxHQUFyQixFQUEwQjtBQUN6Qk8sZ0JBQVlQLElBQUlqNEMsSUFBSixDQUFTVCxDQUFyQjs7QUFFQTtBQUNBcTVDLGdCQUFZSixVQUFVTixPQUFWLEdBQW9CcFosTUFBaEM7QUFDQStaLGdCQUFZOVosU0FBU3laLFVBQVVMLE9BQS9COztBQUVBO0FBQ0EsUUFBSWdGLFdBQVcsQ0FBZixFQUFrQjtBQUNqQixTQUFJdkUsYUFBYSxDQUFqQixFQUFvQjtBQUNuQjBFO0FBQ0EsTUFGRCxNQUVPO0FBQ05EO0FBQ0E7QUFDRDtBQUNEO0FBUEEsU0FRSztBQUNKLFVBQUl6RSxhQUFhLENBQWpCLEVBQW9CO0FBQ25CeUU7QUFDQSxPQUZELE1BRU87QUFDTkM7QUFDQTtBQUNEOztBQUVEO0FBQ0E7QUFDQSxRQUFJN0UsWUFBWSxFQUFaLElBQWtCQyxhQUFhLEVBQW5DLEVBQXVDO0FBQ3RDeGlDLFdBQU0zVyxDQUFOLENBQVF1TCxLQUFSLENBQWNxQixLQUFkLEdBQXNCc3NDLFdBQVcsSUFBakM7QUFDQXZpQyxXQUFNM1csQ0FBTixDQUFRdUwsS0FBUixDQUFjdUUsTUFBZCxHQUF1QnFwQyxZQUFZLElBQW5DOztBQUVBQyxrQkFBYSxJQUFiO0FBQ0EsS0FMRCxNQUtPO0FBQ05BLGtCQUFhLEtBQWI7QUFDQTtBQUNEOztBQUVELFlBQVNLLFNBQVQsR0FBcUI7QUFDcEIsUUFBSUcsVUFBSjs7QUFFQSxXQUFRQSxJQUFJYixVQUFVL3hCLEdBQVYsRUFBWjtBQUE4QjR5QixPQUFFaFMsY0FBRjtBQUE5QixLQUhvQixDQUtwQjtBQUNBM3BDLGFBQVN3QixXQUFULENBQXFCdTVDLFdBQXJCOztBQUVBO0FBQ0E3RyxZQUFRMXlDLFdBQVIsQ0FBb0Isb0JBQXBCOztBQUVBLFFBQUkyNUMsVUFBSixFQUFnQjtBQUNmZixZQUFPMUQsT0FBUCxDQUFlO0FBQ2Q3a0MsY0FBUXFwQyxTQURNO0FBRWR2c0MsYUFBT3NzQztBQUZPLE1BQWY7O0FBS0E7QUFDQXg4QyxZQUFPdUUsSUFBUCxDQUFZLGNBQVo7QUFDQTs7QUFFRDtBQUNBbTRDLGlCQUFhLEtBQWI7QUFDQTtBQUNELEdBdExEO0FBdUxBOztBQUVEOzs7Ozs7QUFNQSxLQUFNNEUsd0JBQXdCLFNBQXhCQSxxQkFBd0IsQ0FBUzNGLE1BQVQsRUFBaUI0RixjQUFqQixFQUFpQztBQUM5RCxNQUFJQSxtQkFBbUIsTUFBbkIsSUFBNkJBLG1CQUFtQixPQUFwRCxFQUE2RDtBQUM1RDVGLFVBQU83RCxPQUFQLENBQWV0cUMsV0FBZixDQUEyQixPQUEzQjtBQUNBLEdBRkQsTUFFTyxJQUFJK3pDLG1CQUFtQixRQUF2QixFQUFpQztBQUN2QzVGLFVBQU8zN0MsTUFBUCxDQUFjZ08sV0FBZCxDQUEwQixhQUExQjtBQUNBMnRDLFVBQU8zN0MsTUFBUCxDQUFjZ08sV0FBZCxDQUEwQixhQUExQjtBQUNBO0FBQ0QsRUFQRDs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVMwdkMsc0JBQVQsQ0FBZ0MxOUMsTUFBaEMsRUFBd0M7QUFDdkMsTUFBTXdoRCxnQkFBZ0IsRUFBdEI7O0FBRUEsTUFBSUMsZ0JBQUo7O0FBRUEsU0FBTyxVQUFTejhDLEtBQVQsRUFBZ0I7QUFDdEIsT0FBTTRJLFVBQVU1TixPQUFPNk4sVUFBUCxDQUFrQixZQUFZN0ksS0FBOUIsQ0FBaEI7O0FBRUE7QUFDQSxPQUFJLENBQUM0SSxPQUFMLEVBQWM7O0FBRWQ7QUFDQTtBQUNBNHpDLGlCQUFjNTFDLElBQWQsQ0FBbUIsWUFBTTtBQUN4QmdDLFlBQVE4ekMsT0FBUixDQUFnQjFoRCxNQUFoQixFQUF3QkEsT0FBTzBFLFdBQVAsRUFBeEI7QUFDQSxJQUZEOztBQUlBLE9BQUlNLFNBQVMsRUFBQ21NLE9BQU8sQ0FBUixFQUFXcEIsTUFBTSxDQUFqQixFQUFvQjZtQyxRQUFRLENBQTVCLEVBQWIsRUFBNkM7QUFDNUNocEMsWUFBUWpLLEVBQVIsQ0FBVyxNQUFYLEVBQW1CLGVBQU87QUFDekIsU0FBTWc0QyxTQUFTZ0csaUJBQWlCM2hELE1BQWpCLENBQWY7O0FBRUEsU0FBSTI3QyxNQUFKLEVBQVk7QUFDWCxVQUFJQSxPQUFPNTNDLElBQVAsQ0FBWWcwQyxLQUFaLEtBQXNCL3lDLEtBQTFCLEVBQWlDO0FBQ2hDczhDLDZCQUFzQjNGLE1BQXRCLEVBQThCMzJDLEtBQTlCOztBQUVBLGNBQU8yMkMsT0FBTzUzQyxJQUFQLENBQVlnMEMsS0FBbkI7QUFDQSxPQUpELE1BSU87QUFDTjRELGNBQU8xRCxPQUFQLENBQWUsT0FBZixFQUF3Qmp6QyxLQUF4QjtBQUNBOztBQUVEO0FBQ0E7QUFDQSxXQUFLLElBQUlwRCxJQUFJNC9DLGNBQWMzL0MsTUFBM0IsRUFBbUNELEdBQW5DO0FBQ0M0L0MscUJBQWM1L0MsQ0FBZDtBQURELE9BR0FvNkMsSUFBSW5TLE1BQUo7QUFDQTtBQUNELEtBbkJEO0FBb0JBOztBQUVEajhCLFdBQVFqSyxFQUFSLENBQVcsU0FBWCxFQUFzQixVQUFTcTRDLEdBQVQsRUFBYztBQUNuQyxRQUFNTCxTQUFTZ0csaUJBQWlCM2hELE1BQWpCLENBQWY7O0FBRUEsUUFBTTRoRCxVQUFVLEVBQUN6d0MsT0FBTyxDQUFSLEVBQVdwQixNQUFNLENBQWpCLEVBQW9CNm1DLFFBQVEsQ0FBNUIsRUFBaEI7O0FBRUEsUUFBSSxDQUFDK0UsTUFBTCxFQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFFBQUk4RixZQUFZNTZDLFNBQWhCLEVBQ0M0NkMsVUFBVXpoRCxPQUFPeVUsTUFBUCxDQUFjK2pDLFlBQWQsQ0FDVHg0QyxPQUFPazNDLE9BQVAsQ0FBZTJLLFVBQWYsQ0FBMEI1bkMsS0FBMUIsQ0FBZ0NzK0IsUUFBaEMsQ0FBeUNSLEtBRGhDLENBQVY7O0FBSUQ7QUFDQSxRQUFJLENBQUMwSixPQUFMLEVBQWMsS0FBS2hzQyxRQUFMLENBQWN4VixTQUFTODdCLGlCQUF2QixFQUFkLEtBQ0s7QUFDSixVQUFLdG1CLFFBQUwsQ0FDQ2ttQyxPQUFPNTNDLElBQVAsQ0FBWWcwQyxLQUFaLElBQXFCL3lDLEtBQXJCLEdBQ0cvRSxTQUFTOE4sV0FEWixHQUVHL0ksU0FBUzQ4QyxPQUFULEdBQ0EzaEQsU0FBUzgrQyxZQURULEdBRUE5K0MsU0FBUzg3QixpQkFMYjtBQU9BOztBQUVEaWdCLFFBQUluUyxNQUFKO0FBQ0EsSUE1QkQ7QUE2QkEsR0FoRUQ7QUFpRUE7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM4WCxnQkFBVCxDQUEwQjNoRCxNQUExQixFQUFrQztBQUNqQyxNQUFNMjdDLFNBQVMzN0MsT0FBT2szQyxPQUFQLENBQWU2RyxPQUE5Qjs7QUFFQSxNQUFJcEMsVUFBVUEsT0FBT3p0QyxJQUFQLElBQWUsT0FBN0IsRUFBc0MsT0FBT3l0QyxNQUFQOztBQUV0QyxTQUFPLElBQVA7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTdEQsdUJBQVQsQ0FBaUNyNEMsTUFBakMsRUFBeUM7QUFDeEMsTUFBTW8zQyxlQUFlcDNDLE9BQU9ULE1BQVAsQ0FBY28rQywrQkFBbkM7O0FBRUEsTUFBTU4sUUFBUTtBQUNiO0FBQ0EvQixRQUFLO0FBQ0o3eEMsV0FBT2d4QyxxQkFBcUJ6NkMsTUFBckI7QUFESCxJQUZRO0FBS2J1N0MsTUFBRztBQUNGOXhDLFdBQU9neEMscUJBQXFCejZDLE1BQXJCO0FBREwsSUFMVTtBQVFicTZDLFFBQUs7QUFDSnQxQyxnQkFBWTtBQURSLElBUlE7QUFXYjIxQyxXQUFRO0FBQ1A5QixhQUFTLE1BQU01NEMsT0FBT1QsTUFBUCxDQUFjcStDO0FBRHRCLElBWEs7QUFjYk4sZUFBWTtBQWRDLEdBQWQ7O0FBaUJBLE1BQUlsRyxZQUFKLEVBQWtCO0FBQ2pCO0FBQ0FpRyxTQUFNL0IsR0FBTixDQUFVMUMsT0FBVixHQUFvQnhCLGFBQWEsQ0FBYixDQUFwQjtBQUNBaUcsU0FBTTlCLENBQU4sQ0FBUTNDLE9BQVIsR0FBa0J5RSxNQUFNL0IsR0FBTixDQUFVMUMsT0FBNUI7O0FBRUE7QUFDQXlFLFNBQU1oRCxHQUFOLENBQVV6QixPQUFWLEdBQW9CeEIsYUFBYSxDQUFiLElBQWtCLEdBQWxCLEdBQXdCQSxhQUFhLENBQWIsQ0FBNUM7QUFDQWlHLFNBQU0zQyxNQUFOLENBQWE5QixPQUFiLElBQXdCLE1BQU15RSxNQUFNaEQsR0FBTixDQUFVekIsT0FBeEM7QUFDQSxHQVJELE1BUU87QUFDTjtBQUNBeUUsU0FBTS9CLEdBQU4sQ0FBVXB6QyxNQUFWLEdBQW1CLFlBQW5CO0FBQ0FtMUMsU0FBTTlCLENBQU4sQ0FBUXJ6QyxNQUFSLEdBQWlCLFlBQWpCOztBQUVBbTFDLFNBQU1oRCxHQUFOLENBQVVueUMsTUFBVixHQUFtQixPQUFuQjtBQUNBbTFDLFNBQU0zQyxNQUFOLENBQWF4eUMsTUFBYixHQUFzQixlQUF0QjtBQUNBOztBQUVELFNBQU9tMUMsS0FBUDtBQUNBOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBU2pFLGlCQUFULENBQTJCcDVDLE1BQTNCLEVBQW1DO0FBQ2xDLE1BQU1vM0MsZUFBZXAzQyxPQUFPVCxNQUFQLENBQWNvK0MsK0JBQW5DOztBQUVBLE1BQU1wRixXQUFXO0FBQ2hCTSxjQUFXO0FBQ1ZjLHFCQUFpQjtBQURQLElBREs7QUFJaEI1QixVQUFPO0FBQ040QixxQkFDQyxTQUNDdkMsZUFBZSxNQUFNQSxhQUFhLENBQWIsQ0FBTixHQUF3QixHQUF2QyxHQUE2QyxTQUQ5QztBQUZLLElBSlM7QUFTaEJPLFlBQVM7QUFDUmdDLHFCQUFpQjtBQURUO0FBVE8sR0FBakI7O0FBY0EsU0FBT3BCLFFBQVA7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTSCxtQkFBVCxDQUE2QnVELE1BQTdCLEVBQXFDO0FBQ3BDLFNBQU9BLE9BQU81M0MsSUFBUCxDQUFZMnpDLFVBQVosR0FBeUJpRSxPQUFPNzFDLE9BQWhDLEdBQTBDNjFDLE9BQU9weEMsS0FBUCxDQUFhMFAsS0FBOUQ7QUFDQTtBQUNELENBeHBERDs7QUEwcERBOzs7Ozs7Ozs7Ozs7QUFZQWhhLFNBQVNWLE1BQVQsQ0FBZ0JxK0MsaUNBQWhCLEdBQW9ELE9BQXBELEM7Ozs7Ozs7Ozs7Ozs7O0FDM3FEQTs7QUFFQTtBQUNBLElBQUksQ0FBQzM5QyxTQUFTcW5CLE9BQVQsQ0FBaUJ4bkIsR0FBakIsQ0FBcUIsVUFBckIsQ0FBTCxFQUF1QztBQUN0QyxLQUFNZ2lELGFBQWEsU0FBbkI7O0FBRUEsS0FBTUMscUJBQXFCLFVBQTNCOztBQUVBOWhELFVBQVMraEQsd0JBQVQsR0FDQyxpRUFERDtBQUVBL2hELFVBQVNnaUQsMkJBQVQsR0FDQyx1Q0FERDtBQUVBaGlELFVBQVNpaUQsaUNBQVQsR0FBNkMsMkJBQTdDO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBamlELFVBQVNxbkIsT0FBVCxDQUFpQnZmLEdBQWpCLENBQXFCLFVBQXJCLEVBQWlDO0FBQ2hDNnlCLFlBQVUsUUFEc0I7QUFFaENnRSxNQUZnQyxnQkFFM0I1K0IsTUFGMkIsRUFFbkI7QUFDWixPQUFNbWlELG1CQUFtQixJQUFJbGlELFNBQVNrMkIsUUFBYixDQUN4Qm4yQixPQUFPVCxNQUFQLENBQWM2aUQsZ0JBQWQsSUFDQ25pRCxTQUFTK2hELHdCQUZjLENBQXpCO0FBSUEsT0FBTUssc0JBQXNCLElBQUlwaUQsU0FBU2syQixRQUFiLENBQzNCbjJCLE9BQU9ULE1BQVAsQ0FBYytpRCxjQUFkLElBQ0NyaUQsU0FBU2dpRCwyQkFGaUIsQ0FBNUI7QUFJQSxPQUFNTSw0QkFBNEIsSUFBSXRpRCxTQUFTazJCLFFBQWIsQ0FDakNuMkIsT0FBT1QsTUFBUCxDQUFjaWpELG1CQUFkLElBQ0N2aUQsU0FBU2lpRCxpQ0FGdUIsQ0FBbEM7O0FBS0E7QUFDQTtBQUNBLE9BQU1PLDZCQUE2QixTQUE3QkEsMEJBQTZCLENBQVMzOEMsT0FBVCxFQUFrQi9CLElBQWxCLEVBQXdCO0FBQzFELFFBQ0MrQixRQUFRb0ksSUFBUixLQUFpQixLQUFqQixJQUNBcEksUUFBUWYsVUFBUixDQUFtQixtQkFBbkIsQ0FGRCxFQUdFO0FBQ0RoQixVQUFLMGMsR0FBTCxHQUFXM2EsUUFBUWYsVUFBUixDQUFtQixtQkFBbkIsQ0FBWDs7QUFFQSxZQUFPLElBQVA7QUFDQTtBQUNELElBVEQ7O0FBV0E7QUFDQS9FLFVBQU9nQyxVQUFQLENBQWtCLFVBQWxCLEVBQThCO0FBQzdCcUssUUFENkIsZ0JBQ3hCck0sTUFEd0IsRUFDaEIrRCxJQURnQixFQUNWO0FBQ2xCL0QsWUFBTyt6QyxVQUFQLENBQ0NzTyxvQkFBb0JyckIsTUFBcEIsQ0FBMkI7QUFDMUJ2VyxXQUFLMWMsS0FBSzBjO0FBRGdCLE1BQTNCLENBREQ7QUFLQTtBQVA0QixJQUE5Qjs7QUFVQTtBQUNBemdCLFVBQU9rM0MsT0FBUCxDQUFlbnZDLEdBQWYsQ0FBbUIsVUFBbkIsRUFBK0I7QUFDOUIyNkMsVUFBTSxJQUR3QjtBQUU5Qi9JLHFCQUFpQix3QkFGYTs7QUFJOUI7Ozs7Ozs7O0FBUUE1MUMsUUFaOEIsZ0JBWXpCRixLQVp5QixFQVlsQjtBQUNYLFNBQU04M0MsU0FBUyxJQUFmOztBQUVBLFNBQU1sN0IsTUFBTTVjLE1BQU1FLElBQU4sQ0FBVzBjLEdBQXZCOztBQUVBLFNBQUlBLEdBQUosRUFBUztBQUNSeGdCLGVBQVN5TyxLQUFULENBQWV3NkIsS0FBZixDQUNDaVosZ0JBREQsRUFFQztBQUNDMWhDLFlBQUtraUMsbUJBQW1CbGlDLEdBQW5CO0FBRE4sT0FGRCxFQUtDLG9CQUFZO0FBQ1gsV0FBSWdwQixTQUFTcU0sSUFBYixFQUFtQjtBQUNsQixZQUNDaU0sbUJBQW1CNTJDLElBQW5CLENBQXdCcytCLFNBQVNxTSxJQUFqQyxDQURELEVBRUU7QUFDRDZGLGdCQUFPaUgsVUFBUCxDQUFrQm5pQyxHQUFsQjtBQUNBLFNBSkQsTUFJTztBQUNOazdCLGdCQUFPNzFDLE9BQVAsQ0FBZSs4QyxPQUFmLENBQXVCcFosU0FBU3FNLElBQWhDO0FBQ0E7QUFDRCxRQVJELE1BUU87QUFDTjZGLGVBQU9pSCxVQUFQLENBQWtCbmlDLEdBQWxCO0FBQ0E7QUFDRCxPQWpCRixFQWtCQyxnQkFBUTtBQUNQazdCLGNBQU9pSCxVQUFQLENBQWtCbmlDLEdBQWxCO0FBQ0EsT0FwQkY7QUFzQkE7QUFDRCxLQXpDNkI7QUEyQzlCbWlDLGNBM0M4QixzQkEyQ25CbmlDLEdBM0NtQixFQTJDZDtBQUNmLFVBQUt6Z0IsTUFBTCxDQUFZZ08sV0FBWixDQUF3QixNQUF4Qjs7QUFFQSxTQUFNODBDLFdBQVdQLDBCQUEwQnZyQixNQUExQixDQUFpQztBQUNqRHZXO0FBRGlELE1BQWpDLENBQWpCOztBQUlBLFVBQUt6Z0IsTUFBTCxDQUFZK3pDLFVBQVosQ0FBdUIrTyxRQUF2QjtBQUNBLFVBQUs5aUQsTUFBTCxDQUFZdUUsSUFBWixDQUFpQixpQkFBakIsRUFBb0MsSUFBcEM7QUFDQSxLQXBENkI7OztBQXNEOUI7Ozs7Ozs7QUFPQXMxQyxVQTdEOEIsa0JBNkR2Qi96QyxPQTdEdUIsRUE2RGQvQixJQTdEYyxFQTZEUjtBQUNyQixTQUFNZy9DLHNCQUNML2lELE9BQU9ULE1BQVAsQ0FBY3dqRCxtQkFBZCxJQUNBTiwwQkFGRDs7QUFJQSxZQUFPTSxvQkFBb0JqOUMsT0FBcEIsRUFBNkIvQixJQUE3QixDQUFQO0FBQ0E7QUFuRTZCLElBQS9COztBQXNFQTtBQUNBL0QsVUFBT3FCLElBQVAsQ0FBWSxZQUFaLEVBQTBCLFlBQU07QUFDL0JyQixXQUFPMkQsRUFBUCxDQUNDLE9BREQsRUFFQyxpQkFBUztBQUNSLFNBQU1pQixPQUFPZixNQUFNRSxJQUFOLENBQVdndUMsU0FBeEI7O0FBRUEsU0FBSStQLFdBQVczMkMsSUFBWCxDQUFnQnZHLElBQWhCLENBQUosRUFBMkI7QUFDMUJmLFlBQU11YSxJQUFOOztBQUVBcGUsYUFBT2dPLFdBQVAsQ0FBbUIsVUFBbkIsRUFBK0I7QUFDOUJ5UyxZQUFLNWMsTUFBTUUsSUFBTixDQUFXZ3VDO0FBRGMsT0FBL0I7QUFHQTtBQUNELEtBWkYsRUFhQyxJQWJELEVBY0MsSUFkRDtBQWVDO0FBQ0E7QUFDQTtBQUNBaVIsNkJBbEJEO0FBb0JBLElBckJEOztBQXVCQTtBQUNBO0FBQ0FoakQsVUFBTzJELEVBQVAsQ0FBVSxpQkFBVixFQUE2QixrQkFBVTtBQUN0QyxRQUFNSixZQUFZdkQsT0FBT29ELFlBQVAsRUFBbEI7O0FBRUEsUUFBSUcsU0FBSixFQUFlO0FBQ2QsU0FBTXVDLFVBQVV2QyxVQUFVdUosa0JBQVYsRUFBaEI7O0FBRUEsU0FBSWhILE9BQUosRUFBYTtBQUNaLFVBQU1xM0MsZ0JBQWdCcjNDLFFBQVF1VCxPQUFSLENBQ3JCLDBCQURxQixDQUF0Qjs7QUFJQSxVQUFJOGpDLGFBQUosRUFBbUI7QUFDbEIsV0FBTTFzQyxTQUFTM0ssUUFBUXV5QixhQUFSLEVBQWY7O0FBRUEsV0FBTStrQixpQkFBaUIsSUFBSW45QyxTQUFTd0UsR0FBVCxDQUFhdEIsTUFBakIsQ0FDdEJBLE1BRHNCLEVBRXJCK2dDLGlCQUZxQixFQUF2QjtBQUdBenpCLGNBQU9WLElBQVAsSUFBZXF0QyxlQUFldHRDLENBQTlCO0FBQ0FXLGNBQU9SLEdBQVAsSUFBY210QyxlQUFlcHRDLENBQTdCOztBQUVBUyxjQUFPaEIsU0FBUCxHQUFtQnhQLFNBQVMyUSx1QkFBNUI7O0FBRUE1USxjQUFPdUUsSUFBUCxDQUFZLG1CQUFaLEVBQWlDO0FBQ2hDK0wscUJBQWEsRUFEbUI7QUFFaENELHVCQUFlO0FBQ2R2SyxrQkFBU3EzQyxhQURLO0FBRWQxc0M7QUFGYztBQUZpQixRQUFqQztBQU9BO0FBQ0Q7QUFDRDtBQUNELElBaENEOztBQWtDQTtBQUNBelEsVUFBT3lVLE1BQVAsQ0FBY3d1QyxrQkFBZCxDQUFpQyxtQkFBVztBQUMzQyxRQUFJLHVCQUF1Qm45QyxRQUFRZixVQUFuQyxFQUErQztBQUM5QyxZQUFPOUUsU0FBU2lqRCxnQkFBaEI7QUFDQTtBQUNELElBSkQ7QUFLQTtBQWpMK0IsRUFBakM7QUFtTEEsQyxDQWpORDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDS0E7Ozs7OztBQUVBLElBQUksQ0FBQ2pqRCxTQUFTcW5CLE9BQVQsQ0FBaUJ4bkIsR0FBakIsQ0FBcUIsVUFBckIsQ0FBTCxFQUF1QztBQUN0QyxLQUFNZ2lELGFBQWEsU0FBbkI7O0FBRUE3aEQsVUFBU2tqRCw0QkFBVCxHQUNDLG1MQUREOztBQUdBOzs7OztBQUtBLEtBQU1DLGtCQUFrQjtBQUN2QkMsVUFBUSxRQURlO0FBRXZCQyxRQUFNLE1BRmlCO0FBR3ZCQyxTQUFPO0FBSGdCLEVBQXhCOztBQU1BOzs7OztBQUtBLEtBQU1DLGVBQWUsQ0FDcEJKLGdCQUFnQkMsTUFESSxFQUVwQkQsZ0JBQWdCRSxJQUZJLEVBR3BCRixnQkFBZ0JHLEtBSEksQ0FBckI7O0FBTUE7Ozs7O0FBS0EsS0FBTUUsdUJBQXVCLENBQzVCO0FBQ0N2MUMsUUFBTSxTQURQO0FBRUNsSixTQUFPO0FBRlIsRUFENEIsRUFLNUI7QUFDQ2tKLFFBQU0sYUFEUDtBQUVDbEosU0FBTztBQUZSLEVBTDRCLEVBUzVCO0FBQ0NrSixRQUFNLGNBRFA7QUFFQ2xKLFNBQU87QUFGUixFQVQ0QixDQUE3Qjs7QUFlQTs7Ozs7OztBQU9BLEtBQU0wK0Msb0JBQW9CLFNBQXBCQSxpQkFBb0IsQ0FBU3hpQyxLQUFULEVBQWdCO0FBQ3pDLE1BQUl5aUMsaUJBQWlCemlDLE1BQU01VCxRQUFOLENBQWUsT0FBZixDQUFyQjs7QUFFQSxNQUNDLENBQUNxMkMsY0FBRCxJQUNBQSxtQkFBbUIsU0FEbkIsSUFFQUEsbUJBQW1CLE1BSHBCLEVBSUU7QUFDREEsb0JBQWlCemlDLE1BQU12SSxZQUFOLENBQW1CLE9BQW5CLENBQWpCO0FBQ0E7O0FBRUQsTUFBSSxDQUFDZ3JDLGNBQUwsRUFBcUI7QUFDcEIsT0FBTUMsZ0JBQWdCSCxxQkFBcUJJLEtBQXJCLENBQTJCLGlCQUFTO0FBQ3pELFFBQUlDLGFBQWE1aUMsTUFBTTVULFFBQU4sQ0FBZXVCLE1BQU1YLElBQXJCLE1BQStCVyxNQUFNN0osS0FBdEQ7O0FBRUEsUUFBSSxDQUFDOCtDLFVBQUQsSUFBZWoxQyxNQUFNazFDLGNBQXpCLEVBQXlDO0FBQ3hDRCxrQkFBYWoxQyxNQUFNazFDLGNBQU4sQ0FBcUIvcUMsSUFBckIsQ0FDWjtBQUFBLGFBQ0NrSSxNQUFNNVQsUUFBTixDQUFlMDJDLGVBQWVuMUMsTUFBTVgsSUFBcEMsTUFDQVcsTUFBTTdKLEtBRlA7QUFBQSxNQURZLENBQWI7QUFLQTs7QUFFRCxXQUFPOCtDLFVBQVA7QUFDQSxJQVpxQixDQUF0Qjs7QUFjQUgsb0JBQWlCQyxnQkFBZ0JSLGdCQUFnQkMsTUFBaEMsR0FBeUMsSUFBMUQ7QUFDQTs7QUFFRCxTQUFPTSxjQUFQO0FBQ0EsRUE5QkQ7O0FBZ0NBOzs7Ozs7O0FBT0EsS0FBTU0sdUJBQXVCLFNBQXZCQSxvQkFBdUIsQ0FBUy9pQyxLQUFULEVBQWdCeWlDLGNBQWhCLEVBQWdDO0FBQzVELE1BQ0NBLG1CQUFtQlAsZ0JBQWdCRSxJQUFuQyxJQUNBSyxtQkFBbUJQLGdCQUFnQkcsS0FGcEMsRUFHRTtBQUNEcmlDLFNBQU0xVCxXQUFOLENBQWtCLE9BQWxCOztBQUVBLE9BQUltMkMsbUJBQW1CRCxrQkFBa0J4aUMsS0FBbEIsQ0FBdkIsRUFBaUQ7QUFDaERBLFVBQU00bkIsZUFBTixDQUFzQixPQUF0QjtBQUNBO0FBQ0QsR0FURCxNQVNPLElBQUk2YSxtQkFBbUJQLGdCQUFnQkMsTUFBdkMsRUFBK0M7QUFDckRJLHdCQUFxQmhyQyxPQUFyQixDQUE2QixpQkFBUztBQUNyQ3lJLFVBQU0xVCxXQUFOLENBQWtCcUIsTUFBTVgsSUFBeEI7O0FBRUEsUUFBSVcsTUFBTWsxQyxjQUFWLEVBQTBCO0FBQ3pCbDFDLFdBQU1rMUMsY0FBTixDQUFxQnRyQyxPQUFyQixDQUE2QjtBQUFBLGFBQzVCeUksTUFBTTFULFdBQU4sQ0FBa0J3MkMsZUFBZW4xQyxNQUFNWCxJQUF2QyxDQUQ0QjtBQUFBLE1BQTdCO0FBR0E7QUFDRCxJQVJEO0FBU0E7QUFDRCxFQXJCRDs7QUF1QkE7Ozs7Ozs7QUFPQSxLQUFNZzJDLG9CQUFvQixTQUFwQkEsaUJBQW9CLENBQVNoakMsS0FBVCxFQUFnQnlpQyxjQUFoQixFQUFnQztBQUN6RE0sdUJBQXFCL2lDLEtBQXJCLEVBQTRCd2lDLGtCQUFrQnhpQyxLQUFsQixDQUE1Qjs7QUFFQSxNQUNDeWlDLG1CQUFtQlAsZ0JBQWdCRSxJQUFuQyxJQUNBSyxtQkFBbUJQLGdCQUFnQkcsS0FGcEMsRUFHRTtBQUNEcmlDLFNBQU11K0IsUUFBTixDQUFlLE9BQWYsRUFBd0JrRSxjQUF4QjtBQUNBLEdBTEQsTUFLTyxJQUFJQSxtQkFBbUJQLGdCQUFnQkMsTUFBdkMsRUFBK0M7QUFDckRJLHdCQUFxQmhyQyxPQUFyQixDQUE2QixpQkFBUztBQUNyQ3lJLFVBQU11K0IsUUFBTixDQUFlNXdDLE1BQU1YLElBQXJCLEVBQTJCVyxNQUFNN0osS0FBakM7O0FBRUEsUUFBSTZKLE1BQU1rMUMsY0FBVixFQUEwQjtBQUN6QmwxQyxXQUFNazFDLGNBQU4sQ0FBcUJ0ckMsT0FBckIsQ0FBNkI7QUFBQSxhQUM1QnlJLE1BQU11K0IsUUFBTixDQUFldUUsZUFBZW4xQyxNQUFNWCxJQUFwQyxFQUEwQ1csTUFBTTdKLEtBQWhELENBRDRCO0FBQUEsTUFBN0I7QUFHQTtBQUNELElBUkQ7QUFTQTtBQUNELEVBbkJEOztBQXFCQSxLQUFNOEgscUJBQXFCLFNBQXJCQSxrQkFBcUIsQ0FBUzlNLE1BQVQsRUFBaUI7QUFDM0MsTUFBTXFrQixTQUFTO0FBQ2RnRyxjQUFXLElBREc7QUFFZHZrQixZQUFTO0FBRkssR0FBZjs7QUFLQSxNQUFNdkMsWUFBWXZELE9BQU9vRCxZQUFQLEVBQWxCOztBQUVBLE1BQUlHLFNBQUosRUFBZTtBQUNkLE9BQU1zSixrQkFBa0J0SixVQUFVdUosa0JBQVYsRUFBeEI7O0FBRUEsT0FDQ0QsbUJBQ0FBLGdCQUFnQjhMLFlBQWhCLENBQTZCLHlCQUE3QixDQUZELEVBR0U7QUFDRDBMLFdBQU9nRyxTQUFQLEdBQW1CcTVCLGtCQUFrQjcyQyxlQUFsQixDQUFuQjtBQUNBd1gsV0FBT3ZlLE9BQVAsR0FBaUIrRyxlQUFqQjtBQUNBO0FBQ0Q7O0FBRUQsU0FBT3dYLE1BQVA7QUFDQSxFQXJCRDs7QUF1QkEsS0FBTTJ4QixnQkFBZ0IsU0FBaEJBLGFBQWdCLENBQVM5NEIsRUFBVCxFQUFhaE4sS0FBYixFQUFvQmtELE1BQXBCLEVBQTRCO0FBQ2pELE1BQU0rd0MsaUJBQWlCam5DLEdBQUdrbkMsYUFBMUI7O0FBRUEsTUFBSUQsa0JBQWtCajBDLFFBQVEsQ0FBMUIsSUFBK0JrRCxTQUFTLENBQTVDLEVBQStDO0FBQzlDLE9BQU15N0IsT0FBT3NWLGVBQWVyVixxQkFBZixFQUFiOztBQUVBLE9BQU11VixTQUNMbjBDLFNBQVMyK0IsS0FBSzMrQixLQUFkLEdBQ0csR0FESCxHQUVHWSxLQUFLMm5CLEtBQUwsQ0FBWXZvQixRQUFRMitCLEtBQUszK0IsS0FBZCxHQUF1QixHQUFsQyxDQUhKO0FBSUEsT0FBTXJCLG1CQUFpQncxQyxNQUFqQixPQUFOOztBQUVBRixrQkFBZXBrRCxZQUFmLENBQTRCLE9BQTVCLEVBQXFDOE8sS0FBckM7O0FBRUEsT0FBTXN1QyxnQkFBZ0JnSCxlQUFlekQsYUFBZixDQUNyQiwwQkFEcUIsQ0FBdEI7O0FBSUEsT0FBSXZELGFBQUosRUFBbUI7QUFDbEIsUUFBTWoxQyxTQUNMbzhDLEtBQUtDLEtBQUwsQ0FBV3BILGNBQWN4a0MsWUFBZCxDQUEyQixhQUEzQixDQUFYLEtBQXlELEVBRDFEOztBQUdBelEsV0FBT2dJLEtBQVAsR0FBa0JBLEtBQWxCO0FBQ0FoSSxXQUFPa0wsTUFBUCxHQUFtQkEsTUFBbkI7O0FBRUErcEMsa0JBQWNwOUMsWUFBZCxDQUNDLGFBREQsRUFFQ3VrRCxLQUFLRSxTQUFMLENBQWV0OEMsTUFBZixDQUZEOztBQUtBLFFBQU11OEMsZ0JBQWdCdEgsY0FBY3VELGFBQWQsQ0FBNEIsUUFBNUIsQ0FBdEI7O0FBRUEsUUFBSStELGFBQUosRUFBbUI7QUFDbEJBLG1CQUFjMWtELFlBQWQsQ0FBMkIsT0FBM0IsRUFBb0NtUSxLQUFwQztBQUNBdTBDLG1CQUFjMWtELFlBQWQsQ0FBMkIsUUFBM0IsRUFBcUNxVCxNQUFyQztBQUNBO0FBQ0Q7QUFDRDtBQUNELEVBdENEOztBQXdDQSxLQUFNc3hDLGVBQWUsU0FBZkEsWUFBZSxDQUFTMWtELE1BQVQsRUFBaUI7QUFDckNpSyxhQUFXLFlBQU07QUFDaEIsT0FBTTFHLFlBQVl2RCxPQUFPb0QsWUFBUCxFQUFsQjs7QUFFQSxPQUFJRyxTQUFKLEVBQWU7QUFDZCxRQUFNNGdELGlCQUFpQjVnRCxVQUFVb2hELElBQVYsQ0FBZUMsSUFBZixDQUN0QiwyQkFEc0IsQ0FBdkI7O0FBSUEsUUFBSVQsY0FBSixFQUFvQjtBQUNuQixTQUFNVSxjQUFjVixlQUFlN2dELENBQW5DO0FBQ0EsU0FBSXVoRCxZQUFZaGpELE1BQVosR0FBcUIsQ0FBekIsRUFBNEI7QUFDM0IsVUFBTWdELGNBQWMsSUFBSTVFLFNBQVN3RSxHQUFULENBQWFxQixPQUFqQixDQUNuQisrQyxZQUFZQSxZQUFZaGpELE1BQVosR0FBcUIsQ0FBakMsQ0FEbUIsQ0FBcEI7O0FBSUEsVUFBTXVYLGVBQWV2VSxZQUFZd1UsT0FBWixDQUFvQixLQUFwQixDQUFyQjtBQUNBLFVBQU04akMsZ0JBQWdCdDRDLFlBQVl3VSxPQUFaLENBQ3JCLDBCQURxQixDQUF0Qjs7QUFJQSxVQUFJRCxnQkFBZ0IrakMsYUFBcEIsRUFBbUM7QUFDbEMsV0FBTXp3QyxRQUFRMU0sT0FBT3dqQyxXQUFQLEVBQWQ7O0FBRUE5MkIsYUFBTUMsUUFBTixDQUFld3dDLGFBQWYsRUFBOEIsQ0FBOUI7QUFDQXp3QyxhQUFNRSxNQUFOLENBQWF3TSxZQUFiLEVBQTJCLENBQTNCOztBQUVBN1YsaUJBQVUySixZQUFWLENBQXVCLENBQUNSLEtBQUQsQ0FBdkI7QUFDQW5KLGlCQUFVaStCLGFBQVYsQ0FBd0IzOEIsV0FBeEI7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQUNELEdBaENELEVBZ0NHLENBaENIO0FBaUNBLEVBbENEOztBQW9DQSxLQUFJaWdELG1CQUFtQixJQUF2QjtBQUNBLEtBQUlDLGlCQUFpQixJQUFyQjtBQUNBLEtBQUl0UCxVQUFVLElBQWQ7O0FBRUE7Ozs7Ozs7OztBQVNBeDFDLFVBQVNxbkIsT0FBVCxDQUFpQnZmLEdBQWpCLENBQXFCLFVBQXJCLEVBQWlDO0FBQ2hDNnlCLFlBQVUsUUFEc0I7O0FBR2hDZ0UsUUFBTSxzQkFBVTtBQUNmLE9BQU1vbUIsdUJBQXVCLElBQUkva0QsU0FBU2syQixRQUFiLENBQzVCbjJCLE9BQU9ULE1BQVAsQ0FBYytpRCxjQUFkLElBQ0NyaUQsU0FBU2tqRCw0QkFGa0IsQ0FBN0I7O0FBS0EsT0FBSThCLFlBQVlqbEQsT0FBT1QsTUFBUCxDQUFjZ0IsY0FBZCxJQUFnQyxFQUFoRDs7QUFFQTBrRCxlQUFZQSxVQUFVdndDLEdBQVYsQ0FBYyxvQkFBWTtBQUNyQyxXQUFPO0FBQ04xTixTQUFJaytDLFNBQVNsK0MsRUFEUDtBQUVOQyxVQUFLLElBQUloSCxTQUFTazJCLFFBQWIscUNBQzhCK3VCLFNBQVNqK0MsR0FEdkMsWUFGQztBQUtOQyxXQUFNZytDLFNBQVNoK0MsSUFMVDtBQU1OQyxpQkFBWSs5QyxTQUFTLzlDLFVBQVQsQ0FBb0J1TixHQUFwQixDQUNYO0FBQUEsYUFBVSxJQUFJczlCLE1BQUosQ0FBV21ULE1BQVgsQ0FBVjtBQUFBLE1BRFc7QUFOTixLQUFQO0FBVUEsSUFYVyxDQUFaOztBQWFBLE9BQU1DLHVCQUF1QixTQUF2QkEsb0JBQXVCLENBQUMza0MsR0FBRCxFQUFNd3lCLE9BQU4sRUFBa0I7QUFDOUMsV0FBTytSLHFCQUFxQmh1QixNQUFyQixDQUE0QjtBQUNsQ2ljLHFCQURrQztBQUVsQ29TLGtCQUFhbGpELFlBQVk2SCxPQUFaLENBQW9CczdDLHFCQUZDO0FBR2xDQyxzQkFBaUJDLFFBQVFDLElBQVIsQ0FBYUMsaUJBQWIsQ0FDaEIsYUFEZ0IsQ0FIaUI7QUFNbENqbEM7QUFOa0MsS0FBNUIsQ0FBUDtBQVFBLElBVEQ7O0FBV0EsT0FBTWdpQyw2QkFBNkIsU0FBN0JBLDBCQUE2QixDQUFDMzhDLE9BQUQsRUFBVS9CLElBQVYsRUFBbUI7QUFDckQsUUFBSTRoRCxlQUFlLEtBQW5COztBQUVBLFFBQ0M3L0MsUUFBUW9JLElBQVIsS0FBaUIsS0FBakIsSUFDQXBJLFFBQVFmLFVBQVIsQ0FBbUIsZ0JBQW5CLENBRkQsRUFHRTtBQUNEaEIsVUFBSzBjLEdBQUwsR0FBVzNhLFFBQVFmLFVBQVIsQ0FBbUIsZ0JBQW5CLENBQVg7O0FBRUE0Z0Qsb0JBQWUsSUFBZjtBQUNBLEtBUEQsTUFPTyxJQUNONy9DLFFBQVFvSSxJQUFSLEtBQWlCLEtBQWpCLElBQ0FwSSxRQUFRZixVQUFSLENBQW1CLGVBQW5CLENBRk0sRUFHTDtBQUNELFNBQU02Z0QsU0FBUzkvQyxRQUFRb2EsUUFBUixDQUFpQixDQUFqQixDQUFmOztBQUVBbmMsVUFBSzBjLEdBQUwsR0FBV21sQyxPQUFPN2dELFVBQVAsQ0FBa0IyRSxHQUE3Qjs7QUFFQSxZQUFPNUQsUUFBUWYsVUFBUixDQUFtQjhKLEtBQTFCOztBQUVBLFNBQU1nM0MsZUFBZVQscUJBQ3BCcmhELEtBQUswYyxHQURlLEVBRXBCM2EsUUFBUWdnRCxZQUFSLEVBRm9CLENBQXJCOztBQUtBLFNBQU1DLGlCQUFpQixJQUFJOWxELFNBQVNpN0MsVUFBVCxDQUFvQjhLLFFBQXBCLENBQTZCQyxRQUFqQyxDQUN0QkosWUFEc0IsQ0FBdkI7O0FBSUFGLG9CQUFlSSxlQUFlN2xDLFFBQWYsQ0FBd0IsQ0FBeEIsQ0FBZjs7QUFFQXlsQyxrQkFBYTVnRCxVQUFiLENBQXdCLGFBQXhCLElBQ0NlLFFBQVFmLFVBQVIsQ0FBbUIsYUFBbkIsQ0FERDtBQUVBNGdELGtCQUFhNWlELFdBQWIsQ0FBeUIsa0JBQXpCO0FBQ0E0aUQsa0JBQWE1aUQsV0FBYixDQUF5Qix3QkFBekI7O0FBRUErQyxhQUFRNjBDLFdBQVIsQ0FBb0JnTCxZQUFwQjtBQUNBOztBQUVELFdBQU9BLFlBQVA7QUFDQSxJQXhDRDs7QUEwQ0EsT0FBTU8sWUFBWSxTQUFaQSxTQUFZLFdBQVk7QUFDN0JsbUQsV0FBT3VFLElBQVAsQ0FBWSxPQUFaLEVBQXFCNGhELFFBQXJCOztBQUVBbDhDLGVBQVcsWUFBTTtBQUNoQmpLLFlBQU9vRCxZQUFQLEdBQXNCTSxlQUF0Qjs7QUFFQTFELFlBQU8yVixLQUFQOztBQUVBOC9CLGFBQVFoWSxJQUFSO0FBQ0EsS0FORCxFQU1HLENBTkg7QUFPQSxJQVZEOztBQVlBejlCLFVBQU9nQyxVQUFQLENBQWtCLFVBQWxCLEVBQThCO0FBQzdCcUssVUFBTSxjQUFDck0sTUFBRCxFQUFTK0QsSUFBVCxFQUFrQjtBQUN2QixTQUFNbUQsT0FBT25ELEtBQUttRCxJQUFsQjtBQUNBLFNBQU11WixNQUFNMWMsS0FBSzBjLEdBQWpCO0FBQ0EsU0FBSXd5QixnQkFBSjs7QUFFQSxTQUFJNk8sV0FBVzMyQyxJQUFYLENBQWdCc1YsR0FBaEIsQ0FBSixFQUEwQjtBQUN6QixVQUFNMmxDLGdCQUFnQm5CLFVBQ3BCeHdDLE1BRG9CLENBQ2Isb0JBQVk7QUFDbkIsY0FBT3ZOLE9BQU9nK0MsU0FBU2grQyxJQUFULEtBQWtCQSxJQUF6QixHQUFnQyxJQUF2QztBQUNBLE9BSG9CLEVBSXBCOFIsSUFKb0IsQ0FJZixvQkFBWTtBQUNqQixXQUFNbXNDLFNBQVNELFNBQVMvOUMsVUFBVCxDQUFvQnk5QyxJQUFwQixDQUNkO0FBQUEsZUFBVU8sT0FBT2g2QyxJQUFQLENBQVlzVixHQUFaLENBQVY7QUFBQSxRQURjLENBQWY7O0FBSUEsV0FBSTBrQyxNQUFKLEVBQVk7QUFDWCxZQUFNa0IsVUFBVWxCLE9BQU85NEMsSUFBUCxDQUFZb1UsR0FBWixFQUFpQixDQUFqQixDQUFoQjs7QUFFQXd5QixrQkFBVWlTLFNBQVNqK0MsR0FBVCxDQUFhK3ZCLE1BQWIsQ0FBb0I7QUFDN0JxdkI7QUFENkIsU0FBcEIsQ0FBVjtBQUdBOztBQUVELGNBQU9sQixNQUFQO0FBQ0EsT0FsQm9CLENBQXRCOztBQW9CQSxVQUFJaUIsYUFBSixFQUFtQjtBQUNsQnBtRCxjQUFPc21ELGtCQUFQLEdBQTRCN2xDLEdBQTVCOztBQUVBLFdBQU1vbEMsZUFBZVQscUJBQ3BCM2tDLEdBRG9CLEVBRXBCd3lCLE9BRm9CLENBQXJCOztBQUtBanpDLGNBQU8rekMsVUFBUCxDQUFrQjhSLFlBQWxCO0FBQ0EsT0FURCxNQVNPO0FBQ05LLGlCQUFVL2pELFlBQVk2SCxPQUFaLENBQW9CdThDLG9CQUE5QjtBQUNBO0FBQ0QsTUFqQ0QsTUFpQ087QUFDTkwsZ0JBQVUvakQsWUFBWTZILE9BQVosQ0FBb0J3OEMsYUFBOUI7QUFDQTtBQUNEO0FBMUM0QixJQUE5Qjs7QUE2Q0F4bUQsVUFBT2szQyxPQUFQLENBQWVudkMsR0FBZixDQUFtQixVQUFuQixFQUErQjtBQUM5Qmt4QyxlQUFXLEtBRG1CO0FBRTlCeUosVUFBTSxJQUZ3QjtBQUc5Qi9JLHFCQUFpQixxQkFIYTs7QUFLOUI1MUMsUUFMOEIsZ0JBS3pCRixLQUx5QixFQUtsQjtBQUNYLFNBQU0rVixXQUFXLElBQWpCOztBQUVBOztBQUVBLFNBQUkxUixTQUFTLElBQWI7O0FBRUEsU0FBTXUrQyxhQUFhN3NDLFNBQVM5VCxPQUFULENBQWlCNlMsWUFBakIsQ0FDbEIsYUFEa0IsQ0FBbkI7O0FBSUEsU0FBSTh0QyxVQUFKLEVBQWdCO0FBQ2YsVUFBSTtBQUNIditDLGdCQUFTbzhDLEtBQUtDLEtBQUwsQ0FBV2tDLFVBQVgsQ0FBVDtBQUNBLE9BRkQsQ0FFRSxPQUFPQyxNQUFQLEVBQWU7QUFDaEJ4K0MsZ0JBQVMsSUFBVDtBQUNBO0FBQ0Q7O0FBRUQsU0FBSSxDQUFDQSxNQUFMLEVBQWE7QUFDWixVQUFNMDlDLFNBQVNoc0MsU0FBU2srQixPQUFULENBQWlCeitCLE9BQWpCLENBQXlCLFFBQXpCLENBQWY7O0FBRUEsVUFBTXN0QyxTQUFTL3NDLFNBQVNrK0IsT0FBVCxDQUFpQngwQyxDQUFqQixDQUFtQndyQyxxQkFBbkIsRUFBZjtBQUNBLFVBQU01K0IsUUFBUTAxQyxPQUFPanRDLFlBQVAsQ0FBb0IsT0FBcEIsQ0FBZDs7QUFFQSxVQUFNMHJDLFNBQ0xuMEMsU0FBU3kyQyxPQUFPejJDLEtBQWhCLEdBQ0csR0FESCxHQUVHWSxLQUFLMjlCLEtBQUwsQ0FBWXYrQixRQUFReTJDLE9BQU96MkMsS0FBaEIsR0FBeUIsR0FBcEMsQ0FISjs7QUFLQWhJLGVBQVM7QUFDUmdJLGNBQVVtMEMsTUFBVjtBQURRLE9BQVQ7QUFHQTs7QUFFRHpxQyxjQUFTaytCLE9BQVQsQ0FBaUIvM0MsWUFBakIsQ0FDQyxPQURELEVBRUNFLFNBQVN5TyxLQUFULENBQWUwc0MsWUFBZixDQUE0Qmx6QyxNQUE1QixDQUZEOztBQUtBLFNBQUlsSSxPQUFPc21ELGtCQUFQLEtBQThCemlELE1BQU1FLElBQU4sQ0FBVzBjLEdBQTdDLEVBQWtEO0FBQ2pEaWtDLG1CQUFhMWtELE1BQWI7QUFDQTtBQUNELEtBaEQ2QjtBQWtEOUIrNEMsWUFsRDhCLG9CQWtEckI0QyxNQWxEcUIsRUFrRGI7QUFDaEIsU0FBTWtLLGVBQWVsSyxPQUFPejdCLFFBQVAsQ0FBZ0IsQ0FBaEIsQ0FBckI7O0FBRUEybEMsa0JBQWE5Z0QsVUFBYixDQUF3QjBWLEtBQXhCLEdBQ0MseUNBREQ7O0FBR0FvckMsa0JBQWE5Z0QsVUFBYixDQUF3QixhQUF4QixJQUF5Q3UvQyxLQUFLRSxTQUFMLENBQ3hDdmtELFNBQVN5TyxLQUFULENBQWVzc0MsWUFBZixDQUNDVyxPQUFPalUsTUFBUCxDQUFjM2lDLFVBQWQsQ0FBeUI4SixLQUQxQixDQUR3QyxDQUF6Qzs7QUFNQWczQyxrQkFBYTlnRCxVQUFiLENBQXdCOEosS0FBeEIsR0FDQzhzQyxPQUFPalUsTUFBUCxDQUFjM2lDLFVBQWQsQ0FBeUI4SixLQUQxQjs7QUFHQSxZQUFPZzNDLFlBQVA7QUFDQSxLQWxFNkI7QUFvRTlCaE0sVUFwRThCLGtCQW9FdkIvekMsT0FwRXVCLEVBb0VkL0IsSUFwRWMsRUFvRVI7QUFDckIsU0FBTWcvQyxzQkFDTC9pRCxPQUFPVCxNQUFQLENBQWN3akQsbUJBQWQsSUFDQU4sMEJBRkQ7O0FBSUEsWUFBT00sb0JBQW9CajlDLE9BQXBCLEVBQTZCL0IsSUFBN0IsQ0FBUDtBQUNBO0FBMUU2QixJQUEvQjs7QUE2RUFaLFVBQU9zYSxnQkFBUCxDQUNDLFFBREQsRUFFQyxZQUFNO0FBQ0xnNEIsWUFBUWhZLElBQVI7QUFDQWluQixpQkFBYTFrRCxNQUFiO0FBQ0EsSUFMRixFQU1DLEtBTkQ7O0FBU0FBLFVBQU8yRCxFQUFQLENBQVUsaUJBQVYsRUFBNkIsa0JBQVU7QUFDdEMsUUFBTUosWUFBWXZELE9BQU9vRCxZQUFQLEVBQWxCOztBQUVBLFFBQUlHLFNBQUosRUFBZTtBQUNkLFNBQU11QyxVQUFVdkMsVUFBVXVKLGtCQUFWLEVBQWhCOztBQUVBLFNBQUloSCxPQUFKLEVBQWE7QUFDWixVQUFNcTNDLGdCQUFnQnIzQyxRQUFRdVQsT0FBUixDQUNyQiwwQkFEcUIsQ0FBdEI7O0FBSUEsVUFBSThqQyxhQUFKLEVBQW1CO0FBQ2xCLFdBQU1DLGlCQUFpQixJQUFJbjlDLFNBQVN3RSxHQUFULENBQWF0QixNQUFqQixDQUN0QkEsTUFEc0IsRUFFckIrZ0MsaUJBRnFCLEVBQXZCOztBQUlBLFdBQU16ekIsU0FBUzNLLFFBQVF1eUIsYUFBUixFQUFmOztBQUVBNW5CLGNBQU9oQixTQUFQLEdBQW1CeFAsU0FBUzJRLHVCQUE1QjtBQUNBSCxjQUFPVixJQUFQLElBQWVxdEMsZUFBZXR0QyxDQUE5QjtBQUNBVyxjQUFPUixHQUFQLElBQWNtdEMsZUFBZXB0QyxDQUE3Qjs7QUFFQWhRLGNBQU91RSxJQUFQLENBQVksbUJBQVosRUFBaUM7QUFDaEMrTCxxQkFBYSxFQURtQjtBQUVoQ0QsdUJBQWU7QUFDZHZLLGtCQUFTcTNDLGFBREs7QUFFZDFzQztBQUZjO0FBRmlCLFFBQWpDO0FBT0E7O0FBRUQsVUFBTTJJLGVBQWV0VCxRQUFRdVQsT0FBUixDQUNwQixxQkFEb0IsQ0FBckI7O0FBSUEsVUFBSUQsWUFBSixFQUFrQjtBQUNqQnE4QixlQUFReGdCLElBQVIsQ0FBYTdiLGFBQWE5VixDQUExQjtBQUNBO0FBQ0QsTUFoQ0QsTUFnQ087QUFDTm15QyxjQUFRaFksSUFBUjtBQUNBO0FBQ0Q7QUFDRCxJQTFDRDs7QUE0Q0F6OUIsVUFBTzJELEVBQVAsQ0FBVSxTQUFWLEVBQXFCLFlBQU07QUFDMUIsUUFBTXF5QyxnQkFBZ0IzeUMsU0FBUzZDLGNBQVQsQ0FBd0IsVUFBeEIsQ0FBdEI7O0FBRUEsUUFBSTh2QyxhQUFKLEVBQW1CO0FBQ2xCQSxtQkFBYzdvQyxNQUFkO0FBQ0E7O0FBRUQ5SixhQUFTNnpCLG1CQUFULENBQTZCLFdBQTdCLEVBQTBDd2UsaUJBQTFDO0FBQ0EsSUFSRDs7QUFVQTExQyxVQUFPMkQsRUFBUCxDQUFVLE1BQVYsRUFBa0IsWUFBTTtBQUN2Qjh4QyxZQUFRaFksSUFBUjtBQUNBLElBRkQ7O0FBSUF6OUIsVUFBT3lVLE1BQVAsQ0FBY3d1QyxrQkFBZCxDQUFpQyxtQkFBVztBQUMzQyxRQUFJLG9CQUFvQm45QyxRQUFRZixVQUFoQyxFQUE0QztBQUMzQyxZQUFPOUUsU0FBU2lqRCxnQkFBaEI7QUFDQTtBQUNELElBSkQ7O0FBTUEsT0FBTXhOLG9CQUFvQixTQUFwQkEsaUJBQW9CLFFBQVM7QUFDbEMsUUFBTXJ4QixTQUFTdlgsbUJBQW1COU0sTUFBbkIsQ0FBZjs7QUFFQThrRCx1QkFBbUJ6Z0MsT0FBT2dHLFNBQTFCO0FBQ0EwNkIscUJBQWlCMWdDLE9BQU92ZSxPQUF4Qjs7QUFFQSxRQUFJMnZDLFFBQVFHLFFBQVIsQ0FBaUIveEMsTUFBTW9CLE1BQXZCLENBQUosRUFBb0M7QUFDbkN3d0MsYUFBUUksUUFBUixDQUFpQmh5QyxLQUFqQjtBQUNBO0FBQ0QsSUFURDs7QUFXQTR4QyxhQUFVLElBQUl4RyxpQkFBSixDQUFZanZDLE1BQVosRUFBb0I7QUFDN0IrdEMsY0FENkIsc0JBQ2xCam9DLE9BRGtCLEVBQ1RvSyxLQURTLEVBQ0ZrRCxNQURFLEVBQ007QUFDbEM0aUMsbUJBQWNsd0MsT0FBZCxFQUF1Qm9LLEtBQXZCLEVBQThCa0QsTUFBOUI7O0FBRUEsU0FBSTB4QyxvQkFBb0JDLGNBQXhCLEVBQXdDO0FBQ3ZDYix3QkFBa0JhLGNBQWxCLEVBQWtDRCxnQkFBbEM7QUFDQTtBQUNESixrQkFBYTFrRCxNQUFiO0FBQ0E7QUFSNEIsSUFBcEIsQ0FBVjs7QUFXQXFELFlBQVNvYSxnQkFBVCxDQUEwQixXQUExQixFQUF1Q2k0QixpQkFBdkMsRUFBMEQsS0FBMUQ7QUFDQSxHQW5UK0I7O0FBcVRoQzhILGFBQVcsMkJBQVU7QUFDcEJnRyxnQkFBYS9xQyxPQUFiLENBQXFCLHNCQUFjO0FBQ2xDLFFBQU03SyxVQUFVNU4sT0FBTzZOLFVBQVAsQ0FBa0IsWUFBWSs0QyxVQUE5QixDQUFoQjs7QUFFQSxRQUFJaDVDLE9BQUosRUFBYTtBQUNaQSxhQUFRakssRUFBUixDQUFXLE1BQVgsRUFBbUIsaUJBQVM7QUFDM0IsVUFBTWtKLGtCQUFrQjdNLE9BQ3RCb0QsWUFEc0IsR0FFdEIwSixrQkFGc0IsRUFBeEI7O0FBSUEsVUFDQ0QsbUJBQ0FBLGdCQUFnQjhMLFlBQWhCLENBQ0MseUJBREQsQ0FGRCxFQUtFO0FBQ0QsV0FBTWt1QyxnQkFBZ0JoNkMsZ0JBQWdCd00sT0FBaEIsQ0FDckIsMENBRHFCLENBQXRCOztBQUlBLFdBQUl3dEMsYUFBSixFQUFtQjtBQUNsQixZQUFNbEQsaUJBQWlCRCxrQkFDdEI3MkMsZUFEc0IsQ0FBdkI7O0FBSUEsWUFBSTgyQyxtQkFBbUJpRCxVQUF2QixFQUFtQztBQUNsQzNDLDhCQUNDcDNDLGVBREQsRUFFQys1QyxVQUZEO0FBSUEsU0FMRCxNQUtPO0FBQ04xQywyQkFDQ3IzQyxlQURELEVBRUMrNUMsVUFGRDtBQUlBOztBQUVEN0IseUJBQWlCbDRDLGVBQWpCO0FBQ0FpNEMsMkJBQW1CcEIsa0JBQ2xCNzJDLGVBRGtCLENBQW5COztBQUlBLFlBQU11TSxlQUFldk0sZ0JBQWdCd00sT0FBaEIsQ0FDcEIsS0FEb0IsQ0FBckI7O0FBSUEsWUFBSUQsWUFBSixFQUFrQjtBQUNqQnE4QixpQkFBUXhnQixJQUFSLENBQWE3YixhQUFhOVYsQ0FBMUI7QUFDQTs7QUFFRE8sY0FBTWdtQyxNQUFOOztBQUVBLFlBQU1ubEMsY0FBYyxJQUFJekUsU0FBU3dFLEdBQVQsQ0FBYUMsV0FBakIsQ0FDbkJtSSxlQURtQixDQUFwQjs7QUFJQTIyQyxxQkFBYS9xQyxPQUFiLENBQXFCLHNCQUFjO0FBQ2xDLGFBQU03SyxVQUFVNU4sT0FBTzZOLFVBQVAsQ0FDZixZQUFZKzRDLFVBREcsQ0FBaEI7O0FBSUEsYUFBSWg1QyxPQUFKLEVBQWE7QUFDWkEsa0JBQVE4ekMsT0FBUixDQUFnQjFoRCxNQUFoQixFQUF3QjBFLFdBQXhCO0FBQ0E7QUFDRCxTQVJEO0FBU0E7QUFDRDtBQUNELE1BOUREOztBQWdFQWtKLGFBQVFqSyxFQUFSLENBQVcsU0FBWCxFQUFzQixpQkFBUztBQUM5QixVQUFNa0IsY0FBY2hCLE1BQU1FLElBQU4sQ0FBV3NGLElBQVgsQ0FBZ0J4RSxXQUFwQzs7QUFFQSxVQUNDQSxlQUNBQSxZQUFZOFQsWUFBWixDQUNDLHlCQURELENBREEsSUFJQTlULFlBQVl3VSxPQUFaLENBQW9CLCtCQUFwQixDQUxELEVBTUU7QUFDRCxXQUFNc3FDLGlCQUFpQkQsa0JBQ3RCNytDLFdBRHNCLENBQXZCOztBQUlBaEIsYUFBTWlqRCxNQUFOLENBQWFyeEMsUUFBYixDQUNDa3VDLG1CQUFtQmlELFVBQW5CLEdBQ0czbUQsU0FBUzhOLFdBRFosR0FFRzlOLFNBQVM4K0MsWUFIYjs7QUFNQWw3QyxhQUFNZ21DLE1BQU47QUFDQTtBQUNELE1BdEJEO0FBdUJBO0FBQ0QsSUE1RkQ7QUE2RkE7QUFuWitCLEVBQWpDO0FBcVpBLEMsQ0E3cEJEOzs7OztrQkErcEJlNXBDLFNBQVNxbkIsT0FBVCxDQUFpQnhuQixHQUFqQixDQUFxQixVQUFyQixDOzs7Ozs7Ozs7Ozs7OztBQzFwQmY7Ozs7OztrTkFMQTs7Ozs7QUFPQSxJQUFJLENBQUNHLFNBQVNxbkIsT0FBVCxDQUFpQnhuQixHQUFqQixDQUFxQixtQkFBckIsQ0FBTCxFQUFnRDtBQUFBOztBQUMvQzs7OztBQUlBLEtBQU1pbkQsa0JBQWtCO0FBQ3ZCMUQsVUFBUSxRQURlO0FBRXZCQyxRQUFNLE1BRmlCO0FBR3ZCQyxTQUFPO0FBSGdCLEVBQXhCOztBQU1BOzs7O0FBSUEsS0FBTUMsZUFBZSxDQUNwQnVELGdCQUFnQnpELElBREksRUFFcEJ5RCxnQkFBZ0J4RCxLQUZJLEVBR3BCd0QsZ0JBQWdCMUQsTUFISSxDQUFyQjs7QUFNQTs7OztBQUlBLEtBQU0yRCw0RkFDSkQsZ0JBQWdCekQsSUFEWixFQUNtQixDQUN2QjtBQUNDcDFDLFFBQU0sU0FEUDtBQUVDbEosU0FBTztBQUZSLEVBRHVCLEVBS3ZCO0FBQ0NrSixRQUFNLE9BRFA7QUFFQ2xKLFNBQU87QUFGUixFQUx1QixFQVN2QjtBQUNDa0osUUFBTSxjQURQO0FBRUNsSixTQUFPO0FBRlIsRUFUdUIsQ0FEbkIsMENBZUoraEQsZ0JBQWdCMUQsTUFmWixFQWVxQixDQUN6QjtBQUNDbjFDLFFBQU0sU0FEUDtBQUVDbEosU0FBTztBQUZSLEVBRHlCLEVBS3pCO0FBQ0NrSixRQUFNLGFBRFA7QUFFQ2xKLFNBQU87QUFGUixFQUx5QixFQVN6QjtBQUNDa0osUUFBTSxjQURQO0FBRUNsSixTQUFPO0FBRlIsRUFUeUIsQ0FmckIsMENBNkJKK2hELGdCQUFnQnhELEtBN0JaLEVBNkJvQixDQUN4QjtBQUNDcjFDLFFBQU0sU0FEUDtBQUVDbEosU0FBTztBQUZSLEVBRHdCLEVBS3hCO0FBQ0NrSixRQUFNLE9BRFA7QUFFQ2xKLFNBQU87QUFGUixFQUx3QixFQVN4QjtBQUNDa0osUUFBTSxhQURQO0FBRUNsSixTQUFPO0FBRlIsRUFUd0IsQ0E3QnBCLHlCQUFOOztBQTZDQTs7Ozs7O0FBTUEsS0FBTWlpRCxvQkFBb0IsU0FBcEJBLGlCQUFvQixDQUFTaHRDLEtBQVQsRUFBZ0I7QUFDekMsTUFBSXNuQyxpQkFBaUJ0bkMsTUFBTTNNLFFBQU4sQ0FBZSxPQUFmLENBQXJCOztBQUVBLE1BQ0MsQ0FBQ2kwQyxjQUFELElBQ0FBLG1CQUFtQixTQURuQixJQUVBQSxtQkFBbUIsTUFIcEIsRUFJRTtBQUNEQSxvQkFBaUJ0bkMsTUFBTXRCLFlBQU4sQ0FBbUIsT0FBbkIsQ0FBakI7QUFDQTs7QUFFRCxNQUFJLENBQUM0b0MsY0FBTCxFQUFxQjtBQUNwQixPQUFJMkYsZ0JBQWdCRixzQkFDbkJELGdCQUFnQjFELE1BREcsRUFFbEJRLEtBRmtCLENBRVosaUJBQVM7QUFDaEIsUUFBSUMsYUFBYTdwQyxNQUFNM00sUUFBTixDQUFldUIsTUFBTVgsSUFBckIsTUFBK0JXLE1BQU03SixLQUF0RDs7QUFFQSxRQUFJLENBQUM4K0MsVUFBRCxJQUFlajFDLE1BQU1rMUMsY0FBekIsRUFBeUM7QUFDeENELGtCQUFhajFDLE1BQU1rMUMsY0FBTixDQUFxQi9xQyxJQUFyQixDQUEwQix3QkFBZ0I7QUFDdEQsYUFDQ2lCLE1BQU0zTSxRQUFOLENBQWUwMkMsZUFBZW4xQyxNQUFNWCxJQUFwQyxNQUNBVyxNQUFNN0osS0FGUDtBQUlBLE1BTFksQ0FBYjtBQU1BOztBQUVELFdBQU84K0MsVUFBUDtBQUNBLElBZm1CLENBQXBCOztBQWlCQSxPQUFJLENBQUN2QyxjQUFMLEVBQXFCO0FBQ3BCLFFBQU00RixpQkFBaUJsdEMsTUFBTTNXLENBQU4sQ0FBUVYsVUFBL0I7O0FBRUEsUUFBSXVrRCxlQUFldDRDLEtBQWYsQ0FBcUJ1NEMsU0FBckIsSUFBa0NMLGdCQUFnQjFELE1BQXRELEVBQThEO0FBQzdEMkQsMkJBQXNCRCxnQkFBZ0IxRCxNQUF0QyxFQUE4QzVxQyxPQUE5QyxDQUNDLGlCQUFTO0FBQ1J3QixZQUFNd2xDLFFBQU4sQ0FBZTV3QyxNQUFNWCxJQUFyQixFQUEyQlcsTUFBTTdKLEtBQWpDOztBQUVBLFVBQUk2SixNQUFNazFDLGNBQVYsRUFBMEI7QUFDekJsMUMsYUFBTWsxQyxjQUFOLENBQXFCdHJDLE9BQXJCLENBQTZCLHdCQUFnQjtBQUM1Q3dCLGNBQU13bEMsUUFBTixDQUNDdUUsZUFBZW4xQyxNQUFNWCxJQUR0QixFQUVDVyxNQUFNN0osS0FGUDtBQUlBLFFBTEQ7QUFNQTtBQUNELE1BWkY7QUFjQWtpRCxxQkFBZ0IsSUFBaEI7QUFDQUMsb0JBQWV0NEMsS0FBZixDQUFxQnU0QyxTQUFyQixHQUFpQyxFQUFqQztBQUNBO0FBQ0Q7O0FBRUQ3RixvQkFBaUIyRixnQkFBZ0JILGdCQUFnQjFELE1BQWhDLEdBQXlDLElBQTFEO0FBQ0E7O0FBRUQsTUFBSSxDQUFDcGpELFNBQVNjLEdBQVQsQ0FBYUUsSUFBZCxJQUFzQmhCLFNBQVNjLEdBQVQsQ0FBYUMsRUFBdkMsRUFBMkM7QUFDMUMsT0FBTXU2QyxJQUFJdGhDLE1BQU1aLE9BQU4sQ0FBYyxHQUFkLENBQVY7QUFDQSxPQUFJa2lDLENBQUosRUFBTztBQUNOZ0cscUJBQWlCaEcsRUFBRWp1QyxRQUFGLENBQVcsWUFBWCxDQUFqQjtBQUNBO0FBQ0Q7O0FBRUQsU0FBT2kwQyxjQUFQO0FBQ0EsRUEvREQ7O0FBaUVBOzs7Ozs7QUFNQSxLQUFNOEYsdUJBQXVCLFNBQXZCQSxvQkFBdUIsQ0FBU3B0QyxLQUFULEVBQWdCc25DLGNBQWhCLEVBQWdDO0FBQzVELE1BQ0NBLG1CQUFtQndGLGdCQUFnQnpELElBQW5DLElBQ0EvQixtQkFBbUJ3RixnQkFBZ0J4RCxLQUZwQyxFQUdFO0FBQ0QsT0FBSWhDLG1CQUFtQjBGLGtCQUFrQmh0QyxLQUFsQixDQUF2QixFQUFpRDtBQUNoREEsVUFBTTZ1QixlQUFOLENBQXNCLE9BQXRCO0FBQ0E7QUFDRCxHQVBELE1BT08sSUFBSXlZLG1CQUFtQndGLGdCQUFnQjFELE1BQXZDLEVBQStDO0FBQ3JELE9BQU04RCxpQkFBaUJsdEMsTUFBTTNXLENBQU4sQ0FBUVYsVUFBL0I7O0FBRUEsT0FBSXVrRCxlQUFldDRDLEtBQWYsQ0FBcUJ1NEMsU0FBckIsSUFBa0NMLGdCQUFnQjFELE1BQXRELEVBQThEO0FBQzdEOEQsbUJBQWV0NEMsS0FBZixDQUFxQnU0QyxTQUFyQixHQUFpQyxFQUFqQztBQUNBO0FBQ0Q7O0FBRUQsTUFBTWwvQyxTQUFTOCtDLHNCQUFzQnpGLGNBQXRCLENBQWY7O0FBRUEsTUFBSXI1QyxNQUFKLEVBQVk7QUFDWEEsVUFBT3VRLE9BQVAsQ0FBZSxpQkFBUztBQUN2QndCLFVBQU16TSxXQUFOLENBQWtCcUIsTUFBTVgsSUFBeEI7O0FBRUEsUUFBSVcsTUFBTWsxQyxjQUFWLEVBQTBCO0FBQ3pCbDFDLFdBQU1rMUMsY0FBTixDQUFxQnRyQyxPQUFyQixDQUE2Qix3QkFBZ0I7QUFDNUN3QixZQUFNek0sV0FBTixDQUFrQncyQyxlQUFlbjFDLE1BQU1YLElBQXZDO0FBQ0EsTUFGRDtBQUdBO0FBQ0QsSUFSRDtBQVNBO0FBQ0QsRUE3QkQ7O0FBK0JBOzs7Ozs7QUFNQSxLQUFNbzVDLG9CQUFvQixTQUFwQkEsaUJBQW9CLENBQVNydEMsS0FBVCxFQUFnQnNuQyxjQUFoQixFQUFnQztBQUN6RDhGLHVCQUFxQnB0QyxLQUFyQixFQUE0Qmd0QyxrQkFBa0JodEMsS0FBbEIsQ0FBNUI7O0FBRUEsTUFBTS9SLFNBQVM4K0Msc0JBQXNCekYsY0FBdEIsQ0FBZjs7QUFFQSxNQUFJcjVDLE1BQUosRUFBWTtBQUNYQSxVQUFPdVEsT0FBUCxDQUFlLGlCQUFTO0FBQ3ZCd0IsVUFBTXdsQyxRQUFOLENBQWU1d0MsTUFBTVgsSUFBckIsRUFBMkJXLE1BQU03SixLQUFqQzs7QUFFQSxRQUFJNkosTUFBTWsxQyxjQUFWLEVBQTBCO0FBQ3pCbDFDLFdBQU1rMUMsY0FBTixDQUFxQnRyQyxPQUFyQixDQUE2Qix3QkFBZ0I7QUFDNUN3QixZQUFNd2xDLFFBQU4sQ0FBZXVFLGVBQWVuMUMsTUFBTVgsSUFBcEMsRUFBMENXLE1BQU03SixLQUFoRDtBQUNBLE1BRkQ7QUFHQTtBQUNELElBUkQ7QUFTQTtBQUNELEVBaEJEOztBQWtCQTs7Ozs7OztBQU9BL0UsVUFBU3FuQixPQUFULENBQWlCdmYsR0FBakIsQ0FBcUIsbUJBQXJCLEVBQTBDO0FBQ3pDOzs7Ozs7O0FBT0F5MUMsV0FSeUMscUJBUS9CeDlDLE1BUitCLEVBUXZCO0FBQ2pCLE9BQU0rMUMsT0FBTyxJQUFiOztBQUVBeU4sZ0JBQWEvcUMsT0FBYixDQUFxQixpQkFBUztBQUM3QixRQUFNN0ssVUFBVTVOLE9BQU82TixVQUFQLENBQWtCLFlBQVk3SSxLQUE5QixDQUFoQjs7QUFFQSxRQUFJNEksT0FBSixFQUFhO0FBQ1pBLGFBQVFqSyxFQUFSLENBQVcsTUFBWCxFQUFtQixpQkFBUztBQUMzQixVQUFNME0sZ0JBQWdCclEsT0FBT3EzQixnQkFBUCxFQUF0Qjs7QUFFQSxVQUNDaG5CLGlCQUNBbEUsd0JBQWM4TixLQUFkLENBQW9CO0FBQ25CbFcsYUFBTSxFQUFDc00sNEJBQUQ7QUFEYSxPQUFwQixDQUZELEVBS0U7QUFDRCxXQUFNNEosUUFBUTVKLGNBQWN2SyxPQUE1Qjs7QUFFQSxXQUFNeTdDLGlCQUFpQjBGLGtCQUFrQmh0QyxLQUFsQixDQUF2Qjs7QUFFQSxXQUFJc25DLG1CQUFtQnY4QyxLQUF2QixFQUE4QjtBQUM3QnFpRCw2QkFBcUJwdEMsS0FBckIsRUFBNEJqVixLQUE1QjtBQUNBLFFBRkQsTUFFTztBQUNOc2lELDBCQUFrQnJ0QyxLQUFsQixFQUF5QmpWLEtBQXpCO0FBQ0E7O0FBRURuQixhQUFNZ21DLE1BQU47O0FBRUFrTSxZQUFLd1IsZUFBTCxDQUNDdm5ELE1BREQsRUFFQyxJQUFJQyxTQUFTd0UsR0FBVCxDQUFhQyxXQUFqQixDQUE2QnVWLEtBQTdCLENBRkQ7QUFJQTtBQUNELE1BMUJEOztBQTRCQXJNLGFBQVFqSyxFQUFSLENBQVcsU0FBWCxFQUFzQixVQUFTRSxLQUFULEVBQWdCO0FBQ3JDLFVBQU13TSxnQkFBZ0I7QUFDckJ2SyxnQkFBU2pDLE1BQU1FLElBQU4sQ0FBV3NGLElBQVgsQ0FBZ0J4RTtBQURKLE9BQXRCOztBQUlBLFVBQ0NzSCx3QkFBYzhOLEtBQWQsQ0FBb0I7QUFDbkJsVyxhQUFNLEVBQUNzTSw0QkFBRDtBQURhLE9BQXBCLENBREQsRUFJRTtBQUNELFdBQU1reEMsaUJBQWlCMEYsa0JBQ3RCNTJDLGNBQWN2SyxPQURRLENBQXZCOztBQUlBLFlBQUsyUCxRQUFMLENBQ0M4ckMsbUJBQW1CdjhDLEtBQW5CLEdBQ0cvRSxTQUFTOE4sV0FEWixHQUVHOU4sU0FBUzgrQyxZQUhiOztBQU1BbDdDLGFBQU1nbUMsTUFBTjtBQUNBO0FBQ0QsTUF0QkQ7QUF1QkE7QUFDRCxJQXhERDtBQXlEQSxHQXBFd0M7OztBQXNFekM7Ozs7Ozs7O0FBUUEwZCxpQkE5RXlDLDJCQThFekJ2bkQsTUE5RXlCLEVBOEVqQjBFLFdBOUVpQixFQThFSjtBQUNwQzgrQyxnQkFBYS9xQyxPQUFiLENBQXFCLGlCQUFTO0FBQzdCLFFBQU03SyxVQUFVNU4sT0FBTzZOLFVBQVAsQ0FBa0IsWUFBWTdJLEtBQTlCLENBQWhCOztBQUVBLFFBQUk0SSxPQUFKLEVBQWE7QUFDWkEsYUFBUTh6QyxPQUFSLENBQWdCMWhELE1BQWhCLEVBQXdCMEUsV0FBeEI7QUFDQTtBQUNELElBTkQ7QUFPQTtBQXRGd0MsRUFBMUM7QUF3RkEsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNTRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFDQTs7OztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7O0FBOUJBOzs7OztRQWdDUThpRCxRLEdBQUFBLGtCOzs7Ozs7Ozs7Ozs7OztBQ2hDUjs7Ozs7QUFLQSxJQUFJLENBQUN2bkQsU0FBU3FuQixPQUFULENBQWlCeG5CLEdBQWpCLENBQXFCLGdCQUFyQixDQUFMLEVBQTZDO0FBQzVDOzs7Ozs7Ozs7QUFTQTs7Ozs7O0FBTUE7Ozs7Ozs7O0FBUUFHLFVBQVNxbkIsT0FBVCxDQUFpQnZmLEdBQWpCLENBQXFCLGdCQUFyQixFQUF1QztBQUN0Qzs7Ozs7OztBQU9BNjJCLE1BUnNDLGdCQVFqQzUrQixNQVJpQyxFQVF6QjtBQUFBOztBQUNaQSxVQUFPcUIsSUFBUCxDQUFZLFlBQVosRUFBMEIsWUFBTTtBQUMvQixRQUFNRSxXQUFXdkIsT0FBT3VCLFFBQVAsRUFBakI7O0FBRUFBLGFBQVMwcEMsY0FBVCxDQUNDMXBDLFFBREQsRUFFQyxPQUZELEVBR0MsTUFBS2t2QyxRQUhOLEVBSUMsS0FKRCxFQUtDO0FBQ0N6d0M7QUFERCxLQUxEO0FBU0EsSUFaRDtBQWFBLEdBdEJxQzs7O0FBd0J0Qzs7Ozs7Ozs7Ozs7QUFXQXl3QyxVQW5Dc0Msb0JBbUM3QjVzQyxLQW5DNkIsRUFtQ3RCO0FBQ2YsT0FBSUEsTUFBTUUsSUFBTixDQUFXVCxDQUFYLENBQWF5dEMsYUFBakIsRUFBZ0M7QUFDL0IsUUFBTUMsYUFBYW50QyxNQUFNRSxJQUFOLENBQVdULENBQVgsQ0FBYXl0QyxhQUFiLENBQTJCaDdCLEtBQTNCLENBQWlDLENBQWpDLENBQW5CO0FBQ0EsUUFBTS9WLFNBQVM2RCxNQUFNUyxZQUFOLENBQW1CdEUsTUFBbEM7O0FBRUEsUUFBSWd4QyxXQUFXOXBDLElBQVgsQ0FBZ0IwQyxPQUFoQixDQUF3QixPQUF4QixNQUFxQyxDQUF6QyxFQUE0QztBQUMzQyxTQUFNcWEsU0FBUyxJQUFJQyxVQUFKLEVBQWY7QUFDQSxTQUFNK3NCLFlBQVlELFdBQVdFLFNBQVgsRUFBbEI7O0FBRUFqdEIsWUFBT0csTUFBUCxHQUFnQixVQUFTdmdCLEtBQVQsRUFBZ0I7QUFDL0IsVUFBTXdnQixTQUFTcmtCLE9BQU91RSxJQUFQLENBQVksZ0JBQVosRUFBOEI7QUFDNUMrZixtQkFBWTJzQjtBQURnQyxPQUE5QixDQUFmOztBQUlBLFVBQUk1c0IsTUFBSixFQUFZO0FBQ1gsV0FBTW5ILEtBQUtqZCxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBYixDQUFxQnFYLGNBQXJCLENBQ1YsZUFBZXRaLE1BQU1vQixNQUFOLENBQWFvZixNQUE1QixHQUFxQyxJQUQzQixDQUFYOztBQUlBcmtCLGNBQU9vZCxhQUFQLENBQXFCRixFQUFyQjs7QUFFQSxXQUFNcUgsWUFBWTtBQUNqQnJILGNBRGlCO0FBRWpCaUgsY0FBTThzQjtBQUZXLFFBQWxCOztBQUtBanhDLGNBQU91RSxJQUFQLENBQVksVUFBWixFQUF3QmdnQixTQUF4QjtBQUNBO0FBQ0QsTUFuQkQ7O0FBcUJBTixZQUFPTyxhQUFQLENBQXFCeXNCLFNBQXJCO0FBQ0E7QUFDRDtBQUNEO0FBcEVxQyxFQUF2QztBQXNFQSxDOzs7Ozs7Ozs7Ozs7OztBQ25HRDs7Ozs7QUFLQSxJQUFJLENBQUNoeEMsU0FBU3FuQixPQUFULENBQWlCeG5CLEdBQWpCLENBQXFCLGdCQUFyQixDQUFMLEVBQTZDO0FBQzVDOzs7Ozs7O0FBT0EsS0FBTTJuRCxXQUFXeG5ELFNBQVNjLEdBQVQsQ0FBYTJtRCxhQUFiLEdBQTZCLE1BQTdCLEdBQXNDLEVBQXZEOztBQUVBLEtBQU1DLHNCQUFzQjtBQUMzQixLQUFHLENBQUMsUUFBUUYsUUFBUixHQUFtQixNQUFwQixDQUR3QjtBQUUzQixLQUFHLENBQUMsRUFBRCxFQUFLLEdBQUwsRUFBVUEsUUFBVixDQUZ3QjtBQUczQixLQUFHLENBQUMsVUFBVUEsUUFBVixHQUFxQixRQUF0QjtBQUh3QixFQUE1Qjs7QUFNQTs7Ozs7OztBQU9BOzs7Ozs7OztBQVFBeG5ELFVBQVNxbkIsT0FBVCxDQUFpQnZmLEdBQWpCLENBQXFCLGdCQUFyQixFQUF1QztBQUN0Qzs7Ozs7OztBQU9BNjJCLE1BUnNDLGdCQVFqQzUrQixNQVJpQyxFQVF6QjtBQUNaQSxVQUFPMkQsRUFBUCxDQUFVLE1BQVYsRUFBa0IsS0FBS2lrRCxlQUF2QixFQUF3QyxJQUF4QztBQUNBNW5ELFVBQU8yRCxFQUFQLENBQVUsUUFBVixFQUFvQixLQUFLaWtELGVBQXpCLEVBQTBDLElBQTFDO0FBQ0E1bkQsVUFBTzJELEVBQVAsQ0FBVSxPQUFWLEVBQW1CLEtBQUtra0QsdUJBQXhCLEVBQWlELElBQWpEO0FBQ0E3bkQsVUFBT3FCLElBQVAsQ0FBWSxZQUFaLEVBQTBCLEtBQUt1bUQsZUFBL0IsRUFBZ0QsSUFBaEQ7QUFDQSxHQWJxQzs7O0FBZXRDOzs7Ozs7OztBQVFBQSxpQkF2QnNDLDJCQXVCdEIvakQsS0F2QnNCLEVBdUJmO0FBQ3RCLE9BQU03RCxTQUFTNkQsTUFBTTdELE1BQXJCOztBQUVBLE9BQU04bkQsZUFBZTluRCxPQUFPdUIsUUFBUCxFQUFyQjs7QUFFQSxPQUFNd21ELFlBQVlELGFBQWF4a0QsQ0FBYixDQUFlcW5DLFNBQWYsQ0FBeUIrVCxJQUF6QixFQUFsQjs7QUFFQSxPQUFNdkQsVUFBVXdNLG9CQUFvQjNuRCxPQUFPVCxNQUFQLENBQWNrOEMsU0FBbEMsRUFBNkN6aUMsSUFBN0MsQ0FDZixtQkFBVztBQUNWLFdBQU8rdUMsY0FBY2ppRCxPQUFyQjtBQUNBLElBSGMsQ0FBaEI7O0FBTUEsT0FBSXExQyxPQUFKLEVBQWE7QUFDWjJNLGlCQUFhN2xELFFBQWIsQ0FBc0JqQyxPQUFPVCxNQUFQLENBQWNpQixnQkFBcEM7QUFDQSxJQUZELE1BRU87QUFDTnNuRCxpQkFBYS9rRCxXQUFiLENBQXlCL0MsT0FBT1QsTUFBUCxDQUFjaUIsZ0JBQXZDO0FBQ0E7QUFDRCxHQXpDcUM7OztBQTJDdEM7Ozs7Ozs7QUFPQXFuRCx5QkFsRHNDLG1DQWtEZGhrRCxLQWxEYyxFQWtEUDtBQUM5QixPQUFNN0QsU0FBUzZELE1BQU03RCxNQUFyQjs7QUFFQSxPQUFNZ29ELGFBQWEsSUFBSS9uRCxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUI5RixPQUFPOEYsT0FBUCxDQUFleEMsQ0FBeEMsQ0FBbkI7O0FBRUEwa0QsY0FBV2psRCxXQUFYLENBQXVCL0MsT0FBT1QsTUFBUCxDQUFjaUIsZ0JBQXJDO0FBQ0E7QUF4RHFDLEVBQXZDO0FBMERBLEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUZEOzs7OztBQUtBOzs7OztBQUtPLElBQU15bkQsOENBQW1CLEVBQXpCO0FBQ0EsSUFBTWpGLHdDQUFnQixDQUF0QixDOzs7Ozs7Ozs7Ozs7OztBQ1hQOzs7OztBQUtBLElBQUksQ0FBQy9pRCxTQUFTcW5CLE9BQVQsQ0FBaUJ4bkIsR0FBakIsQ0FBcUIsd0JBQXJCLENBQUwsRUFBcUQ7QUFDcEQ7Ozs7OztBQU1BRyxVQUFTcW5CLE9BQVQsQ0FBaUJ2ZixHQUFqQixDQUFxQix3QkFBckIsRUFBK0M7QUFDOUM2eUIsWUFBVSxvQkFEb0M7O0FBRzlDOzs7Ozs7OztBQVFBZ0UsTUFYOEMsZ0JBV3pDNStCLE1BWHlDLEVBV2pDO0FBQ1osT0FBSUEsT0FBT1QsTUFBUCxDQUFjb0IsbUJBQWxCLEVBQXVDO0FBQ3RDWCxXQUFPVCxNQUFQLENBQWNvQixtQkFBZCxDQUFrQzhYLE9BQWxDLENBQ0MsOEJBQXNCO0FBQ3JCLFNBQU03SyxVQUFVLElBQUkzTixTQUFTMk4sT0FBYixDQUFxQjVOLE1BQXJCLEVBQTZCO0FBQzVDcU0sVUFENEMsZ0JBQ3ZDck0sTUFEdUMsRUFDL0I7QUFDWkEsY0FBT3VFLElBQVAsQ0FBWSxtQkFBWixFQUFpQztBQUNoQzBjLHlCQUNDaW5DLG1CQUFtQjNrRCxTQUZZO0FBR2hDK00scUJBQWEsRUFIbUI7QUFJaENELHVCQUFlclEsT0FBT3EzQixnQkFBUDtBQUppQixRQUFqQztBQU1BO0FBUjJDLE1BQTdCLENBQWhCOztBQVdBLFNBQU12MUIsY0FDTCx1QkFBdUJvbUQsbUJBQW1CM2tELFNBRDNDOztBQUdBdkQsWUFBT2dDLFVBQVAsQ0FBa0JGLFdBQWxCLEVBQStCOEwsT0FBL0I7QUFDQTVOLFlBQU93TyxZQUFQLENBQ0MwNUMsbUJBQW1Cdm1ELElBRHBCLEVBRUNHLFdBRkQ7QUFJQSxLQXJCRjtBQXVCQTtBQUNEO0FBckM2QyxFQUEvQztBQXVDQSxDOzs7Ozs7Ozs7Ozs7OztBQ25ERDs7Ozs7QUFLQTs7Ozs7QUFLQSxJQUFJLENBQUM3QixTQUFTcW5CLE9BQVQsQ0FBaUJ4bkIsR0FBakIsQ0FBcUIsZ0JBQXJCLENBQUwsRUFBNkM7QUFDNUMsS0FBTXFvRCxTQUFTbG9ELFNBQVN5TyxLQUFULENBQWUwNUMsU0FBOUI7O0FBRUEsVUFBU0MsUUFBVCxDQUFrQm5yQyxFQUFsQixFQUFzQjtBQUNyQixTQUFPamQsU0FBU2MsR0FBVCxDQUFhQyxFQUFiLEdBQ0prYyxHQUFHNVosQ0FBSCxDQUFLdVEsV0FERCxHQUVKSixTQUFTeUosR0FBRzNKLGdCQUFILENBQW9CLE9BQXBCLENBQVQsRUFBdUMsRUFBdkMsQ0FGSDtBQUdBOztBQUVELFVBQVMrMEMsY0FBVCxDQUF3QnhpRCxPQUF4QixFQUFpQ3lpRCxJQUFqQyxFQUF1QztBQUN0QyxNQUFJQyxXQUFXMWlELFFBQVF5TixnQkFBUixDQUF5QixZQUFZZzFDLElBQVosR0FBbUIsUUFBNUMsQ0FBZjs7QUFFQSxNQUFNRSxZQUFZO0FBQ2pCQyxTQUFNLEtBRFc7QUFFakJDLFdBQVEsS0FGUztBQUdqQkMsVUFBTztBQUhVLEdBQWxCOztBQU1BLE1BQUlKLFNBQVM1K0MsT0FBVCxDQUFpQixJQUFqQixJQUF5QixDQUE3QixFQUFnQztBQUMvQjtBQUNBLE9BQ0M0K0MsWUFBWUMsU0FBWixJQUNBM2lELFFBQVF5TixnQkFBUixDQUF5QixjQUF6QixLQUE0QyxNQUY3QyxFQUdFO0FBQ0RpMUMsZUFBV0MsVUFBVUQsUUFBVixDQUFYO0FBQ0EsSUFMRCxNQUtPO0FBQ05BLGVBQVcsQ0FBWDtBQUNBO0FBQ0Q7O0FBRUQsU0FBTy8wQyxTQUFTKzBDLFFBQVQsRUFBbUIsRUFBbkIsQ0FBUDtBQUNBOztBQUVEO0FBQ0EsVUFBU0ssa0JBQVQsQ0FBNEJ4M0IsS0FBNUIsRUFBbUM7QUFDbEMsTUFBTXkzQixRQUFRejNCLE1BQU0vdEIsQ0FBTixDQUFRK3JCLElBQXRCOztBQUVBLE1BQUkwNUIsV0FBVyxDQUFmOztBQUVBLE1BQUlDLG1CQUFKOztBQUVBLE1BQUlDLGlCQUFKOztBQUVBLE1BQUlDLFlBQUo7O0FBRUEsT0FBSyxJQUFJdG5ELElBQUksQ0FBUixFQUFXNDBDLE1BQU1zUyxNQUFNam5ELE1BQTVCLEVBQW9DRCxJQUFJNDBDLEdBQXhDLEVBQTZDNTBDLEdBQTdDLEVBQWtEO0FBQ2pEc25ELFNBQU1KLE1BQU1sbkQsQ0FBTixDQUFOO0FBQ0FvbkQsZ0JBQWFFLElBQUl0aUIsS0FBSixDQUFVL2tDLE1BQXZCOztBQUVBLE9BQUltbkQsYUFBYUQsUUFBakIsRUFBMkI7QUFDMUJBLGVBQVdDLFVBQVg7QUFDQUMsZUFBV0MsR0FBWDtBQUNBO0FBQ0Q7O0FBRUQsU0FBT0QsUUFBUDtBQUNBOztBQUVELFVBQVNFLHVCQUFULENBQWlDOTNCLEtBQWpDLEVBQXdDO0FBQ3ZDLE1BQU0rM0IsVUFBVSxFQUFoQjs7QUFFQSxNQUFJQyxjQUFjLENBQUMsQ0FBbkI7O0FBRUEsTUFBTUMsTUFBTWo0QixNQUFNOWQsZ0JBQU4sQ0FBdUIsV0FBdkIsTUFBd0MsS0FBcEQ7O0FBRUE7QUFDQSxNQUFNMjFDLE1BQU1MLG1CQUFtQngzQixLQUFuQixDQUFaOztBQUVBO0FBQ0E7QUFDQSxNQUFNc1UsUUFBUSxJQUFJMWxDLFNBQVN3RSxHQUFULENBQWFxQixPQUFqQixDQUF5QnVyQixNQUFNL3RCLENBQU4sQ0FBUWltRCxPQUFSLENBQWdCLENBQWhCLENBQXpCLENBQWQ7O0FBRUEsTUFBTUMsZ0JBQWdCN2pCLE1BQU04akIsbUJBQU4sRUFBdEI7O0FBRUE7QUFDQSxPQUFLLElBQUk3bkQsSUFBSSxDQUFSLEVBQVc0MEMsTUFBTTBTLElBQUl0aUIsS0FBSixDQUFVL2tDLE1BQWhDLEVBQXdDRCxJQUFJNDBDLEdBQTVDLEVBQWlENTBDLEdBQWpELEVBQXNEO0FBQ3JEO0FBQ0E7QUFDQSxPQUFNZ2tDLEtBQUssSUFBSTNsQyxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUJvakQsSUFBSXRpQixLQUFKLENBQVVobEMsQ0FBVixDQUF6QixDQUFYOztBQUVBLE9BQU04bkQsU0FDTFIsSUFBSXRpQixLQUFKLENBQVVobEMsSUFBSSxDQUFkLEtBQW9CLElBQUkzQixTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUJvakQsSUFBSXRpQixLQUFKLENBQVVobEMsSUFBSSxDQUFkLENBQXpCLENBRHJCOztBQUdBeW5ELGtCQUFlempCLEdBQUd0aUMsQ0FBSCxDQUFLcW1ELE9BQUwsSUFBZ0IsQ0FBL0I7O0FBRUE7QUFDQSxPQUFJQyxtQkFBSjtBQUNBLE9BQUlDLG9CQUFKOztBQUVBLE9BQUkvNUMsSUFBSTgxQixHQUFHNmpCLG1CQUFILEdBQXlCMzVDLENBQWpDOztBQUVBO0FBQ0EsT0FBSXc1QyxHQUFKLEVBQVM7QUFDUk8sa0JBQWMvNUMsSUFBSXc0QyxlQUFlMWlCLEVBQWYsRUFBbUIsTUFBbkIsQ0FBbEI7QUFDQSxJQUZELE1BRU87QUFDTmdrQixpQkFBYTk1QyxJQUFJODFCLEdBQUd0aUMsQ0FBSCxDQUFLd08sV0FBVCxHQUF1QncyQyxlQUFlMWlCLEVBQWYsRUFBbUIsT0FBbkIsQ0FBcEM7QUFDQTs7QUFFRDtBQUNBLE9BQUk4akIsTUFBSixFQUFZO0FBQ1g1NUMsUUFBSTQ1QyxPQUFPRCxtQkFBUCxHQUE2QjM1QyxDQUFqQzs7QUFFQSxRQUFJdzVDLEdBQUosRUFBUztBQUNSTSxrQkFDQzk1QyxJQUNBNDVDLE9BQU9wbUQsQ0FBUCxDQUFTd08sV0FEVCxHQUVBdzJDLGVBQWVvQixNQUFmLEVBQXVCLE9BQXZCLENBSEQ7QUFJQSxLQUxELE1BS087QUFDTkcsbUJBQWMvNUMsSUFBSXc0QyxlQUFlb0IsTUFBZixFQUF1QixNQUF2QixDQUFsQjtBQUNBO0FBQ0Q7QUFDRDtBQVpBLFFBYUs7QUFDSjU1QyxTQUFJdWhCLE1BQU1vNEIsbUJBQU4sR0FBNEIzNUMsQ0FBaEM7O0FBRUEsU0FBSXc1QyxHQUFKLEVBQVM7QUFDUk0sbUJBQWE5NUMsQ0FBYjtBQUNBLE1BRkQsTUFFTztBQUNOKzVDLG9CQUFjLzVDLElBQUl1aEIsTUFBTS90QixDQUFOLENBQVF3TyxXQUExQjtBQUNBO0FBQ0Q7O0FBRUQsT0FBTWc0QyxjQUFjaDVDLEtBQUtFLEdBQUwsQ0FBUzY0QyxjQUFjRCxVQUF2QixFQUFtQyxDQUFuQyxDQUFwQjs7QUFFQTtBQUNBO0FBQ0FSLFdBQVF4OUMsSUFBUixDQUFhO0FBQ1p5bEIsZ0JBRFk7QUFFWnpjLFdBQU95MEMsV0FGSztBQUdadjVDLE9BQUc4NUMsVUFIUztBQUlaNTVDLE9BQUd3NUMsY0FBY3g1QyxDQUpMO0FBS1pFLFdBQU80NUMsV0FMSztBQU1aMTJDLFlBQVF1eUIsTUFBTXJpQyxDQUFOLENBQVFtTyxZQU5KO0FBT1o2M0M7QUFQWSxJQUFiO0FBU0E7O0FBRUQsU0FBT0YsT0FBUDtBQUNBOztBQUVELFVBQVNXLG1CQUFULENBQTZCWCxPQUE3QixFQUFzQ1ksU0FBdEMsRUFBaUQ7QUFDaEQsT0FBSyxJQUFJcG9ELElBQUksQ0FBUixFQUFXNDBDLE1BQU00UyxRQUFRdm5ELE1BQTlCLEVBQXNDRCxJQUFJNDBDLEdBQTFDLEVBQStDNTBDLEdBQS9DLEVBQW9EO0FBQ25ELE9BQU1xb0QsU0FBU2IsUUFBUXhuRCxDQUFSLENBQWY7O0FBRUEsT0FBSW9vRCxhQUFhQyxPQUFPbjZDLENBQXBCLElBQXlCazZDLGFBQWFDLE9BQU9uNkMsQ0FBUCxHQUFXbTZDLE9BQU8vNUMsS0FBNUQsRUFBbUU7QUFDbEUsV0FBTys1QyxNQUFQO0FBQ0E7QUFDRDs7QUFFRCxTQUFPLElBQVA7QUFDQTs7QUFFRCxVQUFTcGdCLE1BQVQsQ0FBZ0JtUyxHQUFoQixFQUFxQjtBQUNwQixHQUFDQSxJQUFJajRDLElBQUosSUFBWWk0QyxHQUFiLEVBQWtCMzNDLGNBQWxCO0FBQ0E7O0FBRUQsVUFBUzZsRCxhQUFULENBQXVCbHFELE1BQXZCLEVBQStCaXFELE1BQS9CLEVBQXVDO0FBQ3RDLE1BQUlFLHFCQUFKO0FBQ0EsTUFBSUMsMEJBQUo7QUFDQSxNQUFJQyxzQkFBSjtBQUNBLE1BQUlDLGlCQUFKO0FBQ0EsTUFBSUMsMkJBQUo7QUFDQSxNQUFJQyx1QkFBSjtBQUNBLE1BQUlubkIsb0JBQUo7O0FBRUEsTUFBTWhnQyxXQUFXckQsT0FBT3FELFFBQXhCOztBQUVBLE1BQU1veUMsVUFBVXgxQyxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBYixDQUFxQnFYLGNBQXJCLENBQ2YsZ0VBQ0MsK0VBREQsR0FFQywwRkFIYyxFQUlmOVosUUFKZSxDQUFoQjs7QUFPQSxNQUFNb25ELGFBQWMsS0FBS0EsVUFBTCxHQUFrQixZQUFXO0FBQ2hELFVBQU9ILFFBQVA7QUFDQSxHQUZEOztBQUlBLE1BQU1wTSxPQUFRLEtBQUtBLElBQUwsR0FBWSxVQUFTd00sSUFBVCxFQUFlO0FBQ3hDLE9BQUlDLHFCQUNIRCxPQUFPNTVDLEtBQUsyOUIsS0FBTCxDQUFXZ0gsUUFBUW55QyxDQUFSLENBQVV3TyxXQUFWLEdBQXdCLENBQW5DLENBRFI7O0FBR0EsT0FBSTI0QyxVQUFKLEVBQWdCO0FBQ2YsUUFDQ0UsdUJBQXVCUCxpQkFBdkIsSUFDQU8sdUJBQXVCSixrQkFGeEIsRUFHRTtBQUNEO0FBQ0E7O0FBRURJLHlCQUFxQjc1QyxLQUFLRSxHQUFMLENBQ3BCMjVDLGtCQURvQixFQUVwQlAsaUJBRm9CLENBQXJCO0FBSUFPLHlCQUFxQjc1QyxLQUFLQyxHQUFMLENBQ3BCNDVDLGtCQURvQixFQUVwQkosa0JBRm9CLENBQXJCOztBQUtBSixtQkFBZVEscUJBQXFCdG5CLFdBQXBDO0FBQ0E7O0FBRURvUyxXQUFRZ0ssUUFBUixDQUFpQixNQUFqQixFQUF5QjBJLE9BQU93QyxrQkFBUCxDQUF6QjtBQUNBLEdBekJEOztBQTJCQSxXQUFTeHpCLE1BQVQsR0FBa0I7QUFDakJzZSxXQUFRdkssY0FBUixDQUF1QixTQUF2QixFQUFrQzZSLFNBQWxDO0FBQ0F0SCxXQUFRdkssY0FBUixDQUF1QixXQUF2QixFQUFvQzBmLFdBQXBDO0FBQ0FuVixXQUFRdkssY0FBUixDQUF1QixXQUF2QixFQUFvQzRSLFdBQXBDO0FBQ0E7O0FBRUQsV0FBUytOLFdBQVQsR0FBdUI7QUFDdEI7QUFDQTs7QUFFQSxPQUFNQyxjQUFjYixPQUFPcjFDLEtBQTNCOztBQUVBLE9BQU1GLE1BQU16VSxTQUFTeU8sS0FBVCxDQUFlcThDLGFBQWYsQ0FBNkJkLE9BQU81NEIsS0FBcEMsQ0FBWjs7QUFFQSxPQUFNMjVCLGtCQUFrQixFQUF4Qjs7QUFFQSxPQUFNQyxtQkFBbUIsRUFBekI7O0FBRUEsT0FBSUMsY0FBY0MsT0FBT0MsU0FBekI7O0FBRUEsT0FBSUMsZUFBZUgsV0FBbkI7O0FBRUEsT0FBTTVCLE1BQU1XLE9BQU9YLEdBQW5COztBQUVBLFFBQUssSUFBSTFuRCxJQUFJLENBQVIsRUFBVzQwQyxNQUFNOWhDLElBQUk3UyxNQUExQixFQUFrQ0QsSUFBSTQwQyxHQUF0QyxFQUEyQzUwQyxHQUEzQyxFQUFnRDtBQUMvQyxRQUFNNG9CLE1BQU05VixJQUFJOVMsQ0FBSixDQUFaOztBQUVBLFFBQUkwcEQsV0FBVzlnQyxJQUFJc2dDLGVBQWV4QixNQUFNLENBQU4sR0FBVSxDQUF6QixDQUFKLENBQWY7O0FBRUEsUUFBSWlDLFlBQVkvZ0MsSUFBSXNnQyxlQUFleEIsTUFBTSxDQUFOLEdBQVUsQ0FBekIsQ0FBSixDQUFoQjs7QUFFQWdDLGVBQVdBLFlBQVksSUFBSXJyRCxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUJ3bEQsUUFBekIsQ0FBdkI7QUFDQUMsZ0JBQVlBLGFBQWEsSUFBSXRyRCxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUJ5bEQsU0FBekIsQ0FBekI7O0FBRUEsUUFBSSxDQUFDRCxRQUFELElBQWEsQ0FBQ0MsU0FBZCxJQUEyQixDQUFDRCxTQUFTbHJCLE1BQVQsQ0FBZ0JtckIsU0FBaEIsQ0FBaEMsRUFBNEQ7QUFDM0QsU0FBSUQsUUFBSixFQUFjO0FBQ2JKLG9CQUFjcDZDLEtBQUtDLEdBQUwsQ0FBU202QyxXQUFULEVBQXNCN0MsU0FBU2lELFFBQVQsQ0FBdEIsQ0FBZDtBQUNBO0FBQ0QsU0FBSUMsU0FBSixFQUFlO0FBQ2RGLHFCQUFldjZDLEtBQUtDLEdBQUwsQ0FDZHM2QyxZQURjLEVBRWRoRCxTQUFTa0QsU0FBVCxDQUZjLENBQWY7QUFJQTs7QUFFRFAscUJBQWdCcC9DLElBQWhCLENBQXFCMC9DLFFBQXJCO0FBQ0FMLHNCQUFpQnIvQyxJQUFqQixDQUFzQjIvQyxTQUF0QjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQWxCLG1CQUFnQlcsZUFBaEI7QUFDQVIsb0JBQWlCUyxnQkFBakI7O0FBRUE7QUFDQWIsdUJBQW9CSCxPQUFPbjZDLENBQVAsR0FBV283QyxXQUEvQjtBQUNBWCx3QkFBcUJOLE9BQU9uNkMsQ0FBUCxHQUFXdTdDLFlBQWhDOztBQUVBNVYsV0FBUStWLFVBQVIsQ0FBbUIsR0FBbkI7QUFDQW5vQixpQkFBYzV2QixTQUFTZ2lDLFFBQVFub0MsUUFBUixDQUFpQixNQUFqQixDQUFULEVBQW1DLEVBQW5DLENBQWQ7QUFDQTY4QyxrQkFBZSxDQUFmO0FBQ0FHLGNBQVcsQ0FBWDs7QUFFQTdVLFdBQVE5eEMsRUFBUixDQUFXLFdBQVgsRUFBd0JtNUMsV0FBeEI7O0FBRUE7QUFDQXo1QyxZQUFTTSxFQUFULENBQVksV0FBWixFQUF5QmttQyxNQUF6QjtBQUNBOztBQUVELFdBQVM0aEIsU0FBVCxHQUFxQjtBQUNwQm5CLGNBQVcsQ0FBWDs7QUFFQTdVLFdBQVErVixVQUFSLENBQW1CLENBQW5COztBQUVBLE9BQUlyQixZQUFKLEVBQWtCO0FBQ2pCdUI7QUFDQTs7QUFFRCxPQUFNcjZCLFFBQVE0NEIsT0FBTzU0QixLQUFyQjtBQUNBcG5CLGNBQVcsWUFBTTtBQUNoQm9uQixVQUFNczZCLGdCQUFOLENBQXVCLG9CQUF2QjtBQUNBLElBRkQsRUFFRyxDQUZIOztBQUlBdG9ELFlBQVM2bkMsY0FBVCxDQUF3QixXQUF4QixFQUFxQ3JCLE1BQXJDO0FBQ0E7O0FBRUQsV0FBUzZoQixZQUFULEdBQXdCO0FBQUE7O0FBQ3ZCLE9BQU1wQyxNQUFNVyxPQUFPWCxHQUFuQjs7QUFFQSxPQUFNTixhQUFhTSxNQUNoQmtCLGVBQWUzb0QsTUFEQyxHQUVoQndvRCxjQUFjeG9ELE1BRmpCOztBQUlBOztBQVB1Qiw4QkFRZEQsQ0FSYztBQVN0QixRQUFNMHBELFdBQVdqQixjQUFjem9ELENBQWQsQ0FBakI7O0FBRUEsUUFBTTJwRCxZQUFZZixlQUFlNW9ELENBQWYsQ0FBbEI7O0FBRUEsUUFBTXl2QixRQUFRNDRCLE9BQU81NEIsS0FBckI7O0FBRUE7QUFDQXB4QixhQUFTeU8sS0FBVCxDQUFlekUsVUFBZixDQUNDLFVBQ0NxaEQsUUFERCxFQUVDTSxZQUZELEVBR0NMLFNBSEQsRUFJQ00sYUFKRCxFQUtDQyxVQUxELEVBTUNDLFNBTkQsRUFPSztBQUNKO0FBQ0EsU0FBSVQsUUFBSixFQUFjO0FBQ2JBLGVBQVM3TCxRQUFULENBQ0MsT0FERCxFQUVDMEksT0FBT3IzQyxLQUFLRSxHQUFMLENBQVM0NkMsZUFBZUcsU0FBeEIsRUFBbUMsQ0FBbkMsQ0FBUCxDQUZEO0FBSUE7QUFDRCxTQUFJUixTQUFKLEVBQWU7QUFDZEEsZ0JBQVU5TCxRQUFWLENBQ0MsT0FERCxFQUVDMEksT0FBT3IzQyxLQUFLRSxHQUFMLENBQVM2NkMsZ0JBQWdCRSxTQUF6QixFQUFvQyxDQUFwQyxDQUFQLENBRkQ7QUFJQTs7QUFFRDtBQUNBLFNBQUlELFVBQUosRUFBZ0I7QUFDZno2QixZQUFNb3VCLFFBQU4sQ0FDQyxPQURELEVBRUMwSSxPQUFPMkQsYUFBYUMsYUFBYXpDLE1BQU0sQ0FBQyxDQUFQLEdBQVcsQ0FBeEIsQ0FBcEIsQ0FGRDtBQUlBO0FBQ0QsS0E5QkYsRUErQkMsQ0EvQkQsRUFnQ0MsS0FoQ0QsRUFpQ0MsQ0FDQ2dDLFFBREQsRUFFQ0EsWUFBWWpELFNBQVNpRCxRQUFULENBRmIsRUFHQ0MsU0FIRCxFQUlDQSxhQUFhbEQsU0FBU2tELFNBQVQsQ0FKZCxFQUtDLENBQUMsQ0FBQ0QsUUFBRCxJQUFhLENBQUNDLFNBQWYsS0FDQ2xELFNBQVNoM0IsS0FBVCxJQUNDaTNCLGVBQWVqM0IsS0FBZixFQUFzQixNQUF0QixDQURELEdBRUNpM0IsZUFBZWozQixLQUFmLEVBQXNCLE9BQXRCLENBUkgsRUFTQzg0QixZQVRELENBakNEO0FBaEJzQjs7QUFRdkIsUUFBSyxJQUFJdm9ELElBQUksQ0FBYixFQUFnQkEsSUFBSW9uRCxVQUFwQixFQUFnQ3BuRCxHQUFoQyxFQUFxQztBQUFBLFVBQTVCQSxDQUE0QjtBQXFEcEM7QUFDRDs7QUFFRCxXQUFTZ3BELFdBQVQsQ0FBcUI1TyxHQUFyQixFQUEwQjtBQUN6Qm5TLFVBQU9tUyxHQUFQOztBQUVBNk87O0FBRUF4bkQsWUFBU00sRUFBVCxDQUFZLFNBQVosRUFBdUJvNUMsU0FBdkIsRUFBa0MsSUFBbEM7QUFDQTs7QUFFRCxXQUFTQSxTQUFULENBQW1CZixHQUFuQixFQUF3QjtBQUN2QkEsT0FBSTlRLGNBQUo7O0FBRUF1Z0I7QUFDQTs7QUFFRCxXQUFTM08sV0FBVCxDQUFxQmQsR0FBckIsRUFBMEI7QUFDekJrQyxRQUFLbEMsSUFBSWo0QyxJQUFKLENBQVNpb0QsYUFBVCxHQUF5Qmw4QyxDQUE5QjtBQUNBOztBQUVEO0FBQ0E5UCxTQUFPMkQsRUFBUCxDQUFVLFNBQVYsRUFBcUIsWUFBTTtBQUMxQnd6Qjs7QUFFQXNlLFdBQVF0b0MsTUFBUjtBQUNBLEdBSkQ7O0FBTUE7QUFDQTtBQUNBOUosV0FBUzRvRCxrQkFBVCxHQUE4QjNsQixNQUE5QixDQUFxQ21QLE9BQXJDOztBQUVBQSxVQUFRcGpDLFNBQVIsQ0FBa0I7QUFDakJuQyxVQUFPaTRDLE9BQU84QixPQUFPLzVDLEtBQWQsQ0FEVTtBQUVqQmtELFdBQVErMEMsT0FBTzhCLE9BQU83MkMsTUFBZCxDQUZTO0FBR2pCckQsU0FBTW80QyxPQUFPOEIsT0FBT242QyxDQUFkLENBSFc7QUFJakJHLFFBQUtrNEMsT0FBTzhCLE9BQU9qNkMsQ0FBZDtBQUpZLEdBQWxCOztBQU9BeWxDLFVBQVE5eEMsRUFBUixDQUFXLFdBQVgsRUFBd0JpbkQsV0FBeEIsRUFBcUMsSUFBckM7O0FBRUF2bkQsV0FBU3VtQyxPQUFULEdBQW1CNlYsUUFBbkIsQ0FBNEIsUUFBNUIsRUFBc0MsWUFBdEM7O0FBRUE7QUFDQTtBQUNBaEssVUFBUXhnQixJQUFSOztBQUVBLE9BQUtoeUIsT0FBTCxHQUFlLFlBQVc7QUFDekJrMEI7O0FBRUE5ekIsWUFBU3VtQyxPQUFULEdBQW1CNlYsUUFBbkIsQ0FBNEIsUUFBNUIsRUFBc0MsTUFBdEM7O0FBRUFoSyxXQUFRdG9DLE1BQVI7QUFDQSxHQU5EO0FBT0E7O0FBRUQsVUFBUysrQyxpQkFBVCxDQUEyQmxRLEdBQTNCLEVBQWdDO0FBQy9CLE1BQU0vMkMsU0FBUysyQyxJQUFJajRDLElBQUosQ0FBU1ksU0FBVCxFQUFmOztBQUVBLE1BQUlxM0MsSUFBSTl0QyxJQUFKLEtBQWEsVUFBakIsRUFBNkI7QUFDNUI7QUFDQSxPQUFJLENBQUNqSixPQUFPZzhCLEVBQVAsQ0FBVSxPQUFWLENBQUwsRUFBeUI7QUFDeEI7QUFDQTs7QUFFRCxPQUFJa3JCLE9BQU8sSUFBSWxzRCxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FDVmsyQyxJQUFJajRDLElBQUosQ0FBU1QsQ0FBVCxDQUFXeW5DLGFBQVgsSUFBNEJpUixJQUFJajRDLElBQUosQ0FBU1QsQ0FBVCxDQUFXOG9ELFNBRDdCLENBQVg7QUFHQSxVQUFPRCxRQUFRQSxLQUFLN29ELENBQWIsSUFBa0IsQ0FBQzZvRCxLQUFLL3JCLE1BQUwsQ0FBWW43QixNQUFaLENBQW5CLElBQTBDLENBQUNrbkQsS0FBS2xyQixFQUFMLENBQVEsTUFBUixDQUFsRCxFQUFtRTtBQUNsRWtyQixXQUFPQSxLQUFLL2tCLFNBQUwsRUFBUDtBQUNBO0FBQ0QsT0FBSSxDQUFDK2tCLElBQUQsSUFBU0EsS0FBSy9yQixNQUFMLENBQVluN0IsTUFBWixDQUFiLEVBQWtDO0FBQ2pDO0FBQ0E7QUFDRDs7QUFFREEsU0FBTzhiLFlBQVAsQ0FBb0IsT0FBcEIsRUFBNkIsQ0FBN0IsRUFBZ0M0cUMsZ0JBQWhDLENBQWlELG9CQUFqRDtBQUNBM1AsTUFBSTlRLGNBQUo7QUFDQTs7QUFFRGpyQyxVQUFTcW5CLE9BQVQsQ0FBaUJ2ZixHQUFqQixDQUFxQixnQkFBckIsRUFBdUM7QUFDdEM2eUIsWUFBVSxlQUQ0Qjs7QUFHdENnRSxNQUhzQyxnQkFHakM1K0IsTUFIaUMsRUFHekI7QUFDWkEsVUFBTzJELEVBQVAsQ0FBVSxZQUFWLEVBQXdCLFlBQU07QUFDN0IsUUFBSTh4QyxnQkFBSjs7QUFFQSxRQUFNbDBDLFdBQVd2QixPQUFPdUIsUUFBUCxFQUFqQjs7QUFFQTtBQUNBO0FBQ0FBLGFBQVMwcEMsY0FBVCxDQUNDMXBDLFNBQVM4cUQsUUFBVCxLQUFzQjlxRCxRQUF0QixHQUFpQ3ZCLE9BQU9xRCxRQUR6QyxFQUVDLFdBRkQsRUFHQyxlQUFPO0FBQ04yNEMsV0FBTUEsSUFBSWo0QyxJQUFWOztBQUVBLFNBQU1rQixTQUFTKzJDLElBQUlyM0MsU0FBSixFQUFmOztBQUVBO0FBQ0E7QUFDQSxTQUFJTSxPQUFPaUMsSUFBUCxLQUFnQmpILFNBQVMrbUMsWUFBN0IsRUFBMkM7QUFDMUM7QUFDQTs7QUFFRCxTQUFNeDJCLFFBQVF3ckMsSUFBSWdRLGFBQUosR0FBb0JsOEMsQ0FBbEM7O0FBRUE7QUFDQTtBQUNBLFNBQUkybEMsT0FBSixFQUFhO0FBQ1osVUFBSUEsUUFBUWdWLFVBQVIsRUFBSixFQUEwQjtBQUN6QmhWLGVBQVF5SSxJQUFSLENBQWExdEMsS0FBYjs7QUFFQXE1QixjQUFPbVMsR0FBUDs7QUFFQTtBQUNBLE9BTkQsTUFNTztBQUNOdkcsZUFBUXh5QyxPQUFSOztBQUVBd3lDLGlCQUFVLElBQVY7QUFDQTtBQUNEOztBQUVEO0FBQ0EsU0FBSTJULGdCQUFKOztBQUVBLFNBQ0MsQ0FBQ25rRCxPQUFPZzhCLEVBQVAsQ0FBVSxPQUFWLENBQUQsSUFDQSxDQUFDaDhCLE9BQU84YixZQUFQLENBQW9CLE9BQXBCLEVBQTZCLENBQTdCLENBRkYsRUFHRTtBQUNEO0FBQ0E7O0FBRUQsU0FBTXNRLFFBQVFwc0IsT0FBTzhiLFlBQVAsQ0FBb0IsT0FBcEIsRUFBNkIsQ0FBN0IsQ0FBZDs7QUFFQTtBQUNBO0FBQ0EsU0FBSSxDQUFDL2dCLE9BQU91QixRQUFQLEdBQWtCazJCLFFBQWxCLENBQTJCcEcsS0FBM0IsQ0FBTCxFQUF3QztBQUN2QztBQUNBOztBQUVELFNBQ0MsRUFBRSszQixVQUFVLzNCLE1BQU1pN0IsYUFBTixDQUNYLG9CQURXLENBQVosQ0FERCxFQUlFO0FBQ0Q7QUFDQWo3QixZQUFNazdCLGFBQU4sQ0FDQyxvQkFERCxFQUVFbkQsVUFBVUQsd0JBQXdCOTNCLEtBQXhCLENBRlo7QUFJQUEsWUFBTTF0QixFQUFOLENBQVMsVUFBVCxFQUFxQnVvRCxpQkFBckI7QUFDQTc2QixZQUFNMXRCLEVBQU4sQ0FBUyxXQUFULEVBQXNCdW9ELGlCQUF0QjtBQUNBOztBQUVELFNBQU1qQyxTQUFTRixvQkFBb0JYLE9BQXBCLEVBQTZCNTRDLEtBQTdCLENBQWY7O0FBRUEsU0FBSXk1QyxNQUFKLEVBQVk7QUFDWHhVLGdCQUFVLElBQUl5VSxhQUFKLENBQWtCbHFELE1BQWxCLEVBQTBCaXFELE1BQTFCLENBQVY7QUFDQTtBQUNELEtBckVGO0FBdUVBLElBOUVEO0FBK0VBO0FBbkZxQyxFQUF2QztBQXFGQSxDOzs7Ozs7Ozs7Ozs7OztBQy9nQkQ7Ozs7O0FBS0E7Ozs7O0FBS0EsSUFBSSxDQUFDaHFELFNBQVNxbkIsT0FBVCxDQUFpQnhuQixHQUFqQixDQUFxQixlQUFyQixDQUFMLEVBQTRDO0FBQzNDLEtBQU0wc0QsZ0JBQWdCLGFBQXRCOztBQUVBLFVBQVNDLGdCQUFULENBQTBCbHBELFNBQTFCLEVBQXFDO0FBQ3BDLE1BQU0rSSxTQUFTL0ksVUFBVWdKLFNBQVYsRUFBZjtBQUNBLE1BQU1tZ0QsU0FBUyxFQUFmO0FBQ0EsTUFBTUMsV0FBVyxFQUFqQjs7QUFFQSxXQUFTQyxrQkFBVCxDQUE0Qi9zRCxJQUE1QixFQUFrQztBQUNqQztBQUNBLE9BQUk2c0QsT0FBTzdxRCxNQUFQLEdBQWdCLENBQXBCLEVBQXVCOztBQUV2QjtBQUNBO0FBQ0EsT0FDQ2hDLEtBQUtxSCxJQUFMLElBQWFqSCxTQUFTK21DLFlBQXRCLElBQ0F3bEIsY0FBY3JoRCxJQUFkLENBQW1CdEwsS0FBS2tOLE9BQUwsRUFBbkIsQ0FEQSxJQUVBLENBQUNsTixLQUFLeXNELGFBQUwsQ0FBbUIsZUFBbkIsQ0FIRixFQUlFO0FBQ0Ryc0QsYUFBU3dFLEdBQVQsQ0FBYXFCLE9BQWIsQ0FBcUIrbUQsU0FBckIsQ0FDQ0YsUUFERCxFQUVDOXNELElBRkQsRUFHQyxlQUhELEVBSUMsSUFKRDtBQU1BNnNELFdBQU85Z0QsSUFBUCxDQUFZL0wsSUFBWjtBQUNBO0FBQ0Q7O0FBRUQsT0FBSyxJQUFJK0IsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMEssT0FBT3pLLE1BQTNCLEVBQW1DRCxHQUFuQyxFQUF3QztBQUN2QyxPQUFNOEssUUFBUUosT0FBTzFLLENBQVAsQ0FBZDs7QUFFQSxPQUFJOEssTUFBTWcwQixTQUFWLEVBQXFCO0FBQ3BCO0FBQ0EsUUFBTXNELFlBQVl0M0IsTUFBTTJ6QixpQkFBTixFQUFsQjtBQUNBLFFBQU15c0IsY0FDTDlvQixVQUFVampCLFlBQVYsQ0FBdUIsSUFBdkIsRUFBNkIsSUFBN0IsS0FDQWlqQixVQUFVampCLFlBQVYsQ0FBdUIsSUFBdkIsRUFBNkIsSUFBN0IsQ0FGRDtBQUdBLFFBQUkrckMsV0FBSixFQUFpQkosT0FBTzlnRCxJQUFQLENBQVlraEQsV0FBWjtBQUNqQixJQVBELE1BT087QUFDTixRQUFNQyxTQUFTLElBQUk5c0QsU0FBU3dFLEdBQVQsQ0FBYXNvRCxNQUFqQixDQUF3QnJnRCxLQUF4QixDQUFmO0FBQ0EsUUFBSTdNLGFBQUo7QUFDQWt0RCxXQUFPQyxLQUFQLEdBQWVKLGtCQUFmOztBQUVBLFdBQVEvc0QsT0FBT2t0RCxPQUFPLzBDLElBQVAsRUFBZixFQUErQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FDQ25ZLEtBQUtxSCxJQUFMLElBQWFqSCxTQUFTK21DLFlBQXRCLElBQ0EsQ0FBQ25uQyxLQUFLb2hDLEVBQUwsQ0FBUWhoQyxTQUFTZ3RELEdBQVQsQ0FBYTU3QixLQUFyQixDQUZGLEVBR0U7QUFDRCxVQUFNcVcsU0FDTDduQyxLQUFLa2hCLFlBQUwsQ0FBa0IsSUFBbEIsRUFBd0IsSUFBeEIsS0FDQWxoQixLQUFLa2hCLFlBQUwsQ0FBa0IsSUFBbEIsRUFBd0IsSUFBeEIsQ0FGRDtBQUdBLFVBQUkybUIsVUFBVSxDQUFDQSxPQUFPNGtCLGFBQVAsQ0FBcUIsZUFBckIsQ0FBZixFQUFzRDtBQUNyRHJzRCxnQkFBU3dFLEdBQVQsQ0FBYXFCLE9BQWIsQ0FBcUIrbUQsU0FBckIsQ0FDQ0YsUUFERCxFQUVDamxCLE1BRkQsRUFHQyxlQUhELEVBSUMsSUFKRDtBQU1BZ2xCLGNBQU85Z0QsSUFBUCxDQUFZODdCLE1BQVo7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQUNEOztBQUVEem5DLFdBQVN3RSxHQUFULENBQWFxQixPQUFiLENBQXFCb25ELGVBQXJCLENBQXFDUCxRQUFyQzs7QUFFQSxTQUFPRCxNQUFQO0FBQ0E7O0FBRUQsVUFBU1MsNEJBQVQsQ0FBc0NDLGFBQXRDLEVBQXFEO0FBQ3BELE1BQUl4ckQsSUFBSSxDQUFSOztBQUVBLE1BQU15ckQsT0FBT0QsY0FBY3ZyRCxNQUFkLEdBQXVCLENBQXBDOztBQUVBLE1BQU04cUQsV0FBVyxFQUFqQjs7QUFFQSxNQUFJOStCLGFBQUo7O0FBRUEsTUFBSXkvQixvQkFBSjs7QUFFQSxNQUFJdG5CLFdBQUo7O0FBRUEsU0FBUW5ZLE9BQU91L0IsY0FBY3hyRCxHQUFkLENBQWY7QUFDQzNCLFlBQVN3RSxHQUFULENBQWFxQixPQUFiLENBQXFCK21ELFNBQXJCLENBQStCRixRQUEvQixFQUF5QzkrQixJQUF6QyxFQUErQyxhQUEvQyxFQUE4RCxJQUE5RDtBQURELEdBYm9ELENBZ0JwRDtBQUNBanNCLE1BQUksQ0FBSjtBQUNBLFNBQVFpc0IsT0FBT3UvQixjQUFjeHJELEdBQWQsQ0FBZixFQUFvQztBQUNuQyxPQUNFLENBQUMwckQsY0FBY3ovQixLQUFLMGtCLFdBQUwsRUFBZixLQUNBLENBQUMrYSxZQUFZaEIsYUFBWixDQUEwQixhQUExQixDQURGLElBRUMsQ0FBQ2dCLGNBQWN6L0IsS0FBSzRsQixPQUFMLEVBQWYsS0FDQSxDQUFDNlosWUFBWWhCLGFBQVosQ0FBMEIsYUFBMUIsQ0FKSCxFQUtFO0FBQ0Ryc0QsYUFBU3dFLEdBQVQsQ0FBYXFCLE9BQWIsQ0FBcUJvbkQsZUFBckIsQ0FBcUNQLFFBQXJDO0FBQ0EsV0FBT1csV0FBUDtBQUNBO0FBQ0Q7O0FBRURydEQsV0FBU3dFLEdBQVQsQ0FBYXFCLE9BQWIsQ0FBcUJvbkQsZUFBckIsQ0FBcUNQLFFBQXJDOztBQUVBO0FBQ0EzbUIsT0FBS29uQixjQUFjLENBQWQsRUFBaUJobUIsU0FBakIsRUFBTDtBQUNBLE1BQUtwQixLQUFLQSxHQUFHdU0sV0FBSCxFQUFWLEVBQTZCLE9BQU92TSxHQUFHeU0sT0FBSCxFQUFQOztBQUU3QjtBQUNBek0sT0FBS29uQixjQUFjQyxJQUFkLEVBQW9Cam1CLFNBQXBCLEVBQUw7QUFDQSxNQUFLcEIsS0FBS0EsR0FBR3lOLE9BQUgsRUFBVixFQUF5QixPQUFPek4sR0FBR3VDLFFBQUgsQ0FBWSxDQUFaLENBQVA7O0FBRXpCLFNBQU8sSUFBUDtBQUNBOztBQUVELFVBQVNnbEIsU0FBVCxDQUFtQnZ0RCxNQUFuQixFQUEyQitvQyxZQUEzQixFQUF5QztBQUN4QyxNQUFNeGxDLFlBQVl2RCxPQUFPb0QsWUFBUCxFQUFsQjs7QUFFQSxNQUFNd2pDLFFBQVE2bEIsaUJBQWlCbHBELFNBQWpCLENBQWQ7O0FBRUEsTUFBTW9qQyxZQUFZQyxNQUFNLENBQU4sQ0FBbEI7O0FBRUEsTUFBTXZWLFFBQVFzVixVQUFVNWxCLFlBQVYsQ0FBdUIsT0FBdkIsQ0FBZDs7QUFFQSxNQUFNNjZCLE1BQU1qVixVQUFVNm1CLFdBQVYsRUFBWjs7QUFFQSxNQUFNQyxXQUFXN21CLE1BQU0sQ0FBTixFQUFTUSxTQUFULEVBQWpCOztBQUVBLE1BQU1zbUIsZ0JBQWdCRCxTQUFTbnFELENBQVQsQ0FBV3FxRCxRQUFqQzs7QUFFQSxNQUFNQyxXQUFXaG5CLE1BQU1BLE1BQU0va0MsTUFBTixHQUFlLENBQXJCLENBQWpCOztBQUVBLE1BQU1nc0QsY0FDTEQsU0FBU3htQixTQUFULEdBQXFCOWpDLENBQXJCLENBQXVCcXFELFFBQXZCLEdBQWtDQyxTQUFTdHFELENBQVQsQ0FBV3dxRCxPQUE3QyxHQUF1RCxDQUR4RDs7QUFHQSxNQUFNQyxTQUFTLElBQUk5dEQsU0FBU3dFLEdBQVQsQ0FBYXFCLE9BQWpCLENBQXlCdXJCLE1BQU0vdEIsQ0FBTixDQUFRK3JCLElBQVIsQ0FBYXcrQixXQUFiLENBQXpCLENBQWY7O0FBRUEsTUFBTUYsV0FBVzVrQixlQUFlMmtCLGFBQWYsR0FBK0JHLFdBQWhEOztBQUVBLE1BQU1yakMsTUFBTXVlLGVBQWUwa0IsUUFBZixHQUEwQk0sTUFBdEM7O0FBRUEsTUFBTXI1QyxNQUFNelUsU0FBU3lPLEtBQVQsQ0FBZXE4QyxhQUFmLENBQTZCMTVCLEtBQTdCLENBQVo7O0FBRUEsTUFBTTI4QixXQUFXdDVDLElBQUlpNUMsUUFBSixDQUFqQjs7QUFFQSxNQUFNTSxVQUFVbGxCLGVBQWVyMEIsSUFBSWk1QyxXQUFXLENBQWYsQ0FBZixHQUFtQ2o1QyxJQUFJaTVDLFdBQVcsQ0FBZixDQUFuRDs7QUFFQSxNQUFNejlDLFFBQVF3RSxJQUFJLENBQUosRUFBTzdTLE1BQXJCOztBQUVBLE1BQU1xc0QsU0FBU3RTLElBQUlyMkMsYUFBSixDQUFrQixJQUFsQixDQUFmO0FBQ0EsT0FBSyxJQUFJM0QsSUFBSSxDQUFiLEVBQWdCb3NELFNBQVNwc0QsQ0FBVCxLQUFlQSxJQUFJc08sS0FBbkMsRUFBMEN0TyxHQUExQyxFQUErQztBQUM5QyxPQUFJaXNCLGNBQUo7QUFDQTtBQUNBLE9BQ0NtZ0MsU0FBU3BzRCxDQUFULEVBQVlrc0QsT0FBWixHQUFzQixDQUF0QixJQUNBRyxPQURBLElBRUFELFNBQVNwc0QsQ0FBVCxLQUFlcXNELFFBQVFyc0QsQ0FBUixDQUhoQixFQUlFO0FBQ0Rpc0IsWUFBT21nQyxTQUFTcHNELENBQVQsQ0FBUDtBQUNBaXNCLFVBQUtpZ0MsT0FBTCxJQUFnQixDQUFoQjtBQUNBLElBUEQsTUFPTztBQUNOamdDLFlBQU8sSUFBSTV0QixTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUJrb0QsU0FBU3BzRCxDQUFULENBQXpCLEVBQXNDdXNELEtBQXRDLEVBQVA7QUFDQXRnQyxVQUFLaWIsZUFBTCxDQUFxQixTQUFyQjtBQUNBamIsVUFBSzJZLFdBQUw7QUFDQTBuQixXQUFPNW5CLE1BQVAsQ0FBY3pZLEtBQWQ7QUFDQUEsWUFBT0EsTUFBS3ZxQixDQUFaO0FBQ0E7O0FBRUQxQixRQUFLaXNCLE1BQUs4N0IsT0FBTCxHQUFlLENBQXBCO0FBQ0E7O0FBRUQsTUFBSTVnQixZQUFKLEVBQWtCO0FBQ2pCbWxCLFVBQU9ubEIsWUFBUCxDQUFvQnZlLEdBQXBCO0FBQ0EsR0FGRCxNQUVPO0FBQ04wakMsVUFBT0UsV0FBUCxDQUFtQjVqQyxHQUFuQjtBQUNBOztBQUVELE1BQU1xRCxPQUFPLElBQUk1dEIsU0FBU3dFLEdBQVQsQ0FBYXFCLE9BQWpCLENBQXlCb29ELE9BQU81cUQsQ0FBaEMsRUFBbUNpbEMsUUFBbkMsQ0FDWjNCLE1BQU0sQ0FBTixJQUFXQSxNQUFNLENBQU4sRUFBU3RqQyxDQUFULENBQVcrcUQsU0FBdEIsR0FBa0MsQ0FEdEIsQ0FBYjtBQUdBN3NCLGdCQUFjeGhDLE1BQWQsRUFBc0I2dEIsSUFBdEI7QUFDQTs7QUFFRCxVQUFTeWdDLFVBQVQsQ0FBb0JDLGNBQXBCLEVBQW9DO0FBQ25DLE1BQUlBLDBCQUEwQnR1RCxTQUFTd0UsR0FBVCxDQUFhbEIsU0FBM0MsRUFBc0Q7QUFDckQsT0FBTXFqQyxRQUFRNmxCLGlCQUFpQjhCLGNBQWpCLENBQWQ7O0FBRUEsT0FBTTVuQixZQUFZQyxNQUFNLENBQU4sQ0FBbEI7O0FBRUEsT0FBTXZWLFFBQVFzVixVQUFVNWxCLFlBQVYsQ0FBdUIsT0FBdkIsQ0FBZDs7QUFFQSxPQUFNck0sTUFBTXpVLFNBQVN5TyxLQUFULENBQWVxOEMsYUFBZixDQUE2QjE1QixLQUE3QixDQUFaOztBQUVBLE9BQU1vOEIsV0FBVzdtQixNQUFNLENBQU4sRUFBU1EsU0FBVCxFQUFqQjs7QUFFQSxPQUFNc21CLGdCQUFnQkQsU0FBU25xRCxDQUFULENBQVdxcUQsUUFBakM7O0FBRUEsT0FBTUMsV0FBV2huQixNQUFNQSxNQUFNL2tDLE1BQU4sR0FBZSxDQUFyQixDQUFqQjs7QUFFQSxPQUFNZ3NELGNBQ0xELFNBQVN4bUIsU0FBVCxHQUFxQjlqQyxDQUFyQixDQUF1QnFxRCxRQUF2QixHQUFrQ0MsU0FBU3RxRCxDQUFULENBQVd3cUQsT0FBN0MsR0FBdUQsQ0FEeEQ7O0FBR0EsT0FBTVUsZUFBZSxFQUFyQjs7QUFFQTtBQUNBLFFBQUssSUFBSTVzRCxJQUFJOHJELGFBQWIsRUFBNEI5ckQsS0FBS2lzRCxXQUFqQyxFQUE4Q2pzRCxHQUE5QyxFQUFtRDtBQUNsRCxRQUFNNnNELFNBQVMvNUMsSUFBSTlTLENBQUosQ0FBZjs7QUFFQSxRQUFNNG9CLE1BQU0sSUFBSXZxQixTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUJ1ckIsTUFBTS90QixDQUFOLENBQVErckIsSUFBUixDQUFhenRCLENBQWIsQ0FBekIsQ0FBWjs7QUFFQSxTQUFLLElBQUkya0MsSUFBSSxDQUFiLEVBQWdCQSxJQUFJa29CLE9BQU81c0QsTUFBM0IsRUFBbUMwa0MsR0FBbkMsRUFBd0M7QUFDdkMsU0FBTTFZLE9BQU8sSUFBSTV0QixTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUIyb0QsT0FBT2xvQixDQUFQLENBQXpCLENBQWI7O0FBRUEsU0FBTW1vQixlQUFlN2dDLEtBQUt1WixTQUFMLEdBQWlCOWpDLENBQWpCLENBQW1CcXFELFFBQXhDOztBQUVBLFNBQUk5L0IsS0FBS3ZxQixDQUFMLENBQU93cUQsT0FBUCxJQUFrQixDQUF0QixFQUF5QmpnQyxLQUFLMWdCLE1BQUw7QUFDekI7QUFEQSxVQUVLO0FBQ0o7QUFDQTBnQixZQUFLdnFCLENBQUwsQ0FBT3dxRCxPQUFQLElBQWtCLENBQWxCO0FBQ0E7QUFDQSxXQUFJWSxnQkFBZ0I5c0QsQ0FBcEIsRUFBdUI7QUFDdEIsWUFBTStzRCxhQUFhajZDLElBQUk5UyxJQUFJLENBQVIsQ0FBbkI7QUFDQSxZQUFJK3NELFdBQVdwb0IsSUFBSSxDQUFmLENBQUosRUFBdUI7QUFDdEIxWSxjQUFLdWdDLFdBQUwsQ0FDQyxJQUFJbnVELFNBQVN3RSxHQUFULENBQWFxQixPQUFqQixDQUF5QjZvRCxXQUFXcG9CLElBQUksQ0FBZixDQUF6QixDQUREO0FBR0EsU0FKRCxNQUlPO0FBQ04sYUFBSXRtQyxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FDQ3VyQixNQUFNL3RCLENBQU4sQ0FBUStyQixJQUFSLENBQWF6dEIsSUFBSSxDQUFqQixDQURELEVBRUUwa0MsTUFGRixDQUVTelksSUFGVCxFQUVlLENBRmY7QUFHQTtBQUNEO0FBQ0Q7O0FBRUQwWSxVQUFLMVksS0FBS3ZxQixDQUFMLENBQU9xbUQsT0FBUCxHQUFpQixDQUF0QjtBQUNBOztBQUVENkUsaUJBQWE1aUQsSUFBYixDQUFrQjRlLEdBQWxCO0FBQ0E7O0FBRUQsT0FBTTZFLE9BQU9nQyxNQUFNL3RCLENBQU4sQ0FBUStyQixJQUFyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU11L0IsaUJBQWlCLElBQUkzdUQsU0FBU3dFLEdBQVQsQ0FBYXFCLE9BQWpCLENBQ3RCdXBCLEtBQUt3K0IsY0FBYyxDQUFuQixNQUNFSCxnQkFBZ0IsQ0FBaEIsR0FBb0JyK0IsS0FBS3ErQixnQkFBZ0IsQ0FBckIsQ0FBcEIsR0FBOEMsSUFEaEQsS0FFQ3I4QixNQUFNL3RCLENBQU4sQ0FBUVYsVUFIYSxDQUF2Qjs7QUFNQSxRQUFLLElBQUloQixLQUFJNHNELGFBQWEzc0QsTUFBMUIsRUFBa0NELE1BQUssQ0FBdkMsRUFBMENBLElBQTFDO0FBQ0Mwc0QsZUFBV0UsYUFBYTVzRCxFQUFiLENBQVg7QUFERCxJQUdBLE9BQU9ndEQsY0FBUDtBQUNBLEdBekVELE1BeUVPLElBQUlMLDBCQUEwQnR1RCxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBM0MsRUFBb0Q7QUFDMUQsT0FBTXVyQixTQUFRazlCLGVBQWV4dEMsWUFBZixDQUE0QixPQUE1QixDQUFkOztBQUVBLE9BQUlzUSxPQUFNL3RCLENBQU4sQ0FBUStyQixJQUFSLENBQWF4dEIsTUFBYixJQUF1QixDQUEzQixFQUE4Qnd2QixPQUFNbGtCLE1BQU4sR0FBOUIsS0FDS29oRCxlQUFlcGhELE1BQWY7QUFDTDs7QUFFRCxTQUFPLElBQVA7QUFDQTs7QUFFRCxVQUFTMGhELGVBQVQsQ0FBeUJoaEMsSUFBekIsRUFBK0JpaEMsT0FBL0IsRUFBd0M7QUFDdkMsTUFBTXRrQyxNQUFNcUQsS0FBS3VaLFNBQUwsRUFBWjs7QUFFQSxNQUFNMm5CLFdBQVd2a0MsSUFBSWxuQixDQUFKLENBQU1zakMsS0FBdkI7O0FBRUEsTUFBSW9vQixXQUFXLENBQWY7QUFDQSxPQUFLLElBQUlwdEQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbXRELFNBQVNsdEQsTUFBN0IsRUFBcUNELEdBQXJDLEVBQTBDO0FBQ3pDLE9BQU1xdEQsVUFBVUYsU0FBU250RCxDQUFULENBQWhCO0FBQ0FvdEQsZUFBWUYsVUFBVSxDQUFWLEdBQWNHLFFBQVF0RixPQUFsQztBQUNBLE9BQUlzRixXQUFXcGhDLEtBQUt2cUIsQ0FBcEIsRUFBdUI7QUFDdkI7O0FBRUQsU0FBTzByRCxXQUFXLENBQWxCO0FBQ0E7O0FBRUQsVUFBU0UsaUJBQVQsQ0FBMkJ0b0IsS0FBM0IsRUFBa0Nrb0IsT0FBbEMsRUFBMkM7QUFDMUMsTUFBSXBDLFNBQVNvQyxVQUFVbHFCLFFBQVYsR0FBcUIsQ0FBbEM7QUFDQSxPQUFLLElBQUloakMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJZ2xDLE1BQU0va0MsTUFBMUIsRUFBa0NELEdBQWxDLEVBQXVDO0FBQ3RDLE9BQU1vdEQsV0FBV0gsZ0JBQWdCam9CLE1BQU1obEMsQ0FBTixDQUFoQixFQUEwQmt0RCxPQUExQixDQUFqQjtBQUNBLE9BQUlBLFVBQVVFLFdBQVd0QyxNQUFyQixHQUE4QnNDLFdBQVd0QyxNQUE3QyxFQUNDQSxTQUFTc0MsUUFBVDtBQUNEO0FBQ0QsU0FBT3RDLE1BQVA7QUFDQTs7QUFFRCxVQUFTeUMsWUFBVCxDQUFzQm52RCxNQUF0QixFQUE4QitvQyxZQUE5QixFQUE0QztBQUMzQyxNQUFNeGxDLFlBQVl2RCxPQUFPb0QsWUFBUCxFQUFsQjs7QUFFQSxNQUFNd2pDLFFBQVE2bEIsaUJBQWlCbHBELFNBQWpCLENBQWQ7O0FBRUEsTUFBTW9qQyxZQUFZQyxNQUFNLENBQU4sQ0FBbEI7O0FBRUEsTUFBTXZWLFFBQVFzVixVQUFVNWxCLFlBQVYsQ0FBdUIsT0FBdkIsQ0FBZDs7QUFFQSxNQUFNcXVDLFdBQVdGLGtCQUFrQnRvQixLQUFsQixFQUF5QixDQUF6QixDQUFqQjs7QUFFQSxNQUFNeW9CLFVBQVVILGtCQUFrQnRvQixLQUFsQixDQUFoQjs7QUFFQSxNQUFNb29CLFdBQVdqbUIsZUFBZXFtQixRQUFmLEdBQTBCQyxPQUEzQzs7QUFFQSxNQUFNMzZDLE1BQU16VSxTQUFTeU8sS0FBVCxDQUFlcThDLGFBQWYsQ0FBNkIxNUIsS0FBN0IsQ0FBWjs7QUFFQSxNQUFNaStCLFdBQVcsRUFBakI7O0FBRUEsTUFBTUMsVUFBVSxFQUFoQjs7QUFFQSxNQUFNbjhDLFNBQVNzQixJQUFJN1MsTUFBbkI7O0FBRUEsT0FBSyxJQUFJRCxJQUFJLENBQWIsRUFBZ0JBLElBQUl3UixNQUFwQixFQUE0QnhSLEdBQTVCLEVBQWlDO0FBQ2hDMHRELFlBQVMxakQsSUFBVCxDQUFjOEksSUFBSTlTLENBQUosRUFBT290RCxRQUFQLENBQWQ7QUFDQSxPQUFNUSxXQUFXem1CLGVBQ2RyMEIsSUFBSTlTLENBQUosRUFBT290RCxXQUFXLENBQWxCLENBRGMsR0FFZHQ2QyxJQUFJOVMsQ0FBSixFQUFPb3RELFdBQVcsQ0FBbEIsQ0FGSDtBQUdBTyxXQUFRM2pELElBQVIsQ0FBYTRqRCxRQUFiO0FBQ0E7O0FBRUQsTUFBTUMsZ0JBQWdCLEVBQXRCO0FBQ0EsT0FBSyxJQUFJN3RELE1BQUksQ0FBYixFQUFnQkEsTUFBSXdSLE1BQXBCLEVBQTRCeFIsS0FBNUIsRUFBaUM7QUFDaEMsT0FBSWlzQixlQUFKOztBQUVBLE9BQUksQ0FBQ3loQyxTQUFTMXRELEdBQVQsQ0FBTCxFQUFrQjs7QUFFbEI7QUFDQSxPQUFJMHRELFNBQVMxdEQsR0FBVCxFQUFZK25ELE9BQVosR0FBc0IsQ0FBdEIsSUFBMkI0RixRQUFRM3RELEdBQVIsS0FBYzB0RCxTQUFTMXRELEdBQVQsQ0FBN0MsRUFBMEQ7QUFDekRpc0IsYUFBT3loQyxTQUFTMXRELEdBQVQsQ0FBUDtBQUNBaXNCLFdBQUs4N0IsT0FBTCxJQUFnQixDQUFoQjtBQUNBLElBSEQsTUFHTztBQUNOOTdCLGFBQU8sSUFBSTV0QixTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUJ3cEQsU0FBUzF0RCxHQUFULENBQXpCLEVBQXNDdXNELEtBQXRDLEVBQVA7QUFDQXRnQyxXQUFLaWIsZUFBTCxDQUFxQixTQUFyQjtBQUNBamIsV0FBSzJZLFdBQUw7QUFDQTNZLFdBQUtrYixlQUFlLGNBQWYsR0FBZ0MsYUFBckMsRUFBb0RycEMsSUFBcEQsQ0FDQ211QixNQURELEVBRUMsSUFBSTV0QixTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUJ3cEQsU0FBUzF0RCxHQUFULENBQXpCLENBRkQ7QUFJQWlzQixhQUFPQSxPQUFLdnFCLENBQVo7QUFDQTs7QUFFRG1zRCxpQkFBYzd0RCxHQUFkLElBQW1CaXNCLE1BQW5COztBQUVBanNCLFVBQUtpc0IsT0FBS2lnQyxPQUFMLEdBQWUsQ0FBcEI7QUFDQTs7QUFFRCxNQUFNamdDLE9BQU8sSUFBSTV0QixTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FDWjJwRCxjQUFjOW9CLFVBQVVTLFNBQVYsR0FBc0I5akMsQ0FBdEIsQ0FBd0JxcUQsUUFBdEMsQ0FEWSxDQUFiO0FBR0Fuc0IsZ0JBQWN4aEMsTUFBZCxFQUFzQjZ0QixJQUF0QjtBQUNBOztBQUVELFVBQVMyVCxhQUFULENBQXVCeGhDLE1BQXZCLEVBQStCOEYsT0FBL0IsRUFBd0M7QUFDdkMsTUFBTTRHLFFBQVExTSxPQUFPd2pDLFdBQVAsRUFBZDs7QUFFQTkyQixRQUFNbTZCLGNBQU4sQ0FBcUIvZ0MsT0FBckIsRUFBOEI3RixTQUFTNm1DLG9CQUF2QztBQUNBOW1DLFNBQU9vRCxZQUFQLEdBQXNCOEosWUFBdEIsQ0FBbUMsQ0FBQ1IsS0FBRCxDQUFuQztBQUNBOztBQUVELFVBQVNnakQsYUFBVCxDQUF1QkMsZUFBdkIsRUFBd0M7QUFDdkMsTUFBTS9vQixRQUFRNmxCLGlCQUFpQmtELGVBQWpCLENBQWQ7O0FBRUEsTUFBTWhwQixZQUFZQyxNQUFNLENBQU4sQ0FBbEI7O0FBRUEsTUFBTWduQixXQUFXaG5CLE1BQU1BLE1BQU0va0MsTUFBTixHQUFlLENBQXJCLENBQWpCOztBQUVBLE1BQU13dkIsUUFBUXNWLFVBQVU1bEIsWUFBVixDQUF1QixPQUF2QixDQUFkOztBQUVBLE1BQU1yTSxNQUFNelUsU0FBU3lPLEtBQVQsQ0FBZXE4QyxhQUFmLENBQTZCMTVCLEtBQTdCLENBQVo7O0FBRUEsTUFBSXUrQixzQkFBSjs7QUFFQSxNQUFJQyxvQkFBSjs7QUFFQSxNQUFNckIsZUFBZSxFQUFyQjs7QUFFQSxNQUFJbi9CLGFBQUo7O0FBRUE7QUFDQSxPQUFLLElBQUl6dEIsSUFBSSxDQUFSLEVBQVd5dEIsUUFBTzNhLElBQUk3UyxNQUEzQixFQUFtQ0QsSUFBSXl0QixLQUF2QyxFQUE2Q3p0QixHQUE3QyxFQUFrRDtBQUNqRDtBQUNBLFFBQUssSUFBSTJrQyxJQUFJLENBQVIsRUFBV25YLE9BQU8xYSxJQUFJOVMsQ0FBSixFQUFPQyxNQUE5QixFQUFzQzBrQyxJQUFJblgsSUFBMUMsRUFBZ0RtWCxHQUFoRCxFQUFxRDtBQUNwRCxRQUFJN3hCLElBQUk5UyxDQUFKLEVBQU8ya0MsQ0FBUCxLQUFhSSxVQUFVcmpDLENBQTNCLEVBQThCc3NELGdCQUFnQnJwQixDQUFoQjtBQUM5QixRQUFJN3hCLElBQUk5UyxDQUFKLEVBQU8ya0MsQ0FBUCxLQUFhcW5CLFNBQVN0cUQsQ0FBMUIsRUFBNkJ1c0QsY0FBY3RwQixDQUFkO0FBQzdCO0FBQ0Q7O0FBRUQ7QUFDQSxPQUFLLElBQUkza0MsTUFBSWd1RCxhQUFiLEVBQTRCaHVELE9BQUtpdUQsV0FBakMsRUFBOENqdUQsS0FBOUMsRUFBbUQ7QUFDbEQsUUFBSyxJQUFJMmtDLEtBQUksQ0FBYixFQUFnQkEsS0FBSTd4QixJQUFJN1MsTUFBeEIsRUFBZ0Mwa0MsSUFBaEMsRUFBcUM7QUFDcEMsUUFBTWtvQixTQUFTLzVDLElBQUk2eEIsRUFBSixDQUFmOztBQUVBLFFBQU0vYixNQUFNLElBQUl2cUIsU0FBU3dFLEdBQVQsQ0FBYXFCLE9BQWpCLENBQXlCdXJCLE1BQU0vdEIsQ0FBTixDQUFRK3JCLElBQVIsQ0FBYWtYLEVBQWIsQ0FBekIsQ0FBWjs7QUFFQSxRQUFNMVksT0FBTyxJQUFJNXRCLFNBQVN3RSxHQUFULENBQWFxQixPQUFqQixDQUF5QjJvRCxPQUFPN3NELEdBQVAsQ0FBekIsQ0FBYjs7QUFFQSxRQUFJaXNCLEtBQUt2cUIsQ0FBVCxFQUFZO0FBQ1gsU0FBSXVxQixLQUFLdnFCLENBQUwsQ0FBT3FtRCxPQUFQLElBQWtCLENBQXRCLEVBQXlCOTdCLEtBQUsxZ0IsTUFBTDtBQUN6QjtBQURBLFVBRUswZ0IsS0FBS3ZxQixDQUFMLENBQU9xbUQsT0FBUCxJQUFrQixDQUFsQjs7QUFFTHBqQixXQUFLMVksS0FBS3ZxQixDQUFMLENBQU93cUQsT0FBUCxHQUFpQixDQUF0Qjs7QUFFQSxTQUFJLENBQUN0akMsSUFBSWxuQixDQUFKLENBQU1zakMsS0FBTixDQUFZL2tDLE1BQWpCLEVBQXlCMnNELGFBQWE1aUQsSUFBYixDQUFrQjRlLEdBQWxCO0FBQ3pCO0FBQ0Q7QUFDRDs7QUFFRCxNQUFNc2xDLGdCQUFnQnorQixNQUFNL3RCLENBQU4sQ0FBUStyQixJQUFSLENBQWEsQ0FBYixLQUFtQmdDLE1BQU0vdEIsQ0FBTixDQUFRK3JCLElBQVIsQ0FBYSxDQUFiLEVBQWdCdVgsS0FBekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNZ29CLGlCQUFpQixJQUFJM3VELFNBQVN3RSxHQUFULENBQWFxQixPQUFqQixDQUN0QmdxRCxjQUFjRixhQUFkLE1BQ0VBLGdCQUNFRSxjQUFjRixnQkFBZ0IsQ0FBOUIsQ0FERixHQUVFditCLE1BQU0vdEIsQ0FBTixDQUFRVixVQUhaLENBRHNCLENBQXZCOztBQU9BO0FBQ0EsTUFBSTRyRCxhQUFhM3NELE1BQWIsSUFBdUJ3dEIsSUFBM0IsRUFBaUNnQyxNQUFNbGtCLE1BQU47O0FBRWpDLFNBQU95aEQsY0FBUDtBQUNBOztBQUVELFVBQVNtQixVQUFULENBQW9CeHNELFNBQXBCLEVBQStCd2xDLFlBQS9CLEVBQTZDO0FBQzVDLE1BQU1pbkIsZUFBZXpzRCxVQUFVMlYsZUFBVixFQUFyQjtBQUNBLE1BQU0yVSxPQUNMbWlDLGFBQWFqdkMsWUFBYixDQUEwQixJQUExQixFQUFnQyxDQUFoQyxLQUNBaXZDLGFBQWFqdkMsWUFBYixDQUEwQixJQUExQixFQUFnQyxDQUFoQyxDQUZEOztBQUlBLE1BQUksQ0FBQzhNLElBQUwsRUFBVzs7QUFFWDtBQUNBLE1BQU1nYSxVQUFVaGEsS0FBS3NnQyxLQUFMLEVBQWhCO0FBQ0F0bUIsVUFBUXJCLFdBQVI7O0FBRUEsTUFBSXVDLFlBQUosRUFBa0JsQixRQUFRa0IsWUFBUixDQUFxQmxiLElBQXJCLEVBQWxCLEtBQ0tnYSxRQUFRdW1CLFdBQVIsQ0FBb0J2Z0MsSUFBcEI7QUFDTDs7QUFFRCxVQUFTb2lDLFdBQVQsQ0FBcUJOLGVBQXJCLEVBQXNDO0FBQ3JDLE1BQUlBLDJCQUEyQjF2RCxTQUFTd0UsR0FBVCxDQUFhbEIsU0FBNUMsRUFBdUQ7QUFDdEQsT0FBTTZwRCxnQkFBZ0JYLGlCQUFpQmtELGVBQWpCLENBQXRCO0FBQ0EsT0FBTXQrQixRQUNMKzdCLGNBQWMsQ0FBZCxLQUFvQkEsY0FBYyxDQUFkLEVBQWlCcnNDLFlBQWpCLENBQThCLE9BQTlCLENBRHJCO0FBRUEsT0FBTW12QyxjQUFjL0MsNkJBQTZCQyxhQUE3QixDQUFwQjs7QUFFQSxRQUFLLElBQUl4ckQsSUFBSXdyRCxjQUFjdnJELE1BQWQsR0FBdUIsQ0FBcEMsRUFBdUNELEtBQUssQ0FBNUMsRUFBK0NBLEdBQS9DO0FBQ0NxdUQsZ0JBQVk3QyxjQUFjeHJELENBQWQsQ0FBWjtBQURELElBR0EsSUFBSXN1RCxXQUFKLEVBQWlCQyxrQkFBa0JELFdBQWxCLEVBQStCLElBQS9CLEVBQWpCLEtBQ0ssSUFBSTcrQixLQUFKLEVBQVdBLE1BQU1sa0IsTUFBTjtBQUNoQixHQVhELE1BV08sSUFBSXdpRCwyQkFBMkIxdkQsU0FBU3dFLEdBQVQsQ0FBYXFCLE9BQTVDLEVBQXFEO0FBQzNELE9BQU1rZ0MsS0FBSzJwQixnQkFBZ0J2b0IsU0FBaEIsRUFBWDtBQUNBLE9BQUlwQixHQUFHMkIsYUFBSCxNQUFzQixDQUExQixFQUE2QjNCLEdBQUc3NEIsTUFBSCxHQUE3QixLQUNLd2lELGdCQUFnQnhpRCxNQUFoQjtBQUNMO0FBQ0Q7O0FBRUQ7QUFDQSxVQUFTaWpELFFBQVQsQ0FBa0J2aUMsSUFBbEIsRUFBd0I7QUFDdkIsTUFBTXdpQyxRQUFReGlDLEtBQUt5aUMsUUFBTCxFQUFkO0FBQ0EsTUFBSUQsS0FBSixFQUFXO0FBQ1ZBLFNBQU1sakQsTUFBTjtBQUNBO0FBQ0QwZ0IsT0FBSzZ3QixJQUFMO0FBQ0E7O0FBRUQsVUFBU3lSLGlCQUFULENBQTJCdGlDLElBQTNCLEVBQWlDMGlDLFVBQWpDLEVBQTZDO0FBQzVDLE1BQU1DLFdBQVczaUMsS0FBSzIvQixXQUFMLEVBQWpCOztBQUVBLE1BQU1pRCxXQUFXeHdELFNBQVNvRCxRQUExQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUlwRCxTQUFTYyxHQUFULENBQWFDLEVBQWIsSUFBbUJmLFNBQVNjLEdBQVQsQ0FBYUksT0FBYixJQUF3QixFQUEvQyxFQUFtRDtBQUNsRHN2RCxZQUFTOTZDLEtBQVQ7QUFDQTY2QyxZQUFTNzZDLEtBQVQ7QUFDQTs7QUFFRCxNQUFNakosUUFBUSxJQUFJek0sU0FBU3dFLEdBQVQsQ0FBYWlJLEtBQWpCLENBQXVCOGpELFFBQXZCLENBQWQ7QUFDQSxNQUNDLENBQUM5akQsTUFBTSx1QkFBdUI2akQsYUFBYSxLQUFiLEdBQXFCLE9BQTVDLENBQU4sRUFBNEQxaUMsSUFBNUQsQ0FERixFQUVFO0FBQ0RuaEIsU0FBTW0wQixrQkFBTixDQUF5QmhULElBQXpCO0FBQ0FuaEIsU0FBTWdrRCxRQUFOLENBQWVILGFBQWEsS0FBYixHQUFxQixJQUFwQztBQUNBO0FBQ0Q3akQsUUFBTXMwQixNQUFOLENBQWEsSUFBYjtBQUNBOztBQUVELFVBQVMydkIsU0FBVCxDQUFtQkMsUUFBbkIsRUFBNkJqRCxRQUE3QixFQUF1QzkvQixJQUF2QyxFQUE2QztBQUM1QyxNQUFNZ2pDLE9BQU9ELFNBQVNqRCxRQUFULENBQWI7QUFDQSxNQUFJLE9BQU85L0IsSUFBUCxJQUFlLFdBQW5CLEVBQWdDLE9BQU9nakMsSUFBUDs7QUFFaEMsT0FBSyxJQUFJbFksSUFBSSxDQUFiLEVBQWdCa1ksUUFBUWxZLElBQUlrWSxLQUFLaHZELE1BQWpDLEVBQXlDODJDLEdBQXpDLEVBQThDO0FBQzdDLE9BQUk5cUIsS0FBS29ULEVBQUwsSUFBVzR2QixLQUFLbFksQ0FBTCxLQUFXOXFCLEtBQUt2cUIsQ0FBL0IsRUFBa0MsT0FBT3ExQyxDQUFQLENBQWxDLEtBQ0ssSUFBSUEsS0FBSzlxQixJQUFULEVBQWUsT0FBTyxJQUFJNXRCLFNBQVN3RSxHQUFULENBQWFxQixPQUFqQixDQUF5QitxRCxLQUFLbFksQ0FBTCxDQUF6QixDQUFQO0FBQ3BCO0FBQ0QsU0FBTzlxQixLQUFLb1QsRUFBTCxHQUFVLENBQUMsQ0FBWCxHQUFlLElBQXRCO0FBQ0E7O0FBRUQsVUFBUzZ2QixTQUFULENBQW1CRixRQUFuQixFQUE2QjVCLFFBQTdCLEVBQXVDO0FBQ3RDLE1BQU0rQixPQUFPLEVBQWI7QUFDQSxPQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUosU0FBUy91RCxNQUE3QixFQUFxQ212RCxHQUFyQyxFQUEwQztBQUN6QyxPQUFNeG1DLE1BQU1vbUMsU0FBU0ksQ0FBVCxDQUFaO0FBQ0FELFFBQUtubEQsSUFBTCxDQUFVNGUsSUFBSXdrQyxRQUFKLENBQVY7O0FBRUE7QUFDQSxPQUFJeGtDLElBQUl3a0MsUUFBSixFQUFjbEIsT0FBZCxHQUF3QixDQUE1QixFQUErQmtELEtBQUt4bUMsSUFBSXdrQyxRQUFKLEVBQWNsQixPQUFkLEdBQXdCLENBQTdCO0FBQy9CO0FBQ0QsU0FBT2lELElBQVA7QUFDQTs7QUFFRCxVQUFTRSxVQUFULENBQW9CMXRELFNBQXBCLEVBQStCMnRELGNBQS9CLEVBQStDQyxRQUEvQyxFQUF5RDtBQUN4RCxNQUFNdnFCLFFBQVE2bEIsaUJBQWlCbHBELFNBQWpCLENBQWQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJNnRELHVCQUFKO0FBQ0EsTUFDQyxDQUFDRixpQkFBaUJ0cUIsTUFBTS9rQyxNQUFOLElBQWdCLENBQWpDLEdBQXFDK2tDLE1BQU0va0MsTUFBTixHQUFlLENBQXJELEtBQ0MsQ0FBQ3V2RCxpQkFBaUI3dEQsVUFBVTg4QixpQkFBVixFQUFsQixLQUNBK3dCLGVBQWVscUQsSUFBZixJQUF1QmpILFNBQVMrbUMsWUFEaEMsSUFFQW9xQixlQUFlbndCLEVBQWYsQ0FBa0IsT0FBbEIsQ0FKRixFQU1DLE9BQU8sS0FBUDs7QUFFRCxNQUFJcFQsYUFBSjs7QUFFQSxNQUFNOFksWUFBWUMsTUFBTSxDQUFOLENBQWxCOztBQUVBLE1BQU12VixRQUFRc1YsVUFBVTVsQixZQUFWLENBQXVCLE9BQXZCLENBQWQ7O0FBRUEsTUFBTXJNLE1BQU16VSxTQUFTeU8sS0FBVCxDQUFlcThDLGFBQWYsQ0FBNkIxNUIsS0FBN0IsQ0FBWjs7QUFFQSxNQUFNZ2dDLFlBQVkzOEMsSUFBSTdTLE1BQXRCOztBQUVBLE1BQU15dkQsV0FBVzU4QyxJQUFJLENBQUosRUFBTzdTLE1BQXhCOztBQUVBLE1BQU00ckQsV0FBVzltQixVQUFVUyxTQUFWLEdBQXNCOWpDLENBQXRCLENBQXdCcXFELFFBQXpDOztBQUVBLE1BQU00RCxjQUFjWixVQUFVajhDLEdBQVYsRUFBZSs0QyxRQUFmLEVBQXlCOW1CLFNBQXpCLENBQXBCOztBQUVBLE1BQUl1cUIsY0FBSixFQUFvQjtBQUNuQixPQUFJTSxtQkFBSjtBQUNBLE9BQUk7QUFDSCxRQUFNQyxVQUNMaCtDLFNBQVNrekIsVUFBVWh1QixZQUFWLENBQXVCLFNBQXZCLENBQVQsRUFBNEMsRUFBNUMsS0FBbUQsQ0FEcEQ7QUFFQSxRQUFNKzRDLFVBQ0xqK0MsU0FBU2t6QixVQUFVaHVCLFlBQVYsQ0FBdUIsU0FBdkIsQ0FBVCxFQUE0QyxFQUE1QyxLQUFtRCxDQURwRDs7QUFHQTY0QyxpQkFDQzk4QyxJQUNDdzhDLGtCQUFrQixJQUFsQixHQUNHekQsV0FBV2dFLE9BRGQsR0FFR1Asa0JBQWtCLE1BQWxCLEdBQ0F6RCxXQUFXZ0UsT0FEWCxHQUVBaEUsUUFMSixFQU9DeUQsa0JBQWtCLE1BQWxCLEdBQ0dLLGNBQWNHLE9BRGpCLEdBRUdSLGtCQUFrQixPQUFsQixHQUNBSyxjQUFjRyxPQURkLEdBRUFILFdBWEosQ0FERDtBQWNBLElBcEJELENBb0JFLE9BQU9JLEVBQVAsRUFBVztBQUNaLFdBQU8sS0FBUDtBQUNBOztBQUVEO0FBQ0E7QUFDQSxPQUFJLENBQUNILFVBQUQsSUFBZTdxQixVQUFVcmpDLENBQVYsSUFBZWt1RCxVQUFsQyxFQUE4QyxPQUFPLEtBQVA7O0FBRTlDO0FBQ0E1cUIsU0FDQ3NxQixrQkFBa0IsSUFBbEIsSUFBMEJBLGtCQUFrQixNQUE1QyxHQUNHLFNBREgsR0FFRyxNQUhKLEVBSUUsSUFBSWp4RCxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FBeUIwckQsVUFBekIsQ0FKRjtBQUtBOztBQUVEO0FBQ0EsTUFBTTVWLE1BQU1qVixVQUFVNm1CLFdBQVYsRUFBWjs7QUFFQSxNQUFJb0UsZUFBZW5FLFFBQW5COztBQUVBLE1BQUlvRSxlQUFlLENBQW5COztBQUVBLE1BQUlDLGVBQWUsQ0FBbkI7O0FBRUE7O0FBRUEsTUFBTUMsT0FBTyxDQUFDWixRQUFELElBQWEsSUFBSWx4RCxTQUFTd0UsR0FBVCxDQUFhdXRELGdCQUFqQixDQUFrQ3BXLEdBQWxDLENBQTFCOztBQUVBLE1BQUkvQyxZQUFZLENBQWhCOztBQUVBLE9BQUssSUFBSWozQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlnbEMsTUFBTS9rQyxNQUExQixFQUFrQ0QsR0FBbEMsRUFBdUM7QUFDdENpc0IsVUFBTytZLE1BQU1obEMsQ0FBTixDQUFQOztBQUVBLE9BQU1va0MsS0FBS25ZLEtBQUt1WixTQUFMLEVBQVg7O0FBRUEsT0FBTTZxQixpQkFBaUJwa0MsS0FBSzhhLFFBQUwsRUFBdkI7O0FBRUEsT0FBTWdoQixVQUFVOTdCLEtBQUt2cUIsQ0FBTCxDQUFPcW1ELE9BQXZCOztBQUVBLE9BQU1tRSxVQUFVamdDLEtBQUt2cUIsQ0FBTCxDQUFPd3FELE9BQXZCOztBQUVBLE9BQU1ILFdBQVczbkIsR0FBRzFpQyxDQUFILENBQUtxcUQsUUFBdEI7O0FBRUEsT0FBTXFCLFdBQVcyQixVQUFVajhDLEdBQVYsRUFBZWk1QyxRQUFmLEVBQXlCOS9CLElBQXpCLENBQWpCOztBQUVBO0FBQ0FnckIsZ0JBQWE4USxVQUFVbUUsT0FBdkI7QUFDQTtBQUNBZ0Usa0JBQWVoaEQsS0FBS0UsR0FBTCxDQUNkOGdELFlBRGMsRUFFZDlDLFdBQVd1QyxXQUFYLEdBQXlCNUgsT0FGWCxDQUFmO0FBSUFrSSxrQkFBZS9nRCxLQUFLRSxHQUFMLENBQ2Q2Z0QsWUFEYyxFQUVkbEUsV0FBV0YsUUFBWCxHQUFzQkssT0FGUixDQUFmOztBQUtBLE9BQUksQ0FBQ3FELFFBQUwsRUFBZTtBQUNkO0FBQ0EsUUFBS2YsU0FBU3ZpQyxJQUFULEdBQWdCQSxLQUFLcVQsV0FBTCxHQUFtQkMsS0FBbkIsRUFBckIsRUFBa0Q7QUFDakQ7QUFDQSxTQUNDd3NCLFlBQVlpRSxZQUFaLElBQ0FLLGNBREEsSUFFQSxFQUNDQSxlQUFlQyxlQUFmLElBQ0FELGVBQWVDLGVBQWYsQ0FBK0IsRUFBQzNqQixJQUFJLENBQUwsRUFBL0IsQ0FGRCxDQUhELEVBT0U7QUFDRCxVQUFNOGUsT0FBTzBFLEtBQUt0ZixPQUFMLENBQ1p4eUMsU0FBU3dFLEdBQVQsQ0FBYXNvRCxNQUFiLENBQW9Cb0YsV0FBcEIsQ0FBZ0MsSUFBaEMsQ0FEWSxDQUFiO0FBR0EsVUFBSTlFLFFBQVEsRUFBRUEsS0FBS3BzQixFQUFMLElBQVdvc0IsS0FBS3BzQixFQUFMLENBQVEsSUFBUixDQUFiLENBQVosRUFDQzh3QixLQUFLenJCLE1BQUwsQ0FBWSxJQUFaO0FBQ0Q7O0FBRUR6WSxVQUFLdWtDLFlBQUwsQ0FBa0JMLElBQWxCO0FBQ0E7QUFDRCxRQUFJbndELENBQUosRUFBTztBQUNOaXNCLFVBQUsxZ0IsTUFBTDtBQUNBLEtBRkQsTUFFTztBQUNOMGdCLFVBQUtnMUIsT0FBTCxDQUFhLEVBQWI7QUFDQTtBQUNEO0FBQ0QrTyxrQkFBZWpFLFFBQWY7QUFDQTs7QUFFRCxNQUFJLENBQUN3RCxRQUFMLEVBQWU7QUFDZFksUUFBS0ssWUFBTCxDQUFrQnpyQixTQUFsQjs7QUFFQUEsYUFBVUgsV0FBVjs7QUFFQSxPQUFJc3JCLGdCQUFnQlIsUUFBcEIsRUFBOEIzcUIsVUFBVW1DLGVBQVYsQ0FBMEIsU0FBMUIsRUFBOUIsS0FDS25DLFVBQVVyakMsQ0FBVixDQUFZd3FELE9BQVosR0FBc0IrRCxZQUF0Qjs7QUFFTCxPQUFJQSxnQkFBZ0JSLFNBQXBCLEVBQStCMXFCLFVBQVVtQyxlQUFWLENBQTBCLFNBQTFCLEVBQS9CLEtBQ0tuQyxVQUFVcmpDLENBQVYsQ0FBWXFtRCxPQUFaLEdBQXNCbUksWUFBdEI7O0FBRUw7QUFDQSxPQUFNTyxNQUFNLElBQUlweUQsU0FBU3dFLEdBQVQsQ0FBYTZ0RCxRQUFqQixDQUEwQmpoQyxNQUFNL3RCLENBQU4sQ0FBUStyQixJQUFsQyxDQUFaOztBQUVBLE9BQUk4UixRQUFRa3hCLElBQUlseEIsS0FBSixFQUFaOztBQUVBLFFBQUssSUFBSXYvQixNQUFJdS9CLFFBQVEsQ0FBckIsRUFBd0J2L0IsT0FBSyxDQUE3QixFQUFnQ0EsS0FBaEMsRUFBcUM7QUFDcEMsUUFBTTJ3RCxTQUFTRixJQUFJanhCLE9BQUosQ0FBWXgvQixHQUFaLENBQWY7QUFDQSxRQUFJLENBQUMyd0QsT0FBT2p2RCxDQUFQLENBQVNzakMsS0FBVCxDQUFlL2tDLE1BQXBCLEVBQTRCO0FBQzNCMHdELFlBQU9wbEQsTUFBUDtBQUNBZzBCO0FBQ0E7QUFDQTtBQUNEOztBQUVELFVBQU93RixTQUFQO0FBQ0E7QUFDRDtBQUNBO0FBNUJBLE9BNkJLO0FBQ0osV0FBT2tyQixlQUFlQyxZQUFmLElBQStCalosU0FBdEM7QUFDQTtBQUNEOztBQUVELFVBQVMyWixpQkFBVCxDQUEyQmp2RCxTQUEzQixFQUFzQzR0RCxRQUF0QyxFQUFnRDtBQUMvQyxNQUFNdnFCLFFBQVE2bEIsaUJBQWlCbHBELFNBQWpCLENBQWQ7QUFDQSxNQUFJcWpDLE1BQU0va0MsTUFBTixHQUFlLENBQW5CLEVBQXNCLE9BQU8sS0FBUCxDQUF0QixLQUNLLElBQUlzdkQsUUFBSixFQUFjLE9BQU8sSUFBUDs7QUFFbkIsTUFBTXRqQyxPQUFPK1ksTUFBTSxDQUFOLENBQWI7O0FBRUEsTUFBTVosS0FBS25ZLEtBQUt1WixTQUFMLEVBQVg7O0FBRUEsTUFBTS9WLFFBQVEyVSxHQUFHamxCLFlBQUgsQ0FBZ0IsT0FBaEIsQ0FBZDs7QUFFQSxNQUFNck0sTUFBTXpVLFNBQVN5TyxLQUFULENBQWVxOEMsYUFBZixDQUE2QjE1QixLQUE3QixDQUFaOztBQUVBLE1BQU1zOEIsV0FBVzNuQixHQUFHMWlDLENBQUgsQ0FBS3FxRCxRQUF0Qjs7QUFFQSxNQUFNcUIsV0FBVzJCLFVBQVVqOEMsR0FBVixFQUFlaTVDLFFBQWYsRUFBeUI5L0IsSUFBekIsQ0FBakI7O0FBRUEsTUFBTWlnQyxVQUFVamdDLEtBQUt2cUIsQ0FBTCxDQUFPd3FELE9BQXZCOztBQUVBLE1BQUlqbUIsZ0JBQUo7O0FBRUEsTUFBSTRxQixtQkFBSjs7QUFFQSxNQUFJQyx1QkFBSjs7QUFFQSxNQUFJQyxvQkFBSjs7QUFFQSxNQUFJN0UsVUFBVSxDQUFkLEVBQWlCO0FBQ2hCMkUsZ0JBQWEzaEQsS0FBSzhoRCxJQUFMLENBQVU5RSxVQUFVLENBQXBCLENBQWI7QUFDQTRFLG9CQUFpQjVoRCxLQUFLMm5CLEtBQUwsQ0FBV3ExQixVQUFVLENBQXJCLENBQWpCO0FBQ0E2RSxpQkFBY2hGLFdBQVc4RSxVQUF6QjtBQUNBLE9BQU1JLFlBQVksSUFBSTV5RCxTQUFTd0UsR0FBVCxDQUFhcUIsT0FBakIsQ0FDakJ1ckIsTUFBTS90QixDQUFOLENBQVErckIsSUFBUixDQUFhc2pDLFdBQWIsQ0FEaUIsQ0FBbEI7O0FBSUEsT0FBTUcsYUFBYW5DLFVBQVVqOEMsR0FBVixFQUFlaStDLFdBQWYsQ0FBbkI7O0FBRUEsT0FBSUksc0JBQUo7O0FBRUFsckIsYUFBVWhhLEtBQUtzZ0MsS0FBTCxFQUFWOztBQUVBO0FBQ0EsUUFBSyxJQUFJeFYsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbWEsV0FBV2p4RCxNQUEvQixFQUF1QzgyQyxHQUF2QyxFQUE0QztBQUMzQ29hLG9CQUFnQkQsV0FBV25hLENBQVgsQ0FBaEI7QUFDQTtBQUNBLFFBQUlvYSxjQUFjbndELFVBQWQsSUFBNEJpd0QsVUFBVXZ2RCxDQUF0QyxJQUEyQ3ExQyxJQUFJcVcsUUFBbkQsRUFBNkQ7QUFDNURubkIsYUFBUWtCLFlBQVIsQ0FDQyxJQUFJOW9DLFNBQVN3RSxHQUFULENBQWFxQixPQUFqQixDQUF5Qml0RCxhQUF6QixDQUREO0FBR0E7QUFDQSxLQUxELE1BS087QUFDTkEscUJBQWdCLElBQWhCO0FBQ0E7QUFDRDs7QUFFRDtBQUNBLE9BQUksQ0FBQ0EsYUFBTCxFQUFvQkYsVUFBVXZzQixNQUFWLENBQWlCdUIsT0FBakI7QUFDcEIsR0E5QkQsTUE4Qk87QUFDTjZxQixvQkFBaUJELGFBQWEsQ0FBOUI7O0FBRUEsT0FBTUksYUFBWTdzQixHQUFHbW9CLEtBQUgsRUFBbEI7QUFDQTBFLGNBQVV6RSxXQUFWLENBQXNCcG9CLEVBQXRCO0FBQ0E2c0IsY0FBVXZzQixNQUFWLENBQWtCdUIsVUFBVWhhLEtBQUtzZ0MsS0FBTCxFQUE1Qjs7QUFFQSxPQUFNNkUsaUJBQWlCckMsVUFBVWo4QyxHQUFWLEVBQWVpNUMsUUFBZixDQUF2QjtBQUNBLFFBQUssSUFBSS9yRCxJQUFJLENBQWIsRUFBZ0JBLElBQUlveEQsZUFBZW54RCxNQUFuQyxFQUEyQ0QsR0FBM0M7QUFDQ294RCxtQkFBZXB4RCxDQUFmLEVBQWtCa3NELE9BQWxCO0FBREQ7QUFFQTs7QUFFRGptQixVQUFRckIsV0FBUjs7QUFFQTNZLE9BQUt2cUIsQ0FBTCxDQUFPd3FELE9BQVAsR0FBaUIyRSxVQUFqQjtBQUNBNXFCLFVBQVF2a0MsQ0FBUixDQUFVd3FELE9BQVYsR0FBb0I0RSxjQUFwQjtBQUNBLE1BQUlELGNBQWMsQ0FBbEIsRUFBcUI1a0MsS0FBS2liLGVBQUwsQ0FBcUIsU0FBckI7QUFDckIsTUFBSTRwQixrQkFBa0IsQ0FBdEIsRUFBeUI3cUIsUUFBUWlCLGVBQVIsQ0FBd0IsU0FBeEI7O0FBRXpCLFNBQU9qQixPQUFQO0FBQ0E7O0FBRUQsVUFBU29yQixtQkFBVCxDQUE2QjF2RCxTQUE3QixFQUF3QzR0RCxRQUF4QyxFQUFrRDtBQUNqRCxNQUFNdnFCLFFBQVE2bEIsaUJBQWlCbHBELFNBQWpCLENBQWQ7QUFDQSxNQUFJcWpDLE1BQU0va0MsTUFBTixHQUFlLENBQW5CLEVBQXNCLE9BQU8sS0FBUCxDQUF0QixLQUNLLElBQUlzdkQsUUFBSixFQUFjLE9BQU8sSUFBUDs7QUFFbkIsTUFBTXRqQyxPQUFPK1ksTUFBTSxDQUFOLENBQWI7O0FBRUEsTUFBTVosS0FBS25ZLEtBQUt1WixTQUFMLEVBQVg7O0FBRUEsTUFBTS9WLFFBQVEyVSxHQUFHamxCLFlBQUgsQ0FBZ0IsT0FBaEIsQ0FBZDs7QUFFQSxNQUFNck0sTUFBTXpVLFNBQVN5TyxLQUFULENBQWVxOEMsYUFBZixDQUE2QjE1QixLQUE3QixDQUFaOztBQUVBLE1BQU1zOEIsV0FBVzNuQixHQUFHMWlDLENBQUgsQ0FBS3FxRCxRQUF0Qjs7QUFFQSxNQUFNcUIsV0FBVzJCLFVBQVVqOEMsR0FBVixFQUFlaTVDLFFBQWYsRUFBeUI5L0IsSUFBekIsQ0FBakI7O0FBRUEsTUFBTTg3QixVQUFVOTdCLEtBQUt2cUIsQ0FBTCxDQUFPcW1ELE9BQXZCOztBQUVBLE1BQUl1SixtQkFBSjs7QUFFQSxNQUFJQyx1QkFBSjs7QUFFQSxNQUFJeEosVUFBVSxDQUFkLEVBQWlCO0FBQ2hCdUosZ0JBQWFwaUQsS0FBSzhoRCxJQUFMLENBQVVqSixVQUFVLENBQXBCLENBQWI7QUFDQXdKLG9CQUFpQnJpRCxLQUFLMm5CLEtBQUwsQ0FBV2t4QixVQUFVLENBQXJCLENBQWpCO0FBQ0EsR0FIRCxNQUdPO0FBQ053SixvQkFBaUJELGFBQWEsQ0FBOUI7QUFDQSxPQUFNRSxpQkFBaUJ0QyxVQUFVcDhDLEdBQVYsRUFBZXM2QyxRQUFmLENBQXZCO0FBQ0EsUUFBSyxJQUFJcHRELElBQUksQ0FBYixFQUFnQkEsSUFBSXd4RCxlQUFldnhELE1BQW5DLEVBQTJDRCxHQUEzQztBQUNDd3hELG1CQUFleHhELENBQWYsRUFBa0IrbkQsT0FBbEI7QUFERDtBQUVBO0FBQ0QsTUFBTTloQixVQUFVaGEsS0FBS3NnQyxLQUFMLEVBQWhCO0FBQ0F0bUIsVUFBUXVtQixXQUFSLENBQW9CdmdDLElBQXBCO0FBQ0FnYSxVQUFRckIsV0FBUjs7QUFFQTNZLE9BQUt2cUIsQ0FBTCxDQUFPcW1ELE9BQVAsR0FBaUJ1SixVQUFqQjtBQUNBcnJCLFVBQVF2a0MsQ0FBUixDQUFVcW1ELE9BQVYsR0FBb0J3SixjQUFwQjtBQUNBLE1BQUlELGNBQWMsQ0FBbEIsRUFBcUJybEMsS0FBS2liLGVBQUwsQ0FBcUIsU0FBckI7QUFDckIsTUFBSXFxQixrQkFBa0IsQ0FBdEIsRUFBeUJ0ckIsUUFBUWlCLGVBQVIsQ0FBd0IsU0FBeEI7O0FBRXpCLFNBQU9qQixPQUFQO0FBQ0E7O0FBRUQ1bkMsVUFBU3FuQixPQUFULENBQWlCdmYsR0FBakIsQ0FBcUIsZUFBckIsRUFBc0M7QUFDckM2MkIsTUFEcUMsZ0JBQ2hDNStCLE1BRGdDLEVBQ3hCO0FBQ1osWUFBU3F6RCxTQUFULENBQW1CQyxHQUFuQixFQUF3QjtBQUN2QixXQUFPcnpELFNBQVN5TyxLQUFULENBQWU1QyxNQUFmLENBQXNCd25ELE9BQU8sRUFBN0IsRUFBaUM7QUFDdkNDLHVCQUFrQixDQURxQjtBQUV2QzdSLFlBRnVDLG1CQUUvQjFoRCxNQUYrQixFQUV2QnFKLElBRnVCLEVBRWpCO0FBQ3JCLFdBQUtvTSxRQUFMLENBQ0NwTSxLQUFLb3VCLFFBQUwsQ0FBYyxFQUFDbU8sSUFBSSxDQUFMLEVBQVFFLElBQUksQ0FBWixFQUFkLEVBQThCLENBQTlCLElBQ0c3bEMsU0FBUzgrQyxZQURaLEdBRUc5K0MsU0FBUzg3QixpQkFIYjtBQUtBO0FBUnNDLEtBQWpDLENBQVA7QUFVQTtBQUNELFlBQVN5M0IsTUFBVCxDQUFnQnRsRCxJQUFoQixFQUFzQm9sRCxHQUF0QixFQUEyQjtBQUMxQixRQUFJRyxNQUFNenpELE9BQU82TixVQUFQLENBQWtCSyxJQUFsQixDQUFWOztBQUVBLFFBQUl1bEQsR0FBSixFQUFTO0FBQ1I7QUFDQTs7QUFFREEsVUFBTXp6RCxPQUFPZ0MsVUFBUCxDQUFrQmtNLElBQWxCLEVBQXdCb2xELEdBQXhCLENBQU47QUFDQXR6RCxXQUFPMHpELFVBQVAsQ0FBa0JELEdBQWxCO0FBQ0E7O0FBRURELFVBQ0MsV0FERCxFQUVDSCxVQUFVO0FBQ1QxWixxQkFBaUIsT0FEUjtBQUVUdHRDLFFBRlMsZ0JBRUpyTSxNQUZJLEVBRUk7QUFDWixTQUFNdUQsWUFBWXZELE9BQU9vRCxZQUFQLEVBQWxCO0FBQ0Erc0QsdUJBQWtCN0IsV0FBVy9xRCxTQUFYLENBQWxCO0FBQ0E7QUFMUSxJQUFWLENBRkQ7O0FBV0Fpd0QsVUFDQyxpQkFERCxFQUVDSCxVQUFVO0FBQ1QxWixxQkFBaUIsT0FEUjtBQUVUdHRDLFFBRlMsZ0JBRUpyTSxNQUZJLEVBRUk7QUFDWnV0RCxlQUFVdnRELE1BQVYsRUFBa0IsSUFBbEI7QUFDQTtBQUpRLElBQVYsQ0FGRDs7QUFVQXd6RCxVQUNDLGdCQURELEVBRUNILFVBQVU7QUFDVDFaLHFCQUFpQixPQURSO0FBRVR0dEMsUUFGUyxnQkFFSnJNLE1BRkksRUFFSTtBQUNadXRELGVBQVV2dEQsTUFBVjtBQUNBO0FBSlEsSUFBVixDQUZEOztBQVVBd3pELFVBQ0MsY0FERCxFQUVDSCxVQUFVO0FBQ1QxWixxQkFBaUIsT0FEUjtBQUVUdHRDLFFBRlMsZ0JBRUpyTSxNQUZJLEVBRUk7QUFDWixTQUFNdUQsWUFBWXZELE9BQU9vRCxZQUFQLEVBQWxCO0FBQ0EsU0FBTTBDLFVBQVU0cEQsY0FBY25zRCxTQUFkLENBQWhCO0FBQ0EsU0FBSXVDLE9BQUosRUFBYTtBQUNacXFELHdCQUFrQnJxRCxPQUFsQixFQUEyQixJQUEzQjtBQUNBO0FBQ0Q7QUFSUSxJQUFWLENBRkQ7O0FBY0EwdEQsVUFDQyxvQkFERCxFQUVDSCxVQUFVO0FBQ1QxWixxQkFBaUIsT0FEUjtBQUVUdHRDLFFBRlMsZ0JBRUpyTSxNQUZJLEVBRUk7QUFDWm12RCxrQkFBYW52RCxNQUFiLEVBQXFCLElBQXJCO0FBQ0E7QUFKUSxJQUFWLENBRkQ7O0FBVUF3ekQsVUFDQyxtQkFERCxFQUVDSCxVQUFVO0FBQ1QxWixxQkFBaUIsT0FEUjtBQUVUdHRDLFFBRlMsZ0JBRUpyTSxNQUZJLEVBRUk7QUFDWm12RCxrQkFBYW52RCxNQUFiO0FBQ0E7QUFKUSxJQUFWLENBRkQ7O0FBVUF3ekQsVUFDQyxZQURELEVBRUNILFVBQVU7QUFDVDFaLHFCQUFpQixPQURSO0FBRVR0dEMsUUFGUyxnQkFFSnJNLE1BRkksRUFFSTtBQUNaLFNBQU11RCxZQUFZdkQsT0FBT29ELFlBQVAsRUFBbEI7QUFDQTZzRCxpQkFBWTFzRCxTQUFaO0FBQ0E7QUFMUSxJQUFWLENBRkQ7O0FBV0Fpd0QsVUFDQyxXQURELEVBRUNILFVBQVU7QUFDVGx6RCxvQkFBZ0IscUJBRFA7QUFFVHc1QyxxQkFBaUIscUJBRlI7QUFHVHR0QyxRQUhTLGdCQUdKck0sTUFISSxFQUdJO0FBQ1ptd0QsdUJBQ0NjLFdBQVdqeEQsT0FBT29ELFlBQVAsRUFBWCxDQURELEVBRUMsSUFGRDtBQUlBO0FBUlEsSUFBVixDQUZEOztBQWNBb3dELFVBQ0MsZ0JBREQsRUFFQ0gsVUFBVTtBQUNUbHpELG9CQUFnQixhQURQO0FBRVR3NUMscUJBQWlCLGFBRlI7QUFHVHR0QyxRQUhTLGdCQUdKck0sTUFISSxFQUdJO0FBQ1ptd0QsdUJBQ0NjLFdBQVdqeEQsT0FBT29ELFlBQVAsRUFBWCxFQUFrQyxPQUFsQyxDQURELEVBRUMsSUFGRDtBQUlBO0FBUlEsSUFBVixDQUZEOztBQWNBb3dELFVBQ0MsZUFERCxFQUVDSCxVQUFVO0FBQ1RsekQsb0JBQWdCLGFBRFA7QUFFVHc1QyxxQkFBaUIsYUFGUjtBQUdUdHRDLFFBSFMsZ0JBR0pyTSxNQUhJLEVBR0k7QUFDWm13RCx1QkFDQ2MsV0FBV2p4RCxPQUFPb0QsWUFBUCxFQUFYLEVBQWtDLE1BQWxDLENBREQsRUFFQyxJQUZEO0FBSUE7QUFSUSxJQUFWLENBRkQ7O0FBY0Fvd0QsVUFDQyxtQkFERCxFQUVDSCxVQUFVO0FBQ1RsekQsb0JBQWdCLGFBRFA7QUFFVHc1QyxxQkFBaUIsYUFGUjtBQUdUdHRDLFFBSFMsZ0JBR0pyTSxNQUhJLEVBR0k7QUFDWm13RCx1QkFDQ3FDLGtCQUFrQnh5RCxPQUFPb0QsWUFBUCxFQUFsQixDQUREO0FBR0E7QUFQUSxJQUFWLENBRkQ7O0FBYUFvd0QsVUFDQyxxQkFERCxFQUVDSCxVQUFVO0FBQ1RsekQsb0JBQWdCLGFBRFA7QUFFVHc1QyxxQkFBaUIsYUFGUjtBQUdUdHRDLFFBSFMsZ0JBR0pyTSxNQUhJLEVBR0k7QUFDWm13RCx1QkFDQzhDLG9CQUFvQmp6RCxPQUFPb0QsWUFBUCxFQUFwQixDQUREO0FBR0E7QUFQUSxJQUFWLENBRkQ7O0FBYUFvd0QsVUFDQyxrQkFERCxFQUVDSCxVQUFVO0FBQ1QxWixxQkFBaUIsT0FEUjtBQUVUdHRDLFFBRlMsZ0JBRUpyTSxNQUZJLEVBRUk7QUFDWixTQUFNdUQsWUFBWXZELE9BQU9vRCxZQUFQLEVBQWxCO0FBQ0Eyc0QsZ0JBQVd4c0QsU0FBWCxFQUFzQixJQUF0QjtBQUNBO0FBTFEsSUFBVixDQUZEOztBQVdBaXdELFVBQ0MsaUJBREQsRUFFQ0gsVUFBVTtBQUNUMVoscUJBQWlCLE9BRFI7QUFFVHR0QyxRQUZTLGdCQUVKck0sTUFGSSxFQUVJO0FBQ1osU0FBTXVELFlBQVl2RCxPQUFPb0QsWUFBUCxFQUFsQjtBQUNBMnNELGdCQUFXeHNELFNBQVg7QUFDQTtBQUxRLElBQVYsQ0FGRDtBQVVBLEdBOUxvQzs7O0FBZ01yQ2twRDtBQWhNcUMsRUFBdEM7QUFrTUE7O0FBRUQ7Ozs7Ozs7QUFPQXhzRCxTQUFTeU8sS0FBVCxDQUFlcThDLGFBQWYsR0FBK0IsVUFBUzE1QixLQUFULEVBQWdCO0FBQzlDLEtBQU1zaUMsUUFBUXRpQyxNQUFNL3RCLENBQU4sQ0FBUStyQixJQUF0Qjs7QUFFQTtBQUNBLEtBQUkyaEMsSUFBSSxDQUFDLENBQVQ7O0FBRUEsS0FBTTRDLE9BQU8sRUFBYjs7QUFFQSxNQUFLLElBQUloeUQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJK3hELE1BQU05eEQsTUFBMUIsRUFBa0NELEdBQWxDLEVBQXVDO0FBQ3RDb3ZEO0FBQ0EsTUFBSSxDQUFDNEMsS0FBSzVDLENBQUwsQ0FBTCxFQUFjO0FBQ2I0QyxRQUFLNUMsQ0FBTCxJQUFVLEVBQVY7QUFDQTs7QUFFRCxNQUFJclksSUFBSSxDQUFDLENBQVQ7O0FBRUEsT0FBSyxJQUFJcFMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJb3RCLE1BQU0veEQsQ0FBTixFQUFTZ2xDLEtBQVQsQ0FBZS9rQyxNQUFuQyxFQUEyQzBrQyxHQUEzQyxFQUFnRDtBQUMvQyxPQUFNc3RCLFFBQVFGLE1BQU0veEQsQ0FBTixFQUFTZ2xDLEtBQVQsQ0FBZUwsQ0FBZixDQUFkOztBQUVBb1M7QUFDQSxVQUFPaWIsS0FBSzVDLENBQUwsRUFBUXJZLENBQVIsQ0FBUDtBQUFtQkE7QUFBbkIsSUFFQSxJQUFNbWIsV0FBV24yQyxNQUFNazJDLE1BQU1sSyxPQUFaLElBQXVCLENBQXZCLEdBQTJCa0ssTUFBTWxLLE9BQWxEO0FBQ0EsT0FBTW9LLFdBQVdwMkMsTUFBTWsyQyxNQUFNL0YsT0FBWixJQUF1QixDQUF2QixHQUEyQitGLE1BQU0vRixPQUFsRDs7QUFFQSxRQUFLLElBQUlrRyxLQUFLLENBQWQsRUFBaUJBLEtBQUtELFFBQXRCLEVBQWdDQyxJQUFoQyxFQUFzQztBQUNyQyxRQUFJLENBQUNKLEtBQUs1QyxJQUFJZ0QsRUFBVCxDQUFMLEVBQW1CSixLQUFLNUMsSUFBSWdELEVBQVQsSUFBZSxFQUFmOztBQUVuQixTQUFLLElBQUlDLEtBQUssQ0FBZCxFQUFpQkEsS0FBS0gsUUFBdEIsRUFBZ0NHLElBQWhDLEVBQXNDO0FBQ3JDTCxVQUFLNUMsSUFBSWdELEVBQVQsRUFBYXJiLElBQUlzYixFQUFqQixJQUF1Qk4sTUFBTS94RCxDQUFOLEVBQVNnbEMsS0FBVCxDQUFlTCxDQUFmLENBQXZCO0FBQ0E7QUFDRDs7QUFFRG9TLFFBQUttYixXQUFXLENBQWhCO0FBQ0E7QUFDRDtBQUNELFFBQU9GLElBQVA7QUFDQSxDQXJDRCxDOzs7Ozs7Ozs7Ozs7Ozs7OztBQy9nQ0E7Ozs7O0FBS0EsSUFBTU0sbUNBQW1DLFNBQW5DQSxnQ0FBbUMsR0FBVztBQUNuRCxTQUFPLGtDQUFQO0FBQ0EsQ0FGRDs7QUFJQSxJQUFNam9ELDhCQUE4QjtBQUNuQ29sQixTQUFPNmlDO0FBRDRCLENBQXBDOztrQkFJZWpvRCwyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUmY7Ozs7OztBQUVBO0FBQ0EsSUFBTWtvRCxpQkFBaUI7QUFDdEJwa0QsT0FBTSxDQURnQjtBQUV0QkUsTUFBSztBQUZpQixDQUF2Qjs7QUFLQTs7Ozs7OztBQWJBOzs7OztBQW9CQSxJQUFNbWtELGdCQUFnQixTQUFoQkEsYUFBZ0IsQ0FBU3Q5QixPQUFULEVBQWtCK1gsSUFBbEIsRUFBd0I7QUFDN0MsS0FBTXdsQixjQUFjM3hELG1CQUFTa1AsV0FBVCxDQUFxQmtsQixPQUFyQixDQUFwQjs7QUFFQSxLQUFNaDBCLGVBQWVnMEIsUUFBUWh1QixPQUFSLENBQWdCOUksTUFBaEIsQ0FBdUJGLEdBQXZCLENBQTJCLGNBQTNCLENBQXJCO0FBQ0EsS0FBTTJGLFNBQVMzQyxhQUFhdkQsTUFBYixDQUFvQmtHLE1BQXBCLElBQThCcEMsU0FBU3FDLElBQXREO0FBQ0EsS0FBTTROLGNBQWNDLGlCQUFpQjlOLE1BQWpCLENBQXBCO0FBQ0EsS0FBTStOLG1CQUFtQkMsU0FDeEJILFlBQVlJLGdCQUFaLENBQTZCLGFBQTdCLENBRHdCLEVBRXhCLEVBRndCLENBQXpCO0FBSUEsS0FBTUMsb0JBQW9CRixTQUN6QkgsWUFBWUksZ0JBQVosQ0FBNkIsY0FBN0IsQ0FEeUIsRUFFekIsRUFGeUIsQ0FBMUI7QUFJQSxLQUFNRSxhQUNMSixtQkFBbUIvTixPQUFPb08sV0FBMUIsR0FBd0NGLGlCQUR6Qzs7QUFHQSxLQUFNMmdELGdCQUFnQkQsWUFBWXZpRCxXQUFaLEdBQTBCLENBQWhEO0FBQ0EsS0FBTXNyQyxpQkFBaUIsSUFBSW45QyxTQUFTd0UsR0FBVCxDQUFhdEIsTUFBakIsQ0FBd0JBLE1BQXhCLEVBQWdDK2dDLGlCQUFoQyxFQUF2Qjs7QUFFQSxLQUFNcnlCLFNBQVNpbEIsUUFBUWx1QixLQUFSLENBQWNpSixNQUFkLElBQXdCc2lELGNBQXZDOztBQUVBLEtBQU1JLFdBQVd6OUIsUUFBUTlpQixnQkFBUixDQUNoQjY2QixLQUFLOStCLElBQUwsR0FBWTgrQixLQUFLMytCLEtBQUwsR0FBYSxDQUF6QixHQUE2Qmt0QyxlQUFldHRDLENBRDVCLEVBRWhCKytCLEtBQUs1K0IsR0FBTCxHQUFXbXRDLGVBQWVwdEMsQ0FGVixFQUdoQi9QLFNBQVMyUSx1QkFITyxDQUFqQjs7QUFNQSxLQUFNNGpELGdCQUFnQjF4RCxhQUFhTSxZQUFiLEVBQXRCO0FBQ0EsS0FBTWtKLFNBQVNrb0QsY0FBY2pvRCxTQUFkLEVBQWY7QUFDQSxLQUFJa0YsZUFBZSxDQUFuQjs7QUFFQSxLQUFJbkYsVUFBVUEsT0FBT3pLLE1BQVAsS0FBa0IsQ0FBaEMsRUFBbUM7QUFDbEMsTUFBSTJLLGlCQUFpQkYsT0FBTyxDQUFQLEVBQVVFLGNBQS9CO0FBQ0EsTUFBSUEsZUFBZWxKLENBQWYsQ0FBaUJteEQsUUFBakIsS0FBOEJwdkIsS0FBS3F2QixZQUF2QyxFQUFxRDtBQUNwRGxvRCxvQkFBaUJBLGVBQWU0NkIsU0FBZixFQUFqQjtBQUNBO0FBQ0QsTUFBSTU2QixjQUFKLEVBQW9CO0FBQ25CLE9BQU1tb0QsMkJBQTJCbm9ELGVBQWU2ckIsYUFBZixFQUFqQztBQUNBNW1CLGtCQUFla2pELHlCQUF5QjNrRCxDQUF6QixHQUE2QjYrQixLQUFLNStCLEdBQWpEO0FBQ0E7QUFDRDs7QUFFRCxLQUFNMmtELGNBQWMsQ0FDbkIvbEIsS0FBSzkrQixJQUFMLEdBQVk4K0IsS0FBSzMrQixLQUFMLEdBQWEsQ0FBekIsR0FBNkJva0QsYUFBN0IsR0FBNkNsWCxlQUFldHRDLENBRHpDLEVBRW5CKytCLEtBQUs1K0IsR0FBTCxHQUNDd0IsWUFERCxHQUVDNGlELFlBQVk1aUQsWUFGYixHQUdDMnJDLGVBQWVwdEMsQ0FIaEIsR0FJQzZCLE9BQU81QixHQU5XLENBQXBCOztBQVNBLEtBQUkya0QsWUFBWSxDQUFaLElBQWlCLENBQXJCLEVBQXdCO0FBQ3ZCQSxjQUFZLENBQVosSUFBaUIsQ0FBakI7QUFDQSxFQUZELE1BRU8sSUFBSUEsWUFBWSxDQUFaLElBQWlCaGhELGFBQWF5Z0QsWUFBWXZpRCxXQUE5QyxFQUEyRDtBQUNqRThpRCxjQUFZLENBQVosSUFBaUJoaEQsYUFBYXlnRCxZQUFZdmlELFdBQTFDO0FBQ0E7O0FBRURnbEIsU0FBUXpqQixXQUFSLENBQW9Ca2hELFFBQXBCLEVBQThCSyxXQUE5QjtBQUNBLENBM0REOztBQTZEQTs7Ozs7Ozs7QUFRQSxJQUFNQyw0QkFBNEIsU0FBNUJBLHlCQUE0QixDQUFTM3lCLE9BQVQsRUFBa0I7QUFDbkQsS0FBTTd4QixnQkFBZ0I2eEIsUUFBUTd4QixhQUFSLEdBQ25CNnhCLFFBQVE3eEIsYUFEVyxHQUVuQjZ4QixRQUFROXhCLFdBQVIsR0FDQTh4QixRQUFROXhCLFdBQVIsQ0FBb0JyTSxJQUFwQixDQUF5QnNNLGFBRHpCLEdBRUEsSUFKSDs7QUFNQSxLQUFJQSxpQkFBaUJBLGNBQWN2SyxPQUFuQyxFQUE0QztBQUMzQyxNQUFNaEQsZUFBZW8vQixRQUFRbGlDLE1BQVIsQ0FBZUYsR0FBZixDQUFtQixjQUFuQixDQUFyQjtBQUNBLE1BQU0yRixTQUFTM0MsYUFBYXZELE1BQWIsQ0FBb0JrRyxNQUFuQzs7QUFFQSxNQUFNZ04sWUFBWWhOLFNBQVNBLE9BQU9nTixTQUFoQixHQUE0QixDQUE5Qzs7QUFFQSxNQUFNbzhCLE9BQU94K0IsY0FBY3ZLLE9BQWQsQ0FBc0J1eUIsYUFBdEIsRUFBYjtBQUNBd1csT0FBSzUrQixHQUFMLElBQVl3QyxTQUFaOztBQUVBMmhELGdCQUFjLElBQWQsRUFBb0J2bEIsSUFBcEI7O0FBRUEsU0FBTyxJQUFQO0FBQ0E7QUFDRCxDQXBCRDs7QUFzQkE7Ozs7Ozs7O0FBUUEsSUFBTWltQiw0QkFBNEIsU0FBNUJBLHlCQUE0QixDQUFTNXlCLE9BQVQsRUFBa0I7QUFDbkQsS0FBTXAvQixlQUFlby9CLFFBQVFsaUMsTUFBUixDQUFlRixHQUFmLENBQW1CLGNBQW5CLENBQXJCO0FBQ0EsS0FBTTJGLFNBQVMzQyxhQUFhdkQsTUFBYixDQUFvQmtHLE1BQW5DOztBQUVBLEtBQU1nTixZQUFZaE4sU0FBU0EsT0FBT2dOLFNBQWhCLEdBQTRCLENBQTlDOztBQUVBLEtBQU00ZSxRQUFRLElBQUlweEIsU0FBU2l2QixLQUFiLENBQW1CcHNCLFlBQW5CLEVBQWlDNmtCLGdCQUFqQyxFQUFkO0FBQ0EsS0FBTWtuQixPQUFPeGQsTUFBTWdILGFBQU4sRUFBYjtBQUNBd1csTUFBSzUrQixHQUFMLElBQVl3QyxTQUFaOztBQUVBMmhELGVBQWMsSUFBZCxFQUFvQnZsQixJQUFwQjs7QUFFQSxRQUFPLElBQVA7QUFDQSxDQWJEOztBQWVBLElBQU0zaUMsdUJBQXVCO0FBQzVCK04sUUFBTzQ2Qyx5QkFEcUI7QUFFNUJ4akMsUUFBT3lqQztBQUZxQixDQUE3Qjs7a0JBS2U1b0Qsb0I7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0lmOzs7OztBQUtBLElBQU02b0QsdUJBQXVCLFNBQXZCQSxvQkFBdUIsQ0FBU3JvRCxLQUFULEVBQWdCNUcsT0FBaEIsRUFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQ0NBLFFBQVF5NkIsT0FBUixHQUFrQjErQixNQUFsQixLQUE2QjZLLE1BQU15MkIsU0FBbkMsSUFDQ3I5QixRQUFRczZCLE1BQVIsQ0FBZTF6QixNQUFNRixjQUFyQixLQUNBMUcsUUFBUXM2QixNQUFSLENBQWUxekIsTUFBTXcyQixZQUFyQixDQURBLElBRUF4MkIsTUFBTTIyQixXQUFOLEtBQXNCMzJCLE1BQU15MkIsU0FGNUIsSUFHQXoyQixNQUFNeTJCLFNBQU4sS0FBb0IsQ0FMdEI7QUFPQSxDQWxCRDs7QUFvQkEsSUFBTTZ4QixxQkFBcUIsU0FBckJBLGtCQUFxQixDQUFTOXlCLE9BQVQsRUFBa0I7QUFDNUMsS0FBTTd4QixnQkFBZ0I2eEIsUUFBUW4rQixJQUFSLENBQWFzTSxhQUFuQzs7QUFFQSxRQUFPLENBQUMsRUFDUEEsY0FBY3ZLLE9BQWQsSUFDQXVLLGNBQWN2SyxPQUFkLENBQXNCNlMsWUFBdEIsQ0FBbUMsYUFBbkMsTUFBc0QsVUFGL0MsQ0FBUjtBQUlBLENBUEQ7O0FBU0EsSUFBTXM4Qyx3QkFBd0IsU0FBeEJBLHFCQUF3QixDQUFTL3lCLE9BQVQsRUFBa0I7QUFDL0MsS0FBTTd4QixnQkFBZ0I2eEIsUUFBUW4rQixJQUFSLENBQWFzTSxhQUFuQzs7QUFFQSxRQUFPLENBQUMsRUFDUEEsY0FBY3ZLLE9BQWQsSUFDQXVLLGNBQWN2SyxPQUFkLENBQXNCNlMsWUFBdEIsQ0FBbUMsYUFBbkMsTUFBc0QsVUFGL0MsQ0FBUjtBQUlBLENBUEQ7O0FBU0EsSUFBTXU4QywyQkFBMkIsU0FBM0JBLHdCQUEyQixDQUFTaHpCLE9BQVQsRUFBa0I7QUFDbEQsS0FBTWl6QixXQUFXLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLEVBQStCLElBQS9CLENBQWpCO0FBQ0EsS0FBTXJ5RCxlQUFlby9CLFFBQVFsaUMsTUFBUixDQUFlRixHQUFmLENBQW1CLGNBQW5CLENBQXJCO0FBQ0EsS0FBTXVRLGdCQUFnQjZ4QixRQUFRbitCLElBQVIsQ0FBYXNNLGFBQW5DO0FBQ0EsS0FBTStrRCxpQkFBaUJ0eUQsYUFBYXdoQyxnQkFBYixFQUF2Qjs7QUFFQSxRQUFPLENBQUMsRUFDUCxDQUFDajBCLGNBQWN2SyxPQUFmLElBQ0F1SyxjQUFjSSxNQURkLElBRUEsQ0FBQzJrRCxjQUZELElBR0EsQ0FBQ3R5RCxhQUNDTSxZQURELEdBRUNpOUIsaUJBRkQsR0FHQzZHLFVBSEQsRUFIRCxJQU9BcGtDLGFBQWE0QixXQUFiLEdBQTJCK3lCLFFBQTNCLENBQW9DMDlCLFFBQXBDLENBUk8sQ0FBUjtBQVVBLENBaEJEOztBQWtCQSxJQUFNRSxvQkFBb0IsU0FBcEJBLGlCQUFvQixDQUFTbnpCLE9BQVQsRUFBa0I7QUFDM0MsS0FBTXAvQixlQUFlby9CLFFBQVFsaUMsTUFBUixDQUFlRixHQUFmLENBQW1CLGNBQW5CLENBQXJCO0FBQ0EsS0FBTTRNLFFBQVE1SixhQUFhTSxZQUFiLEdBQTRCbUosU0FBNUIsR0FBd0MsQ0FBeEMsQ0FBZDtBQUNBLEtBQU04RCxnQkFBZ0I2eEIsUUFBUW4rQixJQUFSLENBQWFzTSxhQUFuQzs7QUFFQSxLQUFNdkssVUFBVSxJQUFJN0YsU0FBU2duQixJQUFiLENBQWtCbmtCLFlBQWxCLEVBQWdDNmtCLGdCQUFoQyxFQUFoQjtBQUNBLEtBQU0yYyxtQkFBbUJ4aEMsYUFBYXdoQyxnQkFBYixFQUF6QjtBQUNBLEtBQU1neEIsb0JBQW9CamxELGNBQWN2SyxPQUFkLEdBQ3ZCdUssY0FBY3ZLLE9BQWQsQ0FBc0JpSCxPQUF0QixPQUFvQyxLQURiLEdBRXZCLElBRkg7O0FBSUEsUUFBTyxDQUFDLEVBQ1B1M0Isb0JBQ0FneEIsaUJBREEsSUFFQXh2RCxPQUZBLElBR0FBLFFBQVF5NkIsT0FBUixHQUFrQjErQixNQUFsQixLQUE2QjZLLE1BQU15MkIsU0FIbkMsSUFJQXI5QixPQUpBLElBS0EsQ0FBQ0EsUUFBUW9oQyxVQUFSLEVBTEQsSUFNQSxDQUFDNnRCLHFCQUFxQnJvRCxLQUFyQixFQUE0QjVHLE9BQTVCLENBUE0sQ0FBUjtBQVNBLENBcEJEOztBQXNCQSxJQUFNeXZELHFCQUFxQixTQUFyQkEsa0JBQXFCLENBQVNyekIsT0FBVCxFQUFrQjtBQUM1QyxLQUFNN3hCLGdCQUFnQjZ4QixRQUFRbitCLElBQVIsQ0FBYXNNLGFBQW5DO0FBQ0EsS0FBTXZLLFVBQVV1SyxjQUFjdkssT0FBOUI7QUFDQSxLQUFNMHZELFdBQVcsQ0FBQyxDQUFDMXZELE9BQUYsSUFBYSxDQUFDLENBQUNBLFFBQVF1VCxPQUFSLENBQWdCLEtBQWhCLENBQWhDO0FBQ0EsS0FBTW84QyxVQUFVLENBQUMsQ0FBQzN2RCxPQUFGLElBQWFBLFFBQVFpSCxPQUFSLE9BQXNCLEtBQW5EOztBQUVBLFFBQU8sQ0FBQyxFQUFFakgsWUFBWTB2RCxZQUFZQyxPQUF4QixDQUFGLENBQVI7QUFDQSxDQVBEOztBQVNBLElBQU1DLG9CQUFvQixTQUFwQkEsaUJBQW9CLENBQVN4ekIsT0FBVCxFQUFrQjtBQUMzQyxLQUFNcC9CLGVBQWVvL0IsUUFBUWxpQyxNQUFSLENBQWVGLEdBQWYsQ0FBbUIsY0FBbkIsQ0FBckI7O0FBRUEsS0FBTXMxRCxpQkFBaUJ0eUQsYUFBYXdoQyxnQkFBYixFQUF2Qjs7QUFFQSxLQUFNajBCLGdCQUFnQjZ4QixRQUFRbitCLElBQVIsQ0FBYXNNLGFBQW5DOztBQUVBLFFBQU8sQ0FBQyxFQUNQLENBQUNBLGNBQWN2SyxPQUFmLElBQ0F1SyxjQUFjSSxNQURkLElBRUEsQ0FBQzJrRCxjQUZELElBR0EsQ0FBQ3R5RCxhQUNDTSxZQURELEdBRUNpOUIsaUJBRkQsR0FHQzZHLFVBSEQsRUFKTSxDQUFSO0FBU0EsQ0FoQkQ7O0FBa0JBLElBQU15dUIscUJBQXFCLFNBQXJCQSxrQkFBcUIsQ0FBU3p6QixPQUFULEVBQWtCO0FBQzVDLEtBQU1wL0IsZUFBZW8vQixRQUFRbGlDLE1BQVIsQ0FBZUYsR0FBZixDQUFtQixjQUFuQixDQUFyQjs7QUFFQSxLQUFNdXhCLFFBQVEsSUFBSXB4QixTQUFTaXZCLEtBQWIsQ0FBbUJwc0IsWUFBbkIsQ0FBZDtBQUNBLEtBQU1nRCxVQUFVdXJCLE1BQU0xSixnQkFBTixFQUFoQjs7QUFFQSxRQUFPLENBQUMsRUFBRTdoQixXQUFXdXJCLE1BQU00VixVQUFOLENBQWlCbmhDLE9BQWpCLENBQWIsQ0FBUjtBQUNBLENBUEQ7O0FBU0EsSUFBTXFHLGdCQUFnQjtBQUNyQitVLFFBQU84ekMsa0JBRGM7QUFFckJZLFdBQVVYLHFCQUZXO0FBR3JCWSxTQUFRWCx3QkFIYTtBQUlyQmo3QyxRQUFPczdDLGtCQUpjO0FBS3JCM3dELE9BQU15d0QsaUJBTGU7QUFNckJoa0MsUUFBT3NrQyxrQkFOYztBQU9yQmgxQixPQUFNKzBCO0FBUGUsQ0FBdEI7O2tCQVVldnBELGE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVIZjs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQU0vRCxhQUFhLENBQ2xCO0FBQ0M4RixPQUFNLE9BRFA7QUFFQ2xHLFVBQVMsQ0FBQyxhQUFELEVBQWdCLFdBQWhCLENBRlY7QUFHQ21ELE9BQU1nQix3QkFBYytVO0FBSHJCLENBRGtCLEVBTWxCO0FBQ0NoVCxPQUFNLFVBRFA7QUFFQ2xHLFVBQVMsQ0FBQyxZQUFELEVBQWUsZ0JBQWYsQ0FGVjtBQUdDbUQsT0FBTWdCLHdCQUFjeXBEO0FBSHJCLENBTmtCLEVBV2xCO0FBQ0MxbkQsT0FBTSxNQURQO0FBRUNsRyxVQUFTLENBQUMsVUFBRCxDQUZWO0FBR0NtRCxPQUFNZ0Isd0JBQWN2SDtBQUhyQixDQVhrQixFQWdCbEI7QUFDQ3NKLE9BQU0sT0FEUDtBQUVDbEcsVUFBUyxDQUFDLFdBQUQsRUFBYyxhQUFkLEVBQTZCLFlBQTdCLEVBQTJDLGFBQTNDLENBRlY7QUFHQ3N4QixjQUFhcHRCLDRCQUFxQitOLEtBSG5DO0FBSUM5TyxPQUFNZ0Isd0JBQWM4TjtBQUpyQixDQWhCa0IsRUFzQmxCO0FBQ0MvTCxPQUFNLE1BRFA7QUFFQ2xHLFVBQVM7QUFDUjh0RCxRQUFNLENBQ0wsQ0FDQyxNQURELEVBRUMsVUFGRCxFQUdDLFdBSEQsRUFJQyxNQUpELEVBS0MsUUFMRCxFQU1DLFdBTkQsRUFPQyxRQVBELEVBUUMsV0FSRCxFQVNDLE1BVEQsQ0FESyxFQVlMLENBQ0MsZ0JBREQsRUFFQyxXQUZELEVBR0MsSUFIRCxFQUlDLElBSkQsRUFLQyxXQUxELEVBTUMsSUFORCxFQU9DLElBUEQsRUFRQyxXQVJELEVBU0MsYUFURCxFQVVDLGNBVkQsRUFXQyxXQVhELEVBWUMsV0FaRCxFQWFDLFNBYkQsRUFjQyxXQWRELEVBZUMsTUFmRCxFQWdCQyxPQWhCRCxFQWlCQyxXQWpCRCxFQWtCQyxjQWxCRCxDQVpLLENBREU7O0FBbUNSQyxVQUFRLENBQUMsUUFBRCxFQUFXLE1BQVgsRUFBbUIsUUFBbkIsRUFBNkIsV0FBN0IsRUFBMEMsTUFBMUM7QUFuQ0EsRUFGVjtBQXVDQzVxRCxPQUFNZ0Isd0JBQWN3MEI7QUF2Q3JCLENBdEJrQixFQStEbEI7QUFDQ3p5QixPQUFNLE9BRFA7QUFFQ2xHLFVBQVMsQ0FDUixjQURRLEVBRVIsVUFGUSxFQUdSLGFBSFEsRUFJUixXQUpRLEVBS1IsYUFMUSxDQUZWO0FBU0Nrc0IscUJBQW9Cam9CLDRCQUE0Qm9sQixLQVRqRDtBQVVDaUksY0FBYXB0Qiw0QkFBcUJtbEIsS0FWbkM7QUFXQ2xtQixPQUFNZ0Isd0JBQWNrbEI7QUFYckIsQ0EvRGtCLENBQW5CLEMsQ0FUQTs7Ozs7a0JBdUZlanBCLFU7Ozs7Ozs7Ozs7O0FDdkZmLGFBQWEsb0NBQW9DLEVBQUUsSTs7Ozs7Ozs7Ozs7QUNBbkQsYUFBYSxvQ0FBb0MsRUFBRSxJIiwiZmlsZSI6ImFsbG95LWVkaXRvci1jb3JlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvYWRhcHRlci9tYWluLmpzXCIpO1xuIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAnICtcbiAgICAgICAgICAgIGxvY2F0aW9uICsgJyBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJyArIHR5cGVvZiBlcnJvciArICcuICcgK1xuICAgICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArXG4gICAgICAgICAgICAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnRmFpbGVkICcgKyBsb2NhdGlvbiArICcgdHlwZTogJyArIGVycm9yLm1lc3NhZ2UgKyAoc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlc2V0cyB3YXJuaW5nIGNhY2hlIHdoZW4gdGVzdGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgcHJvcCBvbiBgJyArIGNvbXBvbmVudE5hbWUgICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudCB0eXBlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMuICcgK1xuICAgICAgICAgICAgJ0EgY29tbW9uIG1pc3Rha2UgaXMgdG8gd3JpdGUgb25lT2YoeCwgeSwgeikgaW5zdGVhZCBvZiBvbmVPZihbeCwgeSwgel0pLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzLCBmdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBTdHJpbmcocHJvcFZhbHVlKSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAoaGFzKHByb3BWYWx1ZSwga2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cbiAgICAgIC8vIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjguNVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7XG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpO1xufVxuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bsb3dQcmlvcml0eVdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuXG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTtcblxuLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTtcbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BPUlRBTF9UWVBFO1xufVxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG59XG5cbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0ICcuLi9jb3JlJztcblxuaW1wb3J0ICcuLi9wbHVnaW5zJztcblxuaW1wb3J0ICcuLi9jb21wb25lbnRzL3VpYnJpZGdlJztcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5pbXBvcnQge3JlbW92ZUltYWdlQ29tbWFuZH0gZnJvbSAnLi4vY29tbWFuZHMnO1xuaW1wb3J0IFVJIGZyb20gJy4uL2NvbXBvbmVudHMvbWFpbi5qc3gnO1xuaW1wb3J0IEJhc2UgZnJvbSAnLi4vb29wL2Jhc2UnO1xuaW1wb3J0IExhbmcgZnJvbSAnLi4vb29wL2xhbmcnO1xuaW1wb3J0IGV4dGVuZCBmcm9tICcuLi9vb3Avb29wJztcbmltcG9ydCBTZWxlY3Rpb25zIGZyb20gJy4uL3NlbGVjdGlvbnMvc2VsZWN0aW9ucyc7XG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuL2VkaXRvci1jb250ZXh0JztcblxuY29uc3QgRU1CRURfVklERU9fV0lEVEggPSA1NjA7XG5jb25zdCBFTUJFRF9WSURFT19IRUlHSFQgPSAzMTU7XG5cbi8qKlxuICogQWxsb3lFZGl0b3IgbWFpbiBjbGFzcy4gQ3JlYXRlcyBpbnN0YW5jZSBvZiB0aGUgZWRpdG9yIGFuZCBwcm92aWRlcyB0aGUgdXNlciBjb25maWd1cmF0aW9uXG4gKiB0byB0aGUgVUkuXG4gKlxuICogQGNsYXNzIENvcmVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiB0byBiZSB1c2VkLlxuICovXG5mdW5jdGlvbiBDb3JlKGNvbmZpZykge1xuXHRDb3JlLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBjb25maWcpO1xufVxuXG5leHRlbmQoXG5cdENvcmUsXG5cdEJhc2UsXG5cdHtcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplciBsaWZlY3ljbGUgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBBbGxveUVkaXRvciBjbGFzcy4gQ3JlYXRlcyBhIENLRWRpdG9yXG5cdFx0ICogaW5zdGFuY2UsIHBhc3NpbmcgaXQgdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24gYXR0cmlidXRlcy5cblx0XHQgKlxuXHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBtZXRob2QgaW5pdGlhbGl6ZXJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0IGxpdGVyYWwgZm9yIHRoZSBlZGl0b3IuXG5cdFx0ICovXG5cdFx0aW5pdGlhbGl6ZXIoY29uZmlnKSB7XG5cdFx0XHRjb25zdCBub2RlID0gdGhpcy5nZXQoJ3NyY05vZGUnKTtcblxuXHRcdFx0aWYgKHRoaXMuZ2V0KCdlbmFibGVDb250ZW50RWRpdGFibGUnKSkge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgJ3RydWUnKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZWRpdG9yID0gQ0tFRElUT1IuaW5saW5lKG5vZGUpO1xuXG5cdFx0XHRlZGl0b3IuY29uZmlnLmFsbG93ZWRDb250ZW50ID0gdGhpcy5nZXQoJ2FsbG93ZWRDb250ZW50Jyk7XG5cblx0XHRcdGVkaXRvci5jb25maWcudG9vbGJhcnMgPSB0aGlzLmdldCgndG9vbGJhcnMnKTtcblxuXHRcdFx0ZWRpdG9yLmNvbmZpZy5yZW1vdmVQbHVnaW5zID0gdGhpcy5nZXQoJ3JlbW92ZVBsdWdpbnMnKTtcblxuXHRcdFx0ZWRpdG9yLmNvbmZpZy5leHRyYVBsdWdpbnMgPSB0aGlzLmdldCgnZXh0cmFQbHVnaW5zJyk7XG5cblx0XHRcdGVkaXRvci5jb25maWcuZW1iZWRQcm92aWRlcnMgPSB0aGlzLmdldCgnZW1iZWRQcm92aWRlcnMnKTtcblxuXHRcdFx0ZWRpdG9yLmNvbmZpZy5wbGFjZWhvbGRlckNsYXNzID0gdGhpcy5nZXQoJ3BsYWNlaG9sZGVyQ2xhc3MnKTtcblxuXHRcdFx0ZWRpdG9yLmNvbmZpZy5wYXN0ZUZyb21Xb3JkUmVtb3ZlU3R5bGVzID0gZmFsc2U7XG5cdFx0XHRlZGl0b3IuY29uZmlnLnBhc3RlRnJvbVdvcmRSZW1vdmVGb250U3R5bGVzID0gZmFsc2U7XG5cblx0XHRcdGVkaXRvci5jb25maWcuc2VsZWN0aW9uS2V5c3Ryb2tlcyA9IHRoaXMuZ2V0KCdzZWxlY3Rpb25LZXlzdHJva2VzJyk7XG5cblx0XHRcdGVkaXRvci5jb25maWcuc3ByaXRlbWFwID0gdGhpcy5nZXQoJ3Nwcml0ZW1hcCcpO1xuXG5cdFx0XHRMYW5nLm1peChlZGl0b3IuY29uZmlnLCBjb25maWcpO1xuXG5cdFx0XHRpZiAoQ0tFRElUT1IuZW52LmllICYmICFDS0VESVRPUi5lbnYuZWRnZSkge1xuXHRcdFx0XHRjb25zdCBwbHVnaW4gPVxuXHRcdFx0XHRcdENLRURJVE9SLmVudi52ZXJzaW9uID09PSAxMVxuXHRcdFx0XHRcdFx0PyAnYWVfZHJhZ3Jlc2l6ZV9pZTExJ1xuXHRcdFx0XHRcdFx0OiAnYWVfZHJhZ3Jlc2l6ZV9pZSc7XG5cblx0XHRcdFx0ZWRpdG9yLmNvbmZpZy5leHRyYVBsdWdpbnMgPSBlZGl0b3IuY29uZmlnLmV4dHJhUGx1Z2lucy5yZXBsYWNlKFxuXHRcdFx0XHRcdCdhZV9kcmFncmVzaXplJyxcblx0XHRcdFx0XHRwbHVnaW5cblx0XHRcdFx0KTtcblx0XHRcdFx0ZWRpdG9yLmNvbmZpZy5yZW1vdmVQbHVnaW5zID0gZWRpdG9yLmNvbmZpZy5yZW1vdmVQbHVnaW5zLnJlcGxhY2UoXG5cdFx0XHRcdFx0J2FlX2RyYWdyZXNpemUnLFxuXHRcdFx0XHRcdHBsdWdpblxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRlZGl0b3Iub25jZSgnY29udGVudERvbScsICgpID0+IHtcblx0XHRcdFx0dGhpcy5fYWRkUmVhZE9ubHlMaW5rQ2xpY2tMaXN0ZW5lcihlZGl0b3IpO1xuXG5cdFx0XHRcdGNvbnN0IGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdFx0Y29uc3QgZXh0cmFDb21tYW5kcyA9IHRoaXMuZ2V0KCdleHRyYUNvbW1hbmRzJyk7XG5cblx0XHRcdFx0Y29uc3QgZXh0cmFDb21tYW5kS2V5cyA9IE9iamVjdC5rZXlzKGV4dHJhQ29tbWFuZHMpO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGV4dHJhQ29tbWFuZEtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBjb21tYW5kTmFtZSA9IGV4dHJhQ29tbWFuZEtleXNbaV07XG5cblx0XHRcdFx0XHRpZiAoZWRpdG9yLmNvbW1hbmRzW2NvbW1hbmROYW1lXSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWRpdG9yLmFkZENvbW1hbmQoY29tbWFuZE5hbWUsIGV4dHJhQ29tbWFuZHNbY29tbWFuZE5hbWVdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVkaXRhYmxlLmFkZENsYXNzKCdhZS1lZGl0YWJsZScpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX2VkaXRvciA9IGVkaXRvcjtcblxuXHRcdFx0QWxsb3lFZGl0b3IubG9hZExhbmd1YWdlUmVzb3VyY2VzKHRoaXMuX3JlbmRlclVJLmJpbmQodGhpcykpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZXN0cnVjdG9yIGxpZmVjeWNsZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIEFsbG95RWR0b3IgY2xhc3MuIERlc3Ryb3lzIHRoZSBDS0VkaXRvclxuXHRcdCAqIGluc3RhbmNlIGFuZCBkZXN0cm95cyBhbGwgY3JlYXRlZCB0b29sYmFycy5cblx0XHQgKlxuXHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBtZXRob2QgZGVzdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGRlc3RydWN0b3IoKSB7XG5cdFx0XHR0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuXG5cdFx0XHRpZiAodGhpcy5fZWRpdG9yVUlFbGVtZW50KSB7XG5cdFx0XHRcdFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUodGhpcy5fZWRpdG9yVUlFbGVtZW50KTtcblx0XHRcdFx0dGhpcy5fZWRpdG9yVUlFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoXG5cdFx0XHRcdFx0dGhpcy5fZWRpdG9yVUlFbGVtZW50XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHRoaXMuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0aWYgKG5hdGl2ZUVkaXRvcikge1xuXHRcdFx0XHRjb25zdCBlZGl0YWJsZSA9IG5hdGl2ZUVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRcdGlmIChlZGl0YWJsZSkge1xuXHRcdFx0XHRcdGVkaXRhYmxlLnJlbW92ZUNsYXNzKCdhZS1lZGl0YWJsZScpO1xuXG5cdFx0XHRcdFx0aWYgKHRoaXMuZ2V0KCdlbmFibGVDb250ZW50RWRpdGFibGUnKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5nZXQoJ3NyY05vZGUnKS5zZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdFx0XHRcdCdjb250ZW50ZWRpdGFibGUnLFxuXHRcdFx0XHRcdFx0XHQnZmFsc2UnXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2NsZWFyU2VsZWN0aW9ucygpO1xuXG5cdFx0XHRcdG5hdGl2ZUVkaXRvci5kZXN0cm95KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENsZWFyIHNlbGVjdGlvbnMgZnJvbSB3aW5kb3cgb2JqZWN0XG5cdFx0ICpcblx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAbWV0aG9kIF9jbGVhclNlbGVjdGlvbnNcblx0XHQgKi9cblx0XHRfY2xlYXJTZWxlY3Rpb25zKCkge1xuXHRcdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gdGhpcy5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdFx0Y29uc3QgaXNNU1NlbGVjdGlvbiA9IHR5cGVvZiB3aW5kb3cuZ2V0U2VsZWN0aW9uICE9ICdmdW5jdGlvbic7XG5cblx0XHRcdGlmIChpc01TU2VsZWN0aW9uKSB7XG5cdFx0XHRcdG5hdGl2ZUVkaXRvci5kb2N1bWVudC4kLnNlbGVjdGlvbi5lbXB0eSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmF0aXZlRWRpdG9yLmRvY3VtZW50XG5cdFx0XHRcdFx0LmdldFdpbmRvdygpXG5cdFx0XHRcdFx0LiQuZ2V0U2VsZWN0aW9uKClcblx0XHRcdFx0XHQucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIE1ldGhvZCB0byBzZXQgZGVmYXVsdCBsaW5rIGJlaGF2aW9yXG5cdFx0ICpcblx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAbWV0aG9kIF9hZGRSZWFkT25seUxpbmtDbGlja0xpc3RlbmVyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVkaXRvclxuXHRcdCAqL1xuXHRcdF9hZGRSZWFkT25seUxpbmtDbGlja0xpc3RlbmVyKGVkaXRvcikge1xuXHRcdFx0ZWRpdG9yLmVkaXRhYmxlKCkub24oJ2NsaWNrJywgdGhpcy5fZGVmYXVsdFJlYWRPbmx5Q2xpY2tGbiwgdGhpcywge1xuXHRcdFx0XHRlZGl0b3IsXG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2FsbGVkIG9uIGBjbGlja2AgZXZlbnQgd2hlbiB0aGUgZWRpdG9yIGlzIGluIHJlYWQgb25seSBtb2RlLiBOYXZpZ2F0ZXMgdG8gbGluaydzIFVSTCBvciBvcGVuc1xuXHRcdCAqIHRoZSBsaW5rIGluIGEgbmV3IHdpbmRvdy5cblx0XHQgKlxuXHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQGV2ZW50IHJlYWRPbmx5Q2xpY2tcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQG1ldGhvZCBfZGVmYXVsdFJlYWRPbmx5Q2xpY2tGblxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgZmlyZWQgYGNsaWNrYCBldmVudCBwYXlsb2FkXG5cdFx0ICovXG5cdFx0X2RlZmF1bHRSZWFkT25seUNsaWNrRm4oZXZlbnQpIHtcblx0XHRcdGNvbnN0IG1vdXNlRXZlbnQgPSBldmVudC5kYXRhLiQ7XG5cdFx0XHRjb25zdCBoYXNDdHJsS2V5ID0gbW91c2VFdmVudC5jdHJsS2V5IHx8IG1vdXNlRXZlbnQubWV0YUtleTtcblx0XHRcdGNvbnN0IHNob3VsZE9wZW4gPSB0aGlzLl9lZGl0b3IuY29uZmlnLnJlYWRPbmx5IHx8IGhhc0N0cmxLZXk7XG5cblx0XHRcdG1vdXNlRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0aWYgKCFzaG91bGRPcGVuKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRldmVudC5saXN0ZW5lckRhdGEuZWRpdG9yXG5cdFx0XHRcdFx0LmVkaXRhYmxlKClcblx0XHRcdFx0XHQuZWRpdG9yLmZpcmUoJ3JlYWRPbmx5Q2xpY2snLCBldmVudC5kYXRhKSAhPT0gZmFsc2Vcblx0XHRcdCkge1xuXHRcdFx0XHRjb25zdCBja0VsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnRQYXRoKFxuXHRcdFx0XHRcdGV2ZW50LmRhdGEuZ2V0VGFyZ2V0KCksXG5cdFx0XHRcdFx0dGhpc1xuXHRcdFx0XHQpO1xuXHRcdFx0XHRjb25zdCBsaW5rID0gY2tFbGVtZW50Lmxhc3RFbGVtZW50O1xuXG5cdFx0XHRcdGlmIChsaW5rKSB7XG5cdFx0XHRcdFx0Y29uc3QgaHJlZiA9IGxpbmsuJC5hdHRyaWJ1dGVzLmhyZWZcblx0XHRcdFx0XHRcdD8gbGluay4kLmF0dHJpYnV0ZXMuaHJlZi52YWx1ZVxuXHRcdFx0XHRcdFx0OiBudWxsO1xuXHRcdFx0XHRcdGNvbnN0IHRhcmdldCA9IGhhc0N0cmxLZXlcblx0XHRcdFx0XHRcdD8gJ19ibGFuaydcblx0XHRcdFx0XHRcdDogbGluay4kLmF0dHJpYnV0ZXMudGFyZ2V0XG5cdFx0XHRcdFx0XHQ/IGxpbmsuJC5hdHRyaWJ1dGVzLnRhcmdldC52YWx1ZVxuXHRcdFx0XHRcdFx0OiBudWxsO1xuXHRcdFx0XHRcdHRoaXMuX3JlZGlyZWN0TGluayhocmVmLCB0YXJnZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHJpZXZlcyB0aGUgbmF0aXZlIENLRWRpdG9yIGluc3RhbmNlLiBIYXZpbmcgdGhpcywgdGhlIGRldmVsb3BlciBtYXkgdXNlIHRoZSBBUEkgb2YgQ0tFZGl0b3IgT09UQi5cblx0XHQgKlxuXHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBtZXRob2QgX2dldE5hdGl2ZUVkaXRvclxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgQ0tFZGl0b3IuXG5cdFx0ICovXG5cdFx0X2dldE5hdGl2ZUVkaXRvcigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9lZGl0b3I7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlZGlyZWN0cyB0aGUgYnJvd3NlciB0byBhIGdpdmVuIGxpbmtcblx0XHQgKlxuXHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBtZXRob2QgX3JlZGlyZWN0TGlua1xuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIFRoZSBocmVmIHRvIHRha2UgdGhlIGJyb3dzZXIgdG9cblx0XHQgKiBAcGFyYW0ge3N0cmluZz19IHRhcmdldCBTcGVjaWZpZXMgd2hlcmUgdG8gZGlzcGxheSB0aGUgbGlua1xuXHRcdCAqL1xuXHRcdF9yZWRpcmVjdExpbmsoaHJlZiwgdGFyZ2V0KSB7XG5cdFx0XHRpZiAodGFyZ2V0ICYmIGhyZWYpIHtcblx0XHRcdFx0d2luZG93Lm9wZW4oaHJlZiwgdGFyZ2V0KTtcblx0XHRcdH0gZWxzZSBpZiAoaHJlZikge1xuXHRcdFx0XHR3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbmRlcnMgdGhlIHNwZWNpZmllZCBmcm9tIHRoZSB1c2VyIHRvb2xiYXJzLlxuXHRcdCAqXG5cdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQG1ldGhvZCBfcmVuZGVyVUlcblx0XHQgKi9cblx0XHRfcmVuZGVyVUkoKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2Rlc3Ryb3llZCkge1xuXHRcdFx0XHRjb25zdCBlZGl0b3JVSUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdFx0ZWRpdG9yVUlFbGVtZW50LmNsYXNzTmFtZSA9ICdhZS11aSc7XG5cblx0XHRcdFx0Y29uc3QgdWlOb2RlID0gdGhpcy5nZXQoJ3VpTm9kZScpIHx8IGRvY3VtZW50LmJvZHk7XG5cblx0XHRcdFx0dWlOb2RlLmFwcGVuZENoaWxkKGVkaXRvclVJRWxlbWVudCk7XG5cblx0XHRcdFx0Y29uc3QgY2FsbGJhY2tSZWYgPSBlbGVtZW50ID0+IHtcblx0XHRcdFx0XHRpZiAoIXRoaXMuX21haW5VSSAmJiBlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9tYWluVUkgPSBlbGVtZW50O1xuXHRcdFx0XHRcdFx0dGhpcy5nZXQoJ25hdGl2ZUVkaXRvcicpLmZpcmUoJ3VpUmVhZHknKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0UmVhY3RET00ucmVuZGVyKFxuXHRcdFx0XHRcdDxFZGl0b3JDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7ZWRpdG9yOiB0aGlzfX0+XG5cdFx0XHRcdFx0XHQ8VUlcblx0XHRcdFx0XHRcdFx0ZXZlbnRzRGVsYXk9e3RoaXMuZ2V0KCdldmVudHNEZWxheScpfVxuXHRcdFx0XHRcdFx0XHRyZWY9e2NhbGxiYWNrUmVmfVxuXHRcdFx0XHRcdFx0XHR0b29sYmFycz17dGhpcy5nZXQoJ3Rvb2xiYXJzJyl9XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDwvRWRpdG9yQ29udGV4dC5Qcm92aWRlcj4sXG5cdFx0XHRcdFx0ZWRpdG9yVUlFbGVtZW50XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0dGhpcy5fZWRpdG9yVUlFbGVtZW50ID0gZWRpdG9yVUlFbGVtZW50O1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhbiBIVE1MIGVsZW1lbnQgZnJvbSB0aGUgcGFzc2VkIHZhbHVlLiBJZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgc3RyaW5nLCBpdCBzaG91bGQgYmVcblx0XHQgKiB0aGUgSWQgb2YgdGhlIGVsZW1lbnQgd2hpY2ggaGF2ZSB0byBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgRE9NLlxuXHRcdCAqIElmIGFuIEhUTUwgRWxlbWVudCBpcyBwYXNzZWQsIHRoZSBlbGVtZW50IGl0c2VsZiB3aWxsIGJlIHJldHVybmVkLlxuXHRcdCAqXG5cdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWV0aG9kIF90b0VsZW1lbnRcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHBhcmFtIHshKFN0cmluZ3xIVE1MRWxlbWVudCl9IHZhbHVlIFN0cmluZywgd2hpY2ggaGF2ZSB0byBjb3JyZXNwb25kIHRvIGFuIEhUTUwgZWxlbWVudCBmcm9tIHRoZSBET00sXG5cdFx0ICogb3IgdGhlIEhUTUwgZWxlbWVudCBpdHNlbGYuIElmIElkIGlzIHBhc3NlZCwgdGhlIEhUTUwgZWxlbWVudCB3aWxsIGJlIHJldHJpZXZlZCBmcm9tIHRoZSBET00uXG5cdFx0ICogQHJldHVybiB7SFRNTEVsZW1lbnR9IEFuIEhUTUwgZWxlbWVudC5cblx0XHQgKi9cblx0XHRfdG9FbGVtZW50KHZhbHVlKSB7XG5cdFx0XHRpZiAoTGFuZy5pc1N0cmluZyh2YWx1ZSkpIHtcblx0XHRcdFx0dmFsdWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVmFsaWRhdGVzIHRoZSBhbGxvd2VkIGNvbnRlbnQgYXR0cmlidXRlLiBMb29rXG5cdFx0ICogW2hlcmVdKGh0dHA6Ly9kb2NzLmNrZWRpdG9yLmNvbS8jIS9hcGkvQ0tFRElUT1IuY29uZmlnLWNmZy1hbGxvd2VkQ29udGVudCkgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG5cdFx0ICogc3VwcG9ydGVkIHZhbHVlcy5cblx0XHQgKlxuXHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBtZXRob2QgX3ZhbGlkYXRlQWxsb3dlZENvbnRlbnRcblx0XHQgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWRcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBjdXJyZW50IHZhbHVlIGlzIHZhbGlkIGNvbmZpZ3VyYXRpb24sIGZhbHNlIG90aGVyd2lzZVxuXHRcdCAqL1xuXHRcdF92YWxpZGF0ZUFsbG93ZWRDb250ZW50KHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRMYW5nLmlzU3RyaW5nKHZhbHVlKSB8fFxuXHRcdFx0XHRMYW5nLmlzT2JqZWN0KHZhbHVlKSB8fFxuXHRcdFx0XHRMYW5nLmlzQm9vbGVhbih2YWx1ZSlcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFZhbGlkYXRlcyB0aGUgdmFsdWUgb2YgdG9vbGJhcnMgYXR0cmlidXRlXG5cdFx0ICpcblx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAbWV0aG9kIF92YWxpZGF0ZVRvb2xiYXJzXG5cdFx0ICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgY3VycmVudCB2YWx1ZSBpcyB2YWxpZCB0b29sYmFycyBjb25maWd1cmF0aW9uLCBmYWxzZSBvdGhlcndpc2Vcblx0XHQgKi9cblx0XHRfdmFsaWRhdGVUb29sYmFycyh2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIExhbmcuaXNPYmplY3QodmFsdWUpIHx8IExhbmcuaXNOdWxsKHZhbHVlKTtcblx0XHR9LFxuXHR9LFxuXHR7XG5cdFx0QVRUUlM6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogQ29uZmlndXJlcyB0aGUgYWxsb3dlZCBjb250ZW50IGZvciB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiBBbGxveUVkaXRvci5cblx0XHRcdCAqIExvb2sgb24gdGhlIFtvZmZpY2lhbCBDS0VkaXRvciBBUEldKGh0dHA6Ly9kb2NzLmNrZWRpdG9yLmNvbS8jIS9hcGkvQ0tFRElUT1IuY29uZmlnLWNmZy1hbGxvd2VkQ29udGVudClcblx0XHRcdCAqIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2YWxpZCB2YWx1ZXMuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BlcnR5IGFsbG93ZWRDb250ZW50XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAd3JpdGVPbmNlXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbiwgU3RyaW5nLCBPYmplY3R9XG5cdFx0XHQgKi9cblx0XHRcdGFsbG93ZWRDb250ZW50OiB7XG5cdFx0XHRcdHZhbGlkYXRvcjogJ192YWxpZGF0ZUFsbG93ZWRDb250ZW50Jyxcblx0XHRcdFx0dmFsdWU6IHRydWUsXG5cdFx0XHRcdHdyaXRlT25jZTogdHJ1ZSxcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGNsaWNraW5nIG9uIHRoZVxuXHRcdFx0ICogPGNvZGU+c3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tbGluay1lZGl0LWJyb3dzZS5qc3g8L2NvZGU+XG5cdFx0XHQgKiBjb21wb25lbnQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BldHkgZG9jdW1lbnRCcm93c2VMaW5rQ2FsbGJhY2tcblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufHVuZGVmaW5lZH1cblx0XHRcdCAqL1xuXHRcdFx0ZG9jdW1lbnRCcm93c2VMaW5rQ2FsbGJhY2s6IHtcblx0XHRcdFx0dmFsaWRhdG9yOiBMYW5nLmlzRnVuY3Rpb24sXG5cdFx0XHRcdHZhbHVlOiB1bmRlZmluZWQsXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIENvbmZpZ3VyYXRpb24gZm9yIHRoZVxuXHRcdFx0ICogPGNvZGU+c3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tbGluay1lZGl0LWJyb3dzZS5qc3g8L2NvZGU+XG5cdFx0XHQgKiBjb21wb25lbnQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BldHkgZG9jdW1lbnRCcm93c2VMaW5rVXJsXG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd8dW5kZWZpbmVkfVxuXHRcdFx0ICovXG5cdFx0XHRkb2N1bWVudEJyb3dzZUxpbmtVcmw6IHtcblx0XHRcdFx0dmFsaWRhdG9yOiBMYW5nLmlzU3RyaW5nLFxuXHRcdFx0XHR2YWx1ZTogdW5kZWZpbmVkLFxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBMaXN0IG9mIGVtYmVkIHByb3ZpZGVycyBmb3IgdmlkZW9zXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BlcnR5IGVtYmVkUHJvdmlkZXJzXG5cdFx0XHQgKiBAZGVmYXVsdCBbXVxuXHRcdFx0ICogQHR5cGUgQXJyYXl9XG5cdFx0XHQgKi9cblx0XHRcdGVtYmVkUHJvdmlkZXJzOiB7XG5cdFx0XHRcdHZhbGlkYXRvcjogTGFuZy5pc0FycmF5LFxuXHRcdFx0XHR2YWx1ZTogW1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlkOiAnZmFjZWJvb2snLFxuXHRcdFx0XHRcdFx0dHBsOiBgPGlmcmFtZSBhbGxvd0Z1bGxTY3JlZW49XCJ0cnVlXCIgYWxsb3dUcmFuc3BhcmVuY3k9XCJ0cnVlXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBmcmFtZWJvcmRlcj1cIjBcIiBoZWlnaHQ9XCIke0VNQkVEX1ZJREVPX0hFSUdIVH1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0IHNyYz1cImh0dHBzOi8vd3d3LmZhY2Vib29rLmNvbS9wbHVnaW5zL3ZpZGVvLnBocD9ocmVmPXtlbWJlZElkfSdcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAmc2hvd190ZXh0PTAmd2lkdGg9JHtFTUJFRF9WSURFT19XSURUSH0maGVpZ2h0PSR7RU1CRURfVklERU9fSEVJR0hUfVwiIHNjcm9sbGluZz1cIm5vXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBzdHlsZT1cImJvcmRlcjpub25lO292ZXJmbG93OmhpZGRlblwiIHdpZHRoPVwiJHtFTUJFRF9WSURFT19XSURUSH19XCI+PC9pZnJhbWU+YCxcblx0XHRcdFx0XHRcdHR5cGU6ICd2aWRlbycsXG5cdFx0XHRcdFx0XHR1cmxTY2hlbWVzOiBbXG5cdFx0XHRcdFx0XHRcdCcoaHR0cHM/OlxcXFwvXFxcXC8oPzp3d3dcXFxcLik/ZmFjZWJvb2suY29tXFxcXC9cXFxcUypcXFxcL3ZpZGVvc1xcXFwvXFxcXFMqKScsXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWQ6ICd0d2l0Y2gnLFxuXHRcdFx0XHRcdFx0dHBsOiBgPGlmcmFtZSBhbGxvd2Z1bGxzY3JlZW49XCJ0cnVlXCIgZnJhbWVib3JkZXI9XCIwXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBoZWlnaHQ9XCIke0VNQkVEX1ZJREVPX0hFSUdIVH1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0IHNyYz1cImh0dHBzOi8vcGxheWVyLnR3aXRjaC50di8/YXV0b3BsYXk9ZmFsc2UmdmlkZW89e2VtYmVkSWR9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBzY3JvbGxpbmc9XCJub1wiIHdpZHRoPVwiJHtFTUJFRF9WSURFT19XSURUSH1cIj48L2lmcmFtZT5gLFxuXHRcdFx0XHRcdFx0dHlwZTogJ3ZpZGVvJyxcblx0XHRcdFx0XHRcdHVybFNjaGVtZXM6IFtcblx0XHRcdFx0XHRcdFx0J2h0dHBzPzpcXFxcL1xcXFwvKD86d3d3XFxcXC4pP3R3aXRjaC50dlxcXFwvdmlkZW9zXFxcXC8oXFxcXFMqKSQnLFxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlkOiAndmltZW8nLFxuXHRcdFx0XHRcdFx0dHBsOiBgPGlmcmFtZSBhbGxvd2Z1bGxzY3JlZW4gZnJhbWVib3JkZXI9XCIwXCIgaGVpZ2h0PVwiJHtFTUJFRF9WSURFT19IRUlHSFR9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBtb3phbGxvd2Z1bGxzY3JlZW4gc3JjPVwiaHR0cHM6Ly9wbGF5ZXIudmltZW8uY29tL3ZpZGVvL3tlbWJlZElkfVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgd2Via2l0YWxsb3dmdWxsc2NyZWVuIHdpZHRoPVwiJHtFTUJFRF9WSURFT19XSURUSH1cIj48L2lmcmFtZT5gLFxuXHRcdFx0XHRcdFx0dHlwZTogJ3ZpZGVvJyxcblx0XHRcdFx0XHRcdHVybFNjaGVtZXM6IFtcblx0XHRcdFx0XHRcdFx0J2h0dHBzPzpcXFxcL1xcXFwvKD86d3d3XFxcXC4pP3ZpbWVvXFxcXC5jb21cXFxcL2FsYnVtXFxcXC8uKlxcXFwvdmlkZW9cXFxcLyhcXFxcUyopJyxcblx0XHRcdFx0XHRcdFx0J2h0dHBzPzpcXFxcL1xcXFwvKD86d3d3XFxcXC4pP3ZpbWVvXFxcXC5jb21cXFxcL2NoYW5uZWxzXFxcXC8uKlxcXFwvKFxcXFxTKiknLFxuXHRcdFx0XHRcdFx0XHQnaHR0cHM/OlxcXFwvXFxcXC8oPzp3d3dcXFxcLik/dmltZW9cXFxcLmNvbVxcXFwvZ3JvdXBzXFxcXC8uKlxcXFwvdmlkZW9zXFxcXC8oXFxcXFMqKScsXG5cdFx0XHRcdFx0XHRcdCdodHRwcz86XFxcXC9cXFxcLyg/Ond3d1xcXFwuKT92aW1lb1xcXFwuY29tXFxcXC8oXFxcXFMqKSQnLFxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlkOiAneW91dHViZScsXG5cdFx0XHRcdFx0XHR0cGw6IGA8aWZyYW1lIGFsbG93PVwiYXV0b3BsYXk7IGVuY3J5cHRlZC1tZWRpYVwiIGFsbG93ZnVsbHNjcmVlblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0IGhlaWdodD1cIiR7RU1CRURfVklERU9fSEVJR0hUfVwiIGZyYW1lYm9yZGVyPVwiMFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgc3JjPVwiaHR0cHM6Ly93d3cueW91dHViZS5jb20vZW1iZWQve2VtYmVkSWR9P3JlbD0wXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCB3aWR0aD1cIiR7RU1CRURfVklERU9fV0lEVEh9XCI+PC9pZnJhbWU+YCxcblx0XHRcdFx0XHRcdHR5cGU6ICd2aWRlbycsXG5cdFx0XHRcdFx0XHR1cmxTY2hlbWVzOiBbXG5cdFx0XHRcdFx0XHRcdCdodHRwcz86XFxcXC9cXFxcLyg/Ond3d1xcXFwuKT95b3V0dWJlLmNvbVxcXFwvd2F0Y2hcXFxcP3Y9KFxcXFxTKikkJyxcblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XSxcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU3BlY2lmaWVzIHdoZXRoZXIgQWxsb3lFZGl0b3Igc2V0IHRoZSBjb250ZW50ZWRpdGFibGUgYXR0cmlidXRlXG5cdFx0XHQgKiB0byBcInRydWVcIiBvbiBpdHMgc3JjTm9kZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGVydHkgZW5hYmxlQ29udGVudEVkaXRhYmxlXG5cdFx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAd3JpdGVPbmNlXG5cdFx0XHQgKi9cblx0XHRcdGVuYWJsZUNvbnRlbnRFZGl0YWJsZToge1xuXHRcdFx0XHR2YWxpZGF0b3I6IExhbmcuaXNCb29sZWFuLFxuXHRcdFx0XHR2YWx1ZTogdHJ1ZSxcblx0XHRcdFx0d3JpdGVPbmNlOiB0cnVlLFxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgZGVsYXkgKHRpbWVvdXQpLCBpbiBtcywgYWZ0ZXIgd2hpY2ggZXZlbnRzIHN1Y2ggbGlrZSBrZXkgb3IgbW91c2UgZXZlbnRzIHdpbGwgYmUgcHJvY2Vzc2VkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSBldmVudHNEZWxheVxuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqL1xuXHRcdFx0ZXZlbnRzRGVsYXk6IHtcblx0XHRcdFx0dmFsaWRhdG9yOiBMYW5nLmlzTnVtYmVyLFxuXHRcdFx0XHR2YWx1ZTogMTAwLFxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgbGlzdCBvZiBleHRyYSBjb21tYW5kcyB0byBiZSBhZGRlZCB0byB0aGUgZWRpdG9yLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSBleHRyYUNvbW1hbmRzXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICovXG5cdFx0XHRleHRyYUNvbW1hbmRzOiB7XG5cdFx0XHRcdHZhbGlkYXRvcjogTGFuZy5pc09iamVjdCxcblx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRyZW1vdmVJbWFnZTogcmVtb3ZlSW1hZ2VDb21tYW5kLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR3cml0ZU9uY2U6IHRydWUsXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNwZWNpZmllcyB0aGUgZXh0cmEgcGx1Z2lucyB3aGljaCBoYXZlIHRvIGJlIGxvYWRlZCB0byB0aGUgY3VycmVudCBDS0VkaXRvciBpbnN0YW5jZSBpbiBvcmRlciB0b1xuXHRcdFx0ICogbWFrZSBBbGxveUVkaXRvciB0byB3b3JrIHByb3Blcmx5LlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSBleHRyYVBsdWdpbnNcblx0XHRcdCAqIEBkZWZhdWx0ICd1aWNvcmUsc2VsZWN0aW9ucmVnaW9uLGRyYWdyZXNpemUsYWRkaW1hZ2VzLHBsYWNlaG9sZGVyLHRhYmxldG9vbHMsdGFibGVyZXNpemUsYXV0b2xpbmsnXG5cdFx0XHQgKiBAd3JpdGVPbmNlXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICovXG5cdFx0XHRleHRyYVBsdWdpbnM6IHtcblx0XHRcdFx0dmFsaWRhdG9yOiBMYW5nLmlzU3RyaW5nLFxuXHRcdFx0XHR2YWx1ZTpcblx0XHRcdFx0XHQnYWVfdWljb3JlLGFlX3NlbGVjdGlvbnJlZ2lvbixhZV9zZWxlY3Rpb25rZXlzdHJva2VzLGFlX2ltYWdlYWxpZ25tZW50LGFlX2FkZGltYWdlcyxhZV9wbGFjZWhvbGRlciwnICtcblx0XHRcdFx0XHQnYWVfdGFibGV0b29scyxhZV90YWJsZXJlc2l6ZSxhZV9hdXRvbGluayxhZV9lbWJlZCxhZV9hdXRvbGlzdCxhZV9kcmFncmVzaXplLCcgK1xuXHRcdFx0XHRcdCdhZV91aWJyaWRnZSxhZV9yaWNoY29tYm9icmlkZ2UsYWVfcGFuZWxtZW51YnV0dG9uYnJpZGdlLGFlX21lbnVicmlkZ2UsYWVfbWVudWJ1dHRvbmJyaWRnZSxhZV9idXR0b25icmlkZ2UsZm9udCxjb2xvcmJ1dHRvbicsXG5cdFx0XHRcdHdyaXRlT25jZTogdHJ1ZSxcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU3BlY2lmaWVzIHRoZSBcIm1vZGVcIiBmb3IgYWxsb3kgZWRpdG9yXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGVydHkgbW9kZVxuXHRcdFx0ICogQGRlZmF1bHQgJ3NpbXBsZSdcblx0XHRcdCAqIEB3cml0ZU9uY2Vcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKi9cblx0XHRcdG1vZGU6IHtcblx0XHRcdFx0dmFsaWRhdG9yOiBMYW5nLmlzU3RyaW5nLFxuXHRcdFx0XHR2YWx1ZTogJ3NpbXBsZScsXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHJpZXZlcyB0aGUgbmF0aXZlIENLRWRpdG9yIGluc3RhbmNlLiBIYXZpbmcgdGhpcywgdGhlIGRldmVsb3BlciBtYXkgdXNlIHRoZSBmdWxsIEFQSSBvZiBDS0VkaXRvci5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGVydHkgbmF0aXZlRWRpdG9yXG5cdFx0XHQgKiBAcmVhZE9ubHlcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKi9cblx0XHRcdG5hdGl2ZUVkaXRvcjoge1xuXHRcdFx0XHRnZXR0ZXI6ICdfZ2V0TmF0aXZlRWRpdG9yJyxcblx0XHRcdFx0cmVhZE9ubHk6IHRydWUsXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNwZWNpZmllcyB0aGUgY2xhc3MsIHdoaWNoIHNob3VsZCBiZSBhZGRlZCBieSBQbGFjZWhvbGRlciBwbHVnaW5cblx0XHRcdCAqIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfcGxhY2Vob2xkZXJ9fXt7L2Nyb3NzTGlua319XG5cdFx0XHQgKiB3aGVuIGVkaXRvciBpcyBub3QgZm9jdXNlZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGVydHkgcGxhY2Vob2xkZXJDbGFzc1xuXHRcdFx0ICogQGRlZmF1bHQgJ2FlLXBsYWNlaG9sZGVyJ1xuXHRcdFx0ICogQHdyaXRlT25jZVxuXHRcdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHRcdCAqL1xuXHRcdFx0cGxhY2Vob2xkZXJDbGFzczoge1xuXHRcdFx0XHR2YWxpZGF0b3I6IExhbmcuaXNTdHJpbmcsXG5cdFx0XHRcdHZhbHVlOiAnYWUtcGxhY2Vob2xkZXInLFxuXHRcdFx0XHR3cml0ZU9uY2U6IHRydWUsXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNwZWNpZmllcyB0aGUgcGx1Z2lucywgd2hpY2ggY29tZSBieSBkZWZhdWx0IHdpdGggQ0tFZGl0b3IsIGJ1dCB3aGljaCBhcmUgbm90IG5lZWRlZCBieSBBbGxveUVkaXRvci5cblx0XHRcdCAqIFRoZXNlIHBsdWdpbnMgYWRkIHRoZSBkZWZhdWx0IFVJIGZvciBDS2VkaXRvciwgd2hpY2ggaXMgbm8gbW9yZSBuZWVkZWQuIFBsZWFzZSBub3RlIHRoYXQgQWxsb3lFZHRvclxuXHRcdFx0ICogY29tZXMgd2l0aCBpdHMgb3duIGhpZ2hseSBvcHRpbWl6ZWQgY29weSBvZiBDS0VkaXRvciAoanVzdCBjdXN0b21pemVkIHZpYSB0aGVpciBvZmZpY2lhbCBkb3dubG9hZCBwYWdlKS5cblx0XHRcdCAqIFRoaXMgdmVyc2lvbiBkb2VzIG5vdCBjb21lIHdpdGggdGhlIHVubmVlZGVkIHBsdWdpbnMsIHNvIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IHdvbid0IGJlIG5lZWRlZC5cblx0XHRcdCAqIEhvd2V2ZXIsIGlmIHlvdSBkZWNpZGUgdG8gZ28gd2l0aCB0aGUgT09UQiB2ZXJzaW9uIG9mIENLRWRpdG9yLCB5b3Ugd2lsbCBoYXZlIHRvIHJlbW92ZSBzb21lIG9mIHRoZVxuXHRcdFx0ICogcGx1Z2lucyBpZiB5b3UgZGVjaWRlIHRvIHVzZSBBbGxveUVkaXRvci4gS2VlcCBpbiBtaW5kIHRoYXQgcmVtb3ZpbmcgdGhlc2UgcGx1Z2lucyBkb2Vzbid0IHJlbW92ZSB0aGVtXG5cdFx0XHQgKiBlbnRpcmVseSBmcm9tIENLRWRpdG9yLiBJdCBqdXN0IHJlbW92ZXMgdGhlbSBmcm9tIGl0cyBjdXJyZW50IGluc3RhbmNlLCBpbiB3aGljaCB5b3Ugd2lsbCB1c2UgZGlmZmVyZW50XG5cdFx0XHQgKiBVSSAtIHRob3NlIG9mIEFsbG95RWRpdG9yLiBZb3Ugd2lsbCBiZSBmdWxseSBhYmxlIHRvIHVzZSBib3RoIE9PVEIgQ0tFZGl0b3IgYW5kIEFsbG95RWRpdG9yIG9uIHRoZSBzYW1lXG5cdFx0XHQgKiBwYWdlIVxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSByZW1vdmVQbHVnaW5zXG5cdFx0XHQgKiBAZGVmYXVsdCAnY29udGV4dG1lbnUsdG9vbGJhcixlbGVtZW50c3BhdGgscmVzaXplLGxpc3RzdHlsZSxsaW5rJ1xuXHRcdFx0ICogQHdyaXRlT25jZVxuXHRcdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHRcdCAqL1xuXHRcdFx0cmVtb3ZlUGx1Z2luczoge1xuXHRcdFx0XHR2YWxpZGF0b3I6IExhbmcuaXNTdHJpbmcsXG5cdFx0XHRcdHZhbHVlOiAnY29udGV4dG1lbnUsdG9vbGJhcixlbGVtZW50c3BhdGgscmVzaXplLGxpc3RzdHlsZSxsaW5rJyxcblx0XHRcdFx0d3JpdGVPbmNlOiB0cnVlLFxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBcnJheSBvZiBtYW51YWwgc2VsZWN0aW9uIHRyaWdnZXJzLiBUaGV5IGNhbiBiZSBjb25maWd1cmVkIHRvIG1hbnVhbGx5IHNob3cgYSBzcGVjaWZpYyBzZWxlY3Rpb24gdG9vbGJhclxuXHRcdFx0ICogYnkgZm9yY2luZyB0aGUgc2VsZWN0aW9uIHR5cGUuIEEgc2VsZWN0aW9uS2V5c3Ryb2tlIGl0ZW0gY29uc2lzdHMgb2YgYSBrZXlzIHByb3BlcnR5IHdpdGggYSBbQ0tFZGl0b3Iga2V5c3Ryb2tlXG5cdFx0XHQgKiBkZWZpbml0aW9uXShodHRwOi8vZG9jcy5ja2VkaXRvci5jb20vIyEvYXBpL0NLRURJVE9SLmNvbmZpZy1jZmcta2V5c3Ryb2tlcykgYW5kIGEgc2VsZWN0aW9uIHByb3BlcnR5IHdpdGhcblx0XHRcdCAqIHRoZSBzZWxlY3Rpb24gbmFtZSB0byB0cmlnZ2VyLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSBzZWxlY3Rpb25LZXlzdHJva2VzXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKi9cblx0XHRcdHNlbGVjdGlvbktleXN0cm9rZXM6IHtcblx0XHRcdFx0dmFsaWRhdG9yOiBMYW5nLmlzQXJyYXksXG5cdFx0XHRcdHZhbHVlOiBbXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0a2V5czogQ0tFRElUT1IuQ1RSTCArIDc2IC8qIEwqLyxcblx0XHRcdFx0XHRcdHNlbGVjdGlvbjogJ2xpbmsnLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0a2V5czogQ0tFRElUT1IuQ1RSTCArIENLRURJVE9SLlNISUZUICsgNzYgLyogTCovLFxuXHRcdFx0XHRcdFx0c2VsZWN0aW9uOiAnZW1iZWQnLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdF0sXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBwYXRoIHRvIHRoZSBzcHJpdGVtYXAgU1ZHIHVzZWQgZm9yIGljb25zXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BlcnR5IHNwcml0ZW1hcFxuXHRcdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0XHQgKiBAd3JpdGVPbmNlXG5cdFx0XHQgKi9cblx0XHRcdHNwcml0ZW1hcDoge1xuXHRcdFx0XHR2YWxpZGF0b3I6IExhbmcuaXNTdHJpbmcsXG5cdFx0XHRcdHZhbHVlOiAnYWxsb3ktZWRpdG9yL2Fzc2V0cy9pY29ucy9pY29ucy5zdmcnLFxuXHRcdFx0XHR3cml0ZU9uY2U6IHRydWUsXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBOb2RlIElEIG9yIEhUTWwgbm9kZSwgd2hpY2ggQWxsb3lFZGl0b3Igc2hvdWxkIHVzZSBhcyBhbiBlZGl0YWJsZSBhcmVhLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSBzcmNOb2RlXG5cdFx0XHQgKiBAdHlwZSBTdHJpbmcgfCBOb2RlXG5cdFx0XHQgKiBAd3JpdGVPbmNlXG5cdFx0XHQgKi9cblx0XHRcdHNyY05vZGU6IHtcblx0XHRcdFx0c2V0dGVyOiAnX3RvRWxlbWVudCcsXG5cdFx0XHRcdHdyaXRlT25jZTogdHJ1ZSxcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIHRvb2xiYXJzIGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgZWRpdG9yIGluc3RhbmNlXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BlcnR5IHtPYmplY3R9IHRvb2xiYXJzXG5cdFx0XHQgKi9cblx0XHRcdHRvb2xiYXJzOiB7XG5cdFx0XHRcdHZhbGlkYXRvcjogJ192YWxpZGF0ZVRvb2xiYXJzJyxcblx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRhZGQ6IHtcblx0XHRcdFx0XHRcdGJ1dHRvbnM6IFtcblx0XHRcdFx0XHRcdFx0J2ltYWdlRnJvbUZpbGUnLFxuXHRcdFx0XHRcdFx0XHQnZW1iZWQnLFxuXHRcdFx0XHRcdFx0XHQnY2FtZXJhJyxcblx0XHRcdFx0XHRcdFx0J2hsaW5lJyxcblx0XHRcdFx0XHRcdFx0J3RhYmxlJyxcblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHR0YWJJbmRleDogMixcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlczoge1xuXHRcdFx0XHRcdFx0c2VsZWN0aW9uczogU2VsZWN0aW9ucyxcblx0XHRcdFx0XHRcdHRhYkluZGV4OiAxLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0sXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBOb2RlIElEIG9yIEhUTWwgbm9kZSwgd2hlcmUgQWxsb3lFZGl0b3IncyBVSSBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BlcnR5IHVpTm9kZVxuXHRcdFx0ICogQHR5cGUgU3RyaW5nIHwgTm9kZVxuXHRcdFx0ICogQHdyaXRlT25jZVxuXHRcdFx0ICovXG5cdFx0XHR1aU5vZGU6IHtcblx0XHRcdFx0c2V0dGVyOiAnX3RvRWxlbWVudCcsXG5cdFx0XHRcdHdyaXRlT25jZTogdHJ1ZSxcblx0XHRcdH0sXG5cdFx0fSxcblx0fVxuKTtcblxuQ0tFRElUT1IuZXZlbnQuaW1wbGVtZW50T24oQ29yZSk7XG5cbmV4cG9ydCBkZWZhdWx0IENvcmU7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogUmVhY3QgY29udGV4dCB0byBhdm9pZCBleHBsaWNpdGx5IHBhc3NpbmcgdGhlIGVkaXRvciBpbnN0YW5jZSBhbGxcbiAqIHRocm91Z2ggdGhlIGNvbXBvbmVudCBoaWVyYXJjaHkgdmlhIHByb3BzLlxuICovXG5jb25zdCBFZGl0b3JDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcGFzc2VzIHRoZSBlZGl0b3IgY29udGV4dCBpbiB2aWEgYSBwcm9wLlxuICpcbiAqIENvbnRleHQgY2FuIG9ubHkgYmUgYWNjZXNzZWQgaW4gYHJlbmRlcigpYCBhbmQgaW4gbGlmZWN5Y2xlIG1ldGhvZHNcbiAqIChgY29tcG9uZW50RGlkTW91bnQoKWAgZXRjKS4gSWYgYSBjb21wb25lbnQgbmVlZHMgdG8gYWNjZXNzIGNvbnRleHRcbiAqIGVsc2V3aGVyZSwgc3VjaCBhcyBpbiBhIGNvbnN0cnVjdG9yLCB0aGUgY29udGV4dCBuZWVkcyB0byBiZSBwYXNzZWRcbiAqIGluIHZpYSBhIHByb3AuXG4gKi9cbkVkaXRvckNvbnRleHQudG9Qcm9wcyA9IENvbXBvbmVudCA9PiB7XG5cdGNvbnN0IGZvcndhcmRpbmdDb21wb25lbnQgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAoXG5cdFx0PEVkaXRvckNvbnRleHQuQ29uc3VtZXI+XG5cdFx0XHR7Y29udGV4dCA9PiA8Q29tcG9uZW50IHsuLi5wcm9wc30gY29udGV4dD17Y29udGV4dH0gcmVmPXtyZWZ9IC8+fVxuXHRcdDwvRWRpdG9yQ29udGV4dC5Db25zdW1lcj5cblx0KSk7XG5cdGZvcndhcmRpbmdDb21wb25lbnQua2V5ID0gQ29tcG9uZW50LmtleTtcblx0cmV0dXJuIGZvcndhcmRpbmdDb21wb25lbnQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFZGl0b3JDb250ZXh0O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgKiBhcyBCYXNlIGZyb20gJy4uL2NvbXBvbmVudHMvYmFzZSc7XG5pbXBvcnQgQnV0dG9ucyBmcm9tICcuLi9jb21wb25lbnRzL2J1dHRvbnMnO1xuaW1wb3J0ICogYXMgQ29tcGF0IGZyb20gJy4uL2NvbXBvbmVudHMvY29tcGF0JztcbmltcG9ydCBUb29sYmFycyBmcm9tICcuLi9jb21wb25lbnRzL3Rvb2xiYXJzJztcbmltcG9ydCBBdHRyaWJ1dGUgZnJvbSAnLi4vb29wL2F0dHJpYnV0ZSc7XG5pbXBvcnQgTGFuZyBmcm9tICcuLi9vb3AvbGFuZyc7XG5pbXBvcnQgZXh0ZW5kIGZyb20gJy4uL29vcC9vb3AnO1xuaW1wb3J0IFNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcyBmcm9tICcuLi9zZWxlY3Rpb25zL3NlbGVjdGlvbi1hcnJvd2JveCc7XG5pbXBvcnQgU2VsZWN0aW9uU2V0UG9zaXRpb24gZnJvbSAnLi4vc2VsZWN0aW9ucy9zZWxlY3Rpb24tcG9zaXRpb24nO1xuaW1wb3J0IFNlbGVjdGlvblRlc3QgZnJvbSAnLi4vc2VsZWN0aW9ucy9zZWxlY3Rpb24tdGVzdCc7XG5pbXBvcnQgU2VsZWN0aW9ucyBmcm9tICcuLi9zZWxlY3Rpb25zL3NlbGVjdGlvbnMnO1xuaW1wb3J0IENvcmUgZnJvbSAnLi9jb3JlJztcblxuaW1wb3J0ICcuLi9wbHVnaW5zJztcblxuLy8gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGN1cnJlbnRseSByZWdpc3RlcmVkIHBsdWdpbnMgaW4gQWxsb3lFZGl0b3IuXG5jb25zdCBCUklER0VfQlVUVE9OUyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQWxsb3lFZGl0b3IuXG4gKlxuICogQG1lbWJlcm9mIEFsbG95RWRpdG9yXG4gKiBAbWV0aG9kIGVkaXRhYmxlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge1N0cmluZ3xOb2RlfSBub2RlIFRoZSBOb2RlIElEIG9yIEhUTWwgbm9kZSwgd2hpY2ggQWxsb3lFZGl0b3Igc2hvdWxkIHVzZSBhcyBhbiBlZGl0YWJsZSBhcmVhLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIGF0dHJpYnV0ZXMgZm9yIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIEFsbG95RWRpdG9yLlxuICogQHJldHVybiB7T2JqZWN0fSBBbiBpbnN0YW5jZSBvZiB7eyNjcm9zc0xpbmsgXCJDb3JlXCJ9fXt7L2Nyb3NzTGlua319XG4gKi9cbmNvbnN0IGVkaXRhYmxlID0gZnVuY3Rpb24obm9kZSwgY29uZmlnKSB7XG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblx0Y29uZmlnLnNyY05vZGUgPSBub2RlO1xuXG5cdEFsbG95RWRpdG9yLmltcGxlbWVudEV2ZW50VGFyZ2V0KCk7XG5cblx0cmV0dXJuIG5ldyBDb3JlKGNvbmZpZyk7XG59O1xuXG4vKipcbiAqIFRoZSBmdWxsIFVSTCBmb3IgdGhlIEFsbG95RWRpdG9yIGluc3RhbGxhdGlvbiBkaXJlY3RvcnkuXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBtYW51YWxseSBwcm92aWRlIHRoZSBiYXNlIHBhdGggYnkgc2V0dGluZyBhXG4gKiBnbG9iYWwgdmFyaWFibGUgbmFtZWQgYEFMTE9ZRURJVE9SX0JBU0VQQVRIYC4gVGhpcyBnbG9iYWwgdmFyaWFibGVcbiAqIG11c3QgYmUgc2V0ICoqYmVmb3JlKiogdGhlIGVkaXRvciBzY3JpcHQgbG9hZGluZy5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgZ2V0QmFzZVBhdGhcbiAqIEBzdGF0aWNcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGZvdW5kIGJhc2UgcGF0aFxuICovXG5jb25zdCBnZXRCYXNlUGF0aCA9IGZ1bmN0aW9uKCkge1xuXHQvLyBGaW5kIG91dCB0aGUgZWRpdG9yIGRpcmVjdG9yeSBwYXRoLCBiYXNlZCBvbiBpdHMgPHNjcmlwdD4gdGFnLlxuXHRsZXQgcGF0aCA9IHdpbmRvdy5BTExPWUVESVRPUl9CQVNFUEFUSCB8fCAnJztcblxuXHRpZiAoIXBhdGgpIHtcblx0XHRjb25zdCBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBtYXRjaCA9IHNjcmlwdHNbaV0uc3JjLm1hdGNoKEFsbG95RWRpdG9yLnJlZ2V4QmFzZVBhdGgpO1xuXG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0cGF0aCA9IG1hdGNoWzFdO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBJbiBJRSAob25seSkgdGhlIHNjcmlwdC5zcmMgc3RyaW5nIGlzIHRoZSByYXcgdmFsdWUgZW50ZXJlZCBpbiB0aGVcblx0Ly8gSFRNTCBzb3VyY2UuIE90aGVyIGJyb3dzZXJzIHJldHVybiB0aGUgZnVsbCByZXNvbHZlZCBVUkwgaW5zdGVhZC5cblx0aWYgKHBhdGguaW5kZXhPZignOi8nKSA9PT0gLTEgJiYgcGF0aC5zbGljZSgwLCAyKSAhPT0gJy8vJykge1xuXHRcdC8vIEFic29sdXRlIHBhdGguXG5cdFx0aWYgKHBhdGguaW5kZXhPZignLycpID09PSAwKSB7XG5cdFx0XHRwYXRoID0gbG9jYXRpb24uaHJlZi5tYXRjaCgvXi4qPzpcXC9cXC9bXi9dKi8pWzBdICsgcGF0aDtcblx0XHR9XG5cdFx0Ly8gUmVsYXRpdmUgcGF0aC5cblx0XHRlbHNlIHtcblx0XHRcdHBhdGggPSBsb2NhdGlvbi5ocmVmLm1hdGNoKC9eW14/XSpcXC8oPzopLylbMF0gKyBwYXRoO1xuXHRcdH1cblx0fVxuXG5cdGlmICghcGF0aCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdCdUaGUgQWxsb3lFZGl0b3IgaW5zdGFsbGF0aW9uIHBhdGggY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgZGV0ZWN0ZWQuIFBsZWFzZSBzZXQgdGhlIGdsb2JhbCB2YXJpYWJsZSBcIkFMTE9ZRURJVE9SX0JBU0VQQVRIXCIgYmVmb3JlIGNyZWF0aW5nIGVkaXRvciBpbnN0YW5jZXMuJ1xuXHRcdCk7XG5cdH1cblxuXHRyZXR1cm4gcGF0aDtcbn07XG5cbi8qKlxuICogRGV0ZWN0cyBhbmQgbG9hZCB0aGUgY29ycmVzcG9uZGluZyBsYW5ndWFnZSBmaWxlIGlmIEFsbG95RWRpdG9yIGxhbmd1YWdlIHN0cmluZ3MgYXJlIG5vdCBhbHJlYWR5IHByZXNlbnQuXG4gKiBUaGUgZnVuY3Rpb24gZmlyZXMgYSB7eyNjcm9zc0xpbmsgXCJBbGxveUVkaXRvci9sYW5ndWFnZVJlc291cmNlc0xvYWRlZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudFxuICpcbiAqIEBtZW1iZXJvZiBBbGxveUVkaXRvclxuICogQG1ldGhvZCBsb2FkTGFuZ3VhZ2VSZXNvdXJjZXNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuIEFsbG95RWRpdG9yIGxvYWRzIHRoZSBsYW5ndWFnZSByZXNvdXJjZS5cbiAqL1xuY29uc3QgbG9hZExhbmd1YWdlUmVzb3VyY2VzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0QWxsb3lFZGl0b3IuaW1wbGVtZW50RXZlbnRUYXJnZXQoKTtcblxuXHRpZiAoTGFuZy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuXHRcdGlmIChBbGxveUVkaXRvci5TdHJpbmdzKSB7XG5cdFx0XHRzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QWxsb3lFZGl0b3Iub25jZSgnbGFuZ3VhZ2VSZXNvdXJjZXNMb2FkZWQnLCAoKSA9PiB7XG5cdFx0XHRcdHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFBbGxveUVkaXRvci5fbGFuZ1Jlc291cmNlUmVxdWVzdGVkKSB7XG5cdFx0QWxsb3lFZGl0b3IuX2xhbmdSZXNvdXJjZVJlcXVlc3RlZCA9IHRydWU7XG5cblx0XHRjb25zdCBsYW5ndWFnZXMgPSBbXG5cdFx0XHQnYWYnLFxuXHRcdFx0J2FyJyxcblx0XHRcdCdiZycsXG5cdFx0XHQnYm4nLFxuXHRcdFx0J2JzJyxcblx0XHRcdCdjYScsXG5cdFx0XHQnY3MnLFxuXHRcdFx0J2N5Jyxcblx0XHRcdCdkYScsXG5cdFx0XHQnZGUnLFxuXHRcdFx0J2VsJyxcblx0XHRcdCdlbi1hdScsXG5cdFx0XHQnZW4tY2EnLFxuXHRcdFx0J2VuLWdiJyxcblx0XHRcdCdlbicsXG5cdFx0XHQnZW8nLFxuXHRcdFx0J2VzJyxcblx0XHRcdCdldCcsXG5cdFx0XHQnZXUnLFxuXHRcdFx0J2ZhJyxcblx0XHRcdCdmaScsXG5cdFx0XHQnZm8nLFxuXHRcdFx0J2ZyLWNhJyxcblx0XHRcdCdmcicsXG5cdFx0XHQnZ2wnLFxuXHRcdFx0J2d1Jyxcblx0XHRcdCdoZScsXG5cdFx0XHQnaGknLFxuXHRcdFx0J2hyJyxcblx0XHRcdCdodScsXG5cdFx0XHQnaWQnLFxuXHRcdFx0J2lzJyxcblx0XHRcdCdpdCcsXG5cdFx0XHQnamEnLFxuXHRcdFx0J2thJyxcblx0XHRcdCdrbScsXG5cdFx0XHQna28nLFxuXHRcdFx0J2t1Jyxcblx0XHRcdCdsdCcsXG5cdFx0XHQnbHYnLFxuXHRcdFx0J21rJyxcblx0XHRcdCdtbicsXG5cdFx0XHQnbXMnLFxuXHRcdFx0J25iJyxcblx0XHRcdCdubCcsXG5cdFx0XHQnbm8nLFxuXHRcdFx0J3BsJyxcblx0XHRcdCdwdC1icicsXG5cdFx0XHQncHQnLFxuXHRcdFx0J3JvJyxcblx0XHRcdCdydScsXG5cdFx0XHQnc2knLFxuXHRcdFx0J3NrJyxcblx0XHRcdCdzbCcsXG5cdFx0XHQnc3EnLFxuXHRcdFx0J3NyLWxhdG4nLFxuXHRcdFx0J3NyJyxcblx0XHRcdCdzdicsXG5cdFx0XHQndGgnLFxuXHRcdFx0J3RyJyxcblx0XHRcdCd0dCcsXG5cdFx0XHQndWcnLFxuXHRcdFx0J3VrJyxcblx0XHRcdCd2aScsXG5cdFx0XHQnemgtY24nLFxuXHRcdFx0J3poJyxcblx0XHRdO1xuXG5cdFx0Y29uc3QgdXNlckxhbmd1YWdlID1cblx0XHRcdG5hdmlnYXRvci5sYW5ndWFnZSB8fCBuYXZpZ2F0b3IudXNlckxhbmd1YWdlIHx8ICdlbic7XG5cblx0XHRjb25zdCBwYXJ0cyA9IHVzZXJMYW5ndWFnZVxuXHRcdFx0LnRvTG93ZXJDYXNlKClcblx0XHRcdC5tYXRjaCgvKFthLXpdKykoPzotKFthLXpdKykpPy8pO1xuXHRcdGxldCBsYW5nID0gcGFydHNbMV07XG5cdFx0Y29uc3QgbG9jYWxlID0gcGFydHNbMl07XG5cblx0XHRpZiAobGFuZ3VhZ2VzLmluZGV4T2YobGFuZyArICctJyArIGxvY2FsZSkgPj0gMCkge1xuXHRcdFx0bGFuZyA9IGxhbmcgKyAnLScgKyBsb2NhbGU7XG5cdFx0fSBlbHNlIGlmIChsYW5ndWFnZXMuaW5kZXhPZihsYW5nKSA9PT0gLTEpIHtcblx0XHRcdGxhbmcgPSAnZW4nO1xuXHRcdH1cblxuXHRcdENLRURJVE9SLnNjcmlwdExvYWRlci5sb2FkKFxuXHRcdFx0QWxsb3lFZGl0b3IuZ2V0VXJsKCdsYW5nL2FsbG95LWVkaXRvci8nICsgbGFuZyArICcuanMnKSxcblx0XHRcdGxvYWRlZCA9PiB7XG5cdFx0XHRcdGlmIChsb2FkZWQpIHtcblx0XHRcdFx0XHRBbGxveUVkaXRvci5maXJlKCdsYW5ndWFnZVJlc291cmNlc0xvYWRlZCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cdFx0XHR0aGlzIC8vIEFsd2F5cyBgQWxsb3lFZGl0b3JgLlxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblx0XHQpO1xuXHR9XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGZ1bGwgVVJMIGZvciBBbGxveUVkaXRvciByZXNvdXJjZXMuIEJ5IGRlZmF1bHQsIFVSTHNcbiAqIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gY29udGFpbiBhIHF1ZXJ5c3RyaW5nIHBhcmFtZXRlciAoXCJ0XCIpXG4gKiBzZXQgdG8gdGhlIHtAbGluayBDS0VESVRPUiN0aW1lc3RhbXB9IHZhbHVlLlxuICpcbiAqIEBtZW1iZXJvZiBBbGxveUVkaXRvclxuICogQG1ldGhvZCBnZXRVcmxcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXNvdXJjZSBUaGUgcmVzb3VyY2Ugd2hvc2UgZnVsbCBVUkwgd2Ugd2FudCB0byBnZXQuXG4gKiBJdCBtYXkgYmUgYSBmdWxsLCBhYnNvbHV0ZSwgb3IgcmVsYXRpdmUgVVJMLlxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgZnVsbCBVUkwuXG4gKi9cbmNvbnN0IGdldFVybCA9IGZ1bmN0aW9uKHJlc291cmNlKSB7XG5cdGNvbnN0IGJhc2VQYXRoID0gQWxsb3lFZGl0b3IuZ2V0QmFzZVBhdGgoKTtcblxuXHQvLyBJZiB0aGlzIGlzIG5vdCBhIGZ1bGwgb3IgYWJzb2x1dGUgcGF0aC5cblx0aWYgKHJlc291cmNlLmluZGV4T2YoJzovJykgPT09IC0xICYmIHJlc291cmNlLmluZGV4T2YoJy8nKSAhPT0gMCkge1xuXHRcdHJlc291cmNlID0gYmFzZVBhdGggKyByZXNvdXJjZTtcblx0fVxuXG5cdC8vIEFkZCB0aGUgdGltZXN0YW1wLCBleGNlcHQgZm9yIGRpcmVjdG9yaWVzLlxuXHRpZiAoXG5cdFx0Q0tFRElUT1IudGltZXN0YW1wICYmXG5cdFx0cmVzb3VyY2UuY2hhckF0KHJlc291cmNlLmxlbmd0aCAtIDEpICE9PSAnLycgJiZcblx0XHQhL1smP110PS8udGVzdChyZXNvdXJjZSlcblx0KSB7XG5cdFx0cmVzb3VyY2UgKz1cblx0XHRcdChyZXNvdXJjZS5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JykgK1xuXHRcdFx0J3Q9JyArXG5cdFx0XHRDS0VESVRPUi50aW1lc3RhbXA7XG5cdH1cblxuXHRyZXR1cm4gcmVzb3VyY2U7XG59O1xuXG4vKipcbiAqIEltcGxlbWVudHMgZXZlbnQgZmlyaW5nIGFuZCBzdWJzY3JpYmluZyB2aWEgQ0tFRElUT1IuZXZlbnQuXG4gKlxuICogQG1lbWJlcm9mIEFsbG95RWRpdG9yXG4gKiBAbWV0aG9kIGltcGxlbWVudEV2ZW50VGFyZ2V0XG4gKiBAc3RhdGljXG4gKi9cbmNvbnN0IGltcGxlbWVudEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICghQWxsb3lFZGl0b3IuZmlyZSAmJiAhQWxsb3lFZGl0b3Iub24pIHtcblx0XHRDS0VESVRPUi5ldmVudC5pbXBsZW1lbnRPbihBbGxveUVkaXRvcik7XG5cdH1cbn07XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHdoaWNoIHNob3VsZCBtYXRjaCB0aGUgc2NyaXB0IHdoaWNoIGhhdmUgYmVlbiB1c2VkIHRvIGxvYWQgQWxsb3lFZGl0b3IuXG4gKlxuICogQG1lbWJlcm9mIEFsbG95RWRpdG9yXG4gKiBAcHJvcGVydHkgcmVnZXhCYXNlUGF0aFxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBzdGF0aWNcbiAqL1xuY29uc3QgcmVnZXhCYXNlUGF0aCA9IC8oXnwuKltcXFxcL10pKD86YWxsb3ktZWRpdG9yW14vXSt8YWxsb3ktZWRpdG9yKVxcLmpzKD86XFw/Lip8Oy4qKT8kL2k7XG5cbi8qKlxuICogRmlyZWQgd2hlbiBBbGxveUVkaXRvciBkZXRlY3RzIHRoZSBicm93c2VyIGxhbmd1YWdlIGFuZCBsb2FkcyB0aGUgY29ycmVzcG9uZGluZyBsYW5ndWFnZSBmaWxlLiBPbmNlIHRoaXMgZXZlbnRcbiAqIGlzIGZpcmVkLCBBbGxveUVkaXRvci5TdHJpbmdzIHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAZXZlbnQgbGFuZ3VhZ2VSZXNvdXJjZXNMb2FkZWRcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlcXVpcmVkIHBsdWdpbiBuYW1lcyBuZWVkZWQgZm9yIGEgZ2l2ZW4gcGx1Z2luXG4gKiBpZiBpdCBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgb3IgYW4gZW1wdHkgYXJyYXkuXG4gKlxuICogQG1lbWJlcm9mIEFsbG95RWRpdG9yXG4gKiBAbWV0aG9kIGdldEJ1dHRvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1dHRvbnMgQW4gYXJyYXkgb2YgYnV0dG9ucyBvciBwbHVnaW4gbmFtZXMuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBpbnZva2VkIHRvIHJlc29sdmUgdGhlIHJlcXVlc3RlZCBidXR0b24gbmFtZXMuXG4gKiBAc3RhdGljXG4gKi9cbmNvbnN0IGdldEJ1dHRvbnMgPSBmdW5jdGlvbihidXR0b25zKSB7XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gYnV0dG9ucy5yZWR1Y2UoKGFjYywgdmFsKSA9PiB7XG5cdFx0XHR2YWwgPSBCUklER0VfQlVUVE9OU1t2YWxdIHx8IFt2YWxdO1xuXHRcdFx0cmV0dXJuIGFjYy5jb25jYXQodmFsKTtcblx0XHR9LCBbXSk7XG5cdH07XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgYnV0dG9uIGFuZCB0cnkgdG8gZ2V0IGl0cyByZXF1aXJlZCBwbHVnaW5zLlxuICpcbiAqIEBtZW1iZXJvZiBBbGxveUVkaXRvclxuICogQG1ldGhvZCByZWdpc3RlckJyaWRnZUJ1dHRvblxuICogQHBhcmFtIHtTdHJpbmd9IGJ1dHRvbk5hbWUgVGhlIG5hbWUgb2YgdGhlIGJ1dHRvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbHVnaW5OYW1lIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdGhhdCByZWdpc3RlcnMgdGhlIGJ1dHRvbi5cbiAqIEBzdGF0aWNcbiAqL1xuY29uc3QgcmVnaXN0ZXJCcmlkZ2VCdXR0b24gPSBmdW5jdGlvbihidXR0b25OYW1lLCBwbHVnaW5OYW1lKSB7XG5cdGlmICghQlJJREdFX0JVVFRPTlNbcGx1Z2luTmFtZV0pIHtcblx0XHRCUklER0VfQlVUVE9OU1twbHVnaW5OYW1lXSA9IFtdO1xuXHR9XG5cblx0QlJJREdFX0JVVFRPTlNbcGx1Z2luTmFtZV0ucHVzaChidXR0b25OYW1lKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBPT1BcbiAqIEBtZW1iZXJvZiBBbGxveUVkaXRvclxuICovXG5jb25zdCBPT1AgPSB7XG5cdGV4dGVuZCxcbn07XG5cbmV4cG9ydCB7XG5cdEF0dHJpYnV0ZSxcblx0QmFzZSxcblx0QnV0dG9ucyxcblx0Q29tcGF0LFxuXHRDb3JlLFxuXHRMYW5nLFxuXHRPT1AsXG5cdFNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3Nlcyxcblx0U2VsZWN0aW9uU2V0UG9zaXRpb24sXG5cdFNlbGVjdGlvblRlc3QsXG5cdFNlbGVjdGlvbnMsXG5cdFRvb2xiYXJzLFxuXHRlZGl0YWJsZSxcblx0Z2V0QmFzZVBhdGgsXG5cdGdldEJ1dHRvbnMsXG5cdGdldFVybCxcblx0aW1wbGVtZW50RXZlbnRUYXJnZXQsXG5cdGxvYWRMYW5ndWFnZVJlc291cmNlcyxcblx0cmVnZXhCYXNlUGF0aCxcblx0cmVnaXN0ZXJCcmlkZ2VCdXR0b24sXG59O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgcmVtb3ZlSW1hZ2VDb21tYW5kIGZyb20gJy4vcmVtb3ZlLWltYWdlJztcblxuZXhwb3J0IHtyZW1vdmVJbWFnZUNvbW1hbmR9O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5jb25zdCByZW1vdmVJbWFnZUNvbW1hbmQgPSB7XG5cdGV4ZWM6IGVkaXRvciA9PiB7XG5cdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0aWYgKHNlbGVjdGlvbikge1xuXHRcdFx0Y29uc3QgcmFuZ2VzID0gc2VsZWN0aW9uLmdldFJhbmdlcygpO1xuXHRcdFx0Y29uc3Qgc3RhcnRDb250YWluZXIgPSByYW5nZXNbMF0uc3RhcnRDb250YWluZXI7XG5cblx0XHRcdGNvbnN0IG5leHRSYW5nZSA9IG5ldyBDS0VESVRPUi5kb20ucmFuZ2Uoc3RhcnRDb250YWluZXIpO1xuXHRcdFx0bmV4dFJhbmdlLnNldFN0YXJ0KHN0YXJ0Q29udGFpbmVyLCAwKTtcblx0XHRcdG5leHRSYW5nZS5zZXRFbmQoc3RhcnRDb250YWluZXIsIDApO1xuXG5cdFx0XHRjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRFbGVtZW50KCk7XG5cblx0XHRcdGlmIChzZWxlY3RlZEVsZW1lbnQgJiYgc2VsZWN0ZWRFbGVtZW50LmdldE5hbWUoKSA9PT0gJ2ltZycpIHtcblx0XHRcdFx0Y29uc3QgbmF0aXZlID0gc2VsZWN0aW9uLmdldE5hdGl2ZSgpO1xuXHRcdFx0XHRpZiAobmF0aXZlKSB7XG5cdFx0XHRcdFx0bmF0aXZlLnJlbW92ZUFsbFJhbmdlcygpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2VsZWN0aW9uLnNlbGVjdFJhbmdlcyhbbmV4dFJhbmdlXSk7XG5cblx0XHRcdFx0c2VsZWN0ZWRFbGVtZW50LnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJlbW92ZUltYWdlQ29tbWFuZDtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5cbi8qKlxuICogQnV0dG9uQWN0aW9uU3R5bGUgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGFwcGx5aW5nIHN0eWxlIGltcGxlbWVudGF0aW9uIGZvciBhXG4gKiBidXR0b24gYmFzZWQgb24gdGhlIGBhcHBseVN0eWxlYCBhbmQgYHJlbW92ZVN0eWxlYCBBUEkgb2YgQ0tFRElUT1IuXG4gKlxuICogVG8gZXhlY3V0ZSBwcm9wZXJseSwgdGhlIGNvbXBvbmVudCBoYXMgdG8gZXhwb3NlIHRoZSBmb2xsb3dpbmcgbWV0aG9kcyB3aGljaCBjYW4gYmUgb2J0YWluZWRcbiAqIG91dCBvZiB0aGUgYm94IHVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJCdXR0b25TdHlsZVwifX17ey9jcm9zc0xpbmt9fSBtaXhpbjpcbiAqIC0gYEZ1bmN0aW9uYCB7eyNjcm9zc0xpbmsgXCJCdXR0b25TdHlsZS9pc0FjdGl2ZVwifX17ey9jcm9zc0xpbmt9fSB0byBjaGVjayB0aGUgYWN0aXZlIHN0YXRlXG4gKiAtIGBGdW5jdGlvbmAge3sjY3Jvc3NMaW5rIFwiQnV0dG9uU3R5bGUvZ2V0U3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gdG8gcmV0dXJuIHRoZSBzdHlsZSB0aGF0IHNob3VsZCBiZSBhcHBsaWVkXG4gKlxuICogQGNsYXNzIEJ1dHRvbkFjdGlvblN0eWxlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT5cblx0Y2xhc3MgQnV0dG9uQWN0aW9uU3R5bGUgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcblx0XHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyBvciBhcHBsaWVzIHRoZSBjb21wb25lbnQgc3R5bGUgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkFjdGlvblN0eWxlXG5cdFx0ICogQG1ldGhvZCBhcHBseVN0eWxlXG5cdFx0ICovXG5cdFx0YXBwbHlTdHlsZSA9ICgpID0+IHtcblx0XHRcdGlmIChcblx0XHRcdFx0TGFuZy5pc0Z1bmN0aW9uKHRoaXMuaXNBY3RpdmUpICYmXG5cdFx0XHRcdExhbmcuaXNGdW5jdGlvbih0aGlzLmdldFN0eWxlKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0XHRlZGl0b3IuZ2V0U2VsZWN0aW9uKCkubG9jaygpO1xuXG5cdFx0XHRcdGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcblx0XHRcdFx0XHRlZGl0b3IucmVtb3ZlU3R5bGUodGhpcy5nZXRTdHlsZSgpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlZGl0b3IuYXBwbHlTdHlsZSh0aGlzLmdldFN0eWxlKCkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWRpdG9yLmdldFNlbGVjdGlvbigpLnVubG9jaygpO1xuXG5cdFx0XHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcblxuLyoqXG4gKiBCdXR0b25Db21tYW5kQWN0aXZlIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBhbiBgaXNBY3RpdmVgIG1ldGhvZCB0byBkZXRlcm1pbmUgaWZcbiAqIGEgY29udGV4dC1hd2FyZSBjb21tYW5kIGlzIGN1cnJlbnRseSBpbiBhbiBhY3RpdmUgc3RhdGUuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PlxuXHRjbGFzcyBCdXR0b25Db21tYW5kQWN0aXZlIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrcyBpZiB0aGUgY29tbWFuZCBpcyBhY3RpdmUgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRBY3RpdmVcblx0XHQgKiBAbWV0aG9kIGlzQWN0aXZlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tbWFuZCBpcyBhY3RpdmUsIGZhbHNlIG90aGVyd2lzZS5cblx0XHQgKi9cblx0XHRpc0FjdGl2ZSgpIHtcblx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0Y29uc3QgY29tbWFuZCA9IGVkaXRvci5nZXRDb21tYW5kKHRoaXMucHJvcHMuY29tbWFuZCk7XG5cblx0XHRcdHJldHVybiBjb21tYW5kID8gY29tbWFuZC5zdGF0ZSA9PT0gQ0tFRElUT1IuVFJJU1RBVEVfT04gOiBmYWxzZTtcblx0XHR9XG5cdH07XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuXG4vKipcbiAqIEJ1dHRvbkNvbW1hbmQgaXMgYSBtaXhpbiB0aGF0IGV4ZWN1dGVzIGEgY29tbWFuZCB2aWEgQ0tFRElUT1IncyBBUEkuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PlxuXHRjbGFzcyBCdXR0b25Db21tYW5kIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRcdC8qKlxuXHRcdCAqIEV4ZWN1dGVzIGEgQ0tFZGl0b3IgY29tbWFuZCBhbmQgZmlyZXMgYGFjdGlvblBlcmZvcm1lZGAgZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gZGF0YSBPcHRpb25hbCBkYXRhIHRvIGJlIHBhc3NlZCB0byBDS0VESVRPUidzIGBleGVjQ29tbWFuZGAgbWV0aG9kLlxuXHRcdCAqIEBtZXRob2QgZXhlY0NvbW1hbmRcblx0XHQgKi9cblx0XHRleGVjQ29tbWFuZCA9IGRhdGEgPT4ge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0XHRlZGl0b3IuZXhlY0NvbW1hbmQodGhpcy5wcm9wcy5jb21tYW5kLCBkYXRhKTtcblxuXHRcdFx0ZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXHRcdH07XG5cdH07XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuXG4vKipcbiAqIEJ1dHRvbktleXN0cm9rZSBpcyBhIG1peGluIHRoYXQgcHJvdmlkZXMgYSBga2V5c3Ryb2tlYCBwcm9wIHRoYXQgYWxsb3dzIGNvbmZpZ3VyaW5nXG4gKiBhIGZ1bmN0aW9uIG9mIHRoZSBpbnN0YW5jZSB0byBiZSBpbnZva2VkIHVwb24gdGhlIGtleXN0cm9rZSBhY3RpdmF0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25LZXlzdHJva2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PlxuXHRjbGFzcyBCdXR0b25LZXlzdHJva2UgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcblx0XHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdFx0LyoqXG5cdFx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIGJvdGggb24gdGhlIGNsaWVudCBhbmQgc2VydmVyLCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25LZXlzdHJva2Vcblx0XHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxNb3VudFxuXHRcdCAqL1xuXHRcdGNvbXBvbmVudFdpbGxNb3VudCgpIHtcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbE1vdW50KSkge1xuXHRcdFx0XHRzdXBlci5jb21wb25lbnRXaWxsTW91bnQoKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdFx0Y29uc3Qga2V5c3Ryb2tlID0gdGhpcy5wcm9wcy5rZXlzdHJva2U7XG5cblx0XHRcdGNvbnN0IGNvbW1hbmROYW1lID0gYGtleXN0cm9rZToke2tleXN0cm9rZS5uYW1lfWA7XG5cblx0XHRcdGxldCBjb21tYW5kID0gbmF0aXZlRWRpdG9yLmdldENvbW1hbmQoY29tbWFuZE5hbWUpO1xuXG5cdFx0XHRpZiAoIWNvbW1hbmQpIHtcblx0XHRcdFx0Y29tbWFuZCA9IG5ldyBDS0VESVRPUi5jb21tYW5kKG5hdGl2ZUVkaXRvciwge1xuXHRcdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0Y29uc3Qga2V5c3Ryb2tlRm4gPSBrZXlzdHJva2UuZm47XG5cblx0XHRcdFx0XHRcdGlmIChMYW5nLmlzU3RyaW5nKGtleXN0cm9rZUZuKSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzW2tleXN0cm9rZUZuXS5jYWxsKHRoaXMsIGVkaXRvcik7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKExhbmcuaXNGdW5jdGlvbihrZXlzdHJva2VGbikpIHtcblx0XHRcdFx0XHRcdFx0a2V5c3Ryb2tlRm4uY2FsbCh0aGlzLCBlZGl0b3IpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0uYmluZCh0aGlzKSxcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0bmF0aXZlRWRpdG9yLmFkZENvbW1hbmQoY29tbWFuZE5hbWUsIGNvbW1hbmQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9kZWZhdWx0S2V5c3Ryb2tlQ29tbWFuZCA9XG5cdFx0XHRcdG5hdGl2ZUVkaXRvci5rZXlzdHJva2VIYW5kbGVyLmtleXN0cm9rZXNba2V5c3Ryb2tlLmtleXNdO1xuXG5cdFx0XHRuYXRpdmVFZGl0b3Iuc2V0S2V5c3Ryb2tlKGtleXN0cm9rZS5rZXlzLCBjb21tYW5kTmFtZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZnJvbSB0aGUgRE9NLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbktleXN0cm9rZVxuXHRcdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcblx0XHQgKi9cblx0XHRjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbFVubW91bnQpKSB7XG5cdFx0XHRcdHN1cGVyLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY29udGV4dC5lZGl0b3Jcblx0XHRcdFx0LmdldCgnbmF0aXZlRWRpdG9yJylcblx0XHRcdFx0LnNldEtleXN0cm9rZShcblx0XHRcdFx0XHR0aGlzLnByb3BzLmtleXN0cm9rZS5rZXlzLFxuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRLZXlzdHJva2VDb21tYW5kXG5cdFx0XHRcdCk7XG5cdFx0fVxuXHR9O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcblxuLyoqXG4gKiBCdXR0b25DZmdQcm9wcyBpcyBhIGNsYXNzIHRoYXQgcHJvdmlkZXMgYSBtZXJnZUJ1dHRvbkNmZ1Byb3BzIG1ldGhvZCBmb3JcbiAqIG1lcmdpbmcgUmVhY3QgcHJvcHMgYW5kIHRoZSBuYXRpdmUgQ0tFRElUT1IncyBidXR0b25DZmcuXG4gKlxuICogQGNsYXNzIEJ1dHRvblByb3BzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT5cblx0Y2xhc3MgQnV0dG9uUHJvcHMgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcblx0XHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdFx0LyoqXG5cdFx0ICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzLCBwYXNzZWQgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50IHdpdGggdXNlcidzIGNvbmZpZ3VyYXRpb25cblx0XHQgKiB2aWEgYGJ1dHRvbkNmZ2AgcHJvcGVydHkuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uUHJvcHNcblx0XHQgKiBAbWV0aG9kIG1lcmdlQnV0dG9uQ2ZnUHJvcHNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgdG8gYmUgbWVyZ2VkIHdpdGggdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24gZm9yIHRoaXNcblx0XHQgKiBidXR0b24uIElmIG5vdCBwYXNzZWQsIHRoZSB1c2VyIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBtZXJnZWQgd2l0aCBgdGhpcy5wcm9wc2Bcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtZXJnZWQgcHJvcGVydGllc1xuXHRcdCAqL1xuXHRcdG1lcmdlQnV0dG9uQ2ZnUHJvcHMocHJvcHMgPSB0aGlzLnByb3BzKSB7XG5cdFx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdFx0XHRjb25zdCBidXR0b25DZmcgPSBuYXRpdmVFZGl0b3IuY29uZmlnLmJ1dHRvbkNmZyB8fCB7fTtcblx0XHRcdHJldHVybiBDS0VESVRPUi50b29scy5tZXJnZShwcm9wcywgYnV0dG9uQ2ZnWydsaW5rRWRpdCddKTtcblx0XHR9XG5cdH07XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nJztcblxuLyoqXG4gKiBCdXR0b25TdGF0ZUNsYXNzZXMgaXMgYSBtaXhpbiB0aGF0IGRlY29yYXRlcyB0aGUgZG9tRWxlbWVudCBvZiBhIGNvbXBvbmVudFxuICogd2l0aCBkaWZmZXJlbnQgQ1NTIGNsYXNzZXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogVG8gY2hlY2sgZm9yIHN0YXRlLCB0aGUgY29tcG9uZW50IGNhbiBleHBvc2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICogLSBgRnVuY3Rpb25gICoqaXNBY3RpdmUqKiB0byBjaGVjayB0aGUgYWN0aXZlIHN0YXRlXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+XG5cdGNsYXNzIEJ1dHRvblN0YXRlQ2xhc3NlcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIGxpc3Qgb2Ygc3RhdGUgY2xhc3NlcyBhc3NvY2lhdGVkIHRvIHRoZSBjdXJyZW50IGVsZW1lbnQncyBzdGF0ZSwgYWNjb3JkaW5nXG5cdFx0ICogdG8gdGhlIHJlc3VsdHMgb2YgdGhlIGlzQWN0aXZlIG1ldGhvZC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25TdGF0ZUNsYXNzZXNcblx0XHQgKiBAbWV0aG9kIGdldFN0YXRlQ2xhc3Nlc1xuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgd2l0aCB0aGUgc3RhdGUgQ1NTIGNsYXNzZXMuXG5cdFx0ICovXG5cdFx0Z2V0U3RhdGVDbGFzc2VzKCkge1xuXHRcdFx0bGV0IHN0YXRlQ2xhc3NlcyA9ICcnO1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgYWN0aXZlIHN0YXRlXG5cdFx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKHRoaXMuaXNBY3RpdmUpICYmIHRoaXMuaXNBY3RpdmUoKSkge1xuXHRcdFx0XHRzdGF0ZUNsYXNzZXMgKz0gJ2FlLWJ1dHRvbi1wcmVzc2VkJztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHN0YXRlQ2xhc3Nlcztcblx0XHR9XG5cdH07XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuXG4vKipcbiAqIEJ1dHRvblN0eWxlIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBhIHN0eWxlIHByb3AgYW5kIHNvbWUgbWV0aG9kcyB0byBhcHBseSB0aGUgcmVzdWx0aW5nXG4gKiBzdHlsZSBhbmQgY2hlY2tpbmcgaWYgaXQgaXMgcHJlc2VudCBpbiBhIGdpdmVuIHBhdGggb3Igc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdHlsZVxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+XG5cdGNsYXNzIEJ1dHRvblN0eWxlIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRcdC8qKlxuXHRcdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBib3RoIG9uIHRoZSBjbGllbnQgYW5kIHNlcnZlciwgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVcblx0XHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxNb3VudFxuXHRcdCAqL1xuXHRcdGNvbXBvbmVudFdpbGxNb3VudCgpIHtcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbE1vdW50KSkge1xuXHRcdFx0XHRzdXBlci5jb21wb25lbnRXaWxsTW91bnQoKTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IHN0eWxlID0gdGhpcy5wcm9wcy5zdHlsZTtcblxuXHRcdFx0aWYgKExhbmcuaXNTdHJpbmcoc3R5bGUpKSB7XG5cdFx0XHRcdGNvbnN0IHBhcnRzID0gc3R5bGUuc3BsaXQoJy4nKTtcblx0XHRcdFx0bGV0IGN1cnJlbnRNZW1iZXIgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJylcblx0XHRcdFx0XHQuY29uZmlnO1xuXHRcdFx0XHRsZXQgcHJvcGVydHkgPSBwYXJ0cy5zaGlmdCgpO1xuXG5cdFx0XHRcdHdoaWxlIChcblx0XHRcdFx0XHRwcm9wZXJ0eSAmJlxuXHRcdFx0XHRcdExhbmcuaXNPYmplY3QoY3VycmVudE1lbWJlcikgJiZcblx0XHRcdFx0XHRMYW5nLmlzT2JqZWN0KGN1cnJlbnRNZW1iZXJbcHJvcGVydHldKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjdXJyZW50TWVtYmVyID0gY3VycmVudE1lbWJlcltwcm9wZXJ0eV07XG5cdFx0XHRcdFx0cHJvcGVydHkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKExhbmcuaXNPYmplY3QoY3VycmVudE1lbWJlcikpIHtcblx0XHRcdFx0XHRzdHlsZSA9IGN1cnJlbnRNZW1iZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc3R5bGUgPSBuZXcgQ0tFRElUT1Iuc3R5bGUoc3R5bGUpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGZyb20gdGhlIERPTS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuXHRcdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcblx0XHQgKi9cblx0XHRjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbFVubW91bnQpKSB7XG5cdFx0XHRcdHN1cGVyLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3N0eWxlID0gbnVsbDtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGluc3RhbmNlIG9mIENLRURJVE9SLnN0eWxlIHdoaWNoIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgYnV0dG9uIHN0eWxlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlXG5cdFx0ICogQG1ldGhvZCBnZXRTdHlsZVxuXHRcdCAqIEByZXR1cm4ge0NLRURJVE9SLnN0eWxlfSBUaGUgY3VycmVudCBzdHlsZSByZXByZXNlbnRhdGlvbi5cblx0XHQgKi9cblx0XHRnZXRTdHlsZSgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9zdHlsZTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBDaGVja3MgaWYgc3R5bGUgaXMgYWN0aXZlIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuXHRcdCAqIEBtZXRob2QgaXNBY3RpdmVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHN0eWxlIGlzIGFjdGl2ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHRcdCAqL1xuXHRcdGlzQWN0aXZlKCkge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdFx0Y29uc3QgZWxlbWVudFBhdGggPSBlZGl0b3IuZWxlbWVudFBhdGgoKTtcblx0XHRcdHJldHVybiB0aGlzLmdldFN0eWxlKCkuY2hlY2tBY3RpdmUoZWxlbWVudFBhdGgsIGVkaXRvcik7XG5cdFx0fVxuXHR9O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5leHBvcnQge2RlZmF1bHQgYXMgQnV0dG9uQWN0aW9uU3R5bGV9IGZyb20gJy4vYnV0dG9uLWFjdGlvbi1zdHlsZSc7XG5leHBvcnQge2RlZmF1bHQgYXMgQnV0dG9uQ29tbWFuZEFjdGl2ZX0gZnJvbSAnLi9idXR0b24tY29tbWFuZC1hY3RpdmUnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEJ1dHRvbkNvbW1hbmR9IGZyb20gJy4vYnV0dG9uLWNvbW1hbmQnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEJ1dHRvbktleXN0cm9rZX0gZnJvbSAnLi9idXR0b24ta2V5c3Ryb2tlJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBCdXR0b25Qcm9wc30gZnJvbSAnLi9idXR0b24tcHJvcHMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEJ1dHRvblN0YXRlQ2xhc3Nlc30gZnJvbSAnLi9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgQnV0dG9uU3R5bGV9IGZyb20gJy4vYnV0dG9uLXN0eWxlJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBUb29sYmFyQnV0dG9uc30gZnJvbSAnLi90b29sYmFyLWJ1dHRvbnMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFdpZGdldERyb3Bkb3dufSBmcm9tICcuL3dpZGdldC1kcm9wZG93bic7XG5leHBvcnQge2RlZmF1bHQgYXMgV2lkZ2V0RXhjbHVzaXZlfSBmcm9tICcuL3dpZGdldC1leGNsdXNpdmUnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFdpZGdldEZvY3VzTWFuYWdlcn0gZnJvbSAnLi93aWRnZXQtZm9jdXMtbWFuYWdlcic7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5cbi8qKlxuICogVG9vbGJhckJ1dHRvbnMgcHJvdmlkZXMgYSBsaXN0IG9mIGJ1dHRvbnMgd2hpY2ggaGF2ZSB0byBiZSBkaXNwbGF5ZWRcbiAqIG9uIHRoZSBjdXJyZW50IHRvb2xiYXIgZGVwZW5kaW5nIG9uIHVzZXIgcHJlZmVyZW5jZXMgYW5kIGdpdmVuIHN0YXRlLlxuICpcbiAqIEBjbGFzcyBUb29sYmFyQnV0dG9uc1xuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+XG5cdGNsYXNzIFRvb2xiYXJCdXR0b25zIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRcdC8qKlxuXHRcdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGVcblx0XHQgKiB0b29sYmFyLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFRvb2xiYXJCdXR0b25zXG5cdFx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0XHQgKi9cblx0XHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdFx0Li4uV3JhcHBlZENvbXBvbmVudC5kZWZhdWx0UHJvcHMsXG5cdFx0XHRndXR0ZXI6IHtcblx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0dG9wOiAxMCxcblx0XHRcdH0sXG5cdFx0XHRjb25zdHJhaW5Ub1ZpZXdwb3J0OiB0cnVlLFxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBDYW5jZWxzIGFuIHNjaGVkdWxlZCBhbmltYXRpb24gZnJhbWUuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgVG9vbGJhckJ1dHRvbnNcblx0XHQgKiBAbWV0aG9kIGNhbmNlbEFuaW1hdGlvblxuXHRcdCAqL1xuXHRcdGNhbmNlbEFuaW1hdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLl9hbmltYXRpb25GcmFtZUlkKSB7XG5cdFx0XHRcdHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltYXRpb25GcmFtZUlkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBkaXNwbGF5aW5nIHRvb2xiYXIgQXJyb3cgYm94IG9uIHRvcCBvciBvbiBib3R0b20gb2YgdGhlIHRvb2xiYXJcblx0XHQgKiBkZXBlbmRpbmcgb24gdGhlIHBvaW50IG9mIHVzZXIgaW50ZXJhY3Rpb24gd2l0aCB0aGUgZWRpdG9yLlxuXHRcdCAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYXJyb3cgYm94IGNsYXNzZXMgYXNzb2NpYXRlZCB0byB0aGUgY3VycmVudCBlbGVtZW50J3Mgc3RhdGUuIEl0IHJlbGllc1xuXHRcdCAqIG9uIHRoZSBnZXRJbnRlcmFjdGlvblBvaW50IG1ldGhvZCB0byBjYWxjdWxhdGUgdGhlIHNlbGVjdGlvbiBkaXJlY3Rpb24uXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgVG9vbGJhckJ1dHRvbnNcblx0XHQgKiBAbWV0aG9kIGdldEFycm93Qm94Q2xhc3Nlc1xuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgd2l0aCB0aGUgYXJyb3cgYm94IENTUyBjbGFzc2VzLlxuXHRcdCAqL1xuXHRcdGdldEFycm93Qm94Q2xhc3NlcygpIHtcblx0XHRcdGxldCBhcnJvd0JveENsYXNzZXMgPSAnYWUtYXJyb3ctYm94JztcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0aGlzLmdldEludGVyYWN0aW9uUG9pbnQoKS5kaXJlY3Rpb24gPT09XG5cdFx0XHRcdENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NXG5cdFx0XHQpIHtcblx0XHRcdFx0YXJyb3dCb3hDbGFzc2VzICs9ICcgYWUtYXJyb3ctYm94LXRvcCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhcnJvd0JveENsYXNzZXMgKz0gJyBhZS1hcnJvdy1ib3gtYm90dG9tJztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFycm93Qm94Q2xhc3Nlcztcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGFuIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgaW4gcGFnZSBjb29yZGluYXRlcyxcblx0XHQgKiByZXN0cmljdGVkIHRvIGZpdCB0byBnaXZlbiB2aWV3cG9ydC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBUb29sYmFyQnV0dG9uc1xuXHRcdCAqIEBtZXRob2QgZ2V0Q29uc3RyYWluZWRQb3NpdGlvblxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMsIHByb3ZpZGVkIGFzIG51bWJlcnM6XG5cdFx0ICogLSBoZWlnaHRcblx0XHQgKiAtIGxlZnRcblx0XHQgKiAtIHRvcFxuXHRcdCAqIC0gd2lkdGhcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdmlld1BhbmVTaXplIE9wdGlvbmFsLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBjdXJyZW50IHZpZXdwb3J0IHdpbGwgYmUgdXNlZC4gU2hvdWxkIGNvbnRhaW4gYXQgbGVhc3QgdGhlc2UgcHJvcGVydGllczpcblx0XHQgKiAtIHdpZHRoXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzLCB3aGljaCByZXByZXNlbnQgdGhlIGNvbnN0cmFpbmVkIHBvc2l0aW9uIG9mIHRoZVxuXHRcdCAqIGVsZW1lbnQuXG5cdFx0ICovXG5cdFx0Z2V0Q29uc3RyYWluZWRQb3NpdGlvbihhdHRycywgdmlld1BhbmVTaXplKSB7XG5cdFx0XHR2aWV3UGFuZVNpemUgPVxuXHRcdFx0XHR2aWV3UGFuZVNpemUgfHxcblx0XHRcdFx0bmV3IENLRURJVE9SLmRvbS53aW5kb3cod2luZG93KS5nZXRWaWV3UGFuZVNpemUoKTtcblxuXHRcdFx0bGV0IHggPSBhdHRycy5sZWZ0O1xuXHRcdFx0bGV0IHkgPSBhdHRycy50b3A7XG5cblx0XHRcdGlmIChhdHRycy5sZWZ0ICsgYXR0cnMud2lkdGggPiB2aWV3UGFuZVNpemUud2lkdGgpIHtcblx0XHRcdFx0eCAtPSBhdHRycy5sZWZ0ICsgYXR0cnMud2lkdGggLSB2aWV3UGFuZVNpemUud2lkdGg7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh5IDwgMCkge1xuXHRcdFx0XHR5ID0gMDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eCxcblx0XHRcdFx0eSxcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24sIGluIHBhZ2UgY29vcmRpbmF0ZXMsIGFjY29yZGluZyB0byB3aGljaCBhIHRvb2xiYXIgc2hvdWxkIGFwcGVhci5cblx0XHQgKiBEZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2VsZWN0aW9uLCB0aGUgd2RpZ2V0IG1heSBhcHBlYXIgYWJvdmUgb2Ygb3Igb24gYm90dG9tIG9mIHRoZSBzZWxlY3Rpb24uXG5cdFx0ICpcblx0XHQgKiBJdCBkZXBlbmRzIG9uIHRoZSBwcm9wcyBlZGl0b3JFdmVudCB0byBhbmFseXplIHRoZSBmb2xsb3dpbmcgdXNlci1pbnRlcmFjdGlvbiBwYXJhbWV0ZXJzOlxuXHRcdCAqIC0ge09iamVjdH0gc2VsZWN0aW9uRGF0YSBUaGUgZGF0YSBhYm91dCB0aGUgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgYXMgcmV0dXJuZWQgZnJvbVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfc2VsZWN0aW9ucmVnaW9uL2dldFNlbGVjdGlvbkRhdGE6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogLSB7TnVtYmVyfSBwb3MgQ29udGFpbnMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb3NpdGlvbiwgY29uc2lkZXJlZCBhcyBtb3N0IGFwcHJvcHJpYXRlLlxuXHRcdCAqIFRoaXMgbWF5IGJlIHRoZSBwb2ludCB3aGVyZSB0aGUgdXNlciByZWxlYXNlZCB0aGUgbW91c2UsIG9yIGp1c3QgdGhlIGJlZ2lubmluZyBvciB0aGUgZW5kIG9mXG5cdFx0ICogdGhlIHNlbGVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZXRob2QgZ2V0SW50ZXJhY3Rpb25Qb2ludFxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gQW4gT2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0XHQgKiBkaXJlY3Rpb24sIHgsIHksIHdoZXJlIHggYW5kIHkgYXJlIGluIHBhZ2UgY29vcmRpbmF0ZXMgYW5kIGRpcmVjdGlvbiBjYW4gYmUgb25lIG9mIHRoZXNlOlxuXHRcdCAqIENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QIG9yIENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NXG5cdFx0ICovXG5cdFx0Z2V0SW50ZXJhY3Rpb25Qb2ludCgpIHtcblx0XHRcdGNvbnN0IGV2ZW50UGF5bG9hZCA9IHRoaXMucHJvcHMuZWRpdG9yRXZlbnRcblx0XHRcdFx0PyB0aGlzLnByb3BzLmVkaXRvckV2ZW50LmRhdGFcblx0XHRcdFx0OiBudWxsO1xuXG5cdFx0XHRpZiAoIWV2ZW50UGF5bG9hZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBldmVudFBheWxvYWQuc2VsZWN0aW9uRGF0YTtcblxuXHRcdFx0Y29uc3QgbmF0aXZlRXZlbnQgPSBldmVudFBheWxvYWQubmF0aXZlRXZlbnQ7XG5cblx0XHRcdGNvbnN0IHBvcyA9IHtcblx0XHRcdFx0eDogZXZlbnRQYXlsb2FkLm5hdGl2ZUV2ZW50LnBhZ2VYLFxuXHRcdFx0XHR5OiBzZWxlY3Rpb25EYXRhLnJlZ2lvbi50b3AsXG5cdFx0XHR9O1xuXG5cdFx0XHRsZXQgZGlyZWN0aW9uID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uZGlyZWN0aW9uO1xuXG5cdFx0XHRjb25zdCBlbmRSZWN0ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uZW5kUmVjdDtcblxuXHRcdFx0Y29uc3Qgc3RhcnRSZWN0ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uc3RhcnRSZWN0O1xuXG5cdFx0XHRpZiAoZW5kUmVjdCAmJiBzdGFydFJlY3QgJiYgc3RhcnRSZWN0LnRvcCA9PT0gZW5kUmVjdC50b3ApIHtcblx0XHRcdFx0ZGlyZWN0aW9uID0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1A7XG5cdFx0XHR9XG5cblx0XHRcdGxldCB4O1xuXHRcdFx0bGV0IHk7XG5cblx0XHRcdC8vIElmIHdlIGhhdmUgdGhlIHBvaW50IHdoZXJlIHVzZXIgcmVsZWFzZWQgdGhlIG1vdXNlLCBzaG93IFRvb2xiYXIgYXQgdGhpcyBwb2ludFxuXHRcdFx0Ly8gb3RoZXJ3aXNlIHNob3cgaXQgb24gdGhlIG1pZGRsZSBvZiB0aGUgc2VsZWN0aW9uLlxuXG5cdFx0XHRpZiAocG9zLnggJiYgcG9zLnkpIHtcblx0XHRcdFx0eCA9IHRoaXMuX2dldFhQb2ludChzZWxlY3Rpb25EYXRhLCBwb3MueCk7XG5cblx0XHRcdFx0aWYgKGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1ApIHtcblx0XHRcdFx0XHR5ID0gTWF0aC5taW4ocG9zLnksIHNlbGVjdGlvbkRhdGEucmVnaW9uLnRvcCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eSA9IE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0cG9zLnksXG5cdFx0XHRcdFx0XHR0aGlzLl9nZXRZUG9pbnQoc2VsZWN0aW9uRGF0YSwgbmF0aXZlRXZlbnQpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eCA9IHNlbGVjdGlvbkRhdGEucmVnaW9uLmxlZnQgKyBzZWxlY3Rpb25EYXRhLnJlZ2lvbi53aWR0aCAvIDI7XG5cblx0XHRcdFx0aWYgKGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT00pIHtcblx0XHRcdFx0XHR5ID0gdGhpcy5fZ2V0WVBvaW50KHNlbGVjdGlvbkRhdGEsIG5hdGl2ZUV2ZW50KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24udG9wO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRpcmVjdGlvbixcblx0XHRcdFx0eCxcblx0XHRcdFx0eSxcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2xiYXIuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWV0aG9kIF9nZXRYUG9pbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRYIFRoZSBYIGNvb3JkaW5hdGUgcmVjZWl2ZWQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IChtb3VzZXVwKS5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0aW9uRGF0YSBUaGUgZGF0YSBhYm91dCB0aGUgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgYXMgcmV0dXJuZWQgZnJvbSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRTZWxlY3Rpb25EYXRhOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjYWxjdWxhdGVkIFggcG9pbnQgaW4gcGFnZSBjb29yZGluYXRlcy5cblx0XHQgKi9cblx0XHRfZ2V0WFBvaW50KHNlbGVjdGlvbkRhdGEsIGV2ZW50WCkge1xuXHRcdFx0Y29uc3QgcmVnaW9uID0gc2VsZWN0aW9uRGF0YS5yZWdpb247XG5cblx0XHRcdGNvbnN0IGxlZnQgPSByZWdpb24uc3RhcnRSZWN0ID8gcmVnaW9uLnN0YXJ0UmVjdC5sZWZ0IDogcmVnaW9uLmxlZnQ7XG5cdFx0XHRjb25zdCByaWdodCA9IHJlZ2lvbi5lbmRSZWN0ID8gcmVnaW9uLmVuZFJlY3QucmlnaHQgOiByZWdpb24ucmlnaHQ7XG5cblx0XHRcdGxldCB4O1xuXG5cdFx0XHRpZiAobGVmdCA8IGV2ZW50WCAmJiByaWdodCA+IGV2ZW50WCkge1xuXHRcdFx0XHR4ID0gZXZlbnRYO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgbGVmdERpc3QgPSBNYXRoLmFicyhsZWZ0IC0gZXZlbnRYKTtcblx0XHRcdFx0Y29uc3QgcmlnaHREaXN0ID0gTWF0aC5hYnMocmlnaHQgLSBldmVudFgpO1xuXG5cdFx0XHRcdGlmIChsZWZ0RGlzdCA8IHJpZ2h0RGlzdCkge1xuXHRcdFx0XHRcdC8vIHVzZXIgcmFpc2VkIHRoZSBtb3VzZSBvbiBsZWZ0IG9uIHRoZSBzZWxlY3Rpb25cblx0XHRcdFx0XHR4ID0gbGVmdDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4ID0gcmlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHg7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2xiYXIuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWV0aG9kIF9nZXRZUG9pbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gbmF0aXZlRXZlbnQgVGhlIGRhdGEgYWJvdXQgZXZlbnQgaXMgZmlyZWRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0aW9uRGF0YSBUaGUgZGF0YSBhYm91dCB0aGUgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgYXMgcmV0dXJuZWQgZnJvbSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRTZWxlY3Rpb25EYXRhOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjYWxjdWxhdGVkIFkgcG9pbnQgaW4gcGFnZSBjb29yZGluYXRlcy5cblx0XHQgKi9cblx0XHRfZ2V0WVBvaW50KHNlbGVjdGlvbkRhdGEsIG5hdGl2ZUV2ZW50KSB7XG5cdFx0XHRsZXQgeSA9IDA7XG5cblx0XHRcdGlmIChzZWxlY3Rpb25EYXRhICYmIG5hdGl2ZUV2ZW50KSB7XG5cdFx0XHRcdGNvbnN0IGVsZW1lbnRUYXJnZXQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoXG5cdFx0XHRcdFx0bmF0aXZlRXZlbnQudGFyZ2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGVsZW1lbnRUYXJnZXQuJCAmJlxuXHRcdFx0XHRcdGVsZW1lbnRUYXJnZXQuZ2V0U3R5bGUoJ292ZXJmbG93JykgPT09ICdhdXRvJ1xuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHR5ID1cblx0XHRcdFx0XHRcdG5hdGl2ZUV2ZW50LnRhcmdldC5vZmZzZXRUb3AgK1xuXHRcdFx0XHRcdFx0bmF0aXZlRXZlbnQudGFyZ2V0Lm9mZnNldEhlaWdodDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uYm90dG9tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB5O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sYmFyIHRha2luZyBpbiBjb25zaWRlcmF0aW9uIHRoZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIlRvb2xiYXJCdXR0b25zL2d1dHRlcjphdHRyaWJ1dGVcIn19e3svY3Jvc3NMaW5rfX0gYXR0cmlidXRlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFRvb2xiYXJCdXR0b25zXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBtZXRob2QgIGdldFdpZGdldFhZUG9pbnRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gbGVmdCBUaGUgbGVmdCBvZmZzZXQgaW4gcGFnZSBjb29yZGluYXRlcyB3aGVyZSBUb29sYmFyIHNob3VsZCBiZSBzaG93bi5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gdG9wIFRoZSB0b3Agb2Zmc2V0IGluIHBhZ2UgY29vcmRpbmF0ZXMgd2hlcmUgVG9vbGJhciBzaG91bGQgYmUgc2hvd24uXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIG9mIHRoZSBzZWxlY3Rpb24uIE1heSBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcblx0XHQgKiBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUCBvciBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTVxuXHRcdCAqIEByZXR1cm4ge0FycmF5fSBBbiBBcnJheSB3aXRoIGxlZnQgYW5kIHRvcCBvZmZzZXRzIGluIHBhZ2UgY29vcmRpbmF0ZXMuXG5cdFx0ICovXG5cdFx0Z2V0V2lkZ2V0WFlQb2ludChsZWZ0LCB0b3AsIGRpcmVjdGlvbikge1xuXHRcdFx0Y29uc3QgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG5cdFx0XHRjb25zdCBndXR0ZXIgPSB0aGlzLnByb3BzLmd1dHRlcjtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRkaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NIHx8XG5cdFx0XHRcdGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1Bcblx0XHRcdCkge1xuXHRcdFx0XHRsZWZ0ID0gbGVmdCAtIGd1dHRlci5sZWZ0IC0gZG9tTm9kZS5vZmZzZXRXaWR0aCAvIDI7XG5cblx0XHRcdFx0dG9wID1cblx0XHRcdFx0XHRkaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NXG5cdFx0XHRcdFx0XHQ/IHRvcCArIGd1dHRlci50b3Bcblx0XHRcdFx0XHRcdDogdG9wIC0gZG9tTm9kZS5vZmZzZXRIZWlnaHQgLSBndXR0ZXIudG9wO1xuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0ZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fTEVGVF9UT19SSUdIVCB8fFxuXHRcdFx0XHRkaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9SSUdIVF9UT19MRUZUXG5cdFx0XHQpIHtcblx0XHRcdFx0bGVmdCA9XG5cdFx0XHRcdFx0ZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fTEVGVF9UT19SSUdIVFxuXHRcdFx0XHRcdFx0PyBsZWZ0ICsgZ3V0dGVyLmxlZnQgKyBkb21Ob2RlLm9mZnNldEhlaWdodCAvIDJcblx0XHRcdFx0XHRcdDogbGVmdCAtICgzICogZG9tTm9kZS5vZmZzZXRIZWlnaHQpIC8gMiAtIGd1dHRlci5sZWZ0O1xuXG5cdFx0XHRcdHRvcCA9IHRvcCAtIGd1dHRlci50b3AgLSBkb21Ob2RlLm9mZnNldEhlaWdodCAvIDI7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChsZWZ0IDwgMCkge1xuXHRcdFx0XHRsZWZ0ID0gMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRvcCA8IDApIHtcblx0XHRcdFx0dG9wID0gMDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFtsZWZ0LCB0b3BdO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdG9vbGJhciBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2Vcblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBUb29sYmFyQnV0dG9uc1xuXHRcdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdG9vbGJhciBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2Vcblx0XHQgKi9cblx0XHRpc1Zpc2libGUoKSB7XG5cdFx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cblx0XHRcdGlmIChkb21Ob2RlKSB7XG5cdFx0XHRcdGNvbnN0IGRvbUVsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoZG9tTm9kZSk7XG5cblx0XHRcdFx0cmV0dXJuIGRvbUVsZW1lbnQuaGFzQ2xhc3MoJ2FsbG95LWVkaXRvci12aXNpYmxlJyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBNb3ZlcyBhIHRvb2xiYXIgZnJvbSBhIHN0YXJ0aW5nIHBvaW50IHRvIGEgZGVzdGluYXRpb24gcG9pbnQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgVG9vbGJhckJ1dHRvbnNcblx0XHQgKiBAbWV0aG9kIG1vdmVUb1BvaW50XG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSBzdGFydFBvaW50IFRoZSBzdGFydGluZyBwb2ludCBmb3IgdGhlIG1vdmVtZW50LlxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gZW5kUG9pbnQgVGhlIGRlc3RpbmF0aW9uIHBvaW50IGZvciB0aGUgbW92ZW1lbnQuXG5cdFx0ICovXG5cdFx0bW92ZVRvUG9pbnQoc3RhcnRQb2ludCwgZW5kUG9pbnQpIHtcblx0XHRcdGNvbnN0IGRvbUVsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoXG5cdFx0XHRcdFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpXG5cdFx0XHQpO1xuXG5cdFx0XHRkb21FbGVtZW50LnNldFN0eWxlcyh7XG5cdFx0XHRcdGxlZnQ6IHN0YXJ0UG9pbnRbMF0gKyAncHgnLFxuXHRcdFx0XHR0b3A6IHN0YXJ0UG9pbnRbMV0gKyAncHgnLFxuXHRcdFx0XHRvcGFjaXR5OiAwLFxuXHRcdFx0XHRwb2ludGVyRXZlbnRzOiAnbm9uZScsXG5cdFx0XHR9KTtcblxuXHRcdFx0ZG9tRWxlbWVudC5yZW1vdmVDbGFzcygnYWxsb3ktZWRpdG9yLWludmlzaWJsZScpO1xuXG5cdFx0XHR0aGlzLl9hbmltYXRpb25GcmFtZUlkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG5cdFx0XHRcdGRvbUVsZW1lbnQuYWRkQ2xhc3MoJ2FlLXRvb2xiYXItdHJhbnNpdGlvbicpO1xuXHRcdFx0XHRkb21FbGVtZW50LmFkZENsYXNzKCdhbGxveS1lZGl0b3ItdmlzaWJsZScpO1xuXHRcdFx0XHRkb21FbGVtZW50LnNldFN0eWxlcyh7XG5cdFx0XHRcdFx0bGVmdDogZW5kUG9pbnRbMF0gKyAncHgnLFxuXHRcdFx0XHRcdHRvcDogZW5kUG9pbnRbMV0gKyAncHgnLFxuXHRcdFx0XHRcdG9wYWNpdHk6IDEsXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIDE1MG1zIHRvIG1hdGNoIHRyYW5zaXRpb24tZHVyYXRpb24gZm9yIC5hZS10b29sYmFyLXRyYW5zaXRpb246XG5cdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdGRvbUVsZW1lbnQuc2V0U3R5bGVzKHtcblx0XHRcdFx0XHRcdHBvaW50ZXJFdmVudHM6ICcnLFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LCAxNTApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogU2hvd3MgdGhlIHRvb2xiYXIgd2l0aCB0aGUgZGVmYXVsdCBhbmltYXRpb24gdHJhbnNpdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBUb29sYmFyQnV0dG9uc1xuXHRcdCAqIEBtZXRob2Qgc2hvd1xuXHRcdCAqL1xuXHRcdHNob3coKSB7XG5cdFx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cdFx0XHRjb25zdCB1aU5vZGUgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgndWlOb2RlJyk7XG5cblx0XHRcdGNvbnN0IHNjcm9sbFRvcCA9IHVpTm9kZSA/IHVpTm9kZS5zY3JvbGxUb3AgOiAwO1xuXG5cdFx0XHRpZiAoIXRoaXMuaXNWaXNpYmxlKCkgJiYgZG9tTm9kZSkge1xuXHRcdFx0XHRjb25zdCBpbnRlcmFjdGlvblBvaW50ID0gdGhpcy5nZXRJbnRlcmFjdGlvblBvaW50KCk7XG5cblx0XHRcdFx0aWYgKGludGVyYWN0aW9uUG9pbnQpIHtcblx0XHRcdFx0XHRjb25zdCBkb21FbGVtZW50ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGRvbU5vZGUpO1xuXG5cdFx0XHRcdFx0bGV0IGZpbmFsWDtcblx0XHRcdFx0XHRsZXQgZmluYWxZO1xuXHRcdFx0XHRcdGxldCBpbml0aWFsWDtcblx0XHRcdFx0XHRsZXQgaW5pdGlhbFk7XG5cblx0XHRcdFx0XHRmaW5hbFggPSBpbml0aWFsWCA9IHBhcnNlRmxvYXQoZG9tRWxlbWVudC5nZXRTdHlsZSgnbGVmdCcpKTtcblx0XHRcdFx0XHRmaW5hbFkgPSBpbml0aWFsWSA9IHBhcnNlRmxvYXQoZG9tRWxlbWVudC5nZXRTdHlsZSgndG9wJykpO1xuXG5cdFx0XHRcdFx0aWYgKHRoaXMucHJvcHMuY29uc3RyYWluVG9WaWV3cG9ydCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVzID0gdGhpcy5nZXRDb25zdHJhaW5lZFBvc2l0aW9uKHtcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBwYXJzZUZsb2F0KGRvbU5vZGUub2Zmc2V0SGVpZ2h0KSxcblx0XHRcdFx0XHRcdFx0bGVmdDogZmluYWxYLFxuXHRcdFx0XHRcdFx0XHR0b3A6IGZpbmFsWSxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IHBhcnNlRmxvYXQoZG9tTm9kZS5vZmZzZXRXaWR0aCksXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0ZmluYWxYID0gcmVzLng7XG5cdFx0XHRcdFx0XHRmaW5hbFkgPSByZXMueTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRpbnRlcmFjdGlvblBvaW50LmRpcmVjdGlvbiA9PT1cblx0XHRcdFx0XHRcdENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRpbml0aWFsWSA9XG5cdFx0XHRcdFx0XHRcdHRoaXMucHJvcHMuc2VsZWN0aW9uRGF0YS5yZWdpb24uYm90dG9tICsgc2Nyb2xsVG9wO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpbml0aWFsWSA9XG5cdFx0XHRcdFx0XHRcdHRoaXMucHJvcHMuc2VsZWN0aW9uRGF0YS5yZWdpb24udG9wICsgc2Nyb2xsVG9wO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMubW92ZVRvUG9pbnQoW2luaXRpYWxYLCBpbml0aWFsWV0sIFtmaW5hbFgsIGZpbmFsWV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyB0aGUgdG9vbGJhciBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgY3VycmVudCBpbnRlcmFjdGlvbiBwb2ludC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBUb29sYmFyQnV0dG9uc1xuXHRcdCAqIEBtZXRob2QgdXBkYXRlUG9zaXRpb25cblx0XHQgKi9cblx0XHR1cGRhdGVQb3NpdGlvbigpIHtcblx0XHRcdGNvbnN0IGludGVyYWN0aW9uUG9pbnQgPSB0aGlzLmdldEludGVyYWN0aW9uUG9pbnQoKTtcblxuXHRcdFx0Y29uc3QgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG5cdFx0XHRpZiAoaW50ZXJhY3Rpb25Qb2ludCAmJiBkb21Ob2RlKSB7XG5cdFx0XHRcdGNvbnN0IHVpTm9kZSA9XG5cdFx0XHRcdFx0dGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ3VpTm9kZScpIHx8IGRvY3VtZW50LmJvZHk7XG5cdFx0XHRcdGNvbnN0IHVpTm9kZVN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh1aU5vZGUpO1xuXHRcdFx0XHRjb25zdCB1aU5vZGVNYXJnaW5MZWZ0ID0gcGFyc2VJbnQoXG5cdFx0XHRcdFx0dWlOb2RlU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWxlZnQnKSxcblx0XHRcdFx0XHQxMFxuXHRcdFx0XHQpO1xuXHRcdFx0XHRjb25zdCB1aU5vZGVNYXJnaW5SaWdodCA9IHBhcnNlSW50KFxuXHRcdFx0XHRcdHVpTm9kZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ21hcmdpbi1yaWdodCcpLFxuXHRcdFx0XHRcdDEwXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnN0IHRvdGFsV2lkdGggPVxuXHRcdFx0XHRcdHVpTm9kZU1hcmdpbkxlZnQgKyB1aU5vZGUuY2xpZW50V2lkdGggKyB1aU5vZGVNYXJnaW5SaWdodDtcblxuXHRcdFx0XHRjb25zdCBzY3JvbGxUb3AgPVxuXHRcdFx0XHRcdHVpTm9kZS50YWdOYW1lICE9PSAnQk9EWScgPyB1aU5vZGUuc2Nyb2xsVG9wIDogMDtcblxuXHRcdFx0XHRjb25zdCB4eSA9IHRoaXMuZ2V0V2lkZ2V0WFlQb2ludChcblx0XHRcdFx0XHRpbnRlcmFjdGlvblBvaW50LngsXG5cdFx0XHRcdFx0aW50ZXJhY3Rpb25Qb2ludC55LFxuXHRcdFx0XHRcdGludGVyYWN0aW9uUG9pbnQuZGlyZWN0aW9uXG5cdFx0XHRcdCk7XG5cdFx0XHRcdHh5WzFdICs9IHNjcm9sbFRvcDtcblxuXHRcdFx0XHRpZiAoeHlbMF0gPCAwKSB7XG5cdFx0XHRcdFx0eHlbMF0gPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh4eVswXSA+IHRvdGFsV2lkdGggLSBkb21Ob2RlLm9mZnNldFdpZHRoKSB7XG5cdFx0XHRcdFx0eHlbMF0gPSB0b3RhbFdpZHRoIC0gZG9tTm9kZS5vZmZzZXRXaWR0aDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChkb21Ob2RlKS5zZXRTdHlsZXMoe1xuXHRcdFx0XHRcdGxlZnQ6IHh5WzBdICsgJ3B4Jyxcblx0XHRcdFx0XHR0b3A6IHh5WzFdICsgJ3B4Jyxcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQW5hbHlzZXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGFuZCByZXR1cm5zIHRoZSBidXR0b25zIG9yIGJ1dHRvbiBncm91cHMgdG8gYmUgcmVuZGVyZWQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWV0aG9kIGdldFRvb2xiYXJCdXR0b25Hcm91cHNcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBidXR0b25zIFRoZSBidXR0b25zIGNvdWxkIGJlIHNob3duLCBwcmlvciB0byB0aGUgc3RhdGUgZmlsdGVyaW5nLlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBhZGRpdGlvbmFsUHJvcHMgQWRkaXRpb25hbCBwcm9wcyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgZG93biB0byB0aGUgYnV0dG9ucy5cblx0XHQgKiBAcmV0dXJuIHtBcnJheX0gQW4gQXJyYXkgd2hpY2ggY29udGFpbnMgdGhlIGJ1dHRvbnMgb3IgYnV0dG9uIGdyb3VwcyB0aGF0IHNob3VsZCBiZSByZW5kZXJlZC5cblx0XHQgKi9cblx0XHRnZXRUb29sYmFyQnV0dG9uR3JvdXBzKGJ1dHRvbnMsIGFkZGl0aW9uYWxQcm9wcykge1xuXHRcdFx0aWYgKExhbmcuaXNGdW5jdGlvbihidXR0b25zKSkge1xuXHRcdFx0XHRidXR0b25zID0gYnV0dG9ucy5jYWxsKHRoaXMpIHx8IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnV0dG9ucy5yZWR1Y2UoKGxpc3QsIGJ1dHRvbikgPT4ge1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShidXR0b24pKSB7XG5cdFx0XHRcdFx0bGlzdC5wdXNoKHRoaXMuZ2V0VG9vbGJhckJ1dHRvbnMoYnV0dG9uLCBhZGRpdGlvbmFsUHJvcHMpKTtcblx0XHRcdFx0XHRyZXR1cm4gbGlzdDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRUb29sYmFyQnV0dG9ucyhidXR0b25zLCBhZGRpdGlvbmFsUHJvcHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBbXSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQW5hbHl6ZXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGFuZCB0aGUgYnV0dG9ucyBleGNsdXNpdmUgbW9kZSB2YWx1ZSB0byBmaWd1cmUgb3V0IHdoaWNoXG5cdFx0ICogYnV0dG9ucyBzaG91bGQgYmUgcHJlc2VudCBpbiBhIGdpdmVuIHN0YXRlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFRvb2xiYXJCdXR0b25zXG5cdFx0ICogQG1ldGhvZCBnZXRUb29sYmFyQnV0dG9uc1xuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IGJ1dHRvbnMgVGhlIGJ1dHRvbnMgY291bGQgYmUgc2hvd24sIHByaW9yIHRvIHRoZSBzdGF0ZSBmaWx0ZXJpbmcuXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGFkZGl0aW9uYWxQcm9wcyBBZGRpdGlvbmFsIHByb3BzIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCBkb3duIHRvIHRoZSBidXR0b25zLlxuXHRcdCAqIEByZXR1cm4ge0FycmF5fSBBbiBBcnJheSB3aGljaCBjb250YWlucyB0aGUgYnV0dG9ucyB0aGF0IHNob3VsZCBiZSByZW5kZXJlZC5cblx0XHQgKi9cblx0XHRnZXRUb29sYmFyQnV0dG9ucyhidXR0b25zLCBhZGRpdGlvbmFsUHJvcHMpIHtcblx0XHRcdGNvbnN0IGJ1dHRvblByb3BzID0ge307XG5cblx0XHRcdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRcdGNvbnN0IGJ1dHRvbkNmZyA9IG5hdGl2ZUVkaXRvci5jb25maWcuYnV0dG9uQ2ZnIHx8IHt9O1xuXG5cdFx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKGJ1dHRvbnMpKSB7XG5cdFx0XHRcdGJ1dHRvbnMgPSBidXR0b25zLmNhbGwodGhpcykgfHwgW107XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRvb2xiYXJCdXR0b25zID0gdGhpcy5maWx0ZXJFeGNsdXNpdmUoXG5cdFx0XHRcdGJ1dHRvbnNcblx0XHRcdFx0XHQuZmlsdGVyKGJ1dHRvbiA9PiB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHRidXR0b24gJiZcblx0XHRcdFx0XHRcdFx0KEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uXSB8fFxuXHRcdFx0XHRcdFx0XHRcdEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uLm5hbWVdKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5tYXAoYnV0dG9uID0+IHtcblx0XHRcdFx0XHRcdGlmIChMYW5nLmlzU3RyaW5nKGJ1dHRvbikpIHtcblx0XHRcdFx0XHRcdFx0YnV0dG9uUHJvcHNbYnV0dG9uXSA9IGJ1dHRvbkNmZ1tidXR0b25dO1xuXHRcdFx0XHRcdFx0XHRidXR0b24gPSBBbGxveUVkaXRvci5CdXR0b25zW2J1dHRvbl07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKExhbmcuaXNTdHJpbmcoYnV0dG9uLm5hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdGJ1dHRvblByb3BzW1xuXHRcdFx0XHRcdFx0XHRcdEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uLm5hbWVdLmtleVxuXHRcdFx0XHRcdFx0XHRdID0gQ0tFRElUT1IudG9vbHMubWVyZ2UoXG5cdFx0XHRcdFx0XHRcdFx0YnV0dG9uQ2ZnW2J1dHRvbl0sXG5cdFx0XHRcdFx0XHRcdFx0YnV0dG9uLmNmZ1xuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRidXR0b24gPSBBbGxveUVkaXRvci5CdXR0b25zW2J1dHRvbi5uYW1lXTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIGJ1dHRvbjtcblx0XHRcdFx0XHR9KVxuXHRcdFx0KS5tYXAoZnVuY3Rpb24oYnV0dG9uLCBpbmRleCkge1xuXHRcdFx0XHRsZXQgcHJvcHMgPSB0aGlzLm1lcmdlRXhjbHVzaXZlUHJvcHMoXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZWRpdG9yOiB0aGlzLmNvbnRleHQuZWRpdG9yLFxuXHRcdFx0XHRcdFx0a2V5OlxuXHRcdFx0XHRcdFx0XHRidXR0b24ua2V5ICE9PSAnc2VwYXJhdG9yJ1xuXHRcdFx0XHRcdFx0XHRcdD8gYnV0dG9uLmtleVxuXHRcdFx0XHRcdFx0XHRcdDogYCR7YnV0dG9uLmtleX0tJHtpbmRleH1gLFxuXHRcdFx0XHRcdFx0dGFiS2V5OiBidXR0b24ua2V5LFxuXHRcdFx0XHRcdFx0dGFiSW5kZXg6XG5cdFx0XHRcdFx0XHRcdHRoaXMucHJvcHMudHJpZ2dlciAmJlxuXHRcdFx0XHRcdFx0XHR0aGlzLnByb3BzLnRyaWdnZXIucHJvcHMudGFiS2V5ID09PSBidXR0b24ua2V5XG5cdFx0XHRcdFx0XHRcdFx0PyAwXG5cdFx0XHRcdFx0XHRcdFx0OiAtMSxcblx0XHRcdFx0XHRcdHRyaWdnZXI6IHRoaXMucHJvcHMudHJpZ2dlcixcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGJ1dHRvbi5rZXlcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRwcm9wcyA9IHRoaXMubWVyZ2VEcm9wZG93blByb3BzKHByb3BzLCBidXR0b24ua2V5KTtcblxuXHRcdFx0XHRpZiAoYWRkaXRpb25hbFByb3BzKSB7XG5cdFx0XHRcdFx0cHJvcHMgPSBDS0VESVRPUi50b29scy5tZXJnZShwcm9wcywgYWRkaXRpb25hbFByb3BzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHByb3BzID0gQ0tFRElUT1IudG9vbHMubWVyZ2UocHJvcHMsIGJ1dHRvblByb3BzW2J1dHRvbi5rZXldKTtcblxuXHRcdFx0XHRyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChidXR0b24sIHByb3BzKTtcblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHRyZXR1cm4gdG9vbGJhckJ1dHRvbnM7XG5cdFx0fVxuXHR9O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuXG4vKipcbiAqIFByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIG1hbmFnaW5nIGRpZmZlcmVudCBkcm9wZG93bnMgaW5zaWRlIGEgd2lkZ2V0LlxuICpcbiAqIEBjbGFzcyBXaWRnZXREcm9wZG93blxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+XG5cdGNsYXNzIFdpZGdldERyb3Bkb3duIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdFx0dGhpcy5zdGF0ZSA9IHtcblx0XHRcdFx0Li4udGhpcy5zdGF0ZSxcblx0XHRcdFx0ZHJvcGRvd25UcmlnZ2VyOiBudWxsLFxuXHRcdFx0XHRpdGVtRHJvcGRvd246IG51bGwsXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIExpZmVjeWNsZS4gSW52b2tlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlY2VpdmluZyBuZXcgcHJvcHMuXG5cdFx0ICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldERyb3Bkb3duXG5cdFx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG5cdFx0ICovXG5cdFx0Y29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykpIHtcblx0XHRcdFx0c3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdFx0ZHJvcGRvd25UcmlnZ2VyOiBudWxsLFxuXHRcdFx0XHRpdGVtRHJvcGRvd246IG51bGwsXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBNZXJnZXMgdGhlIHByb3ZpZGVkIG9iamVjdCB3aXRoIHR3byBtb3JlIHByb3BlcnRpZXM6XG5cdFx0ICogLSBleHBhbmRlZCAtIGJvb2xlYW4gZmxhZyB3aGljaCBpbmRpY2F0ZXMgaWYgYW4gd2lkZ2V0IHNob3VsZCBiZSByZW5kZXJlZCBleGNsdXNpdmVseS5cblx0XHQgKiAtIHRvZ2dsZURyb3Bkb3duIC0gZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSB1c2VkIGJ5IGFuIHdpZGdldCBpbiBvcmRlciB0byBvYnRhaW4gZXhjbHVzaXZlIHN0YXRlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldERyb3Bkb3duXG5cdFx0ICogQG1ldGhvZCBtZXJnZURyb3Bkb3duUHJvcHNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBwcm9wZXJ0aWVzIGNvbnRhaW5lciB3aGljaCBzaG91bGQgYmUgbWVyZ2VkIHdpdGggdGhlIHByb3BlcnRpZXMsIHJlbGF0ZWRcblx0XHQgKiAgICB0byBkcm9wZG93biBzdGF0ZS5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbUtleSBUaGV5IGtleSBvZiBhbiBSZWFjdCBXaWRnZXQgd2hpY2ggY29udGFpbnMgdGhlIGRyb3Bkb3duLlxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1lcmdlZCBvYmplY3QuXG5cdFx0ICovXG5cdFx0bWVyZ2VEcm9wZG93blByb3BzID0gKG9iaiwgaXRlbUtleSkgPT4ge1xuXHRcdFx0cmV0dXJuIENLRURJVE9SLnRvb2xzLm1lcmdlKG9iaiwge1xuXHRcdFx0XHRleHBhbmRlZDogdGhpcy5zdGF0ZS5pdGVtRHJvcGRvd24gPT09IGl0ZW1LZXkgPyB0cnVlIDogZmFsc2UsXG5cdFx0XHRcdHRhYkluZGV4OiB0aGlzLnN0YXRlLmRyb3Bkb3duVHJpZ2dlciA9PT0gaXRlbUtleSA/IDAgOiAtMSxcblx0XHRcdFx0dG9nZ2xlRHJvcGRvd246IHRoaXMudG9nZ2xlRHJvcGRvd24uYmluZCh0aGlzLCBpdGVtS2V5KSxcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBTZXRzIHRoZSBhY3RpdmUgZHJvcGRvd24gb2YgdGhlIHdpZGdldCBvciBkaXNjYXJkcyB0aGUgdG9nZ2xlZCBpdGVtIGZyb20gdGhlIHN0YXRlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldERyb3Bkb3duXG5cdFx0ICogQG1ldGhvZCB0b2dnbGVEcm9wZG93blxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRHJvcGRvd24gVGhlIHdpZGdldCB3aGljaCByZXF1ZXN0cyB0byB0b2dnbGUgaXRzIGRyb3Bkb3duLlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB0b2dnbGVEaXJlY3Rpb24gVXNlciBtb3ZlbWVudCBkaXJlY3Rpb24gd2hlbiB0b2dnbGVkIHZpYSBrZXlib2FyZC5cblx0XHQgKi9cblx0XHR0b2dnbGVEcm9wZG93biA9IChpdGVtRHJvcGRvd24sIHRvZ2dsZURpcmVjdGlvbikgPT4ge1xuXHRcdFx0dGhpcy5zZXRTdGF0ZShcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGRyb3Bkb3duVHJpZ2dlcjogaXRlbURyb3Bkb3duLFxuXHRcdFx0XHRcdGl0ZW1Ecm9wZG93bjpcblx0XHRcdFx0XHRcdGl0ZW1Ecm9wZG93biAhPT0gdGhpcy5zdGF0ZS5pdGVtRHJvcGRvd25cblx0XHRcdFx0XHRcdFx0PyBpdGVtRHJvcGRvd25cblx0XHRcdFx0XHRcdFx0OiBudWxsLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHQoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLnN0YXRlLml0ZW1Ecm9wZG93bikge1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMubW92ZUZvY3VzKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMubW92ZUZvY3VzKHRvZ2dsZURpcmVjdGlvbik7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9O1xuXHR9O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5cbi8qKlxuICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgbWFuYWdpbmcgZXhjbHVzaXZlIHN0YXRlIG9mIGFuIHdpZGdldC5cbiAqIFRoZSBleGNsdXNpdmUgc3RhdGUgbWVhbnMgdGhhdCBhIGJ1dHRvbiBtYXkgcmVxdWVzdCB0byBiZSB0aGUgb25seSByZW5kZXJlZFxuICogd2lkZ2V0IGluIGl0cyBwYXJlbnQgY29udGFpbmVyLiBXaWRnZXRFeGNsdXNpdmUgd2lsbCBtYW5hZ2UgdGhpcyBzdGF0ZSBieVxuICogZmlsdGVyaW5nIGFuZCBzdXBwcmVzc2luZyB0aGUgb3RoZXIgc2libGluZyB3aWRnZXRzIGZyb20gZGlzcGxheWluZy5cbiAqXG4gKiBAY2xhc3MgV2lkZ2V0RXhjbHVzaXZlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT5cblx0Y2xhc3MgV2lkZ2V0RXhjbHVzaXZlIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0LyoqXG5cdFx0ICogQ2FuY2VscyB0aGUgZXhjbHVzaXZlIHN0YXRlIG9mIGFuIHdpZGdldC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRFeGNsdXNpdmVcblx0XHQgKiBAbWV0aG9kIGNhbmNlbEV4Y2x1c2l2ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRXhjbHVzaXZlIFRoZSB3aWRnZXQgd2hpY2ggZXhjbHVzaXZlIHN0YXRlIHNob3VsZCBiZSBjYW5jZWxlZC5cblx0XHQgKi9cblx0XHRjYW5jZWxFeGNsdXNpdmUoaXRlbUV4Y2x1c2l2ZSkge1xuXHRcdFx0aWYgKHRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSA9PT0gaXRlbUV4Y2x1c2l2ZSkge1xuXHRcdFx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdFx0XHRpdGVtRXhjbHVzaXZlOiBudWxsLFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBMaWZlY3ljbGUuIEludm9rZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZWNlaXZpbmcgbmV3IHByb3BzLlxuXHRcdCAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cblx0XHQgKiBDYWxsaW5nIHRoaXMuc2V0U3RhdGUoKSB3aXRoaW4gdGhpcyBmdW5jdGlvbiB3aWxsIG5vdCB0cmlnZ2VyIGFuIGFkZGl0aW9uYWwgcmVuZGVyLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEV4Y2x1c2l2ZVxuXHRcdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBuZXh0UHJvcHMgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgc2V0IG9mIHByb3BlcnRpZXMuXG5cdFx0ICovXG5cdFx0Y29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykpIHtcblx0XHRcdFx0c3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZWNlaXZpbmcgcHJvcGVydGllcyBtZWFucyB0aGF0IHRoZSBjb21wb25lbnQgaXMgYmVpbmcgcmUtcmVuZGVyZWQuXG5cdFx0XHQvLyBSZS1yZW5kZXJpbmcgaXMgdHJpZ2dlcmVkIGJ5IGVkaXRvckludGVyYWN0aW9uLCBzbyB3ZSBoYXZlIHRvXG5cdFx0XHQvLyByZXNldCB0aGUgZXhjbHVzaXZlIHN0YXRlIGFuZCByZW5kZXIgdGhlIFVJIGFjY29yZGluZyB0byB0aGUgbmV3IHNlbGVjdGlvbi5cblx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRpdGVtRXhjbHVzaXZlOiBudWxsLFxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogRmlsdGVycyB0aGUgaXRlbXMgYW5kIHJldHVybnMgb25seSB0aG9zZSB3aXRoIGV4Y2x1c2l2ZSBzdGF0ZS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRFeGNsdXNpdmVcblx0XHQgKiBAbWV0aG9kIGZpbHRlckV4Y2x1c2l2ZVxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIFRoZSB3aWRnZXRzIHRvIGJlIGZpbHRlcmVkLlxuXHRcdCAqIEByZXR1cm4ge0FycmF5fE9iamVjdH0gVGhlIGl0ZW0gd2l0aCBleGVjdXRpdmUgc3RhdGUuXG5cdFx0ICovXG5cdFx0ZmlsdGVyRXhjbHVzaXZlKGl0ZW1zKSB7XG5cdFx0XHRyZXR1cm4gaXRlbXMuZmlsdGVyKGl0ZW0gPT4ge1xuXHRcdFx0XHRpZiAodGhpcy5zdGF0ZS5pdGVtRXhjbHVzaXZlKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSA9PT0gaXRlbS5rZXkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBpdGVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogTWVyZ2VzIHRoZSBwcm92aWRlZCBvYmplY3Qgd2l0aCB0aHJlZSBtb3JlIHByb3BlcnRpZXM6XG5cdFx0ICogLSBjYW5jZWxFeGNsdXNpdmUgLSBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIHVzZWQgYnkgYSB3aWRnZXQgaW4gb3JkZXIgdG8gY2FuY2VsIGV4ZWN1dGl2ZSBzdGF0ZS5cblx0XHQgKiAtIHJlbmRlckV4Y2x1c2l2ZSAtIGJvb2xlYW4gZmxhZyB3aGljaCBpbmRpY2F0ZXMgaWYgYW4gd2lkZ2V0IHNob3VsZCBiZSByZW5kZXJlZCBleGNsdXNpdmVseS5cblx0XHQgKiAtIHJlcXVlc3RFeGNsdXNpdmUgLSBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIHVzZWQgYnkgYSB3aWRnZXQgaW4gb3JkZXIgdG8gb2J0YWluIGV4Y2x1c2l2ZSBzdGF0ZS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRFeGNsdXNpdmVcblx0XHQgKiBAbWV0aG9kIG1lcmdlRXhjbHVzaXZlUHJvcHNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBwcm9wZXJ0aWVzIGNvbnRhaW5lciB3aGljaCBzaG91bGQgYmUgbWVyZ2VkIHdpdGggdGhlIHByb3BlcnRpZXMsIHJlbGF0ZWRcblx0XHQgKiAgICB0byBleGNsdXNpdmUgc3RhdGUuXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1LZXkgVGhleSBrZXkgb2YgYW4gUmVhY3QgV2lkZ2V0IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZCBleGNsdXNpdmVseS5cblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtZXJnZWQgb2JqZWN0LlxuXHRcdCAqL1xuXHRcdG1lcmdlRXhjbHVzaXZlUHJvcHMob2JqLCBpdGVtS2V5KSB7XG5cdFx0XHRyZXR1cm4gQ0tFRElUT1IudG9vbHMubWVyZ2Uob2JqLCB7XG5cdFx0XHRcdGNhbmNlbEV4Y2x1c2l2ZTogdGhpcy5jYW5jZWxFeGNsdXNpdmUuYmluZCh0aGlzLCBpdGVtS2V5KSxcblx0XHRcdFx0cmVuZGVyRXhjbHVzaXZlOiB0aGlzLnN0YXRlLml0ZW1FeGNsdXNpdmUgPT09IGl0ZW1LZXksXG5cdFx0XHRcdHJlcXVlc3RFeGNsdXNpdmU6IHRoaXMucmVxdWVzdEV4Y2x1c2l2ZS5iaW5kKHRoaXMsIGl0ZW1LZXkpLFxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmVxdWVzdHMgYW5kIHNldHMgZXhjbHVzaXZlIHN0YXRlIG9mIGFuIHdpZGdldC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRFeGNsdXNpdmVcblx0XHQgKiBAbWV0aG9kIHJlcXVlc3RFeGNsdXNpdmVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbUV4Y2x1c2l2ZSBUaGUgd2lkZ2V0IHdoaWNoIHJlcXVlc3RzIGV4Y2x1c2l2ZSBzdGF0ZS5cblx0XHQgKi9cblx0XHRyZXF1ZXN0RXhjbHVzaXZlID0gaXRlbUV4Y2x1c2l2ZSA9PiB7XG5cdFx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdFx0aXRlbUV4Y2x1c2l2ZSxcblx0XHRcdH0pO1xuXHRcdH07XG5cdH07XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5cbmNvbnN0IERJUkVDVElPTl9OT05FID0gMDtcbmNvbnN0IERJUkVDVElPTl9ORVhUID0gMTtcbmNvbnN0IERJUkVDVElPTl9QUkVWID0gLTE7XG5cbmNvbnN0IEFDVElPTl9OT05FID0gMDtcbmNvbnN0IEFDVElPTl9NT1ZFX0ZPQ1VTID0gMTtcbmNvbnN0IEFDVElPTl9ESVNNSVNTX0ZPQ1VTID0gMjtcblxuLyoqXG4gKiBXaWRnZXRGb2N1c01hbmFnZXIgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGtleWJvYXJkIG5hdmlnYXRpb24gaW5zaWRlIGEgd2lkZ2V0LiBUbyBkbyB0aGlzLFxuICogaXQgZXhwb3NlcyB0aGUgZm9sbG93aW5nIHByb3BzIGFuZCBtZXRob2RzOlxuICpcbiAqIEBjbGFzcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PlxuXHRjbGFzcyBXaWRnZXRGb2N1c01hbmFnZXIgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcblx0XHQvKipcblx0XHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50LCBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcblx0XHQgKi9cblx0XHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50RGlkTW91bnQpKSB7XG5cdFx0XHRcdHN1cGVyLmNvbXBvbmVudERpZE1vdW50KCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3JlZnJlc2goKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBMaWZlY3ljbGUuIEludm9rZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbXBvbmVudCdzIHVwZGF0ZXMgYXJlIGZsdXNoZWQgdG8gdGhlIERPTS5cblx0XHQgKiBSZWZyZXNoZXMgdGhlIGRlc2NlbmRhbnRzIGxpc3QuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdFx0ICogQG1ldGhvZCBjb21wb25lbnREaWRVcGRhdGVcblx0XHQgKi9cblx0XHRjb21wb25lbnREaWRVcGRhdGUoKSB7XG5cdFx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKHN1cGVyLmNvbXBvbmVudERpZFVwZGF0ZSkpIHtcblx0XHRcdFx0c3VwZXIuY29tcG9uZW50RGlkVXBkYXRlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3JlZnJlc2goKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBGb2N1c2VzIHRoZSBjdXJyZW50IGFjdGl2ZSBkZXNjZW5kYW50LlxuXHRcdCAqXG5cdFx0ICogU2V2ZXJhbCBXaWRnZXRzIGNhbiBiZSBuZXN0ZWQgaW4gYSBjb21wb25lbnQgaGllcmFyY2h5IGJ5IGF0dGFjaGluZyB0aGlzIGZvY3VzIG1ldGhvZCB0b1xuXHRcdCAqIHRoZSB3aWRnZXQgRE9NIG5vZGUsIHRyYW5zZmVycmluZyB0aGUgRE9NIGZvY3VzIGNvbnRyb2wgdG8gdGhlIGlubmVyIEZvY3VzTWFuYWdlci5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0XHQgKiBAbWV0aG9kIGZvY3VzXG5cdFx0ICovXG5cdFx0Zm9jdXMgPSBldmVudCA9PiB7XG5cdFx0XHRpZiAoIWV2ZW50IHx8IHRoaXMuX2lzVmFsaWRUYXJnZXQoZXZlbnQudGFyZ2V0KSkge1xuXHRcdFx0XHRpZiAodGhpcy5fZGVzY2VuZGFudHMgJiYgdGhpcy5fZGVzY2VuZGFudHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y29uc3QgYWN0aXZlRGVzY2VuZGFudEVsID0gdGhpcy5fZGVzY2VuZGFudHNbXG5cdFx0XHRcdFx0XHR0aGlzLl9hY3RpdmVEZXNjZW5kYW50XG5cdFx0XHRcdFx0XTtcblx0XHRcdFx0XHQvLyBXaGVuIHVzZXIgY2xpY2tzIHdpdGggdGhlIG1vdXNlLCB0aGUgYWN0aXZlRWxlbWVudCBpcyBhbHJlYWR5IHNldCBhbmQgdGhlcmVcblx0XHRcdFx0XHQvLyBpcyBubyBuZWVkIHRvIGZvY3VzIGl0LiBGb2N1c2luZyBvZiB0aGUgYWN0aXZlIGRlc2NlbmRhbnQgKHVzdWFsbHkgc29tZSBidXR0b24pIGlzIHJlcXVpcmVkXG5cdFx0XHRcdFx0Ly8gaW4gY2FzZSBvZiBrZXlib2FyZCBuYXZpZ2F0aW9uLCBiZWNhdXNlIHRoZSBmb2N1c2VkIGVsZW1lbnQgbWlnaHQgYmUgbm90IHRoZSBmaXJzdCBidXR0b24sXG5cdFx0XHRcdFx0Ly8gYnV0IHRoZSBkaXYgZWxlbWVudCwgd2hpY2ggY29udGFpbnMgdGhlIGJ1dHRvbi5cblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBhY3RpdmVEZXNjZW5kYW50RWwgJiZcblx0XHRcdFx0XHRcdCF0aGlzLnByb3BzLmZvY3VzRmlyc3RDaGlsZFxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHR0aGlzLl9kZXNjZW5kYW50cy5pbmRleE9mKFxuXHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcblx0XHRcdFx0XHRcdFx0KSA9PT0gLTFcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRhY3RpdmVEZXNjZW5kYW50RWwuZm9jdXMoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZXZlbnQpIHtcblx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlcyB0aGUga2V5IGV2ZW50cyBvbiBhIERPTSBub2RlIHRvIGV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIG5hdmlnYXRpb24gd2hlbiBuZWVkZWQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBLZXlib2FyZCBldmVudCB0aGF0IHdhcyBkZXRlY3RlZCBvbiB0aGUgd2lkZ2V0IERPTSBub2RlLlxuXHRcdCAqIEBtZXRob2QgaGFuZGxlS2V5XG5cdFx0ICovXG5cdFx0aGFuZGxlS2V5ID0gZXZlbnQgPT4ge1xuXHRcdFx0aWYgKHRoaXMuX2lzVmFsaWRUYXJnZXQoZXZlbnQudGFyZ2V0KSAmJiB0aGlzLl9kZXNjZW5kYW50cykge1xuXHRcdFx0XHRjb25zdCBhY3Rpb24gPSB0aGlzLl9nZXRGb2N1c0FjdGlvbihldmVudCk7XG5cblx0XHRcdFx0aWYgKGFjdGlvbi50eXBlKSB7XG5cdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHRcdGlmIChhY3Rpb24udHlwZSA9PT0gQUNUSU9OX01PVkVfRk9DVVMpIHtcblx0XHRcdFx0XHRcdHRoaXMuX21vdmVGb2N1cyhhY3Rpb24uZGlyZWN0aW9uKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoYWN0aW9uLnR5cGUgPT09IEFDVElPTl9ESVNNSVNTX0ZPQ1VTKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnByb3BzLm9uRGlzbWlzcyhhY3Rpb24uZGlyZWN0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogTW92ZXMgdGhlIGZvY3VzIGFtb25nIGRlc2NlbmRhbnRzIGluIHRoZSBlc3BlY2lmaWVkIGRpcmVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0XHQgKiBAbWV0aG9kIG1vdmVGb2N1c1xuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiAoMSBvciAtMSkgb2YgdGhlIGZvY3VzIG1vdmVtZW50IGFtb25nIGRlc2NlbmRhbnRzLlxuXHRcdCAqL1xuXHRcdG1vdmVGb2N1cyhkaXJlY3Rpb24pIHtcblx0XHRcdGRpcmVjdGlvbiA9IExhbmcuaXNOdW1iZXIoZGlyZWN0aW9uKSA/IGRpcmVjdGlvbiA6IDA7XG5cblx0XHRcdHRoaXMuX21vdmVGb2N1cyhkaXJlY3Rpb24pO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIGFjdGlvbiwgaWYgYW55LCB0aGF0IGEga2V5Ym9hcmQgZXZlbnQgaW4gdGhlIGN1cnJlbnQgZm9jdXMgbWFuYWdlciBzdGF0ZVxuXHRcdCAqIHNob3VsZCBwcm9kdWNlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBtZXRob2QgX2dldEZvY3VzQWN0aW9uXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBLZXlib2FyZCBldmVudC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBhY3Rpb24gb2JqZWN0IHdpdGggdHlwZSBhbmQgZGlyZWN0aW9uIHByb3BlcnRpZXMuXG5cdFx0ICovXG5cdFx0X2dldEZvY3VzQWN0aW9uKGV2ZW50KSB7XG5cdFx0XHRjb25zdCBhY3Rpb24gPSB7XG5cdFx0XHRcdHR5cGU6IEFDVElPTl9OT05FLFxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKHRoaXMucHJvcHMua2V5cykge1xuXHRcdFx0XHRjb25zdCBkaXJlY3Rpb24gPSB0aGlzLl9nZXRGb2N1c01vdmVEaXJlY3Rpb24oZXZlbnQpO1xuXG5cdFx0XHRcdGlmIChkaXJlY3Rpb24pIHtcblx0XHRcdFx0XHRhY3Rpb24uZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuXHRcdFx0XHRcdGFjdGlvbi50eXBlID0gQUNUSU9OX01PVkVfRk9DVVM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBkaXNtaXNzQWN0aW9uID0gdGhpcy5fZ2V0Rm9jdXNEaXNtaXNzQWN0aW9uKFxuXHRcdFx0XHRcdGV2ZW50LFxuXHRcdFx0XHRcdGRpcmVjdGlvblxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmIChkaXNtaXNzQWN0aW9uLmRpc21pc3MpIHtcblx0XHRcdFx0XHRhY3Rpb24uZGlyZWN0aW9uID0gZGlzbWlzc0FjdGlvbi5kaXJlY3Rpb247XG5cdFx0XHRcdFx0YWN0aW9uLnR5cGUgPSBBQ1RJT05fRElTTUlTU19GT0NVUztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYWN0aW9uO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIGRpc21pc3MgYWN0aW9uLCBpZiBhbnksIHRoZSBmb2N1cyBtYW5hZ2VyIHNob3VsZCBleGVjdXRlIHRvIHlpZWxkIHRoZSBmb2N1cy4gVGhpc1xuXHRcdCAqIHdpbGwgaGFwcGVuIGluIGFueSBvZiB0aGVzZSBzY2VuYXJpb3MgaWYgYSBkaXNtaXNzIGNhbGxiYWNrIGhhcyBiZWVuIHNwZWNpZmllZDpcblx0XHQgKiAtIEEgZGlzbWlzcyBrZXkgaGFzIGJlZW4gcHJlc3NlZFxuXHRcdCAqIC0gSW4gYSBub24tY2lyY3VsYXIgZm9jdXMgbWFuYWdlciwgd2hlbjpcblx0XHQgKiAgICAgLSBUaGUgYWN0aXZlIGRlc2NlbmRhbnQgaXMgdGhlIGZpcnN0IG9uZSBhbmQgYSBwcmV2IGtleSBoYXMgYmVlbiBwcmVzc2VkLlxuXHRcdCAqICAgICAtIFRoZSBhY3RpdmUgZGVzY2VuZGFudCBpcyB0aGUgbGFzdCBvbmUgYW5kIGEgbmV4dCBrZXkgaGFzIGJlZW4gcHJlc3NlZC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0XHQgKiBAbWV0aG9kIF9nZXRGb2N1c0Rpc21pc3NBY3Rpb25cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gZm9jdXNNb3ZlRGlyZWN0aW9uIFRoZSBmb2N1cyBtb3ZlbWVudCBkaXJlY3Rpb24gKGlmIGFueSkuXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBLZXlib2FyZCBldmVudC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBBIGRpc21pc3MgYWN0aW9uIHdpdGggZGlzbWlzcyBhbmQgZGlyZWN0aW9uIHByb3BlcnRpZXMuXG5cdFx0ICovXG5cdFx0X2dldEZvY3VzRGlzbWlzc0FjdGlvbihldmVudCwgZm9jdXNNb3ZlRGlyZWN0aW9uKSB7XG5cdFx0XHRjb25zdCBkaXNtaXNzQWN0aW9uID0ge1xuXHRcdFx0XHRkaXJlY3Rpb246IGZvY3VzTW92ZURpcmVjdGlvbixcblx0XHRcdFx0ZGlzbWlzczogZmFsc2UsXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAodGhpcy5wcm9wcy5vbkRpc21pc3MpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2lzVmFsaWRLZXkoZXZlbnQua2V5Q29kZSwgdGhpcy5wcm9wcy5rZXlzLmRpc21pc3MpKSB7XG5cdFx0XHRcdFx0ZGlzbWlzc0FjdGlvbi5kaXNtaXNzID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dGhpcy5faXNWYWxpZEtleShldmVudC5rZXlDb2RlLCB0aGlzLnByb3BzLmtleXMuZGlzbWlzc05leHQpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGRpc21pc3NBY3Rpb24uZGlzbWlzcyA9IHRydWU7XG5cdFx0XHRcdFx0ZGlzbWlzc0FjdGlvbi5kaXJlY3Rpb24gPSBESVJFQ1RJT05fTkVYVDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dGhpcy5faXNWYWxpZEtleShldmVudC5rZXlDb2RlLCB0aGlzLnByb3BzLmtleXMuZGlzbWlzc1ByZXYpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGRpc21pc3NBY3Rpb24uZGlzbWlzcyA9IHRydWU7XG5cdFx0XHRcdFx0ZGlzbWlzc0FjdGlvbi5kaXJlY3Rpb24gPSBESVJFQ1RJT05fUFJFVjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQhZGlzbWlzc0FjdGlvbi5kaXNtaXNzICYmXG5cdFx0XHRcdFx0IXRoaXMucHJvcHMuY2lyY3VsYXIgJiZcblx0XHRcdFx0XHRmb2N1c01vdmVEaXJlY3Rpb25cblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZGlzbWlzc0FjdGlvbi5kaXNtaXNzID1cblx0XHRcdFx0XHRcdChmb2N1c01vdmVEaXJlY3Rpb24gPT09IERJUkVDVElPTl9QUkVWICYmXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgPT09IDApIHx8XG5cdFx0XHRcdFx0XHQoZm9jdXNNb3ZlRGlyZWN0aW9uID09PSBESVJFQ1RJT05fTkVYVCAmJlxuXHRcdFx0XHRcdFx0XHR0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID09PVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2Rlc2NlbmRhbnRzLmxlbmd0aCAtIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkaXNtaXNzQWN0aW9uO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIGRpcmVjdGlvbiwgaWYgYW55LCBpbiB3aGljaCB0aGUgZm9jdXMgc2hvdWxkIGJlIG1vdmVkLiBJbiBwcmVzZW5jZSBvZiB0aGVcblx0XHQgKiBzaGlmdCBrZXkgbW9kaWZpZXIsIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG1vdmVtZW50IGlzIGludmVydGVkLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBtZXRob2QgX2dldEZvY3VzTW92ZURpcmVjdGlvblxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgS2V5Ym9hcmQgZXZlbnQuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNvbXB1dGVkIGRpcmVjdGlvbiBvZiB0aGUgZXhwZWN0ZWQgZm9jdXMgbW92ZW1lbnQuXG5cdFx0ICovXG5cdFx0X2dldEZvY3VzTW92ZURpcmVjdGlvbihldmVudCkge1xuXHRcdFx0bGV0IGRpcmVjdGlvbiA9IERJUkVDVElPTl9OT05FO1xuXG5cdFx0XHRpZiAodGhpcy5faXNWYWxpZEtleShldmVudC5rZXlDb2RlLCB0aGlzLnByb3BzLmtleXMubmV4dCkpIHtcblx0XHRcdFx0ZGlyZWN0aW9uID0gRElSRUNUSU9OX05FWFQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5faXNWYWxpZEtleShldmVudC5rZXlDb2RlLCB0aGlzLnByb3BzLmtleXMucHJldikpIHtcblx0XHRcdFx0ZGlyZWN0aW9uID0gRElSRUNUSU9OX1BSRVY7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChldmVudC5zaGlmS2V5KSB7XG5cdFx0XHRcdGRpcmVjdGlvbiAqPSAtMTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRpcmVjdGlvbjtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYgYSBnaXZlbiBrZXlDb2RlIGlzIHZhbGlkIGZvciB0aGUgZ2l2ZW4gc2V0IG9mIGtleXMuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdFx0ICogQG1ldGhvZCBfaXNWYWxpZEtleVxuXHRcdCAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfSBrZXlzIEEga2V5IHNldC4gQ2FuIGJlIGEgbnVtYmVyIGFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBhbGxvd2VkIGtleUNvZGVzLlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBrZXlDb2RlIEFuIGV2ZW50IGtleUNvZGUuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoZSBrZXkgaXMgdmFsaWQuXG5cdFx0ICovXG5cdFx0X2lzVmFsaWRLZXkoa2V5Q29kZSwga2V5cykge1xuXHRcdFx0cmV0dXJuIExhbmcuaXNBcnJheShrZXlzKVxuXHRcdFx0XHQ/IGtleXMuaW5kZXhPZihrZXlDb2RlKSAhPT0gLTFcblx0XHRcdFx0OiBrZXlDb2RlID09PSBrZXlzO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiBhIGdpdmVuIGVsZW1lbnQgaXMgdmFsaWQgZm9yIGZvY3VzIG1hbmFnZW1lbnQuIFVzZXIgaW5wdXQgZWxlbWVudHMgc3VjaCBhc1xuXHRcdCAqIGlucHV0LCBzZWxlY3Qgb3IgdGV4dGFyZWEgYXJlIGV4Y2x1ZGVkLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBtZXRob2QgX2lzVmFsaWRLZXlcblx0XHQgKiBAcGFyYW0ge0RPTU5vZGV9IGVsZW1lbnQgQSBET00gZWxlbWVudC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgaWYgdGhlIGVsZW1lbnQgaXMgdmFsaWQuXG5cdFx0ICovXG5cdFx0X2lzVmFsaWRUYXJnZXQoZWxlbWVudCkge1xuXHRcdFx0Y29uc3QgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHR0YWdOYW1lICE9PSAnaW5wdXQnICYmXG5cdFx0XHRcdHRhZ05hbWUgIT09ICdzZWxlY3QnICYmXG5cdFx0XHRcdHRhZ05hbWUgIT09ICd0ZXh0YXJlYSdcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogTW92ZXMgdGhlIGZvY3VzIGFtb25nIGRlc2NlbmRhbnRzIGluIHRoZSBlc3BlY2lmaWVkIGRpcmVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0XHQgKiBAbWV0aG9kIF9tb3ZlRm9jdXNcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gKDEgb3IgLTEpIG9mIHRoZSBmb2N1cyBtb3ZlbWVudCBhbW9uZyBkZXNjZW5kYW50cy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X21vdmVGb2N1cyhkaXJlY3Rpb24pIHtcblx0XHRcdGNvbnN0IG51bURlc2NlbmRhbnRzID0gdGhpcy5fZGVzY2VuZGFudHMubGVuZ3RoO1xuXG5cdFx0XHRsZXQgZGVzY2VuZGFudCA9IHRoaXMuX2Rlc2NlbmRhbnRzW3RoaXMuX2FjdGl2ZURlc2NlbmRhbnRdO1xuXG5cdFx0XHRkZXNjZW5kYW50LnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAtMSk7XG5cblx0XHRcdHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgKz0gZGlyZWN0aW9uO1xuXG5cdFx0XHRpZiAodGhpcy5wcm9wcy5jaXJjdWxhcikge1xuXHRcdFx0XHQvLyBDYWxjdWxhdGUgcHJvcGVyIG1vZHVsbyByZXN1bHQgc2luY2UgcmVtYWluZGVyIG9wZXJhdG9yIGRvZXNuJ3QgYmVoYXZlIGluIHRoZVxuXHRcdFx0XHQvLyBzYW1lIHdheSBmb3IgbmVnYXRpdmUgbnVtYmVyc1xuXHRcdFx0XHR0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID1cblx0XHRcdFx0XHQoKHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgJSBudW1EZXNjZW5kYW50cykgK1xuXHRcdFx0XHRcdFx0bnVtRGVzY2VuZGFudHMpICVcblx0XHRcdFx0XHRudW1EZXNjZW5kYW50cztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgPSBNYXRoLm1heChcblx0XHRcdFx0XHRNYXRoLm1pbih0aGlzLl9hY3RpdmVEZXNjZW5kYW50LCBudW1EZXNjZW5kYW50cyAtIDEpLFxuXHRcdFx0XHRcdDBcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0ZGVzY2VuZGFudCA9IHRoaXMuX2Rlc2NlbmRhbnRzW3RoaXMuX2FjdGl2ZURlc2NlbmRhbnRdO1xuXG5cdFx0XHRkZXNjZW5kYW50LnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAwKTtcblx0XHRcdGRlc2NlbmRhbnQuZm9jdXMoKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZWZyZXNoZXMgdGhlIGRlc2NlbmRhbnRzIGxpc3QgYnkgZXhlY3V0aW5nIHRoZSBDU1Mgc2VsZWN0b3IgYWdhaW4gYW5kIHJlc2V0cyB0aGUgZGVzY2VuZGFudHMgdGFiSW5kZXguXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdFx0ICogQG1ldGhvZCBfcmVmcmVzaFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRfcmVmcmVzaCgpIHtcblx0XHRcdGNvbnN0IGRvbU5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcblxuXHRcdFx0aWYgKGRvbU5vZGUpIHtcblx0XHRcdFx0Y29uc3QgZGVzY2VuZGFudHMgPSBkb21Ob2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXG5cdFx0XHRcdFx0dGhpcy5wcm9wcy5kZXNjZW5kYW50c1xuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGxldCBwcmlvcml0eURlc2NlbmRhbnRzID0gW107XG5cblx0XHRcdFx0dGhpcy5fZGVzY2VuZGFudHMgPSBbXTtcblxuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkZXNjZW5kYW50cykuZm9yRWFjaChpdGVtID0+IHtcblx0XHRcdFx0XHRjb25zdCBkYXRhVGFiSW5kZXggPSBpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS10YWJpbmRleCcpO1xuXG5cdFx0XHRcdFx0aWYgKGRhdGFUYWJJbmRleCkge1xuXHRcdFx0XHRcdFx0cHJpb3JpdHlEZXNjZW5kYW50cy5wdXNoKGl0ZW0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZXNjZW5kYW50cy5wdXNoKGl0ZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cHJpb3JpdHlEZXNjZW5kYW50cyA9IHByaW9yaXR5RGVzY2VuZGFudHMuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRMYW5nLnRvSW50KGEuZ2V0QXR0cmlidXRlKCdkYXRhLXRhYmluZGV4JykpID5cblx0XHRcdFx0XHRcdExhbmcudG9JbnQoYi5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFiaW5kZXgnKSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0aGlzLl9kZXNjZW5kYW50cyA9IHByaW9yaXR5RGVzY2VuZGFudHMuY29uY2F0KFxuXHRcdFx0XHRcdHRoaXMuX2Rlc2NlbmRhbnRzXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0dGhpcy5fYWN0aXZlRGVzY2VuZGFudCA9IDA7XG5cblx0XHRcdFx0dGhpcy5fZGVzY2VuZGFudHMuc29tZSgoaXRlbSwgaW5kZXgpID0+IHtcblx0XHRcdFx0XHRpZiAoaXRlbS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgPT09ICcwJykge1xuXHRcdFx0XHRcdFx0dGhpcy5fYWN0aXZlRGVzY2VuZGFudCA9IGluZGV4O1xuXHRcdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uQWNjZXNzaWJpbGl0eUltYWdlQWx0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNoYW5naW5nIHRleHQgY29sb3IgaW4gYSBkb2N1bWVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQWNjZXNzaWJpbGl0eUltYWdlQWx0XG4gKlxuICovXG5jbGFzcyBCdXR0b25BY2Nlc3NpYmlsaXR5SW1hZ2VBbHQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdHN0YXRpYyBrZXkgPSAnaW1hZ2VBbHQnO1xuXG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXG5cdFx0Y29uc3Qgc2VsZWN0aW9uID0gcHJvcHMuY29udGV4dC5lZGl0b3Jcblx0XHRcdC5nZXQoJ25hdGl2ZUVkaXRvcicpXG5cdFx0XHQuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRjb25zdCBlbGVtZW50ID1cblx0XHRcdHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKSB8fCBzZWxlY3Rpb24uZ2V0U3RhcnRFbGVtZW50KCk7XG5cblx0XHR0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcblxuXHRcdGNvbnN0IGltYWdlRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQuZmluZE9uZSgnaW1nJyk7XG5cblx0XHRjb25zdCBpbWFnZUFsdCA9IGltYWdlRWxlbWVudFxuXHRcdFx0PyBpbWFnZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhbHQnKVxuXHRcdFx0OiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnYWx0Jyk7XG5cblx0XHR0aGlzLnN0YXRlID0ge1xuXHRcdFx0aW1hZ2VBbHQsXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZWRpdC1saW5rXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItaW5wdXQgeHhsXCI+XG5cdFx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdFx0YXJpYS1sYWJlbD1cImFsdFwiXG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWlucHV0XCJcblx0XHRcdFx0XHRcdFx0b25DaGFuZ2U9e3RoaXMuX2hhbmRsZUFsdENoYW5nZX1cblx0XHRcdFx0XHRcdFx0b25LZXlEb3duPXt0aGlzLl9oYW5kbGVLZXlEb3dufVxuXHRcdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj1cImFsdFwiXG5cdFx0XHRcdFx0XHRcdHJlZj1cInJlZkFsdElucHV0XCJcblx0XHRcdFx0XHRcdFx0dGl0bGU9XCJhbHRcIlxuXHRcdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0XHRcdHZhbHVlPXt0aGlzLnN0YXRlLmltYWdlQWx0fVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbmZpcm19XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdFx0b25DbGljaz17dGhpcy5fdXBkYXRlSW1hZ2VBbHR9XG5cdFx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5jb25maXJtfT5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNoZWNrXCIgLz5cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLl9yZXF1ZXN0RXhjbHVzaXZlfVxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fT5cblx0XHRcdFx0XHQ8c21hbGwgY2xhc3NOYW1lPVwiYWUtaWNvbiBzbWFsbFwiPkFsdDwvc21hbGw+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRm9jdXNlcyB0aGUgdXNlciBjdXJzb3Igb24gdGhlIHdpZGdldCdzIGlucHV0LlxuXHQgKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX2ZvY3VzQWx0SW5wdXRcblx0ICovXG5cdF9mb2N1c0FsdElucHV0KCkge1xuXHRcdGNvbnN0IGluc3RhbmNlID0gdGhpcztcblxuXHRcdGNvbnN0IGZvY3VzQWx0RWwgPSBmdW5jdGlvbigpIHtcblx0XHRcdFJlYWN0RE9NLmZpbmRET01Ob2RlKGluc3RhbmNlLnJlZnMucmVmQWx0SW5wdXQpLmZvY3VzKCk7XG5cdFx0fTtcblxuXHRcdGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZvY3VzQWx0RWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZXRUaW1lb3V0KGZvY3VzQWx0RWwsIDApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFdmVudCBhdHRhY2hlZCB0byBhbHQgaW5wdXQgdGhhdCBmaXJlcyB3aGVuIGl0cyB2YWx1ZSBpcyBjaGFuZ2VkXG5cdCAqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCAgX2hhbmRsZUFsdENoYW5nZVxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG5cdCAqL1xuXHRfaGFuZGxlQWx0Q2hhbmdlID0gZXZlbnQgPT4ge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0aW1hZ2VBbHQ6IGV2ZW50LnRhcmdldC52YWx1ZSxcblx0XHR9KTtcblxuXHRcdHRoaXMuX2ZvY3VzQWx0SW5wdXQoKTtcblx0fTtcblxuXHQvKipcblx0ICogRXZlbnQgYXR0YWNoZWQgdG8gYWwgdGlucHV0IHRoYXQgZmlyZXMgd2hlbiBrZXkgaXMgZG93blxuXHQgKiBUaGlzIG1ldGhvZCBjaGVjayB0aGF0IGVudGVyIGtleSBpcyBwdXNoZWQgdG8gdXBkYXRlIHRoZSBjb21wb25lbnTCtHMgc3RhdGVcblx0ICpcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kICBfaGFuZGxlS2V5RG93blxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG5cdCAqL1xuXHRfaGFuZGxlS2V5RG93biA9IGV2ZW50ID0+IHtcblx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUltYWdlQWx0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0cyB0aGUgbGluayBidXR0b24gdG8gYmUgcmVuZGVyZWQgaW4gZXhjbHVzaXZlIG1vZGUgdG8gYWxsb3cgdGhlIGNyZWF0aW9uIG9mIGEgbGluay5cblx0ICpcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kIF9yZXF1ZXN0RXhjbHVzaXZlXG5cdCAqL1xuXHRfcmVxdWVzdEV4Y2x1c2l2ZSA9ICgpID0+IHtcblx0XHR0aGlzLnByb3BzLnJlcXVlc3RFeGNsdXNpdmUoQnV0dG9uQWNjZXNzaWJpbGl0eUltYWdlQWx0LmtleSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1ldGhvZCBjYWxsZWQgYnkgY2xpY2tpbmcgb2sgYnV0dG9uIG9yIHB1c2hpbmcga2V5IGVudGVyIHRvIHVwZGF0ZSBpbWFnZUFsdCBzdGF0ZSBhbmQgdG8gdXBkYXRlIGFsdCBwcm9wZXJ0eSBmcm9tIHRoZSBpbWFnZSB0aGF0IGlzIHNlbGVjdGVkXG5cdCAqIFRoaXMgbWV0aG9kIGNhbGxzIGNhbmNlbEV4Y2x1c2l2ZSB0byBzaG93IHRoZSBwcmV2aW91cyB0b29sYmFyIGJlZm9yZSBlbnRlciB0byBlZGl0IGFsdCBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgIF91cGRhdGVJbWFnZUFsdFxuXHQgKi9cblx0X3VwZGF0ZUltYWdlQWx0ID0gKCkgPT4ge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGNvbnN0IGltYWdlQWx0ID0gdGhpcy5yZWZzLnJlZkFsdElucHV0LnZhbHVlO1xuXG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRpbWFnZUFsdCxcblx0XHR9KTtcblxuXHRcdGNvbnN0IGltYWdlRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQuZmluZE9uZSgnaW1nJyk7XG5cdFx0Y29uc3QgaW1hZ2UgPSBpbWFnZUVsZW1lbnQgPyBpbWFnZUVsZW1lbnQgOiB0aGlzLl9lbGVtZW50O1xuXG5cdFx0aW1hZ2Uuc2V0QXR0cmlidXRlKCdhbHQnLCBpbWFnZUFsdCk7XG5cblx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cblx0XHQvLyBXZSBuZWVkIHRvIGNhbmNlbEV4Y2x1c2l2ZSB3aXRoIHRoZSBib3VuZCBwYXJhbWV0ZXJzIGluIGNhc2UgdGhlIGJ1dHRvbiBpcyB1c2VkXG5cdFx0Ly8gaW5zaWRlIGFub3RoZXIgaW4gZXhjbHVzaXZlIG1vZGUgKHN1Y2ggaXMgdGhlIGNhc2Ugb2YgdGhlIGFsdCBidXR0b24pXG5cdFx0dGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRWRpdG9yQ29udGV4dC50b1Byb3BzKEJ1dHRvbkFjY2Vzc2liaWxpdHlJbWFnZUFsdCk7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0IGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LmpzeCc7XG5cbmNsYXNzIEJ1dHRvbkJhY2tncm91bmRDb2xvciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0c3RhdGljIGtleSA9ICdiYWNrZ3JvdW5kQ29sb3InO1xuXG5cdHN0YXRpYyBwcm9wVHlwZXMgPSB7XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN0eWxlcyBsaXN0IGlzIGV4cGFuZGVkIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25CYWNrZ3JvdW5kQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IGV4cGFuZGVkXG5cdFx0ICovXG5cdFx0ZXhwYW5kZWQ6IFByb3BUeXBlcy5ib29sLFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxhYmVsIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGFjY2Vzc2liaWxpdHkgcHVycG9zZXMuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQmFja2dyb3VuZENvbG9yXG5cdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGxhYmVsXG5cdFx0ICovXG5cdFx0bGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVtb3ZlIHN0eWxlcyBpdGVtIHNob3VsZCBhcHBlYXIgaW4gdGhlIHN0eWxlcyBsaXN0LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkJhY2tncm91bmRDb2xvclxuXHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2hvd1JlbW92ZVN0eWxlc0l0ZW1cblx0XHQgKi9cblx0XHRzaG93UmVtb3ZlU3R5bGVzSXRlbTogUHJvcFR5cGVzLmJvb2wsXG5cblx0XHQvKipcblx0XHQgKiBMaXN0IG9mIHRoZSBzdHlsZXMgdGhlIGJ1dHRvbiBpcyBhYmxlIHRvIGhhbmRsZS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25CYWNrZ3JvdW5kQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge0FycmF5fSBzdHlsZXNcblx0XHQgKi9cblx0XHRzdHlsZXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vYmplY3QpLFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRhYkluZGV4IG9mIHRoZSBidXR0b24gaW4gaXRzIHRvb2xiYXIgY3VycmVudCBzdGF0ZS4gQSB2YWx1ZSBvdGhlciB0aGFuIC0xXG5cdFx0ICogbWVhbnMgdGhhdCB0aGUgYnV0dG9uIGhhcyBmb2N1cyBhbmQgaXMgdGhlIGFjdGl2ZSBlbGVtZW50LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkJhY2tncm91bmRDb2xvclxuXHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0YWJJbmRleFxuXHRcdCAqL1xuXHRcdHRhYkluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuXG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgcHJvdmlkZWQgYnkgdGhlIGJ1dHRvbiBob3N0IHRvIG5vdGlmeSB3aGVuIHRoZSBzdHlsZXMgbGlzdCBoYXMgYmVlbiBleHBhbmRlZC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25CYWNrZ3JvdW5kQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB0b2dnbGVEcm9wZG93blxuXHRcdCAqL1xuXHRcdHRvZ2dsZURyb3Bkb3duOiBQcm9wVHlwZXMuZnVuYyxcblx0fTtcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRsZXQgYWN0aXZlQ29sb3IgPSBBbGxveUVkaXRvci5TdHJpbmdzLm5vcm1hbDtcblxuXHRcdGxldCBhY3RpdmVDb2xvckNsYXNzID0gJyc7XG5cblx0XHRjb25zdCBjb2xvcnMgPSB0aGlzLl9nZXRDb2xvcnMoKTtcblxuXHRcdGNvbnN0IGl0ZW1TdHlsZSA9IHtcblx0XHRcdGVsZW1lbnQ6ICdzcGFuJyxcblx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0Y2xhc3M6ICcnLFxuXHRcdFx0fSxcblx0XHR9O1xuXG5cdFx0Y29sb3JzLmZvckVhY2goaXRlbSA9PiB7XG5cdFx0XHRpdGVtU3R5bGUuYXR0cmlidXRlcy5jbGFzcyA9IGl0ZW0uc3R5bGVDbGFzcztcblxuXHRcdFx0aWYgKHRoaXMuX2NoZWNrQWN0aXZlKGl0ZW1TdHlsZSkpIHtcblx0XHRcdFx0YWN0aXZlQ29sb3IgPSBpdGVtLm5hbWU7XG5cblx0XHRcdFx0YWN0aXZlQ29sb3JDbGFzcyA9IGl0ZW0uc3R5bGUuYXR0cmlidXRlcy5jbGFzcztcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGNvbnN0IHtleHBhbmRlZCwgdGFiSW5kZXgsIHRvZ2dsZURyb3Bkb3dufSA9IHRoaXMucHJvcHM7XG5cblx0XHRjb25zdCBidXR0b25TdHlsZXNQcm9wcyA9IHtcblx0XHRcdGFjdGl2ZVN0eWxlOiBhY3RpdmVDb2xvcixcblx0XHRcdG9uRGlzbWlzczogdG9nZ2xlRHJvcGRvd24sXG5cdFx0XHRzaG93UmVtb3ZlU3R5bGVzSXRlbTogZmFsc2UsXG5cdFx0XHRzdHlsZXM6IGNvbG9ycyxcblx0XHR9O1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyIGFlLWhhcy1kcm9wZG93blwiPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1leHBhbmRlZD17ZXhwYW5kZWR9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtdG9vbGJhci1lbGVtZW50XCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0XHRyb2xlPVwiY29tYm9ib3hcIlxuXHRcdFx0XHRcdHRhYkluZGV4PXt0YWJJbmRleH0+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPXthY3RpdmVDb2xvckNsYXNzfT5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInRleHRib3hcIiAvPlxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdHtleHBhbmRlZCAmJiA8QnV0dG9uU3R5bGVzTGlzdCB7Li4uYnV0dG9uU3R5bGVzUHJvcHN9IC8+fVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdF9hcHBseVN0eWxlKGNsYXNzTmFtZSkge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGNvbnN0IHN0eWxlQ29uZmlnID0ge1xuXHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRjbGFzczogY2xhc3NOYW1lLFxuXHRcdFx0fSxcblx0XHR9O1xuXG5cdFx0ZWRpdG9yLmdldFNlbGVjdGlvbigpLmxvY2soKTtcblxuXHRcdHRoaXMuX2dldENvbG9ycygpLmZvckVhY2goaXRlbSA9PiB7XG5cdFx0XHRzdHlsZUNvbmZpZy5hdHRyaWJ1dGVzLmNsYXNzID0gaXRlbS5zdHlsZUNsYXNzO1xuXG5cdFx0XHRpZiAodGhpcy5fY2hlY2tBY3RpdmUoc3R5bGVDb25maWcpKSB7XG5cdFx0XHRcdGVkaXRvci5yZW1vdmVTdHlsZShuZXcgQ0tFRElUT1Iuc3R5bGUoc3R5bGVDb25maWcpKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHN0eWxlQ29uZmlnLmF0dHJpYnV0ZXMuY2xhc3MgPSBjbGFzc05hbWU7XG5cblx0XHRjb25zdCBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZShzdHlsZUNvbmZpZyk7XG5cblx0XHRlZGl0b3IuYXBwbHlTdHlsZShzdHlsZSk7XG5cblx0XHRlZGl0b3IuZ2V0U2VsZWN0aW9uKCkudW5sb2NrKCk7XG5cblx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBjb2xvciBkZWZpbml0aW9uIGlzIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQmFja2dyb3VuZENvbG9yXG5cdCAqIEBtZXRob2QgX2NoZWNrQWN0aXZlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZUNvbmZpZyBjb2xvciBkZWZpbml0aW9uIGFzIHBlciBodHRwOi8vZG9jcy5ja2VkaXRvci5jb20vIyEvYXBpL0NLRURJVE9SLnN0eWxlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29sb3IgaXMgYXBwbGllZCB0byB0aGUgc2VsZWN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuXHRfY2hlY2tBY3RpdmUoc3R5bGVDb25maWcpIHtcblx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHQvLyBTdHlsZXMgd2l0aCB3aWxkY2FyZCBlbGVtZW50ICgqKSB3b24ndCBiZSBjb25zaWRlcmVkIGFjdGl2ZSBieSBDS0VkaXRvci4gRGVmYXVsdGluZ1xuXHRcdC8vIHRvIGEgJ3NwYW4nIGVsZW1lbnQgd29ya3MgZm9yIG1vc3Qgb2YgdGhvc2UgY2FzZXMgd2l0aCBubyBkZWZpbmVkIGVsZW1lbnQuXG5cdFx0c3R5bGVDb25maWcgPSBDS0VESVRPUi50b29scy5tZXJnZSh7ZWxlbWVudDogJ3NwYW4nfSwgc3R5bGVDb25maWcpO1xuXG5cdFx0Y29uc3Qgc3R5bGUgPSBuZXcgQ0tFRElUT1Iuc3R5bGUoc3R5bGVDb25maWcpO1xuXG5cdFx0cmV0dXJuIHN0eWxlLmNoZWNrQWN0aXZlKG5hdGl2ZUVkaXRvci5lbGVtZW50UGF0aCgpLCBuYXRpdmVFZGl0b3IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgY29sb3JzLiBFYWNoIGNvbG9yIGNvbnNpc3RzIG9mIHR3byBwcm9wZXJ0aWVzOlxuXHQgKiAtIG5hbWUgLSB0aGUgc3R5bGUgbmFtZSwgZm9yIGV4YW1wbGUgXCJkZWZhdWx0XCJcblx0ICogLSBzdHlsZSAtIGFuIG9iamVjdCB3aXRoIG9uZSBwcm9wZXJ0eSwgY2FsbGVkIGBlbGVtZW50YCB3aGljaCB2YWx1ZVxuXHQgKiByZXByZXNlbnRzIHRoZSBzdHlsZSB3aGljaCBoYXZlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQmFja2dyb3VuZENvbG9yXG5cdCAqIEBtZXRob2QgX2dldENvbG9yXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7QXJyYXk8b2JqZWN0Pn0gQW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBjb2xvcnMuXG5cdCAqL1xuXHRfZ2V0Q29sb3JzKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLnN0eWxlcyB8fCBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLm5vcm1hbCxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtYm9keScsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVDbGFzczogJycsXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICcnKSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MucHJpbWFyeSxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtcHJpbWFyeScsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVDbGFzczogJ2JnLXByaW1hcnknLFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnYmctcHJpbWFyeScpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5kaXNhYmxlZCxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtc2Vjb25kYXJ5Jyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUNsYXNzOiAnYmctc2Vjb25kYXJ5Jyxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ2JnLXNlY29uZGFyeScpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5zdWNjZXNzLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC1zdWNjZXNzJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUNsYXNzOiAnYmctc3VjY2VzcycsXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICdiZy1zdWNjZXNzJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmRhbmdlcixcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtZGFuZ2VyJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUNsYXNzOiAnYmctZGFuZ2VyJyxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ2JnLWRhbmdlcicpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy53YXJuaW5nLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC13YXJuaW5nJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUNsYXNzOiAnYmctd2FybmluZycsXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICdiZy13YXJuaW5nJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmluZm8sXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdzcGFuJyxcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0XHRcdFx0Y2xhc3M6ICd0ZXh0LWluZm8nLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlQ2xhc3M6ICdiZy1pbmZvJyxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ2JnLWluZm8nKSxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkJhY2tncm91bmRDb2xvcjtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uS2V5c3Ryb2tlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWtleXN0cm9rZSc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uQm9sZCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBzdHlsaW5nIGFuIHNlbGVjdGlvbiB3aXRoIHN0cm9uZyAoYm9sZCkgc3R5bGUuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkJvbGRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbktleXN0cm9rZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25Cb2xkIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkJvbGRcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnYm9sZCcsXG5cdFx0a2V5c3Ryb2tlOiB7XG5cdFx0XHRmbjogJ2V4ZWNDb21tYW5kJyxcblx0XHRcdGtleXM6IENLRURJVE9SLkNUUkwgKyA2NiAvKiBCKi8sXG5cdFx0XHRuYW1lOiAnYm9sZCcsXG5cdFx0fSxcblx0XHRzdHlsZTogJ2NvcmVTdHlsZXNfYm9sZCcsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBib2xkXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Cb2xkXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdib2xkJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkJvbGRcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuYm9sZH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tYm9sZFwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5ib2xkfT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiYm9sZFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbktleXN0cm9rZShCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uU3R5bGUoQnV0dG9uQm9sZCkpKVxuKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkNhbWVyYUltYWdlIGNsYXNzIHRha2VzIHBob3RvIGZyb20gY2FtZXJhIGFuZCBpbnNlcnRzIGl0IHRvIHRoZSBjb250ZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25DYW1lcmFJbWFnZVxuICovXG5jbGFzcyBCdXR0b25DYW1lcmFJbWFnZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdHZpZGVvV2lkdGg6IDMyMCxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IGNhbWVyYUltYWdlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnY2FtZXJhSW1hZ2UnO1xuXG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXHRcdHRoaXMuX2J1dHRvblRha2VQaG90b1JlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXHRcdHRoaXMuX2NhbnZhc0NvbnRhaW5lclJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXHRcdHRoaXMuX3ZpZGVvQ29udGFpbmVyUmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogRm9jdXNlcyB0aGUgdGFrZSBwaG90byBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ2FtZXJhSW1hZ2Vcblx0ICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuXHQgKi9cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0dGhpcy5fYnV0dG9uVGFrZVBob3RvUmVmLmN1cnJlbnQuZm9jdXMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgaW1tZWRpYXRlbHkgYmVmb3JlIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBmcm9tIHRoZSBET00uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ2FtZXJhSW1hZ2Vcblx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsVW5tb3VudFxuXHQgKi9cblx0Y29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0aWYgKHRoaXMuX3N0cmVhbSkge1xuXHRcdFx0aWYgKHRoaXMuX3N0cmVhbS5zdG9wKSB7XG5cdFx0XHRcdHRoaXMuX3N0cmVhbS5zdG9wKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3N0cmVhbS5nZXRWaWRlb1RyYWNrcykge1xuXHRcdFx0XHR0aGlzLl9zdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcblx0XHRcdFx0XHR0cmFjay5zdG9wKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc3RyZWFtID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGdldFVzZXJNZWRpYSA9XG5cdFx0XHRuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIHx8XG5cdFx0XHRuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8XG5cdFx0XHRuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8XG5cdFx0XHRuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWE7XG5cblx0XHRnZXRVc2VyTWVkaWEuY2FsbChcblx0XHRcdG5hdmlnYXRvcixcblx0XHRcdHtcblx0XHRcdFx0dmlkZW86IHRydWUsXG5cdFx0XHRcdGF1ZGlvOiBmYWxzZSxcblx0XHRcdH0sXG5cdFx0XHR0aGlzLl9oYW5kbGVTdHJlYW1TdWNjZXNzLFxuXHRcdFx0dGhpcy5faGFuZGxlU3RyZWFtRXJyb3Jcblx0XHQpO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY2FtZXJhXCI+XG5cdFx0XHRcdDx2aWRlbyByZWY9e3RoaXMuX3ZpZGVvQ29udGFpbmVyUmVmfT5cblx0XHRcdFx0XHRWaWRlbyBzdHJlYW0gbm90IGF2YWlsYWJsZS5cblx0XHRcdFx0PC92aWRlbz5cblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWNhbWVyYS1zaG9vdFwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy50YWtlUGhvdG99XG5cdFx0XHRcdFx0cmVmPXt0aGlzLl9idXR0b25UYWtlUGhvdG9SZWZ9PlxuXHRcdFx0XHRcdFRha2UgcGhvdG9cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdDxjYW52YXNcblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1jYW1lcmEtY2FudmFzXCJcblx0XHRcdFx0XHRyZWY9e3RoaXMuX2NhbnZhc0NvbnRhaW5lclJlZn1cblx0XHRcdFx0Lz5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogVGFrZXMgcGhvdG8gZnJvbSB0aGUgdmlkZW8gc3RyZWFtIGFuZCBpbnNlcnRzIGluIGludG8gZWRpdG9yJ3MgY29udGVudC5cblx0ICpcblx0ICogQGZpcmVzIEJ1dHRvbkNhbWVyYUltYWdlI2ltYWdlQ2FtZXJhQWRkXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ2FtZXJhSW1hZ2Vcblx0ICogQG1ldGhvZCB0YWtlUGhvdG9cblx0ICovXG5cdHRha2VQaG90byA9ICgpID0+IHtcblx0XHRjb25zdCB2aWRlb0VsID0gdGhpcy5fdmlkZW9Db250YWluZXJSZWYuY3VycmVudDtcblx0XHRjb25zdCBjYW52YXNFbCA9IHRoaXMuX2NhbnZhc0NvbnRhaW5lclJlZi5jdXJyZW50O1xuXG5cdFx0Y29uc3QgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG5cblx0XHRjb25zdCBoZWlnaHQgPSB0aGlzLl92aWRlb0hlaWdodDtcblx0XHRjb25zdCB3aWR0aCA9IHRoaXMucHJvcHMudmlkZW9XaWR0aDtcblxuXHRcdGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcblx0XHRcdGNhbnZhc0VsLndpZHRoID0gd2lkdGg7XG5cdFx0XHRjYW52YXNFbC5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHRcdGNvbnRleHQuZHJhd0ltYWdlKHZpZGVvRWwsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG5cdFx0XHRjb25zdCBpbWdVUkwgPSBjYW52YXNFbC50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuXG5cdFx0XHRjb25zdCBlbCA9IENLRURJVE9SLmRvbS5lbGVtZW50LmNyZWF0ZUZyb21IdG1sKFxuXHRcdFx0XHQnPGltZyBzcmM9XCInICsgaW1nVVJMICsgJ1wiPidcblx0XHRcdCk7XG5cblx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0ZWRpdG9yLmluc2VydEVsZW1lbnQoZWwpO1xuXG5cdFx0XHR0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXG5cdFx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cblx0XHRcdGVkaXRvci5maXJlKCdpbWFnZUNhbWVyYUFkZCcsIGVsKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BsYXlzIGVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiB2aWRlbyBzdHJlYW0gY2FwdHVyaW5nIGZhaWx1cmUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ2FtZXJhSW1hZ2Vcblx0ICogQG1ldGhvZCBfaGFuZGxlU3RyZWFtRXJyb3Jcblx0ICogQHBhcmFtIHtFdmVudH0gZXJyb3IgVGhlIGZpcmVkIGV2ZW50IGluIGNhc2Ugb2YgZXJyb3IuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9oYW5kbGVTdHJlYW1FcnJvciA9IGVycm9yID0+IHtcblx0XHR3aW5kb3cuYWxlcnQoJ0FuIGVycm9yIG9jY3VycmVkISAnICsgZXJyb3IpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdGFydHMgc3RyZWFtaW5nIHZpZGVvIGluIHRoZSB2aWRlbyBlbGVtZW50IGFuZCBzZXRzIHdpZHRoL2hlaWdodCB0byB0aGUgdmlkZW9cblx0ICogYW5kIGNhbnZhcyBlbGVtZW50cy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuXHQgKiBAbWV0aG9kIF9oYW5kbGVTdHJlYW1TdWNjZXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW0gVGhlIHZpZGVvIHN0cmVhbVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfaGFuZGxlU3RyZWFtU3VjY2VzcyA9IHN0cmVhbSA9PiB7XG5cdFx0Y29uc3QgdmlkZW9FbCA9IHRoaXMuX3ZpZGVvQ29udGFpbmVyUmVmLmN1cnJlbnQ7XG5cdFx0Y29uc3QgY2FudmFzRWwgPSB0aGlzLl9jYW52YXNDb250YWluZXJSZWYuY3VycmVudDtcblxuXHRcdHZpZGVvRWwuYWRkRXZlbnRMaXN0ZW5lcihcblx0XHRcdCdjYW5wbGF5Jyxcblx0XHRcdCgpID0+IHtcblx0XHRcdFx0bGV0IGhlaWdodCA9XG5cdFx0XHRcdFx0dmlkZW9FbC52aWRlb0hlaWdodCAvXG5cdFx0XHRcdFx0KHZpZGVvRWwudmlkZW9XaWR0aCAvIHRoaXMucHJvcHMudmlkZW9XaWR0aCk7XG5cblx0XHRcdFx0aWYgKGlzTmFOKGhlaWdodCkpIHtcblx0XHRcdFx0XHRoZWlnaHQgPSB0aGlzLnByb3BzLnZpZGVvV2lkdGggLyAoNCAvIDMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmlkZW9FbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5wcm9wcy52aWRlb1dpZHRoKTtcblx0XHRcdFx0dmlkZW9FbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XG5cdFx0XHRcdGNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLnByb3BzLnZpZGVvV2lkdGgpO1xuXHRcdFx0XHRjYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XG5cblx0XHRcdFx0dGhpcy5fdmlkZW9IZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHR9LFxuXHRcdFx0ZmFsc2Vcblx0XHQpO1xuXG5cdFx0dGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuXG5cdFx0aWYgKG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEpIHtcblx0XHRcdHZpZGVvRWwubW96U3JjT2JqZWN0ID0gc3RyZWFtO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2aWRlb0VsLnNyY09iamVjdCA9IHN0cmVhbTtcblx0XHR9XG5cblx0XHR2aWRlb0VsLnBsYXkoKTtcblxuXHRcdHRoaXMuX2J1dHRvblRha2VQaG90b1JlZi5jdXJyZW50LmRpc2FibGVkID0gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIEZpcmVkIHdoZW4gYW4gaW1hZ2UgaXMgYmVpbmcgdGFrZW4gZnJvbSB0aGUgY2FtZXJhIGFuZCBhZGRlZCBhcyBhbiBlbGVtZW50IHRvIHRoZSBlZGl0b3IuXG5cdCAqXG5cdCAqIEBldmVudCBCdXR0b25DYW1lcmFJbWFnZSNpbWFnZUNhbWVyYUFkZFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ2FtZXJhSW1hZ2Vcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZWwgVGhlIGNyZWF0ZWQgaW1nIGVsZW1lbnQgaW4gZWRpdG9yLlxuXHQgKi9cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ2FtZXJhSW1hZ2U7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25DYW1lcmFJbWFnZSBmcm9tICcuL2J1dHRvbi1jYW1lcmEtaW1hZ2UuanN4JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uQ2FtZXJhIGNsYXNzIHJlbmRlcnMgaW4gdHdvIGRpZmZlcmVudCB3YXlzOlxuICpcbiAqIC0gTm9ybWFsOiBKdXN0IGEgYnV0dG9uIHRoYXQgYWxsb3dzIHRvIHN3aXRjaCB0byB0aGUgZWRpdGlvbiBtb2RlLlxuICogLSBFeGNsdXNpdmU6IFJlbmRlcnMgQnV0dG9uQ2FtZXJhSW1hZ2UgaW4gb3JkZXIgdG8gdGFrZSBwaG90byBmcm9tIHRoZSBjYW1lcmEuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkNhbWVyYVxuICovXG5jbGFzcyBCdXR0b25DYW1lcmEgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IGNhbWVyYVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ2FtZXJhXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdjYW1lcmEnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ2FtZXJhXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuXHRcdFx0cmV0dXJuIDxCdXR0b25DYW1lcmFJbWFnZSB7Li4udGhpcy5wcm9wc30gLz47XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGRpc2FibGVkID0gIShcblx0XHRcdFx0bmF2aWdhdG9yLmdldFVzZXJNZWRpYSB8fFxuXHRcdFx0XHQobmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSAmJlxuXHRcdFx0XHRcdGxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHMnKSB8fFxuXHRcdFx0XHRuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8XG5cdFx0XHRcdG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYVxuXHRcdFx0KTtcblxuXHRcdFx0Y29uc3QgbGFiZWwgPSBkaXNhYmxlZFxuXHRcdFx0XHQ/IEFsbG95RWRpdG9yLlN0cmluZ3MuY2FtZXJhRGlzYWJsZWRcblx0XHRcdFx0OiBBbGxveUVkaXRvci5TdHJpbmdzLmNhbWVyYTtcblxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9e2xhYmVsfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWltYWdlLWNhbWVyYVwiXG5cdFx0XHRcdFx0ZGlzYWJsZWQ9e2Rpc2FibGVkfVxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMucHJvcHMucmVxdWVzdEV4Y2x1c2l2ZS5iaW5kKEJ1dHRvbkNhbWVyYS5rZXkpfVxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHRcdHRpdGxlPXtsYWJlbH0+XG5cdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiY2FtZXJhXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25DYW1lcmE7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25BY3Rpb25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1hY3Rpb24tc3R5bGUnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZSc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkNvZGUgY2xhc3MgcHJvdmlkZXMgd3JhcHMgYSBzZWxlY3Rpb24gaW4gYHByZWAgZWxlbWVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQ29kZVxuICogQHVzZXMgQnV0dG9uQWN0aW9uU3R5bGVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uQ29kZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Db2RlXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0c3R5bGU6IHtcblx0XHRcdGVsZW1lbnQ6ICdwcmUnLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBjb2RlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Db2RlXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdjb2RlJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvZGVcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5jb2RlfVxuXHRcdFx0XHRhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9XG5cdFx0XHRcdGNsYXNzTmFtZT17Y3NzQ2xhc3N9XG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1jb2RlXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5hcHBseVN0eWxlfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29kZX0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNvZGVcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25BY3Rpb25TdHlsZShCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uU3R5bGUoQnV0dG9uQ29kZSkpKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3QgZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QuanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uQ29sb3IgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2hhbmdpbmcgdGV4dCBjb2xvciBpbiBhIGRvY3VtZW50LlxuICpcbiAqXG4gKiBAY2xhc3MgQnV0dG9uQ29sb3JcbiAqL1xuY2xhc3MgQnV0dG9uQ29sb3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdHN0YXRpYyBrZXkgPSAnY29sb3InO1xuXG5cdHN0YXRpYyBwcm9wVHlwZXMgPSB7XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN0eWxlcyBsaXN0IGlzIGV4cGFuZGVkIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25Db2xvclxuXHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZXhwYW5kZWRcblx0XHQgKi9cblx0XHRleHBhbmRlZDogUHJvcFR5cGVzLmJvb2wsXG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGFiZWwgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgYWNjZXNzaWJpbGl0eSBwdXJwb3Nlcy5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25Db2xvclxuXHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBsYWJlbFxuXHRcdCAqL1xuXHRcdGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHJlbW92ZSBzdHlsZXMgaXRlbSBzaG91bGQgYXBwZWFyIGluIHRoZSBzdHlsZXMgbGlzdC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25Db2xvclxuXHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2hvd1JlbW92ZVN0eWxlc0l0ZW1cblx0XHQgKi9cblx0XHRzaG93UmVtb3ZlU3R5bGVzSXRlbTogUHJvcFR5cGVzLmJvb2wsXG5cblx0XHQvKipcblx0XHQgKiBMaXN0IG9mIHRoZSBzdHlsZXMgdGhlIGJ1dHRvbiBpcyBhYmxlIHRvIGhhbmRsZS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25Db2xvclxuXHRcdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IHN0eWxlc1xuXHRcdCAqL1xuXHRcdHN0eWxlczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9iamVjdCksXG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGFiSW5kZXggb2YgdGhlIGJ1dHRvbiBpbiBpdHMgdG9vbGJhciBjdXJyZW50IHN0YXRlLiBBIHZhbHVlIG90aGVyIHRoYW4gLTFcblx0XHQgKiBtZWFucyB0aGF0IHRoZSBidXR0b24gaGFzIGZvY3VzIGFuZCBpcyB0aGUgYWN0aXZlIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gdGFiSW5kZXhcblx0XHQgKi9cblx0XHR0YWJJbmRleDogUHJvcFR5cGVzLm51bWJlcixcblxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIHByb3ZpZGVkIGJ5IHRoZSBidXR0b24gaG9zdCB0byBub3RpZnkgd2hlbiB0aGUgc3R5bGVzIGxpc3QgaGFzIGJlZW4gZXhwYW5kZWQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB0b2dnbGVEcm9wZG93blxuXHRcdCAqL1xuXHRcdHRvZ2dsZURyb3Bkb3duOiBQcm9wVHlwZXMuZnVuYyxcblx0fTtcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRsZXQgYWN0aXZlQ29sb3IgPSBBbGxveUVkaXRvci5TdHJpbmdzLm5vcm1hbDtcblxuXHRcdGNvbnN0IGNvbG9ycyA9IHRoaXMuX2dldENvbG9ycygpO1xuXG5cdFx0Y29sb3JzLnNvbWUoaXRlbSA9PiB7XG5cdFx0XHRpZiAodGhpcy5fY2hlY2tBY3RpdmUoaXRlbS5zdHlsZSkpIHtcblx0XHRcdFx0YWN0aXZlQ29sb3IgPSBpdGVtLm5hbWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRjb25zdCB7ZXhwYW5kZWQsIHRhYkluZGV4LCB0b2dnbGVEcm9wZG93bn0gPSB0aGlzLnByb3BzO1xuXG5cdFx0Y29uc3QgYnV0dG9uU3R5bGVzUHJvcHMgPSB7XG5cdFx0XHRhY3RpdmVTdHlsZTogYWN0aXZlQ29sb3IsXG5cdFx0XHRvbkRpc21pc3M6IHRvZ2dsZURyb3Bkb3duLFxuXHRcdFx0c2hvd1JlbW92ZVN0eWxlc0l0ZW06IGZhbHNlLFxuXHRcdFx0c3R5bGVzOiBjb2xvcnMsXG5cdFx0fTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lciBhZS1oYXMtZHJvcGRvd25cIj5cblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGFyaWEtZXhwYW5kZWQ9e2V4cGFuZGVkfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLXRvb2xiYXItZWxlbWVudFwiXG5cdFx0XHRcdFx0b25DbGljaz17dG9nZ2xlRHJvcGRvd259XG5cdFx0XHRcdFx0cm9sZT1cImNvbWJvYm94XCJcblx0XHRcdFx0XHR0YWJJbmRleD17dGFiSW5kZXh9PlxuXHRcdFx0XHRcdDxzcGFuPlxuXHRcdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiY29sb3ItcGlja2VyXCIgLz5cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHR7ZXhwYW5kZWQgJiYgPEJ1dHRvblN0eWxlc0xpc3Qgey4uLmJ1dHRvblN0eWxlc1Byb3BzfSAvPn1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHRfYXBwbHlTdHlsZShjbGFzc05hbWUpIHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRjb25zdCBzdHlsZUNvbmZpZyA9IHtcblx0XHRcdGVsZW1lbnQ6ICdzcGFuJyxcblx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0Y2xhc3M6IGNsYXNzTmFtZSxcblx0XHRcdH0sXG5cdFx0fTtcblxuXHRcdGNvbnN0IHN0eWxlID0gbmV3IENLRURJVE9SLnN0eWxlKHN0eWxlQ29uZmlnKTtcblxuXHRcdGVkaXRvci5nZXRTZWxlY3Rpb24oKS5sb2NrKCk7XG5cblx0XHR0aGlzLl9nZXRDb2xvcnMoKS5mb3JFYWNoKGl0ZW0gPT4ge1xuXHRcdFx0aWYgKHRoaXMuX2NoZWNrQWN0aXZlKGl0ZW0uc3R5bGUpKSB7XG5cdFx0XHRcdGVkaXRvci5yZW1vdmVTdHlsZShuZXcgQ0tFRElUT1Iuc3R5bGUoaXRlbS5zdHlsZSkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0ZWRpdG9yLmFwcGx5U3R5bGUoc3R5bGUpO1xuXG5cdFx0ZWRpdG9yLmdldFNlbGVjdGlvbigpLnVubG9jaygpO1xuXG5cdFx0ZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gY29sb3IgZGVmaW5pdGlvbiBpcyBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbG9yXG5cdCAqIEBtZXRob2QgX2NoZWNrQWN0aXZlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZUNvbmZpZyBDb2xvciBkZWZpbml0aW9uIGFzIHBlciBodHRwOi8vZG9jcy5ja2VkaXRvci5jb20vIyEvYXBpL0NLRURJVE9SLnN0eWxlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29sb3IgaXMgYXBwbGllZCB0byB0aGUgc2VsZWN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuXHRfY2hlY2tBY3RpdmUoc3R5bGVDb25maWcpIHtcblx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHQvLyBTdHlsZXMgd2l0aCB3aWxkY2FyZCBlbGVtZW50ICgqKSB3b24ndCBiZSBjb25zaWRlcmVkIGFjdGl2ZSBieSBDS0VkaXRvci4gRGVmYXVsdGluZ1xuXHRcdC8vIHRvIGEgJ3NwYW4nIGVsZW1lbnQgd29ya3MgZm9yIG1vc3Qgb2YgdGhvc2UgY2FzZXMgd2l0aCBubyBkZWZpbmVkIGVsZW1lbnQuXG5cdFx0c3R5bGVDb25maWcgPSBDS0VESVRPUi50b29scy5tZXJnZSh7ZWxlbWVudDogJ3NwYW4nfSwgc3R5bGVDb25maWcpO1xuXG5cdFx0Y29uc3Qgc3R5bGUgPSBuZXcgQ0tFRElUT1Iuc3R5bGUoc3R5bGVDb25maWcpO1xuXG5cdFx0cmV0dXJuIHN0eWxlLmNoZWNrQWN0aXZlKG5hdGl2ZUVkaXRvci5lbGVtZW50UGF0aCgpLCBuYXRpdmVFZGl0b3IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgY29sb3JzLiBFYWNoIGNvbG9yIGNvbnNpc3RzIG9mIHR3byBwcm9wZXJ0aWVzOlxuXHQgKiAtIG5hbWUgLSBUaGUgc3R5bGUgbmFtZSwgZm9yIGV4YW1wbGUgXCJkZWZhdWx0XCIuXG5cdCAqIC0gc3R5bGUgLSBBbiBvYmplY3Qgd2l0aCBvbmUgcHJvcGVydHksIGNhbGxlZCBgZWxlbWVudGAgd2hpY2ggdmFsdWVcblx0ICogICAgICAgICAgcmVwcmVzZW50cyB0aGUgc3R5bGUgd2hpY2ggaGF2ZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50LlxuXHQgKiAtIHN0eWxlRm4gLSBUaGUgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIHRvIGFwcGx5IHRoZSBzdHlsZSB0byB0aGUgZWxlbWVudC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Db2xvclxuXHQgKiBAbWV0aG9kIF9nZXRDb2xvclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0FycmF5PG9iamVjdD59IEFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgY29sb3JzLlxuXHQgKi9cblx0X2dldENvbG9ycygpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5wcm9wcy5zdHlsZXMgfHwgW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5wcmltYXJ5LFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC1wcmltYXJ5Jyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtcHJpbWFyeScpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5zdWNjZXNzLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC1zdWNjZXNzJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtc3VjY2VzcycpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5kYW5nZXIsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdzcGFuJyxcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0XHRcdFx0Y2xhc3M6ICd0ZXh0LWRhbmdlcicsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICd0ZXh0LWRhbmdlcicpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy53YXJuaW5nLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC13YXJuaW5nJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtd2FybmluZycpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5pbmZvLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC1pbmZvJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtaW5mbycpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5kYXJrLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC1kYXJrJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtZGFyaycpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5kYXJrR3JheSxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtZ3JheS1kYXJrJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtZ3JheS1kYXJrJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLnNlY29uZGFyeSxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtc2Vjb25kYXJ5Jyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtc2Vjb25kYXJ5JyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmxpZ2h0LFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC1kYXJrJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtbGlnaHQnKSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MubGlnaHRlcixcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtZGFyaycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICd0ZXh0LWxpZ2h0ZXInKSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3Mud2hpdGUsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdzcGFuJyxcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0XHRcdFx0Y2xhc3M6ICd0ZXh0LWRhcmsnLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAndGV4dC13aGl0ZScpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29sb3I7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25Db21tYW5kTGlzdEl0ZW0gY2xhc3MgaXMgYSBVSSBjbGFzcyB0aGF0IHJlbmRlcnMgYSBCdXR0b25Db21tYW5kIHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlXG4gKiBhIGxpc3QgYXMgYW4gaXRlbSwgd2l0aCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdHMgYmVoYXZpb3VyLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db21tYW5kTGlzdEl0ZW1cbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuY2xhc3MgQnV0dG9uQ29tbWFuZExpc3RJdGVtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBidXR0b25Db21tYW5kTGlzdEl0ZW1cblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRMaXN0SXRlbVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnYnV0dG9uQ29tbWFuZExpc3RJdGVtJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRMaXN0SXRlbVxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXt0aGlzLnByb3BzLmRlc2NyaXB0aW9ufVxuXHRcdFx0XHRjbGFzc05hbWU9e3RoaXMuX2dldENsYXNzTmFtZSgpfVxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0+XG5cdFx0XHRcdHt0aGlzLnByb3BzLmRlc2NyaXB0aW9ufVxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjbGFzcyBuYW1lIG9mIFdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Db21tYW5kTGlzdEl0ZW1cblx0ICogQG1ldGhvZCBfZ2V0Q2xhc3NOYW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgY2xhc3MgbmFtZSBvZiB0aGUgV2lkZ2V0LlxuXHQgKi9cblx0X2dldENsYXNzTmFtZSgpIHtcblx0XHRjb25zdCBjbGFzc05hbWUgPSAnYWUtY29udGFpbmVyIGFlLXRvb2xiYXItZWxlbWVudCc7XG5cblx0XHRyZXR1cm4gY2xhc3NOYW1lO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoQnV0dG9uQ29tbWFuZExpc3RJdGVtKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyJztcbmltcG9ydCBCdXR0b25Db21tYW5kTGlzdEl0ZW0gZnJvbSAnLi9idXR0b24tY29tbWFuZC1saXN0LWl0ZW0uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uQ29tbWFuZHNMaXN0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHNob3dpbmcgYSBsaXN0IG9mIGNvbW1hbmRzIHRoYXQgY2FuIGJlXG4gKiBleGVjdXRlZCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db21tYW5kc0xpc3RcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBCdXR0b25Db21tYW5kc0xpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZHNMaXN0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y2lyY3VsYXI6IGZhbHNlLFxuXHRcdGRlc2NlbmRhbnRzOiAnLmFlLXRvb2xiYXItZWxlbWVudCcsXG5cdFx0a2V5czoge1xuXHRcdFx0ZGlzbWlzczogWzI3XSxcblx0XHRcdGRpc21pc3NOZXh0OiBbMzldLFxuXHRcdFx0ZGlzbWlzc1ByZXY6IFszN10sXG5cdFx0XHRuZXh0OiBbNDBdLFxuXHRcdFx0cHJldjogWzM4XSxcblx0XHR9LFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgYnV0dG9uQ29tbWFuZHNMaXN0XG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Db21tYW5kc0xpc3Rcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2J1dHRvbkNvbW1hbmRzTGlzdCc7XG5cblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cdFx0dGhpcy5fcmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogRm9jdXNlcyBvbiB0aGUgbGlzdCBub2RlIHRvIGFsbG93IGtleWJvYXJkIGludGVyYWN0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRzTGlzdFxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLl9yZWYuY3VycmVudC5mb2N1cygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGxpc3QuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZHNMaXN0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2XG5cdFx0XHRcdGNsYXNzTmFtZT1cImFlLWFycm93LWJveCBhZS1hcnJvdy1ib3gtdG9wLWxlZnQgYWUtZHJvcGRvd25cIlxuXHRcdFx0XHRvbkZvY3VzPXt0aGlzLmZvY3VzfVxuXHRcdFx0XHRvbktleURvd249e3RoaXMuaGFuZGxlS2V5fVxuXHRcdFx0XHRyZWY9e3RoaXMuX3JlZn1cblx0XHRcdFx0dGFiSW5kZXg9XCIwXCI+XG5cdFx0XHRcdDx1bFxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWxpc3Rib3hcIlxuXHRcdFx0XHRcdGlkPXt0aGlzLnByb3BzLmxpc3RJZH1cblx0XHRcdFx0XHRyb2xlPVwibGlzdGJveFwiPlxuXHRcdFx0XHRcdHt0aGlzLl9yZW5kZXJBY3Rpb25zKHRoaXMucHJvcHMuY29tbWFuZHMpfVxuXHRcdFx0XHQ8L3VsPlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXJzIGluc3RhbmNlcyBvZiBCdXR0b25Db21tYW5kTGlzdEl0ZW0gd2l0aCB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIHJvdyBhY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRzTGlzdFxuXHQgKiBAbWV0aG9kIF9yZW5kZXJBY3Rpb25zXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7QXJyYXl9IFJlbmRlcmVkIGluc3RhbmNlcyBvZiBCdXR0b25Db21tYW5kTGlzdEl0ZW0gY2xhc3Ncblx0ICovXG5cdF9yZW5kZXJBY3Rpb25zKGNvbW1hbmRzKSB7XG5cdFx0bGV0IGl0ZW1zO1xuXG5cdFx0aWYgKGNvbW1hbmRzICYmIGNvbW1hbmRzLmxlbmd0aCkge1xuXHRcdFx0aXRlbXMgPSBjb21tYW5kcy5tYXAoaXRlbSA9PiB7XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0PGxpIGtleT17aXRlbS5jb21tYW5kfSByb2xlPVwib3B0aW9uXCI+XG5cdFx0XHRcdFx0XHQ8QnV0dG9uQ29tbWFuZExpc3RJdGVtXG5cdFx0XHRcdFx0XHRcdGNvbW1hbmQ9e2l0ZW0uY29tbWFuZH1cblx0XHRcdFx0XHRcdFx0ZGVzY3JpcHRpb249e1xuXHRcdFx0XHRcdFx0XHRcdHR5cGVvZiBpdGVtLmxhYmVsID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdFx0XHRcdFx0PyBpdGVtLmxhYmVsXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IGl0ZW0ubGFiZWwoKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGljb249e2l0ZW0uaWNvbn1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBpdGVtcztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRGb2N1c01hbmFnZXIoQnV0dG9uQ29tbWFuZHNMaXN0KTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyJztcblxuLyoqXG4gKiBUaGUgQnV0dG9uRHJvcGRvd24gY2xhc3MgcHJvdmlkZXMgbWFya3VwIGFuZCBrZXlib2FyZCBuYXZpZ2F0aW9uIGJlaGF2aW91ciB0byBhIGRyb3Bkb3duXG4gKiBvcGVuZWQgZnJvbSBhIGJ1dHRvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uRHJvcGRvd25cbiAqL1xuY2xhc3MgQnV0dG9uRHJvcGRvd24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRHJvcGRvd25cblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y2lyY3VsYXI6IGZhbHNlLFxuXHRcdGRlc2NlbmRhbnRzOiAnLmFlLXRvb2xiYXItZWxlbWVudCcsXG5cdFx0a2V5czoge1xuXHRcdFx0ZGlzbWlzczogWzI3XSxcblx0XHRcdGRpc21pc3NOZXh0OiBbMzldLFxuXHRcdFx0ZGlzbWlzc1ByZXY6IFszN10sXG5cdFx0XHRuZXh0OiBbNDBdLFxuXHRcdFx0cHJldjogWzM4XSxcblx0XHR9LFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGRyb3Bkb3duIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBkcm9wZG93blxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRHJvcGRvd25cblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2Ryb3Bkb3duJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkRyb3Bkb3duXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2XG5cdFx0XHRcdGNsYXNzTmFtZT1cImFlLWFycm93LWJveCBhZS1hcnJvdy1ib3gtdG9wLWxlZnQgYWUtZHJvcGRvd25cIlxuXHRcdFx0XHRvbkZvY3VzPXt0aGlzLmZvY3VzfVxuXHRcdFx0XHRvbktleURvd249e3RoaXMuaGFuZGxlS2V5fVxuXHRcdFx0XHR0YWJJbmRleD1cIjBcIj5cblx0XHRcdFx0PHVsIGNsYXNzTmFtZT1cImFlLWxpc3Rib3hcIiByb2xlPVwibGlzdGJveFwiPlxuXHRcdFx0XHRcdHt0aGlzLnByb3BzLmNoaWxkcmVufVxuXHRcdFx0XHQ8L3VsPlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRGb2N1c01hbmFnZXIoQnV0dG9uRHJvcGRvd24pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuY29uc3QgS0VZX0VOVEVSID0gMTM7XG5jb25zdCBLRVlfRVNDID0gMjc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkVtYmVkRWRpdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhbmQgZWRpdGluZyBhbiBlbWJlZCBsaW5rIGluIGEgZG9jdW1lbnQuXG4gKiBQcm92aWRlcyBVSSBmb3IgY3JlYXRpbmcgYW5kIGVkaXRpbmcgYW4gZW1iZWQgbGluay5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uRW1iZWRFZGl0XG4gKi9cbmNsYXNzIEJ1dHRvbkVtYmVkRWRpdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBlbWJlZEVkaXRcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnZW1iZWRFZGl0JztcblxuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdHRoaXMubGlua0lucHV0ID0gUmVhY3QuY3JlYXRlUmVmKCk7XG5cdFx0dGhpcy5zdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogRm9jdXNlcyBvbiB0aGUgbGluayBpbnB1dCB0byBpbW1lZGlhdGVseSBhbGxvdyBlZGl0aW5nLiBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGUgY29tcG9uZW50XG5cdCAqIGlzIHJlbmRlcmVkIGluIGV4Y2x1c2l2ZSBtb2RlIHRvIHByZXZlbnQgYWdncmVzc2l2ZSBmb2N1cyBzdGVhbGluZy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcblx0ICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuXHQgKi9cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0aWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlIHx8IHRoaXMucHJvcHMubWFudWFsU2VsZWN0aW9uKSB7XG5cdFx0XHQvLyBXZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZSBiZWZvcmUgZm9jdXNpbmcgdG8gYXZvaWQgdW5kZXNpcmVkXG5cdFx0XHQvLyBzY3JvbGxzIG9uIHRoZSBwYWdlXG5cdFx0XHRpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHRcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2ZvY3VzTGlua0lucHV0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNldFRpbWVvdXQodGhpcy5fZm9jdXNMaW5rSW5wdXQsIDApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZWNlaXZpbmcgbmV3IHByb3BzLlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG5cdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1xuXHQgKi9cblx0Y29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpIHtcblx0XHR0aGlzLnNldFN0YXRlKHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG5cdCAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoaXMuc3RhdGUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG5cdCAqIEBtZXRob2QgZ2V0SW5pdGlhbFN0YXRlXG5cdCAqL1xuXHRnZXRJbml0aWFsU3RhdGUoKSB7XG5cdFx0Ly8gQ2FuJ3QgYWNjZXNzIGNvbnRleHQgZnJvbSBjb25zdHJ1Y3Rvciwgc28gZ2V0IGVkaXRvciBmcm9tIHByb3BzLlxuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMucHJvcHMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRsZXQgZW1iZWQ7XG5cblx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRpZiAoc2VsZWN0aW9uKSB7XG5cdFx0XHRjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRFbGVtZW50KCk7XG5cblx0XHRcdGlmIChzZWxlY3RlZEVsZW1lbnQpIHtcblx0XHRcdFx0ZW1iZWQgPSBzZWxlY3RlZEVsZW1lbnQuZmluZE9uZSgnW2RhdGEtd2lkZ2V0PVwiYWVfZW1iZWRcIl0nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCBocmVmID0gZW1iZWQgPyBlbWJlZC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWUtZW1iZWQtdXJsJykgOiAnJztcblxuXHRcdHJldHVybiB7XG5cdFx0XHRlbGVtZW50OiBlbWJlZCxcblx0XHRcdGluaXRpYWxMaW5rOiB7XG5cdFx0XHRcdGhyZWYsXG5cdFx0XHR9LFxuXHRcdFx0bGlua0hyZWY6IGhyZWYsXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNsZWFyTGlua1N0eWxlID0ge1xuXHRcdFx0b3BhY2l0eTogdGhpcy5zdGF0ZS5saW5rSHJlZiA/IDEgOiAwLFxuXHRcdH07XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZWRpdC1saW5rXCI+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmRlbGV0ZUVtYmVkfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWVtYmVkLXJlbW92ZVwiXG5cdFx0XHRcdFx0ZGlzYWJsZWQ9eyF0aGlzLnN0YXRlLmVsZW1lbnR9XG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5fcmVtb3ZlRW1iZWR9XG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuZGVsZXRlRW1iZWR9PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIGNsYXNzTmFtZT1cImFlLWljb24tc3ZnLXRyYXNoXCIgc3ltYm9sPVwidHJhc2hcIiAvPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItaW5wdXQgeHhsXCI+XG5cdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1pbnB1dFwiXG5cdFx0XHRcdFx0XHRvbkNoYW5nZT17dGhpcy5faGFuZGxlTGlua0hyZWZDaGFuZ2V9XG5cdFx0XHRcdFx0XHRvbktleURvd249e3RoaXMuX2hhbmRsZUtleURvd259XG5cdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj17QWxsb3lFZGl0b3IuU3RyaW5ncy5lZGl0TGlua31cblx0XHRcdFx0XHRcdHJlZj17dGhpcy5saW5rSW5wdXR9XG5cdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0XHR2YWx1ZT17dGhpcy5zdGF0ZS5saW5rSHJlZn1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY2xlYXJJbnB1dH1cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvbiBhZS1idXR0b24tY2xlYXJcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17dGhpcy5fY2xlYXJMaW5rfVxuXHRcdFx0XHRcdFx0c3R5bGU9e2NsZWFyTGlua1N0eWxlfVxuXHRcdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY2xlYXJ9PlxuXHRcdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwidGltZXMtY2xlYXJcIiAvPlxuXHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29uZmlybX1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdGRpc2FibGVkPXshdGhpcy5faXNWYWxpZFN0YXRlKCl9XG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5fZW1iZWRMaW5rfVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbmZpcm19PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIGNsYXNzTmFtZT1cImFlLWljb24tc3ZnLWNoZWNrXCIgc3ltYm9sPVwiY2hlY2tcIiAvPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIHRoZSBsaW5rIGlucHV0LiBUaGlzIG9ubHkgY2hhbmdlcyB0aGUgY29tcG9uZW50IGludGVybmFsIHN0YXRlLCBidXQgZG9lcyBub3Rcblx0ICogYWZmZWN0IHRoZSBsaW5rIGVsZW1lbnQgb2YgdGhlIGVkaXRvci4gT25seSB0aGUgX3JlbW92ZUxpbmsgYW5kIF91cGRhdGVMaW5rIG1ldGhvZHNcblx0ICogYXJlIHRyYW5zbGF0ZWQgdG8gdGhlIGVkaXRvciBlbGVtZW50LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuXHQgKiBAbWV0aG9kIF9jbGVhckxpbmtcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2NsZWFyTGluayA9ICgpID0+IHtcblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdGxpbmtIcmVmOiAnJyxcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogVHJpZ2dlcnMgdGhlIGVtYmVkVXJsIGNvbW1hbmQgdG8gdHJhbnNmb3JtIHRoZSBsaW5rIGludG8gYW4gZW1iZWQgbWVkaWEgb2JqZWN0XG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG5cdCAqIEBtZXRob2QgX2VtYmVkTGlua1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfZW1iZWRMaW5rID0gKCkgPT4ge1xuXHRcdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdG5hdGl2ZUVkaXRvci5leGVjQ29tbWFuZCgnZW1iZWRVcmwnLCB7XG5cdFx0XHR1cmw6IHRoaXMuc3RhdGUubGlua0hyZWYsXG5cdFx0fSk7XG5cblx0XHQvLyBXZSBuZWVkIHRvIGNhbmNlbEV4Y2x1c2l2ZSB3aXRoIHRoZSBib3VuZCBwYXJhbWV0ZXJzIGluIGNhc2UgdGhlIGJ1dHRvbiBpcyB1c2VkXG5cdFx0Ly8gaW5zaWRlIGFub3RoZXIgaW4gZXhjbHVzaXZlIG1vZGUgKHN1Y2ggaXMgdGhlIGNhc2Ugb2YgdGhlIGxpbmsgYnV0dG9uKVxuXHRcdHRoaXMucHJvcHMuY2FuY2VsRXhjbHVzaXZlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEZvY3VzZXMgdGhlIHVzZXIgY3Vyc29yIG9uIHRoZSB3aWRnZXQncyBpbnB1dC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcblx0ICogQG1ldGhvZCBfZm9jdXNMaW5rSW5wdXRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2ZvY3VzTGlua0lucHV0ID0gKCkgPT4ge1xuXHRcdHRoaXMubGlua0lucHV0LmN1cnJlbnQuZm9jdXMoKTtcblx0fTtcblxuXHQvKipcblx0ICogTW9uaXRvcnMga2V5IGludGVyYWN0aW9uIGluc2lkZSB0aGUgaW5wdXQgZWxlbWVudCB0byByZXNwb25kIHRvIHRoZSBrZXlzOlxuXHQgKiAtIEVudGVyOiBDcmVhdGVzL3VwZGF0ZXMgdGhlIGxpbmsuXG5cdCAqIC0gRXNjYXBlOiBEaXNjYXJkcyB0aGUgY2hhbmdlcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcblx0ICogQG1ldGhvZCBfaGFuZGxlS2V5RG93blxuXHQgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUga2V5Ym9hcmQgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9oYW5kbGVLZXlEb3duID0gZXZlbnQgPT4ge1xuXHRcdGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRU5URVIgfHwgZXZlbnQua2V5Q29kZSA9PT0gS0VZX0VTQykge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gS0VZX0VOVEVSKSB7XG5cdFx0XHR0aGlzLl9lbWJlZExpbmsoKTtcblx0XHR9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWV9FU0MpIHtcblx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0Ly8gV2UgbmVlZCB0byBjYW5jZWxFeGNsdXNpdmUgd2l0aCB0aGUgYm91bmQgcGFyYW1ldGVycyBpbiBjYXNlIHRoZSBidXR0b24gaXMgdXNlZFxuXHRcdFx0Ly8gaW5zaWRlIGFub3RoZXIgaW4gZXhjbHVzaXZlIG1vZGUgKHN1Y2ggaXMgdGhlIGNhc2Ugb2YgdGhlIGxpbmsgYnV0dG9uKVxuXHRcdFx0dGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcblxuXHRcdFx0ZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgY29tcG9uZW50IHN0YXRlIHdoZW4gdGhlIGxpbmsgaW5wdXQgY2hhbmdlcyBvbiB1c2VyIGludGVyYWN0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuXHQgKiBAbWV0aG9kIF9oYW5kbGVMaW5rSHJlZkNoYW5nZVxuXHQgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgY2hhbmdlIGV2ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfaGFuZGxlTGlua0hyZWZDaGFuZ2UgPSBldmVudCA9PiB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRsaW5rSHJlZjogZXZlbnQudGFyZ2V0LnZhbHVlLFxuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBWZXJpZmllcyB0aGF0IHRoZSBjdXJyZW50IGxpbmsgc3RhdGUgaXMgdmFsaWQgc28gdGhlIHVzZXIgY2FuIHNhdmUgdGhlIGxpbmsuIEEgdmFsaWQgc3RhdGVcblx0ICogbWVhbnMgdGhhdCB3ZSBoYXZlIGEgbm9uLWVtcHR5IGhyZWYgdGhhdCdzIGRpZmZlcmVudCBmcm9tIHRoZSBvcmlnaW5hbCBvbmUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG5cdCAqIEBtZXRob2QgX2lzVmFsaWRTdGF0ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHN0YXRlIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdF9pc1ZhbGlkU3RhdGUoKSB7XG5cdFx0Y29uc3QgdmFsaWRTdGF0ZSA9XG5cdFx0XHR0aGlzLnN0YXRlLmxpbmtIcmVmICYmXG5cdFx0XHR0aGlzLnN0YXRlLmxpbmtIcmVmICE9PSB0aGlzLnN0YXRlLmluaXRpYWxMaW5rLmhyZWY7XG5cblx0XHRyZXR1cm4gdmFsaWRTdGF0ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBlbWJlZCBpbiB0aGUgZWRpdG9yIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG5cdCAqIEBtZXRob2QgX3JlbW92ZUVtYmVkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9yZW1vdmVFbWJlZCA9ICgpID0+IHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRjb25zdCBlbWJlZFdyYXBwZXIgPSB0aGlzLnN0YXRlLmVsZW1lbnQuZ2V0QXNjZW5kYW50KGVsZW1lbnQgPT4ge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnQuaGFzQ2xhc3MoJ2NrZV93aWRnZXRfd3JhcHBlcicpO1xuXHRcdH0pO1xuXG5cdFx0ZW1iZWRXcmFwcGVyLnJlbW92ZSgpO1xuXG5cdFx0ZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBFZGl0b3JDb250ZXh0LnRvUHJvcHMoQnV0dG9uRW1iZWRFZGl0KTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuY29uc3QgS0VZX0VOVEVSID0gMTM7XG5jb25zdCBLRVlfRVNDID0gMjc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkVtYmVkVmlkZW9FZGl0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNoYW5naW5nIHRleHQgY29sb3IgaW4gYSBkb2N1bWVudC5cbiAqXG4gKiBAdXNlcyBCdXR0b25JY29uXG4gKlxuICogQGNsYXNzIEJ1dHRvbkVtYmVkVmlkZW9FZGl0XG4gKi9cbmNsYXNzIEJ1dHRvbkVtYmVkVmlkZW9FZGl0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRzdGF0aWMga2V5ID0gJ2VtYmVkVmlkZW9FZGl0JztcblxuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdHRoaXMuc3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdCAqXG5cdCAqIEZvY3VzZXMgb24gdGhlIGxpbmsgaW5wdXQgdG8gaW1tZWRpYXRlbHkgYWxsb3cgZWRpdGluZy4gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlIGNvbXBvbmVudFxuXHQgKiBpcyByZW5kZXJlZCBpbiBleGNsdXNpdmUgbW9kZSB0byBwcmV2ZW50IGFnZ3Jlc3NpdmUgZm9jdXMgc3RlYWxpbmcuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRWaWRlb0VkaXRcblx0ICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuXHQgKi9cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0aWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlIHx8IHRoaXMucHJvcHMubWFudWFsU2VsZWN0aW9uKSB7XG5cdFx0XHQvLyBXZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZSBiZWZvcmUgZm9jdXNpbmcgdG8gYXZvaWQgdW5kZXNpcmVkXG5cdFx0XHQvLyBzY3JvbGxzIG9uIHRoZSBwYWdlXG5cdFx0XHRpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHRcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2ZvY3VzVmlkZW9VcmxJbnB1dCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZXRUaW1lb3V0KHRoaXMuX2ZvY3VzVmlkZW9VcmxJbnB1dCwgMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlY2VpdmluZyBuZXcgcHJvcHMuXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFZpZGVvRWRpdFxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcblx0ICovXG5cdGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKSB7XG5cdFx0Y29uc3QgbmV3U3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSgpO1xuXG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRhbGw6IHVuZGVmaW5lZCxcblx0XHRcdGtleXM6IHVuZGVmaW5lZCxcblx0XHRcdG5ldzogbmV3U3RhdGUsXG5cdFx0XHRvbGQ6IHVuZGVmaW5lZCxcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuXHQgKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGlzLnN0YXRlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkVmlkZW9FZGl0XG5cdCAqIEBtZXRob2QgZ2V0SW5pdGlhbFN0YXRlXG5cdCAqL1xuXHRnZXRJbml0aWFsU3RhdGUoKSB7XG5cdFx0Ly8gQ2FuJ3QgYWNjZXNzIGNvbnRleHQgZnJvbSBjb25zdHJ1Y3Rvciwgc28gZ2V0IGVkaXRvciBmcm9tIHByb3BzLlxuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMucHJvcHMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRsZXQgZWxlbWVudDtcblxuXHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdGlmIChzZWxlY3Rpb24pIHtcblx0XHRcdGNvbnN0IHNlbGVjdGVkRWxlbWVudCA9IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuXHRcdFx0aWYgKHNlbGVjdGVkRWxlbWVudCkge1xuXHRcdFx0XHRlbGVtZW50ID0gc2VsZWN0ZWRFbGVtZW50LmZpbmRPbmUoJ1tkYXRhLXdpZGdldD1cInZpZGVvZW1iZWRcIl0nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCB2aWRlb1VSTCA9IGVsZW1lbnRcblx0XHRcdD8gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZW1iZWQtdmlkZW8tdXJsJylcblx0XHRcdDogJyc7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZWxlbWVudCxcblx0XHRcdGluaXRpYWxFbWJlZDoge1xuXHRcdFx0XHR2aWRlb1VSTCxcblx0XHRcdH0sXG5cdFx0XHR2aWRlb1VSTCxcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFZpZGVvRWRpdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBpbnB1dFBsYWNlaG9sZGVyID0gQWxsb3lFZGl0b3IuU3RyaW5ncy5wYXN0ZVZpZGVvTGluaztcblxuXHRcdGNvbnN0IGNsZWFyVmlkZW9VUkxTdHlsZSA9IHtcblx0XHRcdG9wYWNpdHk6IHRoaXMuc3RhdGUudmlkZW9VUkwgPyAxIDogMCxcblx0XHR9O1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWVtYmVkLXZpZGVvLWVkaXRcIj5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItaW5wdXQgeHhsXCI+XG5cdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1pbnB1dFwiXG5cdFx0XHRcdFx0XHRvbkNoYW5nZT17dGhpcy5faGFuZGxlVmlkZW9VUkxDaGFuZ2V9XG5cdFx0XHRcdFx0XHRvbktleURvd249e3RoaXMuX2hhbmRsZUtleURvd259XG5cdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj17aW5wdXRQbGFjZWhvbGRlcn1cblx0XHRcdFx0XHRcdHJlZj1cImxpbmtJbnB1dFwiXG5cdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0XHR2YWx1ZT17dGhpcy5zdGF0ZS52aWRlb1VSTH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY2xlYXJJbnB1dH1cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvbiBhZS1pY29uLXJlbW92ZVwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLl9jbGVhckxpbmt9XG5cdFx0XHRcdFx0XHRzdHlsZT17Y2xlYXJWaWRlb1VSTFN0eWxlfVxuXHRcdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY2xlYXJ9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbmZpcm19XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0XHRkaXNhYmxlZD17IXRoaXMuX2lzVmFsaWRTdGF0ZSgpfVxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX2VtYmVkVmlkZW9VUkx9XG5cdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29uZmlybX0+XG5cdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiY2hlY2tcIiAvPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIHRoZSBsaW5rIGlucHV0LiBUaGlzIG9ubHkgY2hhbmdlcyB0aGUgY29tcG9uZW50IGludGVybmFsIHN0YXRlLCBidXQgZG9lcyBub3Rcblx0ICogYWZmZWN0IHRoZSBsaW5rIGVsZW1lbnQgb2YgdGhlIGVkaXRvci4gT25seSB0aGUgX3JlbW92ZUxpbmsgYW5kIF91cGRhdGVMaW5rIG1ldGhvZHNcblx0ICogYXJlIHRyYW5zbGF0ZWQgdG8gdGhlIGVkaXRvciBlbGVtZW50LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkVmlkZW9FZGl0XG5cdCAqIEBtZXRob2QgX2NsZWFyTGlua1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfY2xlYXJMaW5rKCkge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0dmlkZW9VUkw6ICcnLFxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJzIHRoZSBlbWJlZFZpZGVvVXJsIGNvbW1hbmQgdG8gdHJhbnNmb3JtIHRoZSBsaW5rIGludG8gYW4gZW1iZWQgbWVkaWEgb2JqZWN0XG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgRW1iZWRWaWRlb0VkaXRcblx0ICogQG1ldGhvZCBfZW1iZWRWaWRlb1VSTFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfZW1iZWRWaWRlb1VSTCA9ICgpID0+IHtcblx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRuYXRpdmVFZGl0b3IuZXhlY0NvbW1hbmQoJ2VtYmVkVXJsJywge1xuXHRcdFx0dHlwZTogJ3ZpZGVvJyxcblx0XHRcdHVybDogdGhpcy5zdGF0ZS52aWRlb1VSTCxcblx0XHR9KTtcblxuXHRcdC8vIFdlIG5lZWQgdG8gY2FuY2VsRXhjbHVzaXZlIHdpdGggdGhlIGJvdW5kIHBhcmFtZXRlcnMgaW4gY2FzZSB0aGUgYnV0dG9uIGlzIHVzZWRcblx0XHQvLyBpbnNpZGUgYW5vdGhlciBpbiBleGNsdXNpdmUgbW9kZSAoc3VjaCBpcyB0aGUgY2FzZSBvZiB0aGUgbGluayBidXR0b24pXG5cdFx0dGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcblx0fTtcblxuXHQvKipcblx0ICogRm9jdXNlcyB0aGUgdXNlciBjdXJzb3Igb24gdGhlIHdpZGdldCdzIGlucHV0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkVmlkZW9FZGl0XG5cdCAqIEBtZXRob2QgX2ZvY3VzVmlkZW9VcmxJbnB1dFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfZm9jdXNWaWRlb1VybElucHV0ID0gKCkgPT4ge1xuXHRcdFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMucmVmcy5saW5rSW5wdXQpLmZvY3VzKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1vbml0b3JzIGtleSBpbnRlcmFjdGlvbiBpbnNpZGUgdGhlIGlucHV0IGVsZW1lbnQgdG8gcmVzcG9uZCB0byB0aGUga2V5czpcblx0ICogLSBFbnRlcjogQ3JlYXRlcy91cGRhdGVzIHRoZSBsaW5rLlxuXHQgKiAtIEVzY2FwZTogRGlzY2FyZHMgdGhlIGNoYW5nZXMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRWaWRlb0VkaXRcblx0ICogQG1ldGhvZCBfaGFuZGxlS2V5RG93blxuXHQgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUga2V5Ym9hcmQgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9oYW5kbGVLZXlEb3duID0gZXZlbnQgPT4ge1xuXHRcdGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRU5URVIgfHwgZXZlbnQua2V5Q29kZSA9PT0gS0VZX0VTQykge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gS0VZX0VOVEVSKSB7XG5cdFx0XHR0aGlzLl9lbWJlZFZpZGVvVVJMKCk7XG5cdFx0fSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRVNDKSB7XG5cdFx0XHR0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgY29tcG9uZW50IHN0YXRlIHdoZW4gdGhlIGxpbmsgaW5wdXQgY2hhbmdlcyBvbiB1c2VyIGludGVyYWN0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkVmlkZW9FZGl0XG5cdCAqIEBtZXRob2QgX2hhbmRsZVZpZGVvVVJMQ2hhbmdlXG5cdCAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBjaGFuZ2UgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9oYW5kbGVWaWRlb1VSTENoYW5nZSA9IGV2ZW50ID0+IHtcblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdHZpZGVvVVJMOiBldmVudC50YXJnZXQudmFsdWUsXG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFZlcmlmaWVzIHRoYXQgdGhlIGN1cnJlbnQgbGluayBzdGF0ZSBpcyB2YWxpZCBzbyB0aGUgdXNlciBjYW4gc2F2ZSB0aGUgbGluay4gQSB2YWxpZCBzdGF0ZVxuXHQgKiBtZWFucyB0aGF0IHdlIGhhdmUgYSBub24tZW1wdHkgdmlkZW9VUkwgdGhhdCdzIGRpZmZlcmVudCBmcm9tIHRoZSBvcmlnaW5hbCBvbmUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgRW1iZWRWaWRlb0VkaXRcblx0ICogQG1ldGhvZCBfaXNWYWxpZFN0YXRlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3RhdGUgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0X2lzVmFsaWRTdGF0ZSgpIHtcblx0XHRjb25zdCB2YWxpZFN0YXRlID1cblx0XHRcdHRoaXMuc3RhdGUudmlkZW9VUkwgJiZcblx0XHRcdHRoaXMuc3RhdGUudmlkZW9VUkwgIT09IHRoaXMuc3RhdGUuaW5pdGlhbEVtYmVkLnZpZGVvVVJMO1xuXG5cdFx0cmV0dXJuIHZhbGlkU3RhdGU7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRWRpdG9yQ29udGV4dC50b1Byb3BzKEJ1dHRvbkVtYmVkVmlkZW9FZGl0KTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25FbWJlZFZpZGVvRWRpdCBmcm9tICcuL2J1dHRvbi1lbWJlZC12aWRlby1lZGl0LmpzeCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkVtYmVkVmlkZW8gY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2hhbmdpbmcgdGV4dCBjb2xvciBpbiBhIGRvY3VtZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25FbWJlZFZpZGVvXG4gKi9cbmNsYXNzIEJ1dHRvbkVtYmVkVmlkZW8gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMga2V5ID0gJ2VtYmVkVmlkZW8nO1xuXG5cdHN0YXRpYyBwcm9wVHlwZXMgPSB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIGxhYmVsIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGFjY2Vzc2liaWxpdHkgcHVycG9zZXMuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRWaWRlb1xuXHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBsYWJlbFxuXHRcdCAqL1xuXHRcdGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRhYkluZGV4IG9mIHRoZSBidXR0b24gaW4gaXRzIHRvb2xiYXIgY3VycmVudCBzdGF0ZS4gQSB2YWx1ZSBvdGhlciB0aGFuIC0xXG5cdFx0ICogbWVhbnMgdGhhdCB0aGUgYnV0dG9uIGhhcyBmb2N1cyBhbmQgaXMgdGhlIGFjdGl2ZSBlbGVtZW50LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkVmlkZW9cblx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gdGFiSW5kZXhcblx0XHQgKi9cblx0XHR0YWJJbmRleDogUHJvcFR5cGVzLm51bWJlcixcblx0fTtcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcblx0XHRcdHJldHVybiA8QnV0dG9uRW1iZWRWaWRlb0VkaXQgey4uLnRoaXMucHJvcHN9IC8+O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy52aWRlb31cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1lbWJlZC12aWRlb1wiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5wcm9wcy5yZXF1ZXN0RXhjbHVzaXZlfVxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnZpZGVvfT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJ2aWRlb1wiIC8+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0KTtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uRW1iZWRWaWRlbztcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbktleXN0cm9rZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1rZXlzdHJva2UnO1xuaW1wb3J0IEJ1dHRvbkVtYmVkRWRpdCBmcm9tICcuL2J1dHRvbi1lbWJlZC1lZGl0LmpzeCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkVtYmVkIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIGFuZCBlZGl0aW5nIGFuIGVtYmVkIGxpbmsgaW4gYSBkb2N1bWVudC5cbiAqIEJ1dHRvbkVtYmVkIHJlbmRlcnMgaW4gdHdvIGRpZmZlcmVudCBtb2RlczpcbiAqXG4gKiAtIE5vcm1hbDogSnVzdCBhIGJ1dHRvbiB0aGF0IGFsbG93cyB0byBzd2l0Y2ggdG8gdGhlIGVkaXRpb24gbW9kZVxuICogLSBFeGNsdXNpdmU6IFRoZSBCdXR0b25FbWJlZEVkaXQgVUkgd2l0aCBhbGwgdGhlIGxpbmsgZWRpdGlvbiBjb250cm9scy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uRW1iZWRcbiAqIEB1c2VzIEJ1dHRvbktleXN0cm9rZVxuICovXG5jbGFzcyBCdXR0b25FbWJlZCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGtleXN0cm9rZToge1xuXHRcdFx0Zm46ICdfcmVxdWVzdEV4Y2x1c2l2ZScsXG5cdFx0XHRrZXlzOiBDS0VESVRPUi5DVFJMICsgQ0tFRElUT1IuU0hJRlQgKyA3NiAvKiBMKi8sXG5cdFx0XHRuYW1lOiAnZW1iZWQnLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBlbWJlZFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2VtYmVkJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuXHRcdFx0cmV0dXJuIDxCdXR0b25FbWJlZEVkaXQgey4uLnRoaXMucHJvcHN9IC8+O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWVtYmVkXCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLl9yZXF1ZXN0RXhjbHVzaXZlfVxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmxpbmt9PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInBsdXNcIiAvPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlcXVlc3RzIHRoZSBsaW5rIGJ1dHRvbiB0byBiZSByZW5kZXJlZCBpbiBleGNsdXNpdmUgbW9kZSB0byBhbGxvdyB0aGUgZW1iZWRkaW5nIG9mIGEgbGluay5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFxuXHQgKiBAbWV0aG9kIF9yZXF1ZXN0RXhjbHVzaXZlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9yZXF1ZXN0RXhjbHVzaXZlID0gKCkgPT4ge1xuXHRcdHRoaXMucHJvcHMucmVxdWVzdEV4Y2x1c2l2ZShCdXR0b25FbWJlZC5rZXkpO1xuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25LZXlzdHJva2UoQnV0dG9uRW1iZWQpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQWN0aW9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tYWN0aW9uLXN0eWxlJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25IMSBjbGFzcyBwcm92aWRlcyB3cmFwcyBhIHNlbGVjdGlvbiBpbiBgaDFgIGVsZW1lbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkgxXG4gKiBAdXNlcyBCdXR0b25BY3Rpb25TdHlsZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25IMSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25IMVxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdHN0eWxlOiB7XG5cdFx0XHRlbGVtZW50OiAnaDEnLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBoMVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSDFcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2gxJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkgxXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuaDF9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWgxXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5hcHBseVN0eWxlfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuaDF9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJoMVwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkFjdGlvblN0eWxlKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25TdHlsZShCdXR0b25IMSkpKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkFjdGlvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWFjdGlvbi1zdHlsZSc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uSDIgY2xhc3MgcHJvdmlkZXMgd3JhcHMgYSBzZWxlY3Rpb24gaW4gYGgyYCBlbGVtZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25IMlxuICogQHVzZXMgQnV0dG9uQWN0aW9uU3R5bGVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uSDIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSDJcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRzdHlsZToge1xuXHRcdFx0ZWxlbWVudDogJ2gyJyxcblx0XHR9LFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgaDJcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkgyXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdoMic7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25IMlxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmgyfVxuXHRcdFx0XHRhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9XG5cdFx0XHRcdGNsYXNzTmFtZT17Y3NzQ2xhc3N9XG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1oMlwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuYXBwbHlTdHlsZX1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmgyfT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiaDJcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25BY3Rpb25TdHlsZShCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uU3R5bGUoQnV0dG9uSDIpKSk7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25IbGluZSBjbGFzcyBwcm92aWRlcyBpbnNlcnRzIGhvcml6b250YWwgbGluZS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSGxpbmVcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuY2xhc3MgQnV0dG9uSGxpbmUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSGxpbmVcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnaG9yaXpvbnRhbHJ1bGUnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgaGxpbmVcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkhsaW5lXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdobGluZSc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25IbGluZVxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmhvcml6b250YWxydWxlfVxuXHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24taGxpbmVcIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuaG9yaXpvbnRhbHJ1bGV9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJoclwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoQnV0dG9uSGxpbmUpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQnV0dG9uSWNvbih7Y2xhc3NOYW1lID0gJycsIHN5bWJvbH0pIHtcblx0cmV0dXJuIChcblx0XHQ8RWRpdG9yQ29udGV4dC5Db25zdW1lcj5cblx0XHRcdHsoe2VkaXRvcn0pID0+IHtcblx0XHRcdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdFx0XHRcdGNvbnN0IHNwcml0ZW1hcCA9IG5hdGl2ZUVkaXRvci5jb25maWcuc3ByaXRlbWFwIHx8ICcnO1xuXHRcdFx0XHRjb25zdCBwYXRoID0gYCR7c3ByaXRlbWFwfSMke3N5bWJvbH1gO1xuXHRcdFx0XHRjb25zdCBjbGFzc05hbWVQcmVmaXggPSBjbGFzc05hbWUgPyBgICR7Y2xhc3NOYW1lfWAgOiAnJztcblx0XHRcdFx0Y29uc3QgY29tYmluZWRDbGFzc05hbWUgPSBgYWUtc3ZnLWljb24ke2NsYXNzTmFtZVByZWZpeH1gO1xuXG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0PHN2ZyBjbGFzc05hbWU9e2NvbWJpbmVkQ2xhc3NOYW1lfSBoZWlnaHQ9XCIxOFwiIHdpZHRoPVwiMThcIj5cblx0XHRcdFx0XHRcdDx1c2UgaHJlZj17cGF0aH0gLz5cblx0XHRcdFx0XHQ8L3N2Zz5cblx0XHRcdFx0KTtcblx0XHRcdH19XG5cdFx0PC9FZGl0b3JDb250ZXh0LkNvbnN1bWVyPlxuXHQpO1xufVxuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkltYWdlQWxpZ25DZW50ZXIgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgYWxpZ25pbmcgYW4gaW1hZ2UgaW4gdGhlIGNlbnRlci5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSW1hZ2VBbGlnbkNlbnRlclxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvbkltYWdlQWxpZ25DZW50ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnbkNlbnRlclxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdqdXN0aWZ5Y2VudGVyJyxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IGltYWdlQ2VudGVyXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZUFsaWduQ2VudGVyXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdpbWFnZUNlbnRlcic7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZUFsaWduQ2VudGVyXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25DZW50ZXJ9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWltYWdlLWFsaWduLWNlbnRlclwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkNlbnRlcn0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImFsaWduLWltYWdlLWNlbnRlclwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbkNvbW1hbmRBY3RpdmUoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvbkltYWdlQWxpZ25DZW50ZXIpKVxuKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZEFjdGl2ZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZSc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25JbWFnZUFsaWduTGVmdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhbGlnbmluZyBhbiBpbWFnZSBvbiBsZWZ0LlxuICpcbiAqIEBjbGFzcyBCdXR0b25JbWFnZUFsaWduTGVmdFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvbkltYWdlQWxpZ25MZWZ0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25MZWZ0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ2p1c3RpZnlsZWZ0Jyxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IGltYWdlTGVmdFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnbkxlZnRcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2ltYWdlTGVmdCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZUFsaWduTGVmdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduTGVmdH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24taW1hZ2UtYWxpZ24tbGVmdFwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkxlZnR9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJhbGlnbi1pbWFnZS1sZWZ0XCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcblx0QnV0dG9uQ29tbWFuZEFjdGl2ZShCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uSW1hZ2VBbGlnbkxlZnQpKVxuKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZEFjdGl2ZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZSc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25JbWFnZUFsaWduUmlnaHQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgYWxpZ25pbmcgYW4gaW1hZ2Ugb24gcmlnaHQuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkltYWdlQWxpZ25SaWdodFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvbkltYWdlQWxpZ25SaWdodCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZUFsaWduUmlnaHRcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnanVzdGlmeXJpZ2h0Jyxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IGltYWdlUmlnaHRcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25SaWdodFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnaW1hZ2VSaWdodCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZUFsaWduUmlnaHRcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnblJpZ2h0fVxuXHRcdFx0XHRhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9XG5cdFx0XHRcdGNsYXNzTmFtZT17Y3NzQ2xhc3N9XG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1pbWFnZS1hbGlnbi1yaWdodFwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnblJpZ2h0fT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiYWxpZ24taW1hZ2UtcmlnaHRcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuXHRCdXR0b25Db21tYW5kQWN0aXZlKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25JbWFnZUFsaWduUmlnaHQpKVxuKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkltYWdlIGNsYXNzIGluc2VydHMgYW4gaW1hZ2UgdG8gdGhlIGNvbnRlbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkltYWdlXG4gKi9cbmNsYXNzIEJ1dHRvbkltYWdlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IGltYWdlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnaW1hZ2VGcm9tRmlsZSc7XG5cblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cdFx0dGhpcy5maWxlSW5wdXQgPSBSZWFjdC5jcmVhdGVSZWYoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2Vcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgaW5wdXRTeWxlID0ge2Rpc3BsYXk6ICdub25lJ307XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdj5cblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuaW1hZ2V9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24taW1hZ2VcIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9XG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuaW1hZ2V9PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImRvY3VtZW50LWltYWdlXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cblx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0YWNjZXB0PVwiaW1hZ2UvKlwiXG5cdFx0XHRcdFx0b25DaGFuZ2U9e3RoaXMuX29uSW5wdXRDaGFuZ2V9XG5cdFx0XHRcdFx0cmVmPXt0aGlzLmZpbGVJbnB1dH1cblx0XHRcdFx0XHRzdHlsZT17aW5wdXRTeWxlfVxuXHRcdFx0XHRcdHR5cGU9XCJmaWxlXCJcblx0XHRcdFx0Lz5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogU2ltdWxhdGVzIGNsaWNrIG9uIHRoZSBpbnB1dCBlbGVtZW50LiBUaGlzIHdpbGwgb3BlbiBicm93c2VyJ3MgbmF0aXZlIGZpbGUgb3BlbiBkaWFsb2cuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2Vcblx0ICogQG1ldGhvZCBoYW5kbGVDbGlja1xuXHQgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgcmVjZWl2ZWQgY2xpY2sgZXZlbnQgb24gdGhlIGJ1dHRvbi5cblx0ICovXG5cdGhhbmRsZUNsaWNrID0gKCkgPT4ge1xuXHRcdHRoaXMuZmlsZUlucHV0LmN1cnJlbnQuY2xpY2soKTtcblx0fTtcblxuXHQvKipcblx0ICogT24gaW5wdXQgY2hhbmdlLCByZWFkcyB0aGUgY2hvc2VuIGZpbGUgYW5kIGZpcmVzIGFuIGV2ZW50IGBiZWZvcmVJbWFnZUFkZGAgd2l0aCB0aGUgaW1hZ2Ugd2hpY2ggd2lsbCBiZSBhZGRlZFxuXHQgKiB0byB0aGUgY29udGVudC4gVGhlIGltYWdlIGZpbGUgd2lsbCBiZSBwYXNzZWQgaW4gdGhlIGBpbWFnZUZpbGVzYCBwcm9wZXJ0eS5cblx0ICogSWYgYW55IG9mIHRoZSBsaXN0ZW5lcnMgcmV0dXJucyBgZmFsc2VgIG9yIGNhbmNlbHMgdGhlIGV2ZW50LCB0aGUgaW1hZ2Ugd29uJ3QgYmUgYWRkZWQgdG8gdGhlIGNvbnRlbnQuXG5cdCAqIE90aGVyd2lzZSwgYW4gZXZlbnQgYGltYWdlQWRkYCB3aWxsIGJlIGZpcmVkIHdpdGggdGhlIGluc2VydGVkIGVsZW1lbnQgaW50byB0aGUgZWRpdGFibGUgYXJlYS5cblx0ICogVGhlIHBhc3NlZCBwYXJhbXMgd2lsbCBiZTpcblx0ICogLSBgZWxgIC0gdGhlIGNyZWF0ZWQgaW1nIGVsZW1lbnRcblx0ICogLSBgZmlsZWAgLSB0aGUgb3JpZ2luYWwgaW1hZ2UgZmlsZSBmcm9tIHRoZSBpbnB1dCBlbGVtZW50XG5cdCAqXG5cdCAqIEBmaXJlcyBCdXR0b25JbWFnZSNiZWZvcmVJbWFnZUFkZFxuXHQgKiBAZmlyZXMgQnV0dG9uSW1hZ2UjaW1hZ2VBZGRcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZVxuXHQgKiBAbWV0aG9kIF9vbklucHV0Q2hhbmdlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9vbklucHV0Q2hhbmdlID0gKCkgPT4ge1xuXHRcdGNvbnN0IGlucHV0RWwgPSB0aGlzLmZpbGVJbnB1dC5jdXJyZW50O1xuXG5cdFx0Ly8gT24gSUUxMSB0aGUgZnVuY3Rpb24gbWlnaHQgYmUgY2FsbGVkIHdpdGggYW4gZW1wdHkgYXJyYXkgb2Zcblx0XHQvLyBmaWxlcy4gSW4gc3VjaCBhIGNhc2UsIG5vIGFjdGlvbnMgd2lsbCBiZSB0YWtlbi5cblx0XHRpZiAoIWlucHV0RWwuZmlsZXMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRjb25zdCBmaWxlID0gaW5wdXRFbC5maWxlc1swXTtcblxuXHRcdHJlYWRlci5vbmxvYWQgPSBldmVudCA9PiB7XG5cdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdGNvbnN0IHJlc3VsdCA9IGVkaXRvci5maXJlKCdiZWZvcmVJbWFnZUFkZCcsIHtcblx0XHRcdFx0aW1hZ2VGaWxlczogZmlsZSxcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdGNvbnN0IGVsID0gQ0tFRElUT1IuZG9tLmVsZW1lbnQuY3JlYXRlRnJvbUh0bWwoXG5cdFx0XHRcdFx0YDxpbWcgc3JjPVwiJHtldmVudC50YXJnZXQucmVzdWx0fVwiPmBcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRlZGl0b3IuaW5zZXJ0RWxlbWVudChlbCk7XG5cblx0XHRcdFx0ZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXG5cdFx0XHRcdGNvbnN0IGltYWdlRGF0YSA9IHtcblx0XHRcdFx0XHRlbCxcblx0XHRcdFx0XHRmaWxlLFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGVkaXRvci5maXJlKCdpbWFnZUFkZCcsIGltYWdlRGF0YSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuXG5cdFx0aW5wdXRFbC52YWx1ZSA9ICcnO1xuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25JbWFnZTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZEFjdGl2ZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZSc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25JbmRlbnRCbG9jayBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBpbmRlbnRpbmcgdGhlIHNlbGVjdGVkIGJsb2Nrcy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSW5kZW50QmxvY2tcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25JbmRlbnRCbG9jayBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbmRlbnRCbG9ja1xuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdpbmRlbnQnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgaW5kZW50QmxvY2tcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkluZGVudEJsb2NrXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdpbmRlbnRCbG9jayc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbmRlbnRCbG9ja1xuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmluZGVudH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24taW5kZW50LWJsb2NrXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmluZGVudH0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImluZGVudC1sZXNzXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcblx0QnV0dG9uQ29tbWFuZEFjdGl2ZShCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uSW5kZW50QmxvY2spKVxuKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uS2V5c3Ryb2tlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWtleXN0cm9rZSc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uSXRhbGljIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHN0eWxpbmcgYW4gc2VsZWN0aW9uIHdpdGggaXRhbGljIChlbSkgc3R5bGUuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkl0YWxpY1xuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uS2V5c3Ryb2tlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvbkl0YWxpYyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JdGFsaWNcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnaXRhbGljJyxcblx0XHRrZXlzdHJva2U6IHtcblx0XHRcdGZuOiAnZXhlY0NvbW1hbmQnLFxuXHRcdFx0a2V5czogQ0tFRElUT1IuQ1RSTCArIDczIC8qIEkqLyxcblx0XHRcdG5hbWU6ICdpdGFsaWMnLFxuXHRcdH0sXG5cdFx0c3R5bGU6ICdjb3JlU3R5bGVzX2l0YWxpYycsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBpdGFsaWNcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkl0YWxpY1xuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnaXRhbGljJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkl0YWxpY1xuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLml0YWxpY31cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24taXRhbGljXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLml0YWxpY30+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cIml0YWxpY1wiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbktleXN0cm9rZShCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uU3R5bGUoQnV0dG9uSXRhbGljKSkpXG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBAY2xhc3MgQnV0dG9uSXRlbVNlbGVjdG9yQXVkaW9cbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuY2xhc3MgQnV0dG9uSXRlbVNlbGVjdG9yQXVkaW8gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdhdWRpb3NlbGVjdG9yJyxcblx0fTtcblxuXHRzdGF0aWMga2V5ID0gJ2F1ZGlvJztcblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hdWRpb31cblx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWF1ZGlvXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5faGFuZGxlQ2xpY2t9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5hdWRpb30+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImF1ZGlvXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cblxuXHRfaGFuZGxlQ2xpY2sgPSAoKSA9PiB7XG5cdFx0dGhpcy5leGVjQ29tbWFuZChudWxsKTtcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChCdXR0b25JdGVtU2VsZWN0b3JBdWRpbyk7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIEBjbGFzcyBCdXR0b25JdGVtU2VsZWN0b3JJbWFnZVxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICovXG5jbGFzcyBCdXR0b25JdGVtU2VsZWN0b3JJbWFnZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ2ltYWdlc2VsZWN0b3InLFxuXHR9O1xuXG5cdHN0YXRpYyBrZXkgPSAnaW1hZ2UnO1xuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmltYWdlfVxuXHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24taW1hZ2VcIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLl9oYW5kbGVDbGlja31cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmltYWdlfT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwicGljdHVyZVwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG5cblx0X2hhbmRsZUNsaWNrID0gKCkgPT4ge1xuXHRcdHRoaXMuZXhlY0NvbW1hbmQobnVsbCk7XG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoQnV0dG9uSXRlbVNlbGVjdG9ySW1hZ2UpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBAY2xhc3MgQnV0dG9uSXRlbVNlbGVjdG9yVmlkZW9cbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuY2xhc3MgQnV0dG9uSXRlbVNlbGVjdG9yVmlkZW8gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICd2aWRlb3NlbGVjdG9yJyxcblx0fTtcblxuXHRzdGF0aWMga2V5ID0gJ3ZpZGVvJztcblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy52aWRlb31cblx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXZpZGVvXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5faGFuZGxlQ2xpY2t9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy52aWRlb30+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInZpZGVvXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cblxuXHRfaGFuZGxlQ2xpY2sgPSAoKSA9PiB7XG5cdFx0dGhpcy5leGVjQ29tbWFuZChudWxsKTtcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChCdXR0b25JdGVtU2VsZWN0b3JWaWRlbyk7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBXaWRnZXRGb2N1c01hbmFnZXIgZnJvbSAnLi4vYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlcic7XG5pbXBvcnQgQnV0dG9uRHJvcGRvd24gZnJvbSAnLi9idXR0b24tZHJvcGRvd24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3Igc2hvd2luZyBhIGxpc3Qgb2ZcbiAqIGl0ZW1zIHRoYXQgY2FuIGJlIHNlbGVjdGVkIGZvciB0aGUgbGluay5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3RcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNpcmN1bGFyOiBmYWxzZSxcblx0XHRkYXRhOiBbXSxcblx0XHRkZWxheTogMTAwLFxuXHRcdGRlc2NlbmRhbnRzOiAnLmFlLXRvb2xiYXItZWxlbWVudCcsXG5cdFx0a2V5czoge1xuXHRcdFx0ZGlzbWlzczogWzI3XSxcblx0XHRcdGRpc21pc3NOZXh0OiBbMzldLFxuXHRcdFx0ZGlzbWlzc1ByZXY6IFszN10sXG5cdFx0XHRuZXh0OiBbNDBdLFxuXHRcdFx0cHJldjogWzM4XSxcblx0XHR9LFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgYnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Rcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdidXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdCc7XG5cblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHR0aGlzLnN0YXRlID0ge1xuXHRcdFx0aXRlbXM6IFtdLFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVjZWl2aW5nIG5ldyBwcm9wcy5cblx0ICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG5cdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1xuXHQgKi9cblx0Y29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcblx0XHRpZiAoIW5leHRQcm9wcy50ZXJtIHx8IG5leHRQcm9wcy50ZXJtICE9PSB0aGlzLnByb3BzLnRlcm0pIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcblxuXHRcdFx0aWYgKG5leHRQcm9wcy50ZXJtKSB7XG5cdFx0XHRcdHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX3VwZGF0ZUl0ZW1zLCB0aGlzLnByb3BzLmRlbGF5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRcdGl0ZW1zOiBbXSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG5leHRQcm9wcy5hdXRvY29tcGxldGVTZWxlY3RlZCkge1xuXHRcdFx0c2V0VGltZW91dCh0aGlzLmZvY3VzLCAwKTtcblx0XHRcdHRoaXMucHJvcHMuc2V0QXV0b2NvbXBsZXRlU3RhdGUoe1xuXHRcdFx0XHRzZWxlY3RlZDogZmFsc2UsXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZnJvbSB0aGUgRE9NLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG5cdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcblx0ICovXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBsaXN0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICghdGhpcy5wcm9wcy5leHBhbmRlZCB8fCAhdGhpcy5zdGF0ZS5pdGVtcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8QnV0dG9uRHJvcGRvd24+XG5cdFx0XHRcdHt0aGlzLl9yZW5kZXJBdXRvY29tcGxldGVJdGVtcyh0aGlzLnN0YXRlLml0ZW1zKX1cblx0XHRcdDwvQnV0dG9uRHJvcGRvd24+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgYmVmb3JlIHJlbmRlcmluZyB3aGVuIG5ldyBwcm9wcyBvciBzdGF0ZSBhcmUgYmVpbmcgcmVjZWl2ZWQuXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlciBvciB3aGVuIGZvcmNlVXBkYXRlIGlzIHVzZWQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Rcblx0ICogQG1ldGhvZCAgc2hvdWxkQ29tcG9uZW50VXBkYXRlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgZmFsc2Ugd2hlbiB0aGUgdHJhbnNpdGlvbiB0byB0aGUgbmV3IHByb3BzIGFuZCBzdGF0ZSB3aWxsIG5vdFxuXHQgKiByZXF1aXJlIGEgY29tcG9uZW50IHVwZGF0ZS5cblx0ICovXG5cdHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuXHRcdHJldHVybiAoXG5cdFx0XHRuZXh0UHJvcHMuZXhwYW5kZWQgIT09IHRoaXMucHJvcHMuZXhwYW5kZWQgfHxcblx0XHRcdG5leHRQcm9wcy50ZXJtICE9PSB0aGlzLnByb3BzLnRlcm0gfHxcblx0XHRcdG5leHRTdGF0ZS5pdGVtcyAhPT0gdGhpcy5zdGF0ZS5pdGVtc1xuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVycyBhIHNldCBvZiBsaXN0IGl0ZW1zIGZvciB0aGUgcHJvdmlkZWQgaXRlbXNcblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuXHQgKiBAbWV0aG9kIF9yZW5kZXJBdXRvY29tcGxldGVJdGVtc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBpdGVtcyBMaXN0IG9mIGF1dG9jb21wbGV0ZSBpdGVtcyB0byByZW5kZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtBcnJheX0gUmVuZGVyZWQgbGlzdCBpdGVtIGluc3RhbmNlc1xuXHQgKi9cblx0X3JlbmRlckF1dG9jb21wbGV0ZUl0ZW1zKGl0ZW1zKSB7XG5cdFx0aXRlbXMgPSBpdGVtcyB8fCBbXTtcblxuXHRcdGNvbnN0IGhhbmRsZUxpbmtBdXRvY29tcGxldGVDbGljayA9IHRoaXMucHJvcHNcblx0XHRcdC5oYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2s7XG5cblx0XHRyZXR1cm4gaXRlbXMubWFwKGl0ZW0gPT4ge1xuXHRcdFx0Y29uc3QgY2xhc3NOYW1lID1cblx0XHRcdFx0dGhpcy5wcm9wcy50ZXJtID09PSBpdGVtLnVybFxuXHRcdFx0XHRcdD8gJ2FlLXRvb2xiYXItZWxlbWVudCBhY3RpdmUnXG5cdFx0XHRcdFx0OiAnYWUtdG9vbGJhci1lbGVtZW50JztcblxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PGxpIGtleT17aXRlbS51cmx9IHJvbGU9XCJvcHRpb25cIj5cblx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzTmFtZX1cblx0XHRcdFx0XHRcdGRhdGEtdmFsdWU9e2l0ZW0udXJsfVxuXHRcdFx0XHRcdFx0b25DbGljaz17aGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrfT5cblx0XHRcdFx0XHRcdHtpdGVtLnRpdGxlfVxuXHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0KTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgdGhlIGRhdGEgYWNjb3JkaW5nIHRvIHt0aGlzLnByb3BzLnRlcm19IGFuZCBjYWxscyBzZXRTdGF0ZSgpIHdpdGggdGhlIHJldHVybmVkIGRhdGFcblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuXHQgKiBAbWV0aG9kIF91cGRhdGVJdGVtc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfdXBkYXRlSXRlbXMoKSB7XG5cdFx0aWYgKCF0aGlzLnByb3BzLnRlcm0pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHRoaXMucHJvcHMuZGF0YSh0aGlzLnByb3BzLnRlcm0pKTtcblxuXHRcdHByb21pc2UudGhlbihpdGVtcyA9PiB7XG5cdFx0XHRpZiAoaXRlbXMubGVuZ3RoICYmICF0aGlzLnByb3BzLmV4cGFuZGVkKSB7XG5cdFx0XHRcdHRoaXMucHJvcHMudG9nZ2xlRHJvcGRvd24oKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRcdGl0ZW1zLFxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0Rm9jdXNNYW5hZ2VyKEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0KTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25LZXlzdHJva2UgZnJvbSAnLi4vYmFzZS9idXR0b24ta2V5c3Ryb2tlJztcbmltcG9ydCBCdXR0b25Qcm9wcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1wcm9wcyc7XG5pbXBvcnQgQnV0dG9uTGlua0VkaXRCcm93c2UgZnJvbSAnLi9idXR0b24tbGluay1lZGl0LWJyb3dzZS5qc3gnO1xuaW1wb3J0IEJ1dHRvbkxpbmsgZnJvbSAnLi9idXR0b24tbGluay5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25MaW5rQnJvd3NlIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNoYW5naW5nIHRleHQgY29sb3IgaW4gYSBkb2N1bWVudC5cbiAqXG4gKiBAdXNlcyBCdXR0b25LZXlzdHJva2VcbiAqIEB1c2VzIEJ1dHRvblByb3BzXG4gKlxuICogQGNsYXNzIEJ1dHRvbkxpbmtCcm93c2VcbiAqL1xuY2xhc3MgQnV0dG9uTGlua0Jyb3dzZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0a2V5c3Ryb2tlOiB7XG5cdFx0XHRmbjogJ19yZXF1ZXN0RXhjbHVzaXZlJyxcblx0XHRcdGtleXM6IENLRURJVE9SLkNUUkwgKyA3NiAvKiBMKi8sXG5cdFx0XHRuYW1lOiAnbGlua0Jyb3dzZScsXG5cdFx0fSxcblx0fTtcblxuXHRzdGF0aWMga2V5ID0gJ2xpbmtCcm93c2UnO1xuXG5cdHN0YXRpYyBwcm9wVHlwZXMgPSB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIGxhYmVsIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGFjY2Vzc2liaWxpdHkgcHVycG9zZXMuXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gbGFiZWxcblx0XHQgKi9cblx0XHRsYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0YWJJbmRleCBvZiB0aGUgYnV0dG9uIGluIGl0cyB0b29sYmFyIGN1cnJlbnQgc3RhdGUuIEEgdmFsdWUgb3RoZXIgdGhhbiAtMVxuXHRcdCAqIG1lYW5zIHRoYXQgdGhlIGJ1dHRvbiBoYXMgZm9jdXMgYW5kIGlzIHRoZSBhY3RpdmUgZWxlbWVudC5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0YWJJbmRleFxuXHRcdCAqL1xuXHRcdHRhYkluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuXHRcdFx0dGhpcy5wcm9wcyA9IHRoaXMubWVyZ2VCdXR0b25DZmdQcm9wcygpO1xuXG5cdFx0XHRyZXR1cm4gPEJ1dHRvbkxpbmtFZGl0QnJvd3NlIHsuLi50aGlzLnByb3BzfSAvPjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIDxCdXR0b25MaW5rIHsuLi50aGlzLnByb3BzfSAvPjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVxdWVzdHMgdGhlIGxpbmsgYnV0dG9uIHRvIGJlIHJlbmRlcmVkIGluIGV4Y2x1c2l2ZSBtb2RlIHRvIGFsbG93IHRoZSBjcmVhdGlvbiBvZiBhIGxpbmsuXG5cdCAqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCBfcmVxdWVzdEV4Y2x1c2l2ZVxuXHQgKi9cblx0X3JlcXVlc3RFeGNsdXNpdmUoKSB7XG5cdFx0dGhpcy5wcm9wcy5yZXF1ZXN0RXhjbHVzaXZlKEJ1dHRvbkxpbmtCcm93c2Uua2V5KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Qcm9wcyhCdXR0b25LZXlzdHJva2UoQnV0dG9uTGlua0Jyb3dzZSkpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25MaW5rRWRpdCBmcm9tICcuL2J1dHRvbi1saW5rLWVkaXQuanN4JztcblxuLyoqXG4gKiBUaGUgTGlua0VkaXRCcm93c2UgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgYW5kIGVkaXRpbmcgYSBsaW5rIGluIGEgZG9jdW1lbnQsXG4gKiBhbmQgYWxzbyBhbGxvd3MgdG8gbGluayB0byBhbiBleGlzdGluZyBmaWxlIGluIERNLlxuICogUHJvdmlkZXMgVUkgZm9yIGNyZWF0aW5nLCBlZGl0aW5nIGFuZCByZW1vdmluZyBhIGxpbmsuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkxpbmtFZGl0QnJvd3NlXG4gKi9cbmNsYXNzIEJ1dHRvbkxpbmtFZGl0QnJvd3NlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRzdGF0aWMga2V5ID0gJ2xpbmtFZGl0QnJvd3NlJztcblxuXHQvKipcblx0ICpcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXG5cdFx0Y29uc3QgbGluayA9IG5ldyBDS0VESVRPUi5MaW5rKFxuXHRcdFx0Ly8gQ2FuJ3QgYWNjZXNzIGNvbnRleHQgZnJvbSBjb25zdHJ1Y3Rvciwgc28gZ2V0IGVkaXRvciBmcm9tIHByb3BzLlxuXHRcdFx0dGhpcy5wcm9wcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpXG5cdFx0KS5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cblx0XHRjb25zdCBocmVmID0gbGluayA/IGxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJykgOiAnJztcblxuXHRcdHRoaXMubGlua0VkaXRCdXR0b25SZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcblxuXHRcdHRoaXMuc3RhdGUgPSB7XG5cdFx0XHRlbGVtZW50OiBsaW5rLFxuXHRcdFx0bGlua0hyZWY6IGhyZWYsXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1saW5rLWVkaXQtYnJvd3NlXCI+XG5cdFx0XHRcdDxCdXR0b25MaW5rRWRpdCByZWY9e3RoaXMubGlua0VkaXRCdXR0b25SZWZ9IHsuLi50aGlzLnByb3BzfSAvPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1sYWJlbD1cIkJyb3dzZVwiXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLl9icm93c2VDbGlja31cblx0XHRcdFx0XHR0aXRsZT1cImJyb3dzZVwiPlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImZvbGRlclwiIC8+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBPcGVucyBhbiBpdGVtIHNlbGVjdG9yIGRpYWxvZy5cblx0ICpcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kIF9icm93c2VDbGlja1xuXHQgKi9cblx0X2Jyb3dzZUNsaWNrID0gKCkgPT4ge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRjb25zdCB1cmwgPSBlZGl0b3IuY29uZmlnLmRvY3VtZW50QnJvd3NlTGlua1VybDtcblx0XHRjb25zdCBicm93c2VMaW5rQ2FsbGJhY2sgPSBlZGl0b3IuY29uZmlnLmRvY3VtZW50QnJvd3NlTGlua0NhbGxiYWNrO1xuXHRcdGNvbnN0IGxpbmtUYXJnZXQgPSB0aGlzLmxpbmtFZGl0QnV0dG9uUmVmLmN1cnJlbnRcblx0XHRcdD8gdGhpcy5saW5rRWRpdEJ1dHRvblJlZi5jdXJyZW50LnN0YXRlLmxpbmtUYXJnZXRcblx0XHRcdDogJyc7XG5cblx0XHRjb25zdCBjaGFuZ2VMaW5rQ2FsbGJhY2sgPSBzZWxlY3RlZEl0ZW0gPT4ge1xuXHRcdFx0dGhpcy5fdXBkYXRlTGluayhcblx0XHRcdFx0c2VsZWN0ZWRJdGVtLnZhbHVlLFxuXHRcdFx0XHRsaW5rVGFyZ2V0LFxuXHRcdFx0XHRzZWxlY3RlZEl0ZW0udGl0bGVcblx0XHRcdCk7XG5cdFx0fTtcblxuXHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oYnJvd3NlTGlua0NhbGxiYWNrKSkge1xuXHRcdFx0YnJvd3NlTGlua0NhbGxiYWNrLmFwcGx5KG51bGwsIFtlZGl0b3IsIHVybCwgY2hhbmdlTGlua0NhbGxiYWNrXSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBsaW5rIGluIHRoZSBlZGl0b3IgZWxlbWVudC4gSWYgdGhlIGVsZW1lbnQgZGlkbid0IGV4aXN0IHByZXZpb3VzbHksIGl0IHdpbGxcblx0ICogY3JlYXRlIGEgbmV3IDxhPiBlbGVtZW50IHdpdGggdGhlIGhyZWYgc3BlY2lmaWVkIGluIHRoZSBsaW5rIGlucHV0LlxuXHQgKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX3VwZGF0ZUxpbmtcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxpbmtIcmVmIGhyZWYgdmFsdWUgZm9yIHRoZSBsaW5rXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsaW5rVGFyZ2V0IHRhcmdldCB2YWx1ZSBmb3IgdGhlIGxpbmtcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxpbmtUaXRsZSBpZiB0aGUgbGluayBpcyBhIHRpdGxlIHRoYXQgcG9pbnRzIHRvIGEgd2lraSBwYWdlIChvbmx5IHdvcmtzIGZvciBjcmVvbGUpXG5cdCAqL1xuXHRfdXBkYXRlTGluayA9IChsaW5rSHJlZiwgbGlua1RhcmdldCwgbGlua1RpdGxlKSA9PiB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdGNvbnN0IGxpbmtVdGlscyA9IG5ldyBDS0VESVRPUi5MaW5rKGVkaXRvciwge2FwcGVuZFByb3RvY29sOiBmYWxzZX0pO1xuXHRcdGNvbnN0IGxpbmtBdHRycyA9IHtcblx0XHRcdHRhcmdldDogbGlua1RhcmdldCxcblx0XHR9O1xuXHRcdGNvbnN0IG1vZGlmeVNlbGVjdGlvbiA9IHthZHZhbmNlOiB0cnVlfTtcblxuXHRcdGlmIChsaW5rSHJlZikge1xuXHRcdFx0aWYgKGVkaXRvci5wbHVnaW5zICYmIGVkaXRvci5wbHVnaW5zLmNyZW9sZSAmJiAhbGlua1RpdGxlKSB7XG5cdFx0XHRcdGxpbmtIcmVmID0gbG9jYXRpb24ub3JpZ2luICsgbGlua0hyZWY7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLnN0YXRlLmVsZW1lbnQpIHtcblx0XHRcdFx0bGlua0F0dHJzLmhyZWYgPSBsaW5rSHJlZjtcblxuXHRcdFx0XHRsaW5rVXRpbHMudXBkYXRlKFxuXHRcdFx0XHRcdGxpbmtBdHRycyxcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmVsZW1lbnQsXG5cdFx0XHRcdFx0bW9kaWZ5U2VsZWN0aW9uXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsaW5rVXRpbHMuY3JlYXRlKGxpbmtIcmVmLCBsaW5rQXR0cnMsIG1vZGlmeVNlbGVjdGlvbik7XG5cdFx0XHR9XG5cblx0XHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0XHR9XG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVkaXRvckNvbnRleHQudG9Qcm9wcyhCdXR0b25MaW5rRWRpdEJyb3dzZSk7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuaW1wb3J0IFdpZGdldERyb3Bkb3duIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWRyb3Bkb3duJztcbmltcG9ydCBXaWRnZXRGb2N1c01hbmFnZXIgZnJvbSAnLi4vYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlcic7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QgZnJvbSAnLi9idXR0b24tbGluay1hdXRvY29tcGxldGUtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkxpbmtUYXJnZXRFZGl0IGZyb20gJy4vYnV0dG9uLWxpbmstdGFyZ2V0LWVkaXQuanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uTGlua0VkaXQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgYW5kIGVkaXRpbmcgYSBsaW5rIGluIGEgZG9jdW1lbnQuXG4gKiBQcm92aWRlcyBVSSBmb3IgY3JlYXRpbmcsIGVkaXRpbmcgYW5kIHJlbW92aW5nIGEgbGluay5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uTGlua0VkaXRcbiAqIEB1c2VzIFdpZGdldERyb3Bkb3duXG4gKiBAdXNlcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqL1xuY2xhc3MgQnV0dG9uTGlua0VkaXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGFwcGVuZFByb3RvY29sOiB0cnVlLFxuXHRcdGF1dG9jb21wbGV0ZVVybDogJycsXG5cdFx0Y2lyY3VsYXI6IHRydWUsXG5cdFx0Y3VzdG9tSW5kZXhTdGFydDogdHJ1ZSxcblx0XHRkZWZhdWx0TGlua1RhcmdldDogJycsXG5cdFx0ZGVzY2VuZGFudHM6ICcuYWUtdG9vbGJhci1lbGVtZW50Jyxcblx0XHRrZXlzOiB7XG5cdFx0XHRkaXNtaXNzOiBbMjddLFxuXHRcdFx0ZGlzbWlzc05leHQ6IFszOV0sXG5cdFx0XHRkaXNtaXNzUHJldjogWzM3XSxcblx0XHRcdG5leHQ6IFs0MF0sXG5cdFx0XHRwcmV2OiBbMzhdLFxuXHRcdH0sXG5cdFx0c2hvd1RhcmdldFNlbGVjdG9yOiB0cnVlLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgbGlua0VkaXRcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdsaW5rRWRpdCc7XG5cblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHR0aGlzLmxpbmtJbnB1dCA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXHRcdHRoaXMuc3RhdGUgPSB0aGlzLl9nZXRJbml0aWFsU3RhdGUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50LCBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuXHQgKlxuXHQgKiBGb2N1c2VzIG9uIHRoZSBsaW5rIGlucHV0IHRvIGltbWVkaWF0ZWx5IGFsbG93IGVkaXRpbmcuIFRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZSBjb21wb25lbnRcblx0ICogaXMgcmVuZGVyZWQgaW4gZXhjbHVzaXZlIG1vZGUgdG8gcHJldmVudCBhZ2dyZXNzaXZlIGZvY3VzIHN0ZWFsaW5nLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcblx0ICovXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSB8fCB0aGlzLnByb3BzLm1hbnVhbFNlbGVjdGlvbikge1xuXHRcdFx0Ly8gV2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUgYmVmb3JlIGZvY3VzaW5nIHRvIGF2b2lkIHVuZGVzaXJlZFxuXHRcdFx0Ly8gc2Nyb2xscyBvbiB0aGUgcGFnZVxuXHRcdFx0dGhpcy5fZm9jdXNMaW5rSW5wdXQoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVjZWl2aW5nIG5ldyBwcm9wcy5cblx0ICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG5cdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1xuXHQgKi9cblx0Y29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpIHtcblx0XHR0aGlzLnNldFN0YXRlKHRoaXMuX2dldEluaXRpYWxTdGF0ZSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IHRhcmdldFNlbGVjdG9yID0ge1xuXHRcdFx0YWxsb3dlZFRhcmdldHM6IHRoaXMucHJvcHMuYWxsb3dlZFRhcmdldHMsXG5cdFx0XHRlZGl0b3I6IHRoaXMuY29udGV4dC5lZGl0b3IsXG5cdFx0XHRoYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlOiB0aGlzLl9oYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlLFxuXHRcdFx0c2VsZWN0ZWRUYXJnZXQ6XG5cdFx0XHRcdHRoaXMuc3RhdGUubGlua1RhcmdldCB8fCBBbGxveUVkaXRvci5TdHJpbmdzLmxpbmtUYXJnZXREZWZhdWx0LFxuXHRcdH07XG5cblx0XHR0YXJnZXRTZWxlY3RvciA9IHRoaXMubWVyZ2VEcm9wZG93blByb3BzKFxuXHRcdFx0dGFyZ2V0U2VsZWN0b3IsXG5cdFx0XHRCdXR0b25MaW5rVGFyZ2V0RWRpdC5rZXlcblx0XHQpO1xuXG5cdFx0bGV0IGF1dG9jb21wbGV0ZURyb3Bkb3duO1xuXG5cdFx0aWYgKHRoaXMucHJvcHMuZGF0YSkge1xuXHRcdFx0bGV0IGRhdGFGbiA9IHRoaXMucHJvcHMuZGF0YTtcblxuXHRcdFx0aWYgKCFMYW5nLmlzRnVuY3Rpb24oZGF0YUZuKSkge1xuXHRcdFx0XHRjb25zdCBpdGVtcyA9IHRoaXMucHJvcHMuZGF0YTtcblxuXHRcdFx0XHRkYXRhRm4gPSAoKSA9PiBpdGVtcztcblx0XHRcdH1cblxuXHRcdFx0bGV0IGF1dG9jb21wbGV0ZURyb3Bkb3duUHJvcHMgPSB7XG5cdFx0XHRcdGF1dG9jb21wbGV0ZVNlbGVjdGVkOiB0aGlzLnN0YXRlLmF1dG9jb21wbGV0ZVNlbGVjdGVkLFxuXHRcdFx0XHRkYXRhOiBkYXRhRm4sXG5cdFx0XHRcdGVkaXRvcjogdGhpcy5jb250ZXh0LmVkaXRvcixcblx0XHRcdFx0aGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrOiB0aGlzLl9oYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2ssXG5cdFx0XHRcdG9uRGlzbWlzczogdGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bixcblx0XHRcdFx0c2V0QXV0b2NvbXBsZXRlU3RhdGU6IHRoaXMuX3NldEF1dG9jb21wbGV0ZVN0YXRlLFxuXHRcdFx0XHR0ZXJtOiB0aGlzLnN0YXRlLmxpbmtIcmVmLFxuXHRcdFx0fTtcblxuXHRcdFx0YXV0b2NvbXBsZXRlRHJvcGRvd25Qcm9wcyA9IHRoaXMubWVyZ2VEcm9wZG93blByb3BzKFxuXHRcdFx0XHRhdXRvY29tcGxldGVEcm9wZG93blByb3BzLFxuXHRcdFx0XHRCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdC5rZXlcblx0XHRcdCk7XG5cblx0XHRcdGF1dG9jb21wbGV0ZURyb3Bkb3duID0gKFxuXHRcdFx0XHQ8QnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Qgey4uLmF1dG9jb21wbGV0ZURyb3Bkb3duUHJvcHN9IC8+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGxldCBidXR0b25DbGVhckxpbms7XG5cblx0XHRpZiAodGhpcy5zdGF0ZS5saW5rSHJlZikge1xuXHRcdFx0YnV0dG9uQ2xlYXJMaW5rID0gKFxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5jbGVhcklucHV0fVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvbiBhZS1idXR0b24tY2xlYXJcIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX2NsZWFyTGlua31cblx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5jbGVhcn0+XG5cdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwidGltZXMtY2lyY2xlXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHBsYWNlaG9sZGVyUHJvcCA9IHt9O1xuXG5cdFx0aWYgKCFDS0VESVRPUi5lbnYuaWUgJiYgQWxsb3lFZGl0b3IuU3RyaW5ncykge1xuXHRcdFx0cGxhY2Vob2xkZXJQcm9wLnBsYWNlaG9sZGVyID0gQWxsb3lFZGl0b3IuU3RyaW5ncy5lZGl0TGluaztcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZWRpdC1saW5rXCI+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnJlbW92ZUxpbmt9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0XHRkaXNhYmxlZD17IXRoaXMuc3RhdGUuZWxlbWVudH1cblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLl9yZW1vdmVMaW5rfVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnJlbW92ZX0+XG5cdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiY2hhaW4tYnJva2VuXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWlucHV0IHh4bFwiPlxuXHRcdFx0XHRcdHt0aGlzLnByb3BzLnNob3dUYXJnZXRTZWxlY3RvciAmJiAoXG5cdFx0XHRcdFx0XHQ8QnV0dG9uTGlua1RhcmdldEVkaXQgey4uLnRhcmdldFNlbGVjdG9yfSAvPlxuXHRcdFx0XHRcdCl9XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItaW5wdXRcIj5cblx0XHRcdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1pbnB1dFwiXG5cdFx0XHRcdFx0XHRcdG9uQ2hhbmdlPXt0aGlzLl9oYW5kbGVMaW5rSHJlZkNoYW5nZX1cblx0XHRcdFx0XHRcdFx0b25LZXlEb3duPXt0aGlzLl9oYW5kbGVLZXlEb3dufVxuXHRcdFx0XHRcdFx0XHR7Li4ucGxhY2Vob2xkZXJQcm9wfVxuXHRcdFx0XHRcdFx0XHRyZWY9e3RoaXMubGlua0lucHV0fVxuXHRcdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0XHRcdHZhbHVlPXt0aGlzLnN0YXRlLmxpbmtIcmVmfVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdHthdXRvY29tcGxldGVEcm9wZG93bn1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHR7YnV0dG9uQ2xlYXJMaW5rfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29uZmlybX1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdGRpc2FibGVkPXshdGhpcy5faXNWYWxpZFN0YXRlKCl9XG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5fdXBkYXRlTGlua31cblx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5jb25maXJtfT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBjbGFzc05hbWU9XCJhZS1pY29uLXN2Zy1jaGVja1wiIHN5bWJvbD1cImNoZWNrXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoaXMuc3RhdGUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBfZ2V0SW5pdGlhbFN0YXRlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKi9cblx0X2dldEluaXRpYWxTdGF0ZSgpIHtcblx0XHQvLyBDYW4ndCBhY2Nlc3MgY29udGV4dCBmcm9tIGNvbnRydWN0b3IsIHNvIGdldCBlZGl0b3IgZnJvbSBwcm9wcy5cblx0XHRjb25zdCB7ZWRpdG9yfSA9IHRoaXMucHJvcHMuY29udGV4dDtcblx0XHRjb25zdCB7ZGVmYXVsdExpbmtUYXJnZXR9ID0gdGhpcy5wcm9wcztcblxuXHRcdGNvbnN0IGxpbmsgPSBuZXcgQ0tFRElUT1IuTGluayhcblx0XHRcdGVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpXG5cdFx0KS5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cdFx0Y29uc3QgaHJlZiA9IChsaW5rICYmIGxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJykpIHx8ICcnO1xuXHRcdGNvbnN0IHRhcmdldCA9XG5cdFx0XHQobGluayAmJiBsaW5rLmdldEF0dHJpYnV0ZSgndGFyZ2V0JykpIHx8IGRlZmF1bHRMaW5rVGFyZ2V0O1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGF1dG9jb21wbGV0ZVNlbGVjdGVkOiBmYWxzZSxcblx0XHRcdGVsZW1lbnQ6IGxpbmssXG5cdFx0XHRpbml0aWFsTGluazoge1xuXHRcdFx0XHRocmVmLFxuXHRcdFx0XHR0YXJnZXQsXG5cdFx0XHR9LFxuXHRcdFx0bGlua0hyZWY6IGhyZWYsXG5cdFx0XHRsaW5rVGFyZ2V0OiB0YXJnZXQsXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIGxpbmsgaW5wdXQuIFRoaXMgb25seSBjaGFuZ2VzIHRoZSBjb21wb25lbnQgaW50ZXJuYWwgc3RhdGUsIGJ1dCBkb2VzIG5vdFxuXHQgKiBhZmZlY3QgdGhlIGxpbmsgZWxlbWVudCBvZiB0aGUgZWRpdG9yLiBPbmx5IHRoZSBfcmVtb3ZlTGluayBhbmQgX3VwZGF0ZUxpbmsgbWV0aG9kc1xuXHQgKiBhcmUgdHJhbnNsYXRlZCB0byB0aGUgZWRpdG9yIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBfY2xlYXJMaW5rXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9jbGVhckxpbmsgPSAoKSA9PiB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRsaW5rSHJlZjogJycsXG5cdFx0fSk7XG5cblx0XHR0aGlzLl9mb2N1c0xpbmtJbnB1dCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb2N1c2VzIHRoZSB1c2VyIGN1cnNvciBvbiB0aGUgd2lkZ2V0J3MgaW5wdXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBfZm9jdXNMaW5rSW5wdXRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2ZvY3VzTGlua0lucHV0KCkge1xuXHRcdGNvbnN0IGluc3RhbmNlID0gdGhpcztcblxuXHRcdGNvbnN0IGZvY3VzTGlua0VsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpbnN0YW5jZS5saW5rSW5wdXQuY3VycmVudC5mb2N1cygpO1xuXHRcdH07XG5cblx0XHRpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmb2N1c0xpbmtFbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNldFRpbWVvdXQoZm9jdXNMaW5rRWwsIDApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBNb25pdG9ycyBrZXkgaW50ZXJhY3Rpb24gaW5zaWRlIHRoZSBpbnB1dCBlbGVtZW50IHRvIHJlc3BvbmQgdG8gdGhlIGtleXM6XG5cdCAqIC0gRW50ZXI6IENyZWF0ZXMvdXBkYXRlcyB0aGUgbGluay5cblx0ICogLSBFc2NhcGU6IERpc2NhcmRzIHRoZSBjaGFuZ2VzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG5cdCAqIEBtZXRob2QgX2hhbmRsZUtleURvd25cblx0ICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgVGhlIGtleWJvYXJkIGV2ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfaGFuZGxlS2V5RG93biA9IGV2ZW50ID0+IHtcblx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMgfHwgZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LmtleUNvZGUgPT09IDEzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVMaW5rKCk7XG5cdFx0fSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSA0MCkge1xuXHRcdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRcdGF1dG9jb21wbGV0ZVNlbGVjdGVkOiB0cnVlLFxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0XHRuZXcgQ0tFRElUT1IuTGluayhlZGl0b3IpLmFkdmFuY2VTZWxlY3Rpb24oKTtcblxuXHRcdFx0dGhpcy5jb250ZXh0LmVkaXRvclxuXHRcdFx0XHQuZ2V0KCduYXRpdmVFZGl0b3InKVxuXHRcdFx0XHQuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQgc3RhdGUgd2hlbiB0aGUgbGluayBpbnB1dCBjaGFuZ2VzIG9uIHVzZXIgaW50ZXJhY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBfaGFuZGxlTGlua0hyZWZDaGFuZ2Vcblx0ICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgVGhlIGNoYW5nZSBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2hhbmRsZUxpbmtIcmVmQ2hhbmdlID0gZXZlbnQgPT4ge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0bGlua0hyZWY6IGV2ZW50LnRhcmdldC52YWx1ZSxcblx0XHR9KTtcblxuXHRcdHRoaXMuX2ZvY3VzTGlua0lucHV0KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCBzdGF0ZSB3aGVuIHRoZSBsaW5rIHRhcmdldCBjaGFuZ2VzIG9uIHVzZXIgaW50ZXJhY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBfaGFuZGxlTGlua1RhcmdldENoYW5nZVxuXHQgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgY2xpY2sgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9oYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlID0gZXZlbnQgPT4ge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0aXRlbURyb3Bkb3duOiBudWxsLFxuXHRcdFx0bGlua1RhcmdldDogZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpLFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fZm9jdXNMaW5rSW5wdXQoKTtcblx0fTtcblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgY29tcG9uZW50IHN0YXRlIHdoZW4gYW4gYXV0b2NvbXBsZXRlIGxpbmsgcmVzdWx0IGlzIHNlbGVjdGVkIGJ5IHVzZXIgaW50ZXJhY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBfaGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrXG5cdCAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBjbGljayBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2hhbmRsZUxpbmtBdXRvY29tcGxldGVDbGljayhldmVudCkge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0aXRlbURyb3Bkb3duOiBudWxsLFxuXHRcdFx0bGlua0hyZWY6IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKSxcblx0XHR9KTtcblxuXHRcdHRoaXMuX2ZvY3VzTGlua0lucHV0KCk7XG5cdH1cblxuXHQvKipcblx0ICogVmVyaWZpZXMgdGhhdCB0aGUgY3VycmVudCBsaW5rIHN0YXRlIGlzIHZhbGlkIHNvIHRoZSB1c2VyIGNhbiBzYXZlIHRoZSBsaW5rLiBBIHZhbGlkIHN0YXRlXG5cdCAqIG1lYW5zIHRoYXQgd2UgaGF2ZSBhIG5vbi1lbXB0eSBocmVmIGFuZCB0aGF0IGVpdGhlciB0aGF0IG9yIHRoZSBsaW5rIHRhcmdldCBhcmUgZGlmZmVyZW50XG5cdCAqIGZyb20gdGhlIG9yaWdpbmFsIGxpbmsuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBfaXNWYWxpZFN0YXRlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gW2Rlc2NyaXB0aW9uXVxuXHQgKi9cblx0X2lzVmFsaWRTdGF0ZSgpIHtcblx0XHRjb25zdCB2YWxpZFN0YXRlID1cblx0XHRcdHRoaXMuc3RhdGUubGlua0hyZWYgJiZcblx0XHRcdCh0aGlzLnN0YXRlLmxpbmtIcmVmICE9PSB0aGlzLnN0YXRlLmluaXRpYWxMaW5rLmhyZWYgfHxcblx0XHRcdFx0dGhpcy5zdGF0ZS5saW5rVGFyZ2V0ICE9PSB0aGlzLnN0YXRlLmluaXRpYWxMaW5rLnRhcmdldCk7XG5cblx0XHRyZXR1cm4gdmFsaWRTdGF0ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBsaW5rIGluIHRoZSBlZGl0b3IgZWxlbWVudC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuXHQgKiBAbWV0aG9kIF9yZW1vdmVMaW5rXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9yZW1vdmVMaW5rID0gKCkgPT4ge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRjb25zdCBsaW5rVXRpbHMgPSBuZXcgQ0tFRElUT1IuTGluayhlZGl0b3IpO1xuXHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRjb25zdCBib29rbWFya3MgPSBzZWxlY3Rpb24uY3JlYXRlQm9va21hcmtzKCk7XG5cblx0XHRsaW5rVXRpbHMucmVtb3ZlKHRoaXMuc3RhdGUuZWxlbWVudCwge2FkdmFuY2U6IHRydWV9KTtcblxuXHRcdHNlbGVjdGlvbi5zZWxlY3RCb29rbWFya3MoYm9va21hcmtzKTtcblxuXHRcdC8vIFdlIG5lZWQgdG8gY2FuY2VsRXhjbHVzaXZlIHdpdGggdGhlIGJvdW5kIHBhcmFtZXRlcnMgaW4gY2FzZSB0aGUgYnV0dG9uIGlzIHVzZWRcblx0XHQvLyBpbnNpZGUgYW5vdGhlciBpbiBleGNsdXNpdmUgbW9kZSAoc3VjaCBpcyB0aGUgY2FzZSBvZiB0aGUgbGluayBidXR0b24pXG5cdFx0dGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcblxuXHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogVXBkYXRlIGF1dG9jb21wbGV0ZVNlbGVjdGVkIHN0YXRlIHRvIGZvY3VzIGFuZCBzZWxlY3QgYXV0b2NvbXBsZXRlwrRzIGRyb3Bkb3duXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBfc2V0QXV0b2NvbXBsZXRlU3RhdGVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3NldEF1dG9jb21wbGV0ZVN0YXRlKHN0YXRlKSB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRhdXRvY29tcGxldGVTZWxlY3RlZDogc3RhdGUuc2VsZWN0ZWQsXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgbGluayBpbiB0aGUgZWRpdG9yIGVsZW1lbnQuIElmIHRoZSBlbGVtZW50IGRpZG4ndCBleGlzdCBwcmV2aW91c2x5LCBpdCB3aWxsXG5cdCAqIGNyZWF0ZSBhIG5ldyA8YT4gZWxlbWVudCB3aXRoIHRoZSBocmVmIHNwZWNpZmllZCBpbiB0aGUgbGluayBpbnB1dC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuXHQgKiBAbWV0aG9kIF91cGRhdGVMaW5rXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF91cGRhdGVMaW5rID0gKCkgPT4ge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRjb25zdCBsaW5rVXRpbHMgPSBuZXcgQ0tFRElUT1IuTGluayhlZGl0b3IsIHtcblx0XHRcdGFwcGVuZFByb3RvY29sOiB0aGlzLnByb3BzLmFwcGVuZFByb3RvY29sLFxuXHRcdH0pO1xuXHRcdGxldCBsaW5rQXR0cnMgPSB7XG5cdFx0XHR0YXJnZXQ6IHRoaXMuc3RhdGUubGlua1RhcmdldCB8fCBudWxsLFxuXHRcdH07XG5cdFx0Y29uc3QgbW9kaWZ5U2VsZWN0aW9uID0ge2FkdmFuY2U6IHRydWV9O1xuXG5cdFx0aWYgKHRoaXMuc3RhdGUubGlua0hyZWYpIHtcblx0XHRcdGlmICh0aGlzLnN0YXRlLmVsZW1lbnQpIHtcblx0XHRcdFx0bGlua0F0dHJzLmhyZWYgPSB0aGlzLnN0YXRlLmxpbmtIcmVmO1xuXG5cdFx0XHRcdGxpbmtVdGlscy51cGRhdGUoXG5cdFx0XHRcdFx0bGlua0F0dHJzLFxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuZWxlbWVudCxcblx0XHRcdFx0XHRtb2RpZnlTZWxlY3Rpb25cblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghdGhpcy5zdGF0ZS5saW5rVGFyZ2V0KSBsaW5rQXR0cnMgPSB7fTtcblxuXHRcdFx0XHRsaW5rVXRpbHMuY3JlYXRlKFxuXHRcdFx0XHRcdHRoaXMuc3RhdGUubGlua0hyZWYsXG5cdFx0XHRcdFx0bGlua0F0dHJzLFxuXHRcdFx0XHRcdG1vZGlmeVNlbGVjdGlvblxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgbmVlZCB0byBjYW5jZWxFeGNsdXNpdmUgd2l0aCB0aGUgYm91bmQgcGFyYW1ldGVycyBpbiBjYXNlIHRoZSBidXR0b24gaXMgdXNlZFxuXHRcdC8vIGluc2lkZSBhbm90aGVyIGluIGV4Y2x1c2l2ZSBtb2RlIChzdWNoIGlzIHRoZSBjYXNlIG9mIHRoZSBsaW5rIGJ1dHRvbilcblx0XHR0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBFZGl0b3JDb250ZXh0LnRvUHJvcHMoXG5cdFdpZGdldERyb3Bkb3duKFdpZGdldEZvY3VzTWFuYWdlcihCdXR0b25MaW5rRWRpdCkpXG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFyZ2V0TGlzdCBmcm9tICcuL2J1dHRvbi10YXJnZXQtbGlzdC5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25MaW5rVGFyZ2V0RWRpdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjaGFuZ2luZyB0aGUgdGFyZ2V0IG9mIGEgbGlua1xuICogaW4gdGhlIGRvY3VtZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25MaW5rVGFyZ2V0RWRpdFxuICovXG5jbGFzcyBCdXR0b25MaW5rVGFyZ2V0RWRpdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgbGlua1RhcmdldEVkaXRcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtUYXJnZXRFZGl0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdsaW5rVGFyZ2V0RWRpdCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rVGFyZ2V0RWRpdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBoYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlID0gdGhpcy5wcm9wcy5oYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlO1xuXHRcdGNvbnN0IGFsbG93ZWRMaW5rVGFyZ2V0cyA9IHRoaXMucHJvcHMuYWxsb3dlZFRhcmdldHM7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdlxuXHRcdFx0XHRjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24gYWUtY29udGFpbmVyLWRyb3Bkb3duLW1lZGl1bSBhZS1jb250YWluZXItZWRpdC1saW5rLXRhcmdldCBhZS1oYXMtZHJvcGRvd25cIlxuXHRcdFx0XHR0YWJJbmRleD1cIjBcIj5cblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9XG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17dGhpcy5wcm9wcy5zZWxlY3RlZFRhcmdldH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS10b29sYmFyLWVsZW1lbnRcIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259XG5cdFx0XHRcdFx0cm9sZT1cImNvbWJvYm94XCJcblx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHR0aXRsZT17dGhpcy5wcm9wcy5zZWxlY3RlZFRhcmdldH0+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXJcIj5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1kcm9wZG93bi1zZWxlY3RlZC1pdGVtXCI+XG5cdFx0XHRcdFx0XHRcdHt0aGlzLnByb3BzLnNlbGVjdGVkVGFyZ2V0fVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiY2FyZXQtYm90dG9tXCIgLz5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdHt0aGlzLnByb3BzLmV4cGFuZGVkICYmIChcblx0XHRcdFx0XHQ8QnV0dG9uVGFyZ2V0TGlzdFxuXHRcdFx0XHRcdFx0YWxsb3dlZExpbmtUYXJnZXRzPXthbGxvd2VkTGlua1RhcmdldHN9XG5cdFx0XHRcdFx0XHRoYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlPXtoYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlfVxuXHRcdFx0XHRcdFx0b25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdFx0c2VsZWN0ZWRUYXJnZXQ9e3RoaXMucHJvcHMuc2VsZWN0ZWRUYXJnZXR9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0KX1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIGJlZm9yZSByZW5kZXJpbmcgd2hlbiBuZXcgcHJvcHMgb3Igc3RhdGUgYXJlIGJlaW5nIHJlY2VpdmVkLlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIgb3Igd2hlbiBmb3JjZVVwZGF0ZSBpcyB1c2VkLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtUYXJnZXRFZGl0XG5cdCAqIEBtZXRob2QgIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGZhbHNlIHdoZW4gdGhlIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcyBhbmQgc3RhdGUgd2lsbCBub3Rcblx0ICogcmVxdWlyZSBhIGNvbXBvbmVudCB1cGRhdGUuXG5cdCAqL1xuXHRzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdG5leHRQcm9wcy5leHBhbmRlZCAhPT0gdGhpcy5wcm9wcy5leHBhbmRlZCB8fFxuXHRcdFx0bmV4dFByb3BzLnNlbGVjdGVkVGFyZ2V0ICE9PSB0aGlzLnByb3BzLnNlbGVjdGVkVGFyZ2V0XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25MaW5rVGFyZ2V0RWRpdDtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgQnV0dG9uS2V5c3Ryb2tlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWtleXN0cm9rZSc7XG5pbXBvcnQgQnV0dG9uUHJvcHMgZnJvbSAnLi4vYmFzZS9idXR0b24tcHJvcHMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25MaW5rRWRpdCBmcm9tICcuL2J1dHRvbi1saW5rLWVkaXQuanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uTGluayBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhbmQgZWRpdGluZyBhIGxpbmsgaW4gYSBkb2N1bWVudC4gQnV0dG9uTGlua1xuICogcmVuZGVycyBpbiB0d28gZGlmZmVyZW50IG1vZGVzOlxuICpcbiAqIC0gTm9ybWFsOiBKdXN0IGEgYnV0dG9uIHRoYXQgYWxsb3dzIHRvIHN3aXRjaCB0byB0aGUgZWRpdGlvbiBtb2RlXG4gKiAtIEV4Y2x1c2l2ZTogVGhlIEJ1dHRvbkxpbmtFZGl0IFVJIHdpdGggYWxsIHRoZSBsaW5rIGVkaXRpb24gY29udHJvbHMuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkxpbmtcbiAqIEB1c2VzIEJ1dHRvblByb3BzXG4gKiBAdXNlcyBCdXR0b25LZXlzdHJva2VcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25MaW5rIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua1xuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGtleXN0cm9rZToge1xuXHRcdFx0Zm46ICdfcmVxdWVzdEV4Y2x1c2l2ZScsXG5cdFx0XHRrZXlzOiBDS0VESVRPUi5DVFJMICsgNzYgLyogTCovLFxuXHRcdFx0bmFtZTogJ2xpbmsnLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBsaW5rXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdsaW5rJztcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBjb250YWluZWQgd2l0aGluIGEgbGluay5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rXG5cdCAqIEBtZXRob2QgaXNBY3RpdmVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIGlzIGluc2lkZSBhIGxpbmssIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG5cdGlzQWN0aXZlKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHRuZXcgQ0tFRElUT1IuTGluayhcblx0XHRcdFx0dGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpXG5cdFx0XHQpLmdldEZyb21TZWxlY3Rpb24oKSAhPT0gbnVsbFxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0aWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlKSB7XG5cdFx0XHRjb25zdCBwcm9wcyA9IHRoaXMubWVyZ2VCdXR0b25DZmdQcm9wcygpO1xuXG5cdFx0XHRyZXR1cm4gPEJ1dHRvbkxpbmtFZGl0IHsuLi5wcm9wc30gLz47XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmxpbmt9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tbGlua1wiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5fcmVxdWVzdEV4Y2x1c2l2ZX1cblx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rfT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJsaW5rXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0cyB0aGUgbGluayBidXR0b24gdG8gYmUgcmVuZGVyZWQgaW4gZXhjbHVzaXZlIG1vZGUgdG8gYWxsb3cgdGhlIGNyZWF0aW9uIG9mIGEgbGluay5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rXG5cdCAqIEBtZXRob2QgX3JlcXVlc3RFeGNsdXNpdmVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3JlcXVlc3RFeGNsdXNpdmUgPSAoKSA9PiB7XG5cdFx0dGhpcy5wcm9wcy5yZXF1ZXN0RXhjbHVzaXZlKEJ1dHRvbkxpbmsua2V5KTtcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uUHJvcHMoQnV0dG9uS2V5c3Ryb2tlKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25MaW5rKSkpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25PcmRlcmVkTGlzdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBvcmRlcmVkIGxpc3RzIGluIGFuIGVkaXRvci5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uT3JkZXJlZExpc3RcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uT3JkZXJlZExpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uT3JkZXJlZExpc3Rcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnbnVtYmVyZWRsaXN0Jyxcblx0XHRzdHlsZToge1xuXHRcdFx0ZWxlbWVudDogJ29sJyxcblx0XHR9LFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgb2xcblx0ICogQG1lbWJlcm9mIEJ1dHRvbk9yZGVyZWRMaXN0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdvbCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25PcmRlcmVkTGlzdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLm51bWJlcmVkbGlzdH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tb2xcIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MubnVtYmVyZWRsaXN0fT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwibGlzdC1vbFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25TdHlsZShCdXR0b25PcmRlcmVkTGlzdCkpXG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbk91dGRlbnRCbG9jayBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBvdXRkZW50aW5nIGJsb2Nrcy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uT3V0ZGVudEJsb2NrXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uT3V0ZGVudEJsb2NrIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbk91dGRlbnRCbG9ja1xuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdvdXRkZW50Jyxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IG91dGRlbnRCbG9ja1xuXHQgKiBAbWVtYmVyb2YgQnV0dG9uT3V0ZGVudEJsb2NrXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdvdXRkZW50QmxvY2snO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uT3V0ZGVudEJsb2NrXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3Mub3V0ZGVudH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tb3V0ZGVudC1ibG9ja1wiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5vdXRkZW50fT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiaW5kZW50LW1vcmVcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuXHRCdXR0b25Db21tYW5kQWN0aXZlKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25PdXRkZW50QmxvY2spKVxuKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZEFjdGl2ZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZSc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgYWxpZ25pbmcgYSBwYXJhZ3JhcGggb24gbGVmdC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0XG4gKlxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnRcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnanVzdGlmeWxlZnQnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgcGFyYWdyYXBoTGVmdFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdwYXJhZ3JhcGhMZWZ0JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduTGVmdH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tcGFyYWdyYXBoLWFsaWduLWxlZnRcIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25MZWZ0fT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiYWxpZ24tbGVmdFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbkNvbW1hbmRBY3RpdmUoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdCkpXG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgYWxpZ25pbmcgYSBwYXJhZ3JhcGggb24gcmlnaHQuXG4gKlxuICogQGNsYXNzIEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHRcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnanVzdGlmeXJpZ2h0Jyxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IHBhcmFncmFwaFJpZ2h0XG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdwYXJhZ3JhcGhSaWdodCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25SaWdodH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tcGFyYWdyYXBoLWFsaWduLXJpZ2h0XCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduUmlnaHR9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJhbGlnbi1yaWdodFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbkNvbW1hbmRBY3RpdmUoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHQpKVxuKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZHNMaXN0IGZyb20gJy4vYnV0dG9uLWNvbW1hbmRzLWxpc3QuanN4JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uUGFyYWdyYXBoQWxpZ24gY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byB3b3JrIHdpdGggdGFibGUgcm93cy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUGFyYWdyYXBoQWxpZ25cbiAqL1xuY2xhc3MgQnV0dG9uUGFyYWdyYXBoQWxpZ24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdHN0YXRpYyBrZXkgPSAncGFyYWdyYXBoQWxpZ24nO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQWxpZ25cblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IGJ1dHRvbkNvbW1hbmRzTGlzdDtcblx0XHRsZXQgYnV0dG9uQ29tbWFuZHNMaXN0SWQ7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5leHBhbmRlZCkge1xuXHRcdFx0YnV0dG9uQ29tbWFuZHNMaXN0SWQgPSBCdXR0b25QYXJhZ3JhcGhBbGlnbi5rZXkgKyAnTGlzdCc7XG5cdFx0XHRidXR0b25Db21tYW5kc0xpc3QgPSAoXG5cdFx0XHRcdDxCdXR0b25Db21tYW5kc0xpc3Rcblx0XHRcdFx0XHRjb21tYW5kcz17dGhpcy5fZ2V0Q29tbWFuZHMoKX1cblx0XHRcdFx0XHRpbmxpbmVJY29ucz17ZmFsc2V9XG5cdFx0XHRcdFx0bGlzdElkPXtidXR0b25Db21tYW5kc0xpc3RJZH1cblx0XHRcdFx0XHRvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259XG5cdFx0XHRcdC8+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGNvbnN0IGFjdGl2ZUNvbW1hbmQgPSB0aGlzLl9nZXRDb21tYW5kcygpXG5cdFx0XHQuZmlsdGVyKGFsaWdubWVudCA9PiB7XG5cdFx0XHRcdGNvbnN0IGNvbW1hbmQgPSBlZGl0b3IuZ2V0Q29tbWFuZChhbGlnbm1lbnQuY29tbWFuZCk7XG5cblx0XHRcdFx0cmV0dXJuIGNvbW1hbmQgPyBjb21tYW5kLnN0YXRlID09PSBDS0VESVRPUi5UUklTVEFURV9PTiA6IGZhbHNlO1xuXHRcdFx0fSlcblx0XHRcdC5wb3AoKTtcblxuXHRcdGNvbnN0IGljb25DbGFzc05hbWUgPSBhY3RpdmVDb21tYW5kLmljb247XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24gYWUtY29udGFpbmVyLWRyb3Bkb3duLXhzbWFsbCBhZS1oYXMtZHJvcGRvd25cIj5cblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9XG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17YWN0aXZlQ29tbWFuZC5sYWJlbH1cblx0XHRcdFx0XHRhcmlhLW93bnM9e2J1dHRvbkNvbW1hbmRzTGlzdElkfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLXRvb2xiYXItZWxlbWVudFwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0XHRyb2xlPVwiY29tYm9ib3hcIlxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnJvd30+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXJcIj5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD17aWNvbkNsYXNzTmFtZX0gLz5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNhcmV0LWJvdHRvbVwiIC8+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHR7YnV0dG9uQ29tbWFuZHNMaXN0fVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbGlzdCBvZiBjb21tYW5kcy4gSWYgYSBsaXN0IG9mIGNvbW1hbmRzIHdhcyBwYXNzZWRcblx0ICogYXMgcHJvcGVydHkgYGNvbW1hbmRzYCwgaXQgd2lsbCB0YWtlIGEgcHJlY2VkZW5jZSBvdmVyIHRoZSBkZWZhdWx0IG9uZXMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQWxpZ25cblx0ICogQG1ldGhvZCBfZ2V0Q29tbWFuZHNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGNvbW1hbmRzLlxuXHQgKi9cblx0X2dldENvbW1hbmRzKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLmNvbW1hbmRzIHx8IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdqdXN0aWZ5bGVmdCcsXG5cdFx0XHRcdFx0aWNvbjogJ2FsaWduLWxlZnQnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduTGVmdCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdqdXN0aWZ5Y2VudGVyJyxcblx0XHRcdFx0XHRpY29uOiAnYWxpZ24tY2VudGVyJyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkNlbnRlcixcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdqdXN0aWZ5cmlnaHQnLFxuXHRcdFx0XHRcdGljb246ICdhbGlnbi1yaWdodCcsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25SaWdodCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdqdXN0aWZ5YmxvY2snLFxuXHRcdFx0XHRcdGljb246ICdhbGlnbi1qdXN0aWZ5Jyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkp1c3RpZnksXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25QYXJhZ3JhcGhBbGlnbjtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZEFjdGl2ZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZSc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25QYXJhZ3JhcGhDZW50ZXIgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2VudGVyaW5nIGEgcGFyYWdyYXBoLlxuICpcbiAqIEBjbGFzcyBCdXR0b25QYXJhZ3JhcGhDZW50ZXJcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25QYXJhZ3JhcGhDZW50ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQ2VudGVyXG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ2p1c3RpZnljZW50ZXInLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgcGFyYWdyYXBoQ2VudGVyXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhDZW50ZXJcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3BhcmFncmFwaENlbnRlcic7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhDZW50ZXJcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkNlbnRlcn1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tcGFyYWdyYXBoLWNlbnRlclwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkNlbnRlcn0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImFsaWduLWNlbnRlclwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbkNvbW1hbmRBY3RpdmUoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblBhcmFncmFwaENlbnRlcikpXG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblBhcmFncmFwaEp1c3RpZnkgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IganVzdGZ5aW5nIGEgcGFyYWdyYXBoLlxuICpcbiAqIEBjbGFzcyBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uUGFyYWdyYXBoSnVzdGlmeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ2p1c3RpZnlibG9jaycsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBwYXJhZ3JhcGhKdXN0aWZ5XG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdwYXJhZ3JhcGhKdXN0aWZ5JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEp1c3RpZnlcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkp1c3RpZnl9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXBhcmFncmFwaC1qdXN0aWZ5XCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduSnVzdGlmeX0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImFsaWduLWp1c3RpZnlcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuXHRCdXR0b25Db21tYW5kQWN0aXZlKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5KSlcbik7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZSc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblF1b3RlIGNsYXNzIHdyYXBzIGEgc2VsZWN0aW9uIGluIGBibG9ja3F1b3RlYCBlbGVtZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25RdW90ZVxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25RdW90ZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25RdW90ZVxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdibG9ja3F1b3RlJyxcblx0XHRzdHlsZToge1xuXHRcdFx0ZWxlbWVudDogJ2Jsb2NrcXVvdGUnLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBxdW90ZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUXVvdGVcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3F1b3RlJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblF1b3RlXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MucXVvdGV9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXF1b3RlXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnF1b3RlfT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwicXVvdGUtcmlnaHRcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25TdHlsZShCdXR0b25RdW90ZSkpKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblJlbW92ZUZvcm1hdCBjbGFzcyByZW1vdmVzIHN0eWxlIGZvcm1hdHRpbmcuXG4gKlxuICogQGNsYXNzIEJ1dHRvblJlbW92ZUZvcm1hdFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICovXG5jbGFzcyBCdXR0b25SZW1vdmVGb3JtYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUmVtb3ZlRm9ybWF0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ3JlbW92ZUZvcm1hdCcsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCByZW1vdmVGb3JtYXRcblx0ICogQG1lbWJlcm9mIEJ1dHRvblJlbW92ZUZvcm1hdFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAncmVtb3ZlRm9ybWF0JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblJlbW92ZUZvcm1hdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnJlbW92ZWZvcm1hdH1cblx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXJlbW92ZWZvcm1hdFwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5yZW1vdmVmb3JtYXR9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJyZW1vdmUtc3R5bGVcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKEJ1dHRvblJlbW92ZUZvcm1hdCk7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25SZW1vdmVJbWFnZSBjbGFzcyByZW1vdmVzIGFuIGltYWdlIHVzaW5nIGEgQ0tFRElUT1IuY29tbWFuZC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUmVtb3ZlSW1hZ2VcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuY2xhc3MgQnV0dG9uUmVtb3ZlSW1hZ2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdyZW1vdmVJbWFnZScsXG5cdH07XG5cblx0c3RhdGljIGtleSA9ICdyZW1vdmVJbWFnZSc7XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5yZW1vdmVJbWFnZX1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtmYWxzZX1cblx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MucmVtb3ZlSW1hZ2V9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJ0aW1lcy1jaXJjbGVcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKEJ1dHRvblJlbW92ZUltYWdlKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uU2VwYXJhdG9yIGZ1bmN0aW9uIHJlbmRlcnMgYSBzaW1wbGUgc2VwYXJhdG9yLlxuICovXG5mdW5jdGlvbiBCdXR0b25TZXBhcmF0b3IoX3Byb3BzKSB7XG5cdHJldHVybiA8c3BhbiBjbGFzc05hbWU9XCJhZS1zZXBhcmF0b3JcIiAvPjtcbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBzZXBhcmF0b3JcbiAqIEBtZW1iZXJvZiBCdXR0b25TZXBhcmF0b3JcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uU2VwYXJhdG9yLmtleSA9ICdzZXBhcmF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25TZXBhcmF0b3I7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0IGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblNwYWNpbmcgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2hhbmdpbmcgdGV4dCBzcGFjaW5nIGluIGEgZG9jdW1lbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvblNwYWNpbmdcbiAqL1xuY2xhc3MgQnV0dG9uU3BhY2luZyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0c3RhdGljIGtleSA9ICdzcGFjaW5nJztcblxuXHRzdGF0aWMgcHJvcFR5cGVzID0ge1xuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdHlsZXMgbGlzdCBpcyBleHBhbmRlZCBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgU3BhY2luZ1xuXHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZXhwYW5kZWRcblx0XHQgKi9cblx0XHRleHBhbmRlZDogUHJvcFR5cGVzLmJvb2wsXG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGFiZWwgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgYWNjZXNzaWJpbGl0eSBwdXJwb3Nlcy5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBTcGFjaW5nXG5cdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGxhYmVsXG5cdFx0ICovXG5cdFx0bGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVtb3ZlIHN0eWxlcyBpdGVtIHNob3VsZCBhcHBlYXIgaW4gdGhlIHN0eWxlcyBsaXN0LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFNwYWNpbmdcblx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNob3dSZW1vdmVTdHlsZXNJdGVtXG5cdFx0ICovXG5cdFx0c2hvd1JlbW92ZVN0eWxlc0l0ZW06IFByb3BUeXBlcy5ib29sLFxuXG5cdFx0LyoqXG5cdFx0ICogTGlzdCBvZiB0aGUgc3R5bGVzIHRoZSBidXR0b24gaXMgYWJsZSB0byBoYW5kbGUuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgU3BhY2luZ1xuXHRcdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IHN0eWxlc1xuXHRcdCAqL1xuXHRcdHN0eWxlczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9iamVjdCksXG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGFiSW5kZXggb2YgdGhlIGJ1dHRvbiBpbiBpdHMgdG9vbGJhciBjdXJyZW50IHN0YXRlLiBBIHZhbHVlIG90aGVyIHRoYW4gLTFcblx0XHQgKiBtZWFucyB0aGF0IHRoZSBidXR0b24gaGFzIGZvY3VzIGFuZCBpcyB0aGUgYWN0aXZlIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgU3BhY2luZ1xuXHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0YWJJbmRleFxuXHRcdCAqL1xuXHRcdHRhYkluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuXG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgcHJvdmlkZWQgYnkgdGhlIGJ1dHRvbiBob3N0IHRvIG5vdGlmeSB3aGVuIHRoZSBzdHlsZXMgbGlzdCBoYXMgYmVlbiBleHBhbmRlZC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBTcGFjaW5nXG5cdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdG9nZ2xlRHJvcGRvd25cblx0XHQgKi9cblx0XHR0b2dnbGVEcm9wZG93bjogUHJvcFR5cGVzLmZ1bmMsXG5cdH07XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IGFjdGl2ZVNwYWNpbmcgPSAnMS4weCc7XG5cblx0XHRjb25zdCBzcGFjaW5ncyA9IHRoaXMuX2dldFNwYWNpbmdzKCk7XG5cblx0XHRzcGFjaW5ncy5mb3JFYWNoKGl0ZW0gPT4ge1xuXHRcdFx0aWYgKHRoaXMuX2NoZWNrQWN0aXZlKGl0ZW0uc3R5bGUpKSB7XG5cdFx0XHRcdGFjdGl2ZVNwYWNpbmcgPSBpdGVtLm5hbWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRjb25zdCB7ZWRpdG9yLCBleHBhbmRlZCwgdGFiSW5kZXgsIHRvZ2dsZURyb3Bkb3dufSA9IHRoaXMucHJvcHM7XG5cblx0XHRjb25zdCBidXR0b25TdHlsZXNQcm9wcyA9IHtcblx0XHRcdGFjdGl2ZVN0eWxlOiBhY3RpdmVTcGFjaW5nLFxuXHRcdFx0ZWRpdG9yLFxuXHRcdFx0b25EaXNtaXNzOiB0b2dnbGVEcm9wZG93bixcblx0XHRcdHNob3dSZW1vdmVTdHlsZXNJdGVtOiBmYWxzZSxcblx0XHRcdHN0eWxlczogc3BhY2luZ3MsXG5cdFx0fTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lciBhZS1jb250YWluZXItZHJvcGRvd24tc21hbGwgYWUtaGFzLWRyb3Bkb3duXCI+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWV4cGFuZGVkPXtleHBhbmRlZH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS10b29sYmFyLWVsZW1lbnRcIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdHJvbGU9XCJjb21ib2JveFwiXG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RhYkluZGV4fT5cblx0XHRcdFx0XHQ8c3Bhbj5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInNlcGFyYXRvclwiIC8+XG5cdFx0XHRcdFx0XHQmbmJzcDtcblx0XHRcdFx0XHRcdHthY3RpdmVTcGFjaW5nfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdHtleHBhbmRlZCAmJiA8QnV0dG9uU3R5bGVzTGlzdCB7Li4uYnV0dG9uU3R5bGVzUHJvcHN9IC8+fVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdF9hcHBseVN0eWxlKGNsYXNzTmFtZSkge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGNvbnN0IHN0eWxlQ29uZmlnID0ge1xuXHRcdFx0ZWxlbWVudDogJ2RpdicsXG5cdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdGNsYXNzOiBjbGFzc05hbWUsXG5cdFx0XHR9LFxuXHRcdH07XG5cblx0XHRjb25zdCBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZShzdHlsZUNvbmZpZyk7XG5cblx0XHRlZGl0b3IuZ2V0U2VsZWN0aW9uKCkubG9jaygpO1xuXG5cdFx0dGhpcy5fZ2V0U3BhY2luZ3MoKS5mb3JFYWNoKGl0ZW0gPT4ge1xuXHRcdFx0aWYgKHRoaXMuX2NoZWNrQWN0aXZlKGl0ZW0uc3R5bGUpKSB7XG5cdFx0XHRcdGVkaXRvci5yZW1vdmVTdHlsZShuZXcgQ0tFRElUT1Iuc3R5bGUoaXRlbS5zdHlsZSkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0ZWRpdG9yLmFwcGx5U3R5bGUoc3R5bGUpO1xuXG5cdFx0ZWRpdG9yLmdldFNlbGVjdGlvbigpLnVubG9jaygpO1xuXG5cdFx0ZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3BhY2luZyBkZWZpbml0aW9uIGlzIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgU3BhY2luZ1xuXHQgKiBAbWV0aG9kIF9jaGVja0FjdGl2ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVDb25maWcgU3BhY2luZyBkZWZpbml0aW9uIGFzIHBlciBodHRwOi8vZG9jcy5ja2VkaXRvci5jb20vIyEvYXBpL0NLRURJVE9SLnN0eWxlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BhY2luZyBpcyBhcHBsaWVkIHRvIHRoZSBzZWxlY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG5cdF9jaGVja0FjdGl2ZShzdHlsZUNvbmZpZykge1xuXHRcdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGxldCBhY3RpdmUgPSB0cnVlO1xuXG5cdFx0Y29uc3QgZWxlbWVudFBhdGggPSBuYXRpdmVFZGl0b3IuZWxlbWVudFBhdGgoKTtcblxuXHRcdGlmIChlbGVtZW50UGF0aCAmJiBlbGVtZW50UGF0aC5sYXN0RWxlbWVudCkge1xuXHRcdFx0c3R5bGVDb25maWcuYXR0cmlidXRlcy5jbGFzcy5zcGxpdCgnICcpLmZvckVhY2goY2xhc3NOYW1lID0+IHtcblx0XHRcdFx0YWN0aXZlID0gYWN0aXZlICYmIGVsZW1lbnRQYXRoLmxhc3RFbGVtZW50Lmhhc0NsYXNzKGNsYXNzTmFtZSk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YWN0aXZlID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjdGl2ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHNwYWNpbmdzLiBFYWNoIHNwYWNpbmcgY29uc2lzdHMgZnJvbSB0aHJlZSBwcm9wZXJ0aWVzOlxuXHQgKiAtIG5hbWUgLSB0aGUgc3R5bGUgbmFtZSwgZm9yIGV4YW1wbGUgXCJkZWZhdWx0XCJcblx0ICogLSBzdHlsZSAtIGFuIG9iamVjdCB3aXRoIG9uZSBwcm9wZXJ0eSwgY2FsbGVkIGBlbGVtZW50YCB3aGljaCB2YWx1ZVxuXHQgKiByZXByZXNlbnRzIHRoZSBzdHlsZSB3aGljaCBoYXZlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQuXG5cdCAqIC0gc3R5bGVGbiAtIGEgZnVuY3Rpb24gd2hpY2ggYXBwbGllcyBzZWxlY3RlZCBzdHlsZSB0byB0aGUgZWRpdG9yIHNlbGVjdGlvblxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFNwYWNpbmdcblx0ICogQG1ldGhvZCBfZ2V0U3BhY2luZ3Ncblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtBcnJheTxvYmplY3Q+fSBBbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHNwYWNpbmdzLlxuXHQgKi9cblx0X2dldFNwYWNpbmdzKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLnN0eWxlcyB8fCBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnMS4weCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnMS41eCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ210LTEgbWItMScsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnbXQtMSBtYi0xJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnMi4weCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ210LTIgbWItMicsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnbXQtMiBtYi0yJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnMy4weCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ210LTMgbWItMycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnbXQtMyBtYi0zJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnNC4weCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ210LTQgbWItNCcsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnbXQtNCBtYi00JyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnNS4weCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ210LTUgbWItNScsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnbXQtNSBtYi01JyksXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25TcGFjaW5nO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TdHJpa2UgY2xhc3Mgc3R5bGVzIGEgc2VsZWN0aW9uIHdpdGggc3RyaWtlIHN0eWxlLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdHJpa2VcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uU3RyaWtlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0cmlrZVxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdzdHJpa2UnLFxuXHRcdHN0eWxlOiAnY29yZVN0eWxlc19zdHJpa2UnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgc3RyaWtlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHJpa2Vcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3N0cmlrZSc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHJpa2Vcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5zdHJpa2V9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXN0cmlrZVwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5zdHJpa2V9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJzdHJpa2V0aHJvdWdoXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uU3R5bGUoQnV0dG9uU3RyaWtlKSkpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25zU3R5bGVzTGlzdEhlYWRlciBjbGFzcyBwcm92aWRlcyB0aGUgaGVhZGVyIG9mIGFuIGxpc3Qgb2Ygc3R5bGUgaXRlbXMuXG4gKlxuICogQGNsYXNzIEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyXG4gKi9cbmNsYXNzIEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGtleSA9ICdidXR0b25TdHlsZXNMaXN0SGVhZGVyJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnN0eWxlcyAmJiB0aGlzLnByb3BzLnN0eWxlcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiA8c3BhbiBjbGFzc05hbWU9XCJhZS1saXN0LWhlYWRlclwiPnt0aGlzLnByb3BzLm5hbWV9PC9zcGFuPjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmUgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgcHJldmlld2luZyBhIHN0eWxlIGRlZmluaXRpb25cbiAqIGluc2lkZSBhIGxpc3QgYW5kIGFwcGx5aW5nIGl0IHRvIHRoZSBjdXJyZW50IGVkaXRvciBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlXG4gKi9cbmNsYXNzIEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmVcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRyZW1vdmVCbG9ja3M6IFsnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAncHJlJ10sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBidXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmVcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2J1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8bGkgcm9sZT1cIm9wdGlvblwiPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtdG9vbGJhci1lbGVtZW50XCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLl9yZW1vdmVTdHlsZXN9XG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9PlxuXHRcdFx0XHRcdHtBbGxveUVkaXRvci5TdHJpbmdzLm5vcm1hbH1cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQ8L2xpPlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgaW5saW5lIHN0eWxlcyBhbmQgY29uZmlndXJlZCBibG9jayBlbGVtZW50cyBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZVxuXHQgKiBAbWV0aG9kIF9yZW1vdmVTdHlsZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3JlbW92ZVN0eWxlcyA9ICgpID0+IHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRlZGl0b3IuZXhlY0NvbW1hbmQoJ3JlbW92ZUZvcm1hdCcpO1xuXG5cdFx0dGhpcy5wcm9wcy5yZW1vdmVCbG9ja3MuZm9yRWFjaChibG9ja0l0ZW0gPT4ge1xuXHRcdFx0Y29uc3QgYmxvY2tTdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZSh7ZWxlbWVudDogYmxvY2tJdGVtfSk7XG5cblx0XHRcdGVkaXRvci5yZW1vdmVTdHlsZShibG9ja1N0eWxlKTtcblx0XHR9KTtcblxuXHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmU7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IEJ1dHRvbkFjdGlvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWFjdGlvbi1zdHlsZSc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TdHlsZXNMaXN0SXRlbSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBwcmV2aWV3aW5nIGEgc3R5bGUgZGVmaW5pdGlvblxuICogaW5zaWRlIGEgbGlzdCBhbmQgYXBwbHlpbmcgaXQgdG8gdGhlIGN1cnJlbnQgZWRpdG9yIHNlbGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3R5bGVzTGlzdEl0ZW1cbiAqIEB1c2VzIEJ1dHRvbkFjdGlvblN0eWxlXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25TdHlsZXNMaXN0SXRlbSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBidXR0b25TdHlsZXNMaXN0SXRlbVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1cblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2J1dHRvblN0eWxlc0xpc3RJdGVtJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIGJvdGggb24gdGhlIGNsaWVudCBhbmQgc2VydmVyLCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxNb3VudFxuXHQgKi9cblx0Y29tcG9uZW50V2lsbE1vdW50KCkge1xuXHRcdC8vIFN0eWxlcyB3aXRoIHdpbGRjYXJkIGVsZW1lbnQgKCopIGdlbmVyYXRlIGFuIGVtcHR5IHRhZyBpbiB0aGVpciBwcmV2aWV3IDwgY2xhc3M9XCJjdXN0b20tY2xhc3NcIiAvPi5cblx0XHQvLyBXZSBkZWZhdWx0IHRvIGVsZW1lbnQgc3BhbiBhbmQgcmVtb3ZlIHRoZSBtYXJnaW5zIHRvIG9idGFpbiBhIG1vcmUgY29uc2lzdGVudCBzZXQgb2YgcHJldmlld3MuXG5cdFx0bGV0IHN0eWxlQ2ZnID0ge1xuXHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0c3R5bGVzOiB7XG5cdFx0XHRcdG1hcmdpbjogMCxcblx0XHRcdH0sXG5cdFx0fTtcblxuXHRcdHN0eWxlQ2ZnID0gQ0tFRElUT1IudG9vbHMubWVyZ2Uoc3R5bGVDZmcsIHRoaXMucHJvcHMuc3R5bGUpO1xuXG5cdFx0dGhpcy5fcHJldmlldyA9IG5ldyBDS0VESVRPUi5zdHlsZShzdHlsZUNmZykuYnVpbGRQcmV2aWV3KFxuXHRcdFx0dGhpcy5wcm9wcy5uYW1lXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1cblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Ly8gV2UgbmVlZCB0byB1c2UgZGFuZ2Vyb3VzZWx5U2V0SW5udGVySFRNTCBzaW5jZSB3ZSdyZSBub3QgaW4gY29udHJvbCBvZiB0aGUgc3R5bGVcblx0XHQvLyBwcmV2aWV3IHRoYXQgaXMgZ2VuZXJhdGVkIGJ5IENLRWRpdG9yLlxuXHRcdGNvbnN0IGNsYXNzTmFtZSA9XG5cdFx0XHR0aGlzLnByb3BzLm5hbWUgPT09IHRoaXMucHJvcHMuYWN0aXZlU3R5bGVcblx0XHRcdFx0PyAnYWUtdG9vbGJhci1lbGVtZW50IGFjdGl2ZSdcblx0XHRcdFx0OiAnYWUtdG9vbGJhci1lbGVtZW50JztcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuXHRcdFx0XHRkYW5nZXJvdXNseVNldElubmVySFRNTD17e19faHRtbDogdGhpcy5fcHJldmlld319XG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX29uQ2xpY2t9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0Lz5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGl0ZW0gc3R5bGUgdG8gdGhlIGVkaXRvciBzZWxlY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1cblx0ICogQG1ldGhvZCBfb25DbGlja1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfb25DbGljayA9ICgpID0+IHtcblx0XHRpZiAodGhpcy5wcm9wcy5zdHlsZUZuKSB7XG5cdFx0XHR0aGlzLnByb3BzLnN0eWxlRm4oKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHlwaWNhbGx5LCB3ZSB3YW50IHRoZSBzdHlsZSB0byBiZSB0aGUgb25seSBvbmUgYXBwbGllZCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24sIHNvXG5cdFx0XHQvLyB3ZSBleGVjdXRlIHRoZSAncmVtb3ZlRm9ybWF0JyBjb21tYW5kIGZpcnN0LiBOb3RlIHRoYXQgYmxvY2sgc3R5bGVzIHdvbid0IGJlIGNsZWFuZWQuXG5cdFx0XHQvLyBIb3dldmVyLCB0aGlzIGlzIGNvbnNpc3RlbnQgd2l0aCBvdGhlciBlZGl0b3JzIGltcGxlbWVudGF0aW9ucyBvZiB0aGlzIGZlYXR1cmUuXG5cdFx0XHR0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJykuZXhlY0NvbW1hbmQoJ3JlbW92ZUZvcm1hdCcpO1xuXG5cdFx0XHR0aGlzLmFwcGx5U3R5bGUoKTtcblx0XHR9XG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkFjdGlvblN0eWxlKEJ1dHRvblN0eWxlKEJ1dHRvblN0eWxlc0xpc3RJdGVtKSk7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyJztcbmltcG9ydCBCdXR0b25Ecm9wZG93biBmcm9tICcuL2J1dHRvbi1kcm9wZG93bi5qc3gnO1xuaW1wb3J0IEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyIGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LWhlYWRlci5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlIGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0tcmVtb3ZlLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3R5bGVzTGlzdEl0ZW0gZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QtaXRlbS5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TdHlsZXNMaXN0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHNob3dpbmcgYSBsaXN0IG9mIHN0eWxlcyB0aGF0IGNhbiBiZVxuICogYXBwbGllZCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdHlsZXNMaXN0XG4gKiBAdXNlcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqL1xuY2xhc3MgQnV0dG9uU3R5bGVzTGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y2lyY3VsYXI6IGZhbHNlLFxuXHRcdGRlc2NlbmRhbnRzOiAnLmFlLXRvb2xiYXItZWxlbWVudCcsXG5cdFx0a2V5czoge1xuXHRcdFx0ZGlzbWlzczogWzI3XSxcblx0XHRcdGRpc21pc3NOZXh0OiBbMzldLFxuXHRcdFx0ZGlzbWlzc1ByZXY6IFszN10sXG5cdFx0XHRuZXh0OiBbNDBdLFxuXHRcdFx0cHJldjogWzM4XSxcblx0XHR9LFxuXHRcdHNob3dSZW1vdmVTdHlsZXNJdGVtOiB0cnVlLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3Rcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBkZWZhdWx0IGJ1dHRvblN0eWxlc0xpc3Rcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnYnV0dG9uU3R5bGVzTGlzdCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdCAqXG5cdCAqIEZvY3VzZXMgb24gdGhlIGxpc3Qgbm9kZSB0byBhbGxvdyBrZXlib2FyZCBpbnRlcmFjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0XG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcblx0ICovXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpLmZvY3VzKCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIGJvdGggb24gdGhlIGNsaWVudCBhbmQgc2VydmVyLCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0XG5cdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnRXaWxsTW91bnQoKSB7XG5cdFx0Y29uc3QgYmxvY2tTdHlsZXMgPSBbXTtcblx0XHRjb25zdCBpbmxpbmVTdHlsZXMgPSBbXTtcblx0XHRjb25zdCBvYmplY3RTdHlsZXMgPSBbXTtcblxuXHRcdHRoaXMucHJvcHMuc3R5bGVzLmZvckVhY2goaXRlbSA9PiB7XG5cdFx0XHRjb25zdCBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZShpdGVtLnN0eWxlKTtcblxuXHRcdFx0aWYgKHN0eWxlLnR5cGUgPT09IENLRURJVE9SLlNUWUxFX0JMT0NLKSB7XG5cdFx0XHRcdGJsb2NrU3R5bGVzLnB1c2goaXRlbSk7XG5cdFx0XHR9IGVsc2UgaWYgKHN0eWxlLnR5cGUgPT09IENLRURJVE9SLlNUWUxFX0lOTElORSkge1xuXHRcdFx0XHRpbmxpbmVTdHlsZXMucHVzaChpdGVtKTtcblx0XHRcdH0gZWxzZSBpZiAoc3R5bGUudHlwZSA9PT0gQ0tFRElUT1IuU1RZTEVfT0JKRUNUKSB7XG5cdFx0XHRcdG9iamVjdFN0eWxlcy5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fYmxvY2tTdHlsZXMgPSBibG9ja1N0eWxlcztcblx0XHR0aGlzLl9pbmxpbmVTdHlsZXMgPSBpbmxpbmVTdHlsZXM7XG5cdFx0dGhpcy5fb2JqZWN0U3R5bGVzID0gb2JqZWN0U3R5bGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGxpc3QuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRsZXQgcmVtb3ZlU3R5bGVzSXRlbTtcblxuXHRcdGlmICh0aGlzLnByb3BzLnNob3dSZW1vdmVTdHlsZXNJdGVtKSB7XG5cdFx0XHRyZW1vdmVTdHlsZXNJdGVtID0gKFxuXHRcdFx0XHQ8QnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmVcblx0XHRcdFx0XHRvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259XG5cdFx0XHRcdC8+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8QnV0dG9uRHJvcGRvd24gey4uLnRoaXMucHJvcHN9PlxuXHRcdFx0XHR7cmVtb3ZlU3R5bGVzSXRlbX1cblxuXHRcdFx0XHQ8QnV0dG9uc1N0eWxlc0xpc3RIZWFkZXJcblx0XHRcdFx0XHRuYW1lPXtBbGxveUVkaXRvci5TdHJpbmdzLmJsb2NrU3R5bGVzfVxuXHRcdFx0XHRcdHN0eWxlcz17dGhpcy5fYmxvY2tTdHlsZXN9XG5cdFx0XHRcdC8+XG5cdFx0XHRcdHt0aGlzLl9yZW5kZXJTdHlsZXNJdGVtcyh0aGlzLl9ibG9ja1N0eWxlcyl9XG5cblx0XHRcdFx0PEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyXG5cdFx0XHRcdFx0bmFtZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5pbmxpbmVTdHlsZXN9XG5cdFx0XHRcdFx0c3R5bGVzPXt0aGlzLl9pbmxpbmVTdHlsZXN9XG5cdFx0XHRcdC8+XG5cdFx0XHRcdHt0aGlzLl9yZW5kZXJTdHlsZXNJdGVtcyh0aGlzLl9pbmxpbmVTdHlsZXMpfVxuXG5cdFx0XHRcdDxCdXR0b25zU3R5bGVzTGlzdEhlYWRlclxuXHRcdFx0XHRcdG5hbWU9e0FsbG95RWRpdG9yLlN0cmluZ3Mub2JqZWN0U3R5bGVzfVxuXHRcdFx0XHRcdHN0eWxlcz17dGhpcy5fb2JqZWN0U3R5bGVzfVxuXHRcdFx0XHQvPlxuXHRcdFx0XHR7dGhpcy5fcmVuZGVyU3R5bGVzSXRlbXModGhpcy5fb2JqZWN0U3R5bGVzKX1cblx0XHRcdDwvQnV0dG9uRHJvcGRvd24+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXJzIGluc3RhbmNlcyBvZiBCdXR0b25TdHlsZXNMaXN0SXRlbSB3aXRoIHRoZSBwcmV2aWV3IG9mIHRoZSBjb3JyZXNwb25kZW50IGJsb2NrLCBpbmxpbmUgb3Igb2JqZWN0IHN0eWxlcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0XG5cdCAqIEBtZXRob2QgX3JlbmRlclN0eWxlc0l0ZW1zXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHN0eWxlcyBMaXN0IG9mIHN0eWxlcyBmb3Igd2hpY2ggcHJldmlldyBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7QXJyYXl9IFJlbmRlcmVkIGluc3RhbmNlcyBvZiBCdXR0b25TdHlsZXNMaXN0SXRlbSBjbGFzc1xuXHQgKi9cblx0X3JlbmRlclN0eWxlc0l0ZW1zKHN0eWxlcykge1xuXHRcdGxldCBpdGVtcztcblxuXHRcdGlmIChzdHlsZXMgJiYgc3R5bGVzLmxlbmd0aCkge1xuXHRcdFx0aXRlbXMgPSBzdHlsZXMubWFwKGl0ZW0gPT4ge1xuXHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdDxsaSBrZXk9e2l0ZW0ubmFtZX0gcm9sZT1cIm9wdGlvblwiPlxuXHRcdFx0XHRcdFx0PEJ1dHRvblN0eWxlc0xpc3RJdGVtXG5cdFx0XHRcdFx0XHRcdGFjdGl2ZVN0eWxlPXt0aGlzLnByb3BzLmFjdGl2ZVN0eWxlfVxuXHRcdFx0XHRcdFx0XHRuYW1lPXtpdGVtLm5hbWV9XG5cdFx0XHRcdFx0XHRcdHN0eWxlPXtpdGVtLnN0eWxlfVxuXHRcdFx0XHRcdFx0XHRzdHlsZUZuPXtpdGVtLnN0eWxlRm59XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbXM7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0Rm9jdXNNYW5hZ2VyKEJ1dHRvblN0eWxlc0xpc3QpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0IGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblN0eWxlcyBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBzdHlsaW5nIGEgc2VsZWN0aW9uIHdpdGggYSBsaXN0IG9mXG4gKiBjb25maWd1cmFibGUgYW5kIGN1c3RvbWl6YWJsZSBzdHlsZXMuIFRoZSBhbGxvd2VkIHN0eWxlcyBmb2xsb3cgQ0tFRElUT1IuU3R5bGUgY29uZmlndXJhdGlvblxuICogKGh0dHA6Ly9kb2NzLmNrZWRpdG9yLmNvbS8jIS9hcGkvQ0tFRElUT1Iuc3R5bGUpXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0eWxlc1xuICovXG5jbGFzcyBCdXR0b25TdHlsZXMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgc3R5bGVzXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3N0eWxlcyc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IGFjdGl2ZVN0eWxlID0gQWxsb3lFZGl0b3IuU3RyaW5ncy5ub3JtYWw7XG5cblx0XHRjb25zdCBzdHlsZXMgPSB0aGlzLl9nZXRTdHlsZXMoKTtcblxuXHRcdHN0eWxlcy5mb3JFYWNoKGl0ZW0gPT4ge1xuXHRcdFx0aWYgKHRoaXMuX2NoZWNrQWN0aXZlKGl0ZW0uc3R5bGUpKSB7XG5cdFx0XHRcdGFjdGl2ZVN0eWxlID0gaXRlbS5uYW1lO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0bGV0IGJ1dHRvblN0eWxlc0xpc3Q7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5leHBhbmRlZCkge1xuXHRcdFx0YnV0dG9uU3R5bGVzTGlzdCA9IChcblx0XHRcdFx0PEJ1dHRvblN0eWxlc0xpc3Rcblx0XHRcdFx0XHRhY3RpdmVTdHlsZT17YWN0aXZlU3R5bGV9XG5cdFx0XHRcdFx0b25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdHNob3dSZW1vdmVTdHlsZXNJdGVtPXt0aGlzLnByb3BzLnNob3dSZW1vdmVTdHlsZXNJdGVtfVxuXHRcdFx0XHRcdHN0eWxlcz17c3R5bGVzfVxuXHRcdFx0XHQvPlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24gYWUtaGFzLWRyb3Bkb3duXCI+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfVxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3R5bGVzICsgJyAnICsgYWN0aXZlU3R5bGV9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtdG9vbGJhci1lbGVtZW50XCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdHJvbGU9XCJjb21ib2JveFwiXG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3R5bGVzICsgJyAnICsgYWN0aXZlU3R5bGV9PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyXCI+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24tc2VsZWN0ZWQtaXRlbVwiPlxuXHRcdFx0XHRcdFx0XHR7YWN0aXZlU3R5bGV9XG5cdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJjYXJldC1ib3R0b21cIiAvPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0e2J1dHRvblN0eWxlc0xpc3R9XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBpcyBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc1xuXHQgKiBAbWV0aG9kIF9jaGVja0FjdGl2ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVDb25maWcgU3R5bGUgZGVmaW5pdGlvbiBhcyBwZXIgaHR0cDovL2RvY3MuY2tlZGl0b3IuY29tLyMhL2FwaS9DS0VESVRPUi5zdHlsZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHN0eWxlIGlzIGFwcGxpZWQgdG8gdGhlIHNlbGVjdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cblx0X2NoZWNrQWN0aXZlKHN0eWxlQ29uZmlnKSB7XG5cdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0Ly8gU3R5bGVzIHdpdGggd2lsZGNhcmQgZWxlbWVudCAoKikgd29uJ3QgYmUgY29uc2lkZXJlZCBhY3RpdmUgYnkgQ0tFZGl0b3IuIERlZmF1bHRpbmdcblx0XHQvLyB0byBhICdzcGFuJyBlbGVtZW50IHdvcmtzIGZvciBtb3N0IG9mIHRob3NlIGNhc2VzIHdpdGggbm8gZGVmaW5lZCBlbGVtZW50LlxuXHRcdHN0eWxlQ29uZmlnID0gQ0tFRElUT1IudG9vbHMubWVyZ2Uoe2VsZW1lbnQ6ICdzcGFuJ30sIHN0eWxlQ29uZmlnKTtcblxuXHRcdGNvbnN0IHN0eWxlID0gbmV3IENLRURJVE9SLnN0eWxlKHN0eWxlQ29uZmlnKTtcblxuXHRcdHJldHVybiBzdHlsZS5jaGVja0FjdGl2ZShuYXRpdmVFZGl0b3IuZWxlbWVudFBhdGgoKSwgbmF0aXZlRWRpdG9yKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHN0eWxlcy4gRWFjaCBzdHlsZSBjb25zaXN0cyBmcm9tIHR3byBwcm9wZXJ0aWVzOlxuXHQgKiAtIG5hbWUgLSB0aGUgc3R5bGUgbmFtZSwgZm9yIGV4YW1wbGUgXCJoMVwiXG5cdCAqIC0gc3R5bGUgLSBhbiBvYmplY3Qgd2l0aCBvbmUgcHJvcGVydHksIGNhbGxlZCBgZWxlbWVudGAgd2hpY2ggdmFsdWVcblx0ICogcmVwcmVzZW50cyB0aGUgc3R5bGUgd2hpY2ggaGF2ZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc1xuXHQgKiBAbWV0aG9kIF9nZXRTdHlsZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtBcnJheTxvYmplY3Q+fSBBbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHN0eWxlcy5cblx0ICovXG5cdF9nZXRTdHlsZXMoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMucHJvcHMuc3R5bGVzIHx8IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MuaDEsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdoMScsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MuaDIsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdoMicsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MuZm9ybWF0dGVkLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAncHJlJyxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5jaXRlLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnY2l0ZScsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MuY29kZSxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ2NvZGUnLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25TdHlsZXM7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZSc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblN1YnNjcmlwdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhcHBseWluZyBzdWJzY3JpcHQgc3R5bGUgdG8gYSB0ZXh0IHNlbGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3Vic2NyaXB0XG4gKlxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25TdWJzY3JpcHQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3Vic2NyaXB0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ3N1YnNjcmlwdCcsXG5cdFx0c3R5bGU6ICdjb3JlU3R5bGVzX3N1YnNjcmlwdCcsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBzdWJzY3JpcHRcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN1YnNjcmlwdFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnc3Vic2NyaXB0JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN1YnNjcmlwdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnN1YnNjcmlwdH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tc3Vic2NyaXB0XCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnN1YnNjcmlwdH0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInN1YnNjcmlwdFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblN0eWxlKEJ1dHRvblN1YnNjcmlwdCkpKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uU3VwZXJzY3JpcHQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgYXBwbHlpbmcgc3VwZXJzY3JpcHQgc3R5bGUgdG8gYSB0ZXh0IHNlbGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3VwZXJzY3JpcHRcbiAqXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblN1cGVyc2NyaXB0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN1cGVyc2NyaXB0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ3N1cGVyc2NyaXB0Jyxcblx0XHRzdHlsZTogJ2NvcmVTdHlsZXNfc3VwZXJzY3JpcHQnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgc3VwZXJzY3JpcHRcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN1cGVyc2NyaXB0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdzdXBlcnNjcmlwdCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdXBlcnNjcmlwdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnN1cGVyc2NyaXB0fVxuXHRcdFx0XHRhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9XG5cdFx0XHRcdGNsYXNzTmFtZT17Y3NzQ2xhc3N9XG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1zdXBlcnNjcmlwdFwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5zdXBlcnNjcmlwdH0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInN1cGVyc2NyaXB0XCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcblx0QnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblN0eWxlKEJ1dHRvblN1cGVyc2NyaXB0KSlcbik7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kc0xpc3QgZnJvbSAnLi9idXR0b24tY29tbWFuZHMtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYWJsZUNlbGwgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byB3b3JrIHdpdGggdGFibGUgY2VsbHMuXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhYmxlQ2VsbFxuICovXG5jbGFzcyBCdXR0b25UYWJsZUNlbGwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IHRhYmxlQ2VsbFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVDZWxsXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICd0YWJsZUNlbGwnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVDZWxsXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGxldCBidXR0b25Db21tYW5kc0xpc3Q7XG5cdFx0bGV0IGJ1dHRvbkNvbW1hbmRzTGlzdElkO1xuXG5cdFx0aWYgKHRoaXMucHJvcHMuZXhwYW5kZWQpIHtcblx0XHRcdGJ1dHRvbkNvbW1hbmRzTGlzdElkID0gQnV0dG9uVGFibGVDZWxsLmtleSArICdMaXN0Jztcblx0XHRcdGJ1dHRvbkNvbW1hbmRzTGlzdCA9IChcblx0XHRcdFx0PEJ1dHRvbkNvbW1hbmRzTGlzdFxuXHRcdFx0XHRcdGNvbW1hbmRzPXt0aGlzLl9nZXRDb21tYW5kcygpfVxuXHRcdFx0XHRcdGxpc3RJZD17YnV0dG9uQ29tbWFuZHNMaXN0SWR9XG5cdFx0XHRcdFx0b25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHQvPlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXIgYWUtaGFzLWRyb3Bkb3duXCI+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfVxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY2VsbH1cblx0XHRcdFx0XHRhcmlhLW93bnM9e2J1dHRvbkNvbW1hbmRzTGlzdElkfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsfT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJhZGQtY2VsbFwiIC8+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHR7YnV0dG9uQ29tbWFuZHNMaXN0fVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbGlzdCBvZiBjb21tYW5kcy4gSWYgYSBsaXN0IG9mIGNvbW1hbmRzIHdhcyBwYXNzZWRcblx0ICogYXMgcHJvcGVydHkgYGNvbW1hbmRzYCwgaXQgd2lsbCB0YWtlIGEgcHJlY2VkZW5jZSBvdmVyIHRoZSBkZWZhdWx0IG9uZXMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVDZWxsXG5cdCAqIEBtZXRob2QgX2dldENvbW1hbmRzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIGF2YWlsYWJsZSBjb21tYW5kcy5cblx0ICovXG5cdF9nZXRDb21tYW5kcygpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5wcm9wcy5jb21tYW5kcyB8fCBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAnY2VsbEluc2VydEJlZm9yZScsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2VsbEluc2VydEJlZm9yZSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdjZWxsSW5zZXJ0QWZ0ZXInLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNlbGxJbnNlcnRBZnRlcixcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdjZWxsRGVsZXRlJyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsRGVsZXRlLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ2NlbGxNZXJnZScsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2VsbE1lcmdlLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ2NlbGxNZXJnZURvd24nLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNlbGxNZXJnZURvd24sXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAnY2VsbE1lcmdlUmlnaHQnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNlbGxNZXJnZVJpZ2h0LFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ2NlbGxIb3Jpem9udGFsU3BsaXQnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNlbGxTcGxpdEhvcml6b250YWwsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAnY2VsbFZlcnRpY2FsU3BsaXQnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNlbGxTcGxpdFZlcnRpY2FsLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uVGFibGVDZWxsO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZHNMaXN0IGZyb20gJy4vYnV0dG9uLWNvbW1hbmRzLWxpc3QuanN4JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFibGVDb2x1bW4gY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byB3b3JrIHdpdGggdGFibGUgY29sdW1ucy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVGFibGVDb2x1bW5cbiAqL1xuY2xhc3MgQnV0dG9uVGFibGVDb2x1bW4gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IHRhYmxlQ29sdW1uXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUNvbHVtblxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndGFibGVDb2x1bW4nO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVDb2x1bW5cblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IGJ1dHRvbkNvbW1hbmRzTGlzdDtcblx0XHRsZXQgYnV0dG9uQ29tbWFuZHNMaXN0SWQ7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5leHBhbmRlZCkge1xuXHRcdFx0YnV0dG9uQ29tbWFuZHNMaXN0SWQgPSBCdXR0b25UYWJsZUNvbHVtbi5rZXkgKyAnTGlzdCc7XG5cdFx0XHRidXR0b25Db21tYW5kc0xpc3QgPSAoXG5cdFx0XHRcdDxCdXR0b25Db21tYW5kc0xpc3Rcblx0XHRcdFx0XHRjb21tYW5kcz17dGhpcy5fZ2V0Q29tbWFuZHMoKX1cblx0XHRcdFx0XHRsaXN0SWQ9e2J1dHRvbkNvbW1hbmRzTGlzdElkfVxuXHRcdFx0XHRcdG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0Lz5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyIGFlLWhhcy1kcm9wZG93blwiPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1leHBhbmRlZD17dGhpcy5wcm9wcy5leHBhbmRlZH1cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbHVtbn1cblx0XHRcdFx0XHRhcmlhLW93bnM9e2J1dHRvbkNvbW1hbmRzTGlzdElkfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0XHRyb2xlPVwibGlzdGJveFwiXG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29sdW1ufT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJhZGQtY29sdW1uXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdHtidXR0b25Db21tYW5kc0xpc3R9XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBsaXN0IG9mIGNvbW1hbmRzLiBJZiBhIGxpc3Qgb2YgY29tbWFuZHMgd2FzIHBhc3NlZFxuXHQgKiBhcyBwcm9wZXJ0eSBgY29tbWFuZHNgLCBpdCB3aWxsIHRha2UgYSBwcmVjZWRlbmNlIG92ZXIgdGhlIGRlZmF1bHQgb25lcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUNvbHVtblxuXHQgKiBAbWV0aG9kIF9nZXRDb21tYW5kc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBhdmFpbGFibGUgY29tbWFuZHMuXG5cdCAqL1xuXHRfZ2V0Q29tbWFuZHMoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMucHJvcHMuY29tbWFuZHMgfHwgW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ2NvbHVtbkluc2VydEJlZm9yZScsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY29sdW1uSW5zZXJ0QmVmb3JlLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ2NvbHVtbkluc2VydEFmdGVyJyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jb2x1bW5JbnNlcnRBZnRlcixcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdjb2x1bW5EZWxldGUnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNvbHVtbkRlbGV0ZSxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlQ29sdW1uO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuY29uc3QgS0VZX0VOVEVSID0gMTM7XG5jb25zdCBLRVlfRVNDID0gMjc7XG5cbmNvbnN0IElOUFVUX05BTUVTID0ge1xuXHRDT0xTOiAnY29scycsXG5cdFJPV1M6ICdyb3dzJyxcbn07XG5cbmNvbnN0IE1JTklNVU1fR1JJRF9WQUxVRSA9IDE7XG5cbi8qKlxuICogVGhlIEJ1dHRvblRhYmxlRWRpdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhbmQgZWRpdGluZyBhIHRhYmxlIGluIGEgZG9jdW1lbnQuXG4gKiBQcm92aWRlcyBVSSBmb3IgY3JlYXRpbmcgYSB0YWJsZS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVGFibGVFZGl0XG4gKi9cbmNsYXNzIEJ1dHRvblRhYmxlRWRpdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHR0YWJsZUF0dHJpYnV0ZXM6IHtcblx0XHRcdGJvcmRlcjogMSxcblx0XHRcdGNlbGxQYWRkaW5nOiAwLFxuXHRcdFx0Y2VsbFNwYWNpbmc6IDAsXG5cdFx0XHRzdHlsZTogJ3RhYmxlLWxheW91dDogZml4ZWQ7IHdpZHRoOiAxMDAlOycsXG5cdFx0fSxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IHRhYmxlRWRpdFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVFZGl0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICd0YWJsZUVkaXQnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuXHQgKiBAbWV0aG9kIGdldEluaXRpYWxTdGF0ZVxuXHQgKi9cblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHR0aGlzLnJvd3NSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcblx0XHR0aGlzLmNvbHNSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcblx0XHR0aGlzLnN0YXRlID0ge1xuXHRcdFx0Y29sczogMyxcblx0XHRcdHJvd3M6IDMsXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50IChub3Qgb24gdGhlIHNlcnZlciksXG5cdCAqIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdCAqXG5cdCAqIEZvY3VzZXMgb24gdGhlIGxpbmsgaW5wdXQgdG8gaW1tZWRpYXRlbHkgYWxsb3cgZWRpdGluZy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUVkaXRcblx0ICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuXHQgKi9cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0dGhpcy5yb3dzUmVmLmN1cnJlbnQuZm9jdXMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgdGFibGUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVFZGl0XG5cdCAqIEBtZXRob2QgX2NyZWF0ZVRhYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9jcmVhdGVUYWJsZSA9ICgpID0+IHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdFx0Y29uc3QgdGFibGVVdGlscyA9IG5ldyBDS0VESVRPUi5UYWJsZShlZGl0b3IpO1xuXG5cdFx0dGFibGVVdGlscy5jcmVhdGUoe1xuXHRcdFx0YXR0cnM6IHRoaXMucHJvcHMudGFibGVBdHRyaWJ1dGVzLFxuXHRcdFx0Y29sczogdGhpcy5zdGF0ZS5jb2xzLFxuXHRcdFx0cm93czogdGhpcy5zdGF0ZS5yb3dzLFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcblxuXHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlcyBhIGNoYW5nZSBpbiBpbnB1dCB2YWx1ZS4gU2V0cyB0aGUgcHJvdmlkZWQgdmFsdWUgZnJvbSB0aGUgdXNlciBiYWNrIHRvIHRoZSBpbnB1dC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUVkaXRcblx0ICogQG1ldGhvZCBfaGFuZGxlQ2hhbmdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGlucHV0IHdoaWNoIHZhbHVlIHNob3VsZCBiZSB1cGRhdGVkLlxuXHQgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgcHJvdmlkZWQgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9oYW5kbGVDaGFuZ2UgPSAoaW5wdXROYW1lLCBldmVudCkgPT4ge1xuXHRcdGNvbnN0IHN0YXRlID0ge307XG5cblx0XHRpZiAoaW5wdXROYW1lID09PSBJTlBVVF9OQU1FUy5DT0xTIHx8IGlucHV0TmFtZSA9PT0gSU5QVVRfTkFNRVMuUk9XUykge1xuXHRcdFx0c3RhdGVbaW5wdXROYW1lXSA9IE1hdGgubWluKGV2ZW50LnRhcmdldC52YWx1ZSwgTUlOSU1VTV9HUklEX1ZBTFVFKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RhdGVbaW5wdXROYW1lXSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcblx0XHR9XG5cblx0XHR0aGlzLnNldFN0YXRlKHN0YXRlKTtcblx0fTtcblxuXHQvKipcblx0ICogTW9uaXRvcnMga2V5IGludGVyYWN0aW9uIGluc2lkZSB0aGUgaW5wdXQgZWxlbWVudCB0byByZXNwb25kIHRvIHRoZSBrZXlzOlxuXHQgKiAtIEVudGVyOiBDcmVhdGVzIHRoZSB0YWJsZS5cblx0ICogLSBFc2NhcGU6IERpc2NhcmRzIHRoZSBjaGFuZ2VzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuXHQgKiBAbWV0aG9kIF9oYW5kbGVLZXlEb3duXG5cdCAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBrZXlib2FyZCBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2hhbmRsZUtleURvd24gPSBldmVudCA9PiB7XG5cdFx0aWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWV9FTlRFUiB8fCBldmVudC5rZXlDb2RlID09PSBLRVlfRVNDKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRU5URVIpIHtcblx0XHRcdHRoaXMuX2NyZWF0ZVRhYmxlKCk7XG5cdFx0fSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRVNDKSB7XG5cdFx0XHR0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCB0aW1lID0gRGF0ZS5ub3coKTtcblx0XHRjb25zdCByb3dzSWQgPSB0aW1lICsgSU5QVVRfTkFNRVMuUk9XUztcblx0XHRjb25zdCBjb2xzSWQgPSB0aW1lICsgSU5QVVRfTkFNRVMuQ09MUztcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1lZGl0LXRhYmxlXCI+XG5cdFx0XHRcdDxsYWJlbCBodG1sRm9yPXtyb3dzSWR9PntBbGxveUVkaXRvci5TdHJpbmdzLnJvd3N9PC9sYWJlbD5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItaW5wdXQgc21hbGxcIj5cblx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWlucHV0XCJcblx0XHRcdFx0XHRcdGlkPXtyb3dzSWR9XG5cdFx0XHRcdFx0XHRtaW49e01JTklNVU1fR1JJRF9WQUxVRX1cblx0XHRcdFx0XHRcdG9uQ2hhbmdlPXt0aGlzLl9oYW5kbGVDaGFuZ2UuYmluZChcblx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0SU5QVVRfTkFNRVMuUk9XU1xuXHRcdFx0XHRcdFx0KX1cblx0XHRcdFx0XHRcdG9uS2V5RG93bj17dGhpcy5faGFuZGxlS2V5RG93bn1cblx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPVwiUm93c1wiXG5cdFx0XHRcdFx0XHRyZWY9e3RoaXMucm93c1JlZn1cblx0XHRcdFx0XHRcdHR5cGU9XCJudW1iZXJcIlxuXHRcdFx0XHRcdFx0dmFsdWU9e3RoaXMuc3RhdGUucm93c31cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8bGFiZWwgaHRtbEZvcj17Y29sc0lkfT57QWxsb3lFZGl0b3IuU3RyaW5ncy5jb2x1bW5zfTwvbGFiZWw+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWlucHV0IHNtYWxsXCI+XG5cdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1pbnB1dFwiXG5cdFx0XHRcdFx0XHRpZD17Y29sc0lkfVxuXHRcdFx0XHRcdFx0bWluPXtNSU5JTVVNX0dSSURfVkFMVUV9XG5cdFx0XHRcdFx0XHRvbkNoYW5nZT17dGhpcy5faGFuZGxlQ2hhbmdlLmJpbmQoXG5cdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdElOUFVUX05BTUVTLkNPTFNcblx0XHRcdFx0XHRcdCl9XG5cdFx0XHRcdFx0XHRvbktleURvd249e3RoaXMuX2hhbmRsZUtleURvd259XG5cdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj1cIkNvbHVtc1wiXG5cdFx0XHRcdFx0XHRyZWY9e3RoaXMuY29sc1JlZn1cblx0XHRcdFx0XHRcdHR5cGU9XCJudW1iZXJcIlxuXHRcdFx0XHRcdFx0dmFsdWU9e3RoaXMuc3RhdGUuY29sc31cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1sYWJlbD1cIkNvbmZpcm1cIlxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5fY3JlYXRlVGFibGV9PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNoZWNrXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlRWRpdDtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZHNMaXN0IGZyb20gJy4vYnV0dG9uLWNvbW1hbmRzLWxpc3QuanN4JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFibGVIZWFkaW5nIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gd29yayB3aXRoIHRhYmxlIGhlYWRpbmcuXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhYmxlSGVhZGluZ1xuICovXG5jbGFzcyBCdXR0b25UYWJsZUhlYWRpbmcgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgdGFibGVSb3dcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlSGVhZGluZ1xuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndGFibGVIZWFkaW5nJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlSGVhZGluZ1xuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRsZXQgYnV0dG9uQ29tbWFuZHNMaXN0O1xuXHRcdGxldCBidXR0b25Db21tYW5kc0xpc3RJZDtcblxuXHRcdGlmICh0aGlzLnByb3BzLmV4cGFuZGVkKSB7XG5cdFx0XHRidXR0b25Db21tYW5kc0xpc3RJZCA9IEJ1dHRvblRhYmxlSGVhZGluZy5rZXkgKyAnTGlzdCc7XG5cdFx0XHRidXR0b25Db21tYW5kc0xpc3QgPSAoXG5cdFx0XHRcdDxCdXR0b25Db21tYW5kc0xpc3Rcblx0XHRcdFx0XHRjb21tYW5kcz17dGhpcy5fZ2V0Q29tbWFuZHMoKX1cblx0XHRcdFx0XHRsaXN0SWQ9e2J1dHRvbkNvbW1hbmRzTGlzdElkfVxuXHRcdFx0XHRcdG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0Lz5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgYWN0aXZlSGVhZGluZyA9IG5ldyBDS0VESVRPUi5UYWJsZShcblx0XHRcdHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKVxuXHRcdCkuZ2V0SGVhZGluZygpO1xuXHRcdGNvbnN0IGFjdGl2ZUhlYWRpbmdJbnRybyA9IEFsbG95RWRpdG9yLlN0cmluZ3MuaGVhZGVycyArICc6Jztcblx0XHRjb25zdCBhY3RpdmVIZWFkaW5nTGFiZWwgPVxuXHRcdFx0QWxsb3lFZGl0b3IuU3RyaW5nc1snaGVhZGVycycgKyBhY3RpdmVIZWFkaW5nXTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1kcm9wZG93bi14bCBhZS1oYXMtZHJvcGRvd25cIj5cblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9XG5cdFx0XHRcdFx0YXJpYS1sYWJlbD1cIlwiXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtdG9vbGJhci1lbGVtZW50XCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdHJvbGU9XCJjb21ib2JveFwiXG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0dGl0bGU9XCJcIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lclwiPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWRyb3Bkb3duLXNlbGVjdGVkLWl0ZW1cIj5cblx0XHRcdFx0XHRcdFx0e2FjdGl2ZUhlYWRpbmdJbnRyb317JyAnfVxuXHRcdFx0XHRcdFx0XHQ8c3Ryb25nPnthY3RpdmVIZWFkaW5nTGFiZWx9PC9zdHJvbmc+XG5cdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJjYXJldC1ib3R0b21cIiAvPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0e2J1dHRvbkNvbW1hbmRzTGlzdH1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGxpc3Qgb2YgY29tbWFuZHMuIElmIGEgbGlzdCBvZiBjb21tYW5kcyB3YXMgcGFzc2VkXG5cdCAqIGFzIHByb3BlcnR5IGBjb21tYW5kc2AsIGl0IHdpbGwgdGFrZSBhIHByZWNlZGVuY2Ugb3ZlciB0aGUgZGVmYXVsdCBvbmVzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlSGVhZGluZ1xuXHQgKiBAbWV0aG9kIF9nZXRDb21tYW5kc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBhdmFpbGFibGUgY29tbWFuZHMuXG5cdCAqL1xuXHRfZ2V0Q29tbWFuZHMoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMucHJvcHMuY29tbWFuZHMgfHwgW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ3RhYmxlSGVhZGluZ05vbmUnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmhlYWRlcnNOb25lLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ3RhYmxlSGVhZGluZ1JvdycsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuaGVhZGVyc1Jvdyxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICd0YWJsZUhlYWRpbmdDb2x1bW4nLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmhlYWRlcnNDb2x1bW4sXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAndGFibGVIZWFkaW5nQm90aCcsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuaGVhZGVyc0JvdGgsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25UYWJsZUhlYWRpbmc7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYWJsZVJlbW92ZSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciByZW1vdmluZyBhIHRhYmxlXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhYmxlUmVtb3ZlXG4gKi9cbmNsYXNzIEJ1dHRvblRhYmxlUmVtb3ZlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IHRhYmxlUmVtb3ZlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVJlbW92ZVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndGFibGVSZW1vdmUnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVSZW1vdmVcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5kZWxldGVUYWJsZX1cblx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXRhYmxlLXJlbW92ZVwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX3JlbW92ZVRhYmxlfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuZGVsZXRlVGFibGV9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJ0cmFzaFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHRhYmxlIGluIHRoZSBlZGl0b3IgZWxlbWVudC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVJlbW92ZVxuXHQgKiBAbWV0aG9kIF9yZW1vdmVUYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfcmVtb3ZlVGFibGUgPSAoKSA9PiB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdGNvbnN0IHRhYmxlVXRpbHMgPSBuZXcgQ0tFRElUT1IuVGFibGUoZWRpdG9yKTtcblxuXHRcdHRhYmxlVXRpbHMucmVtb3ZlKCk7XG5cblx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlUmVtb3ZlO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZHNMaXN0IGZyb20gJy4vYnV0dG9uLWNvbW1hbmRzLWxpc3QuanN4JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFibGVSb3cgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byB3b3JrIHdpdGggdGFibGUgcm93cy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVGFibGVSb3dcbiAqL1xuY2xhc3MgQnV0dG9uVGFibGVSb3cgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IHRhYmxlUm93XG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVJvd1xuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndGFibGVSb3cnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVSb3dcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IGJ1dHRvbkNvbW1hbmRzTGlzdDtcblx0XHRsZXQgYnV0dG9uQ29tbWFuZHNMaXN0SWQ7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5leHBhbmRlZCkge1xuXHRcdFx0YnV0dG9uQ29tbWFuZHNMaXN0SWQgPSBCdXR0b25UYWJsZVJvdy5rZXkgKyAnTGlzdCc7XG5cdFx0XHRidXR0b25Db21tYW5kc0xpc3QgPSAoXG5cdFx0XHRcdDxCdXR0b25Db21tYW5kc0xpc3Rcblx0XHRcdFx0XHRjb21tYW5kcz17dGhpcy5fZ2V0Q29tbWFuZHMoKX1cblx0XHRcdFx0XHRsaXN0SWQ9e2J1dHRvbkNvbW1hbmRzTGlzdElkfVxuXHRcdFx0XHRcdG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0Lz5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyIGFlLWhhcy1kcm9wZG93blwiPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1leHBhbmRlZD17dGhpcy5wcm9wcy5leHBhbmRlZH1cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnJvd31cblx0XHRcdFx0XHRhcmlhLW93bnM9e2J1dHRvbkNvbW1hbmRzTGlzdElkfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0XHRyb2xlPVwiY29tYm9ib3hcIlxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnJvd30+XG5cdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiYWRkLXJvd1wiIC8+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHR7YnV0dG9uQ29tbWFuZHNMaXN0fVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbGlzdCBvZiBjb21tYW5kcy4gSWYgYSBsaXN0IG9mIGNvbW1hbmRzIHdhcyBwYXNzZWRcblx0ICogYXMgcHJvcGVydHkgYGNvbW1hbmRzYCwgaXQgd2lsbCB0YWtlIGEgcHJlY2VkZW5jZSBvdmVyIHRoZSBkZWZhdWx0IG9uZXMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVSb3dcblx0ICogQG1ldGhvZCBfZ2V0Q29tbWFuZHNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGNvbW1hbmRzLlxuXHQgKi9cblx0X2dldENvbW1hbmRzKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLmNvbW1hbmRzIHx8IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdyb3dJbnNlcnRCZWZvcmUnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLnJvd0luc2VydEJlZm9yZSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdyb3dJbnNlcnRBZnRlcicsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3Mucm93SW5zZXJ0QWZ0ZXIsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAncm93RGVsZXRlJyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5yb3dEZWxldGUsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25UYWJsZVJvdztcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlRWRpdCBmcm9tICcuL2J1dHRvbi10YWJsZS1lZGl0LmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblRhYmxlIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIGFuZCBlZGl0aW5nIGEgdGFibGUgaW4gYSBkb2N1bWVudC4gQnV0dG9uVGFibGVcbiAqIHJlbmRlcnMgaW4gdHdvIGRpZmZlcmVudCBtb2RlczpcbiAqXG4gKiAtIE5vcm1hbDogSnVzdCBhIGJ1dHRvbiB0aGF0IGFsbG93cyB0byBzd2l0Y2ggdG8gdGhlIGVkaXRpb24gbW9kZVxuICogLSBFeGNsdXNpdmU6IFRoZSBCdXR0b25UYWJsZUVkaXQgVUkgd2l0aCBhbGwgdGhlIHRhYmxlIGVkaXRpb24gY29udHJvbHMuXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhYmxlXG4gKi9cbmNsYXNzIEJ1dHRvblRhYmxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCB0YWJsZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3RhYmxlJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuXHRcdFx0cmV0dXJuIDxCdXR0b25UYWJsZUVkaXQgey4uLnRoaXMucHJvcHN9IC8+O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy50YWJsZX1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi10YWJsZVwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5wcm9wcy5yZXF1ZXN0RXhjbHVzaXZlfVxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnRhYmxlfT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJ0YWJsZVwiIC8+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0KTtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uVGFibGU7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyJztcbmltcG9ydCBCdXR0b25Ecm9wZG93biBmcm9tICcuL2J1dHRvbi1kcm9wZG93bi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYXJnZXRMaXN0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNoYW5naW5nIHRoZSB0YXJnZXQgb2YgYSBsaW5rXG4gKiBpbiB0aGUgZG9jdW1lbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhcmdldExpc3RcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBCdXR0b25UYXJnZXRMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhcmdldExpc3Rcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y2lyY3VsYXI6IHRydWUsXG5cdFx0ZGVzY2VuZGFudHM6ICcuYWUtdG9vbGJhci1lbGVtZW50Jyxcblx0XHRrZXlzOiB7XG5cdFx0XHRkaXNtaXNzOiBbMjddLFxuXHRcdFx0ZGlzbWlzc05leHQ6IFszOV0sXG5cdFx0XHRkaXNtaXNzUHJldjogWzM3XSxcblx0XHRcdG5leHQ6IFs0MF0sXG5cdFx0XHRwcmV2OiBbMzhdLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBsaW5rVGFyZ2V0RWRpdFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFyZ2V0TGlzdFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndGFyZ2V0TGlzdCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFyZ2V0TGlzdFxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHRSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5mb2N1cygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYXJnZXRMaXN0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGxpc3RUYXJnZXRzID0gdGhpcy5fcmVuZGVyTGlzdFRhcmdldHMoKTtcblxuXHRcdHJldHVybiA8QnV0dG9uRHJvcGRvd24gey4uLnRoaXMucHJvcHN9PntsaXN0VGFyZ2V0c308L0J1dHRvbkRyb3Bkb3duPjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0aGUgYWxsb3dlZCBsaW5rIHRhcmdldCBpdGVtcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYXJnZXRMaXN0XG5cdCAqIEBtZXRob2QgX2dldEFsbG93ZWRUYXJnZXRJdGVtc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0FycmF5fSBUaGUgYWxsb3dlZCB0YXJnZXQgaXRlbXMuXG5cdCAqL1xuXHRfZ2V0QWxsb3dlZFRhcmdldEl0ZW1zKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLmFsbG93ZWRMaW5rVGFyZ2V0cyB8fCBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0RGVmYXVsdCxcblx0XHRcdFx0XHR2YWx1ZTogJycsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0U2VsZixcblx0XHRcdFx0XHR2YWx1ZTogJ19zZWxmJyxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmxpbmtUYXJnZXRCbGFuayxcblx0XHRcdFx0XHR2YWx1ZTogJ19ibGFuaycsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0UGFyZW50LFxuXHRcdFx0XHRcdHZhbHVlOiAnX3BhcmVudCcsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0VG9wLFxuXHRcdFx0XHRcdHZhbHVlOiAnX3RvcCcsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXJzIHRoZSBhbGxvd2VkIGxpbmsgdGFyZ2V0IGl0ZW1zLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhcmdldExpc3Rcblx0ICogQG1ldGhvZCBfcmVuZGVyTGlzdFRhcmdldHNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIHJlbmRlcmVkIGxpbmsgaXRlbXNcblx0ICovXG5cdF9yZW5kZXJMaXN0VGFyZ2V0cygpIHtcblx0XHRsZXQgdGFyZ2V0cyA9IHRoaXMuX2dldEFsbG93ZWRUYXJnZXRJdGVtcygpO1xuXG5cdFx0Y29uc3QgaGFuZGxlTGlua1RhcmdldENoYW5nZSA9IHRoaXMucHJvcHMuaGFuZGxlTGlua1RhcmdldENoYW5nZTtcblxuXHRcdHRhcmdldHMgPSB0YXJnZXRzLm1hcCh0YXJnZXQgPT4ge1xuXHRcdFx0Y29uc3QgY2xhc3NOYW1lID1cblx0XHRcdFx0dGhpcy5wcm9wcy5zZWxlY3RlZFRhcmdldCA9PT0gdGFyZ2V0LnZhbHVlXG5cdFx0XHRcdFx0PyAnYWUtdG9vbGJhci1lbGVtZW50IGFjdGl2ZSdcblx0XHRcdFx0XHQ6ICdhZS10b29sYmFyLWVsZW1lbnQnO1xuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8bGkga2V5PXt0YXJnZXQudmFsdWV9IHJvbGU9XCJvcHRpb25cIj5cblx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzTmFtZX1cblx0XHRcdFx0XHRcdGRhdGEtdmFsdWU9e3RhcmdldC52YWx1ZX1cblx0XHRcdFx0XHRcdG9uQ2xpY2s9e2hhbmRsZUxpbmtUYXJnZXRDaGFuZ2V9PlxuXHRcdFx0XHRcdFx0e3RhcmdldC5sYWJlbH1cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PC9saT5cblx0XHRcdCk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0cztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRGb2N1c01hbmFnZXIoQnV0dG9uVGFyZ2V0TGlzdCk7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuY29uc3QgTUFYX1RXRUVUX0xFTkdUSCA9IDI4MDtcblxuLyoqXG4gKiBUaGUgQnV0dG9uVHdpdHRlciBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhIGxpbmsgd2hpY2hcbiAqIGFsbG93cyBwZW9wbGUgdG8gdHdlZXQgcGFydCBvZiB0aGUgY29udGVudCBpbiB0aGUgZWRpdG9yLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Ud2l0dGVyXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uVHdpdHRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCB0d2l0dGVyXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Ud2l0dGVyXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICd0d2l0dGVyJztcblxuXHQvKipcblx0ICogQ3JlYXRlcyBvciByZW1vdmVzIHRoZSB0d2l0dGVyIGxpbmsgb24gdGhlIHNlbGVjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Ud2l0dGVyXG5cdCAqIEBtZXRob2QgaGFuZGxlQ2xpY2tcblx0ICovXG5cdGhhbmRsZUNsaWNrID0gKCkgPT4ge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGNvbnN0IGxpbmtVdGlscyA9IG5ldyBDS0VESVRPUi5MaW5rKGVkaXRvcik7XG5cblx0XHRpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG5cdFx0XHRsaW5rVXRpbHMucmVtb3ZlKGxpbmtVdGlscy5nZXRGcm9tU2VsZWN0aW9uKCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsaW5rVXRpbHMuY3JlYXRlKHRoaXMuX2dldEhyZWYoKSwge1xuXHRcdFx0XHRjbGFzczogJ2FlLXR3aXR0ZXItbGluaycsXG5cdFx0XHRcdHRhcmdldDogJ19ibGFuaycsXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgY29udGFpbmVkIHdpdGhpbiBhIGxpbmsgdGhhdCBwb2ludHMgdG8gdHdpdHRlci5jb20vaW50ZW50L3R3ZWV0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblR3aXR0ZXJcblx0ICogQG1ldGhvZCBpc0FjdGl2ZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBzZWxlY3Rpb24gaXMgaW5zaWRlIGEgdHdpdHRlciBsaW5rLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuXHRpc0FjdGl2ZSgpIHtcblx0XHRjb25zdCBsaW5rID0gbmV3IENLRURJVE9SLkxpbmsoXG5cdFx0XHR0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJylcblx0XHQpLmdldEZyb21TZWxlY3Rpb24oKTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHRsaW5rICYmXG5cdFx0XHRsaW5rLmdldEF0dHJpYnV0ZSgnaHJlZicpLmluZGV4T2YoJ3R3aXR0ZXIuY29tL2ludGVudC90d2VldCcpICE9PSAtMVxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblR3aXR0ZXJcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy50d2l0dGVyfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tdHdpdHRlclwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy50d2l0dGVyfT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwidHdpdHRlclwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyB0aGUgYXBwcm9wcmlhdGUgdHdpdHRlciB1cmwgYmFzZWQgb24gdGhlIHNlbGVjdGVkIHRleHQgYW5kIHRoZSBjb25maWd1cmF0aW9uXG5cdCAqIG9wdGlvbnMgcmVjZWl2ZWQgdmlhIHByb3BzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblR3aXR0ZXJcblx0ICogQG1ldGhvZCBfZ2V0SHJlZlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gQSB2YWxpZCB0d2l0dGVyIHVybCB3aXRoIHRoZSBzZWxlY3RlZCB0ZXh0IGFuZCBnaXZlbiBjb25maWd1cmF0aW9uLlxuXHQgKi9cblx0X2dldEhyZWYoKSB7XG5cdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdGNvbnN0IHNlbGVjdGVkVGV4dCA9IG5hdGl2ZUVkaXRvclxuXHRcdFx0LmdldFNlbGVjdGlvbigpXG5cdFx0XHQuZ2V0U2VsZWN0ZWRUZXh0KClcblx0XHRcdC5zdWJzdHJpbmcoMCwgTUFYX1RXRUVUX0xFTkdUSCk7XG5cdFx0Y29uc3QgdXJsID0gdGhpcy5wcm9wcy51cmw7XG5cdFx0Y29uc3QgdmlhID0gdGhpcy5wcm9wcy52aWE7XG5cdFx0bGV0IHR3aXR0ZXJIcmVmID1cblx0XHRcdCdodHRwczovL3R3aXR0ZXIuY29tL2ludGVudC90d2VldD90ZXh0PScgKyBzZWxlY3RlZFRleHQ7XG5cblx0XHRpZiAodXJsKSB7XG5cdFx0XHR0d2l0dGVySHJlZiArPSAnJnVybD0nICsgdXJsO1xuXHRcdH1cblxuXHRcdGlmICh2aWEpIHtcblx0XHRcdHR3aXR0ZXJIcmVmICs9ICcmdmlhPScgKyB2aWE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHR3aXR0ZXJIcmVmO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25Ud2l0dGVyKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVW5vcmRlcmVkbGlzdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyB1bm9yZGVyZWQgbGlzdHMgaW4gYW4gZWRpdG9yLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Vbm9yZGVyZWRsaXN0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblVub3JkZXJlZGxpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVW5vcmRlcmVkbGlzdFxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdidWxsZXRlZGxpc3QnLFxuXHRcdHN0eWxlOiB7XG5cdFx0XHRlbGVtZW50OiAndWwnLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCB1bFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVW5vcmRlcmVkbGlzdFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndWwnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVW5vcmRlcmVkbGlzdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmJ1bGxldGVkbGlzdH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tdWxcIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYnVsbGV0ZWRsaXN0fT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwibGlzdC11bFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25TdHlsZShCdXR0b25Vbm9yZGVyZWRsaXN0KSlcbik7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbktleXN0cm9rZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1rZXlzdHJva2UnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZSc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblVuZGVybGluZSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciB1bmRlcmx5aW5nIGEgdGV4dCBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvblVuZGVybGluZVxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uS2V5c3Ryb2tlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblVuZGVybGluZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25VbmRlcmxpbmVcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAndW5kZXJsaW5lJyxcblx0XHRrZXlzdHJva2U6IHtcblx0XHRcdGZuOiAnZXhlY0NvbW1hbmQnLFxuXHRcdFx0a2V5czogQ0tFRElUT1IuQ1RSTCArIDg1IC8qIFUqLyxcblx0XHRcdG5hbWU6ICd1bmRlcmxpbmUnLFxuXHRcdH0sXG5cdFx0c3R5bGU6ICdjb3JlU3R5bGVzX3VuZGVybGluZScsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCB1bmRlcmxpbmVcblx0ICogQG1lbWJlcm9mIEJ1dHRvblVuZGVybGluZVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndW5kZXJsaW5lJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblVuZGVybGluZVxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnVuZGVybGluZX1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tdW5kZXJsaW5lXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnVuZGVybGluZX0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInVuZGVybGluZVwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbktleXN0cm9rZShCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uU3R5bGUoQnV0dG9uVW5kZXJsaW5lKSkpXG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgQnV0dG9uQWNjZXNzaWJpbGl0eUltYWdlQWx0IGZyb20gJy4vYnV0dG9uLWFjY2Vzc2liaWxpdHktaW1hZ2UtYWx0LmpzeCc7XG5pbXBvcnQgQnV0dG9uQmFja2dyb3VuZENvbG9yIGZyb20gJy4vYnV0dG9uLWJhY2tncm91bmQtY29sb3IuanN4JztcbmltcG9ydCBCdXR0b25Cb2xkIGZyb20gJy4vYnV0dG9uLWJvbGQuanN4JztcbmltcG9ydCBCdXR0b25DYW1lcmFJbWFnZSBmcm9tICcuL2J1dHRvbi1jYW1lcmEtaW1hZ2UuanN4JztcbmltcG9ydCBCdXR0b25DYW1lcmEgZnJvbSAnLi9idXR0b24tY2FtZXJhLmpzeCc7XG5pbXBvcnQgQnV0dG9uQ29kZSBmcm9tICcuL2J1dHRvbi1jb2RlLmpzeCc7XG5pbXBvcnQgQnV0dG9uQ29sb3IgZnJvbSAnLi9idXR0b24tY29sb3IuanN4JztcbmltcG9ydCBCdXR0b25Db21tYW5kTGlzdEl0ZW0gZnJvbSAnLi9idXR0b24tY29tbWFuZC1saXN0LWl0ZW0uanN4JztcbmltcG9ydCBCdXR0b25Db21tYW5kc0xpc3QgZnJvbSAnLi9idXR0b24tY29tbWFuZHMtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkRyb3Bkb3duIGZyb20gJy4vYnV0dG9uLWRyb3Bkb3duLmpzeCc7XG5pbXBvcnQgQnV0dG9uRW1iZWRFZGl0IGZyb20gJy4vYnV0dG9uLWVtYmVkLWVkaXQuanN4JztcbmltcG9ydCBCdXR0b25FbWJlZFZpZGVvRWRpdCBmcm9tICcuL2J1dHRvbi1lbWJlZC12aWRlby1lZGl0LmpzeCc7XG5pbXBvcnQgQnV0dG9uRW1iZWRWaWRlbyBmcm9tICcuL2J1dHRvbi1lbWJlZC12aWRlby5qc3gnO1xuaW1wb3J0IEJ1dHRvbkVtYmVkIGZyb20gJy4vYnV0dG9uLWVtYmVkLmpzeCc7XG5pbXBvcnQgQnV0dG9uSDEgZnJvbSAnLi9idXR0b24taDEuanN4JztcbmltcG9ydCBCdXR0b25IMiBmcm9tICcuL2J1dHRvbi1oMi5qc3gnO1xuaW1wb3J0IEJ1dHRvbkhsaW5lIGZyb20gJy4vYnV0dG9uLWhsaW5lLmpzeCc7XG5pbXBvcnQgQnV0dG9uSW1hZ2VBbGlnbkNlbnRlciBmcm9tICcuL2J1dHRvbi1pbWFnZS1hbGlnbi1jZW50ZXIuanN4JztcbmltcG9ydCBCdXR0b25JbWFnZUFsaWduTGVmdCBmcm9tICcuL2J1dHRvbi1pbWFnZS1hbGlnbi1sZWZ0LmpzeCc7XG5pbXBvcnQgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0IGZyb20gJy4vYnV0dG9uLWltYWdlLWFsaWduLXJpZ2h0LmpzeCc7XG5pbXBvcnQgQnV0dG9uSW1hZ2UgZnJvbSAnLi9idXR0b24taW1hZ2UuanN4JztcbmltcG9ydCBCdXR0b25JbmRlbnRCbG9jayBmcm9tICcuL2J1dHRvbi1pbmRlbnQtYmxvY2suanN4JztcbmltcG9ydCBCdXR0b25JdGFsaWMgZnJvbSAnLi9idXR0b24taXRhbGljLmpzeCc7XG5pbXBvcnQgQnV0dG9uSXRlbVNlbGVjdG9yQXVkaW8gZnJvbSAnLi9idXR0b24taXRlbS1zZWxlY3Rvci1hdWRpby5qc3gnO1xuaW1wb3J0IEJ1dHRvbkl0ZW1TZWxlY3RvckltYWdlIGZyb20gJy4vYnV0dG9uLWl0ZW0tc2VsZWN0b3ItaW1hZ2UuanN4JztcbmltcG9ydCBCdXR0b25JdGVtU2VsZWN0b3JWaWRlbyBmcm9tICcuL2J1dHRvbi1pdGVtLXNlbGVjdG9yLXZpZGVvLmpzeCc7XG5pbXBvcnQgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QgZnJvbSAnLi9idXR0b24tbGluay1hdXRvY29tcGxldGUtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkxpbmtCcm93c2UgZnJvbSAnLi9idXR0b24tbGluay1icm93c2UuanN4JztcbmltcG9ydCBCdXR0b25MaW5rRWRpdEJyb3dzZSBmcm9tICcuL2J1dHRvbi1saW5rLWVkaXQtYnJvd3NlLmpzeCc7XG5pbXBvcnQgQnV0dG9uTGlua0VkaXQgZnJvbSAnLi9idXR0b24tbGluay1lZGl0LmpzeCc7XG5pbXBvcnQgQnV0dG9uTGlua1RhcmdldEVkaXQgZnJvbSAnLi9idXR0b24tbGluay10YXJnZXQtZWRpdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkxpbmsgZnJvbSAnLi9idXR0b24tbGluay5qc3gnO1xuaW1wb3J0IEJ1dHRvbk9sIGZyb20gJy4vYnV0dG9uLW9sLmpzeCc7XG5pbXBvcnQgQnV0dG9uT3V0ZGVudEJsb2NrIGZyb20gJy4vYnV0dG9uLW91dGRlbnQtYmxvY2suanN4JztcbmltcG9ydCBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnQgZnJvbSAnLi9idXR0b24tcGFyYWdyYXBoLWFsaWduLWxlZnQuanN4JztcbmltcG9ydCBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0IGZyb20gJy4vYnV0dG9uLXBhcmFncmFwaC1hbGlnbi1yaWdodC5qc3gnO1xuaW1wb3J0IEJ1dHRvblBhcmFncmFwaEFsaWduIGZyb20gJy4vYnV0dG9uLXBhcmFncmFwaC1hbGlnbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblBhcmFncmFwaENlbnRlciBmcm9tICcuL2J1dHRvbi1wYXJhZ3JhcGgtY2VudGVyLmpzeCc7XG5pbXBvcnQgQnV0dG9uUGFyYWdyYXBoSnVzdGlmeSBmcm9tICcuL2J1dHRvbi1wYXJhZ3JhcGgtanVzdGlmeS5qc3gnO1xuaW1wb3J0IEJ1dHRvblF1b3RlIGZyb20gJy4vYnV0dG9uLXF1b3RlLmpzeCc7XG5pbXBvcnQgQnV0dG9uUmVtb3ZlRm9ybWF0IGZyb20gJy4vYnV0dG9uLXJlbW92ZS1mb3JtYXQuanN4JztcbmltcG9ydCBCdXR0b25SZW1vdmVJbWFnZSBmcm9tICcuL2J1dHRvbi1yZW1vdmUtaW1hZ2UuanN4JztcbmltcG9ydCBCdXR0b25TZXBhcmF0b3IgZnJvbSAnLi9idXR0b24tc2VwYXJhdG9yLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3BhY2luZyBmcm9tICcuL2J1dHRvbi1zcGFjaW5nLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3RyaWtlIGZyb20gJy4vYnV0dG9uLXN0cmlrZS5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3RIZWFkZXIgZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QtaGVhZGVyLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmUgZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QtaXRlbS1yZW1vdmUuanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0SXRlbSBmcm9tICcuL2J1dHRvbi1zdHlsZXMtbGlzdC1pdGVtLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3R5bGVzTGlzdCBmcm9tICcuL2J1dHRvbi1zdHlsZXMtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlcyBmcm9tICcuL2J1dHRvbi1zdHlsZXMuanN4JztcbmltcG9ydCBCdXR0b25TdWJzY3JpcHQgZnJvbSAnLi9idXR0b24tc3Vic2NyaXB0LmpzeCc7XG5pbXBvcnQgQnV0dG9uU3VwZXJzY3JpcHQgZnJvbSAnLi9idXR0b24tc3VwZXJzY3JpcHQuanN4JztcbmltcG9ydCBCdXR0b25UYWJsZUNlbGwgZnJvbSAnLi9idXR0b24tdGFibGUtY2VsbC5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlQ29sdW1uIGZyb20gJy4vYnV0dG9uLXRhYmxlLWNvbHVtbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlRWRpdCBmcm9tICcuL2J1dHRvbi10YWJsZS1lZGl0LmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFibGVIZWFkaW5nIGZyb20gJy4vYnV0dG9uLXRhYmxlLWhlYWRpbmcuanN4JztcbmltcG9ydCBCdXR0b25UYWJsZVJlbW92ZSBmcm9tICcuL2J1dHRvbi10YWJsZS1yZW1vdmUuanN4JztcbmltcG9ydCBCdXR0b25UYWJsZVJvdyBmcm9tICcuL2J1dHRvbi10YWJsZS1yb3cuanN4JztcbmltcG9ydCBCdXR0b25UYWJsZSBmcm9tICcuL2J1dHRvbi10YWJsZS5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhcmdldExpc3QgZnJvbSAnLi9idXR0b24tdGFyZ2V0LWxpc3QuanN4JztcbmltcG9ydCBCdXR0b25Ud2l0dGVyIGZyb20gJy4vYnV0dG9uLXR3aXR0ZXIuanN4JztcbmltcG9ydCBCdXR0b25VbCBmcm9tICcuL2J1dHRvbi11bC5qc3gnO1xuaW1wb3J0IEJ1dHRvblVuZGVybGluZSBmcm9tICcuL2J1dHRvbi11bmRlcmxpbmUuanN4JztcblxuZXhwb3J0IGRlZmF1bHQge1xuXHRbQnV0dG9uQWNjZXNzaWJpbGl0eUltYWdlQWx0LmtleV06IEJ1dHRvbkFjY2Vzc2liaWxpdHlJbWFnZUFsdCxcblx0W0J1dHRvbkJhY2tncm91bmRDb2xvci5rZXldOiBCdXR0b25CYWNrZ3JvdW5kQ29sb3IsXG5cdFtCdXR0b25Cb2xkLmtleV06IEJ1dHRvbkJvbGQsXG5cdFtCdXR0b25DYW1lcmFJbWFnZS5rZXldOiBCdXR0b25DYW1lcmFJbWFnZSxcblx0W0J1dHRvbkNhbWVyYS5rZXldOiBCdXR0b25DYW1lcmEsXG5cdFtCdXR0b25Db2RlLmtleV06IEJ1dHRvbkNvZGUsXG5cdFtCdXR0b25Db2xvci5rZXldOiBCdXR0b25Db2xvcixcblx0W0J1dHRvbkNvbW1hbmRMaXN0SXRlbS5rZXldOiBCdXR0b25Db21tYW5kTGlzdEl0ZW0sXG5cdFtCdXR0b25Db21tYW5kc0xpc3Qua2V5XTogQnV0dG9uQ29tbWFuZHNMaXN0LFxuXHRbQnV0dG9uRHJvcGRvd24ua2V5XTogQnV0dG9uRHJvcGRvd24sXG5cdFtCdXR0b25FbWJlZEVkaXQua2V5XTogQnV0dG9uRW1iZWRFZGl0LFxuXHRbQnV0dG9uRW1iZWQua2V5XTogQnV0dG9uRW1iZWQsXG5cdFtCdXR0b25FbWJlZFZpZGVvRWRpdC5rZXldOiBCdXR0b25FbWJlZFZpZGVvRWRpdCxcblx0W0J1dHRvbkVtYmVkVmlkZW8ua2V5XTogQnV0dG9uRW1iZWRWaWRlbyxcblx0W0J1dHRvbkgxLmtleV06IEJ1dHRvbkgxLFxuXHRbQnV0dG9uSDIua2V5XTogQnV0dG9uSDIsXG5cdFtCdXR0b25IbGluZS5rZXldOiBCdXR0b25IbGluZSxcblx0W0J1dHRvbkltYWdlQWxpZ25DZW50ZXIua2V5XTogQnV0dG9uSW1hZ2VBbGlnbkNlbnRlcixcblx0W0J1dHRvbkltYWdlQWxpZ25MZWZ0LmtleV06IEJ1dHRvbkltYWdlQWxpZ25MZWZ0LFxuXHRbQnV0dG9uSW1hZ2VBbGlnblJpZ2h0LmtleV06IEJ1dHRvbkltYWdlQWxpZ25SaWdodCxcblx0W0J1dHRvbkltYWdlLmtleV06IEJ1dHRvbkltYWdlLFxuXHRbQnV0dG9uSW5kZW50QmxvY2sua2V5XTogQnV0dG9uSW5kZW50QmxvY2ssXG5cdFtCdXR0b25JdGFsaWMua2V5XTogQnV0dG9uSXRhbGljLFxuXHRbQnV0dG9uSXRlbVNlbGVjdG9yQXVkaW8ua2V5XTogQnV0dG9uSXRlbVNlbGVjdG9yQXVkaW8sXG5cdFtCdXR0b25JdGVtU2VsZWN0b3JJbWFnZS5rZXldOiBCdXR0b25JdGVtU2VsZWN0b3JJbWFnZSxcblx0W0J1dHRvbkl0ZW1TZWxlY3RvclZpZGVvLmtleV06IEJ1dHRvbkl0ZW1TZWxlY3RvclZpZGVvLFxuXHRbQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Qua2V5XTogQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QsXG5cdFtCdXR0b25MaW5rQnJvd3NlLmtleV06IEJ1dHRvbkxpbmtCcm93c2UsXG5cdFtCdXR0b25MaW5rRWRpdEJyb3dzZS5rZXldOiBCdXR0b25MaW5rRWRpdEJyb3dzZSxcblx0W0J1dHRvbkxpbmtFZGl0LmtleV06IEJ1dHRvbkxpbmtFZGl0LFxuXHRbQnV0dG9uTGlua1RhcmdldEVkaXQua2V5XTogQnV0dG9uTGlua1RhcmdldEVkaXQsXG5cdFtCdXR0b25MaW5rLmtleV06IEJ1dHRvbkxpbmssXG5cdFtCdXR0b25PbC5rZXldOiBCdXR0b25PbCxcblx0W0J1dHRvbk91dGRlbnRCbG9jay5rZXldOiBCdXR0b25PdXRkZW50QmxvY2ssXG5cdFtCdXR0b25QYXJhZ3JhcGhBbGlnbi5rZXldOiBCdXR0b25QYXJhZ3JhcGhBbGlnbixcblx0W0J1dHRvblBhcmFncmFwaEFsaWduTGVmdC5rZXldOiBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnQsXG5cdFtCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0LmtleV06IEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHQsXG5cdFtCdXR0b25QYXJhZ3JhcGhDZW50ZXIua2V5XTogQnV0dG9uUGFyYWdyYXBoQ2VudGVyLFxuXHRbQnV0dG9uUGFyYWdyYXBoSnVzdGlmeS5rZXldOiBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5LFxuXHRbQnV0dG9uUXVvdGUua2V5XTogQnV0dG9uUXVvdGUsXG5cdFtCdXR0b25SZW1vdmVGb3JtYXQua2V5XTogQnV0dG9uUmVtb3ZlRm9ybWF0LFxuXHRbQnV0dG9uUmVtb3ZlSW1hZ2Uua2V5XTogQnV0dG9uUmVtb3ZlSW1hZ2UsXG5cdFtCdXR0b25TZXBhcmF0b3Iua2V5XTogQnV0dG9uU2VwYXJhdG9yLFxuXHRbQnV0dG9uU3BhY2luZy5rZXldOiBCdXR0b25TcGFjaW5nLFxuXHRbQnV0dG9uU3RyaWtlLmtleV06IEJ1dHRvblN0cmlrZSxcblx0W0J1dHRvblN0eWxlc0xpc3RIZWFkZXIua2V5XTogQnV0dG9uU3R5bGVzTGlzdEhlYWRlcixcblx0W0J1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlLmtleV06IEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlLFxuXHRbQnV0dG9uU3R5bGVzTGlzdEl0ZW0ua2V5XTogQnV0dG9uU3R5bGVzTGlzdEl0ZW0sXG5cdFtCdXR0b25TdHlsZXNMaXN0LmtleV06IEJ1dHRvblN0eWxlc0xpc3QsXG5cdFtCdXR0b25TdHlsZXMua2V5XTogQnV0dG9uU3R5bGVzLFxuXHRbQnV0dG9uU3Vic2NyaXB0LmtleV06IEJ1dHRvblN1YnNjcmlwdCxcblx0W0J1dHRvblN1cGVyc2NyaXB0LmtleV06IEJ1dHRvblN1cGVyc2NyaXB0LFxuXHRbQnV0dG9uVGFibGVDZWxsLmtleV06IEJ1dHRvblRhYmxlQ2VsbCxcblx0W0J1dHRvblRhYmxlQ29sdW1uLmtleV06IEJ1dHRvblRhYmxlQ29sdW1uLFxuXHRbQnV0dG9uVGFibGVFZGl0LmtleV06IEJ1dHRvblRhYmxlRWRpdCxcblx0W0J1dHRvblRhYmxlSGVhZGluZy5rZXldOiBCdXR0b25UYWJsZUhlYWRpbmcsXG5cdFtCdXR0b25UYWJsZVJlbW92ZS5rZXldOiBCdXR0b25UYWJsZVJlbW92ZSxcblx0W0J1dHRvblRhYmxlUm93LmtleV06IEJ1dHRvblRhYmxlUm93LFxuXHRbQnV0dG9uVGFibGUua2V5XTogQnV0dG9uVGFibGUsXG5cdFtCdXR0b25UYXJnZXRMaXN0LmtleV06IEJ1dHRvblRhcmdldExpc3QsXG5cdFtCdXR0b25Ud2l0dGVyLmtleV06IEJ1dHRvblR3aXR0ZXIsXG5cdFtCdXR0b25VbC5rZXldOiBCdXR0b25VbCxcblx0W0J1dHRvblVuZGVybGluZS5rZXldOiBCdXR0b25VbmRlcmxpbmUsXG59O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5cbi8qKlxuICogQnV0dG9uQWN0aW9uU3R5bGUgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGFwcGx5aW5nIHN0eWxlXG4gKiBpbXBsZW1lbnRhdGlvbiBmb3IgYSBidXR0b24gYmFzZWQgb24gdGhlIGBhcHBseVN0eWxlYCBhbmRcbiAqIGByZW1vdmVTdHlsZWAgQVBJIG9mIENLRURJVE9SLlxuICpcbiAqIFRvIGV4ZWN1dGUgcHJvcGVybHksIHRoZSBjb21wb25lbnQgaGFzIHRvIGV4cG9zZSB0aGUgZm9sbG93aW5nXG4gKiBtZXRob2RzIHdoaWNoIGNhbiBiZSBvYnRhaW5lZCBvdXQgb2YgdGhlIGJveCB1c2luZyB0aGUge3sjY3Jvc3NMaW5rXG4gKiBcIkJ1dHRvblN0eWxlXCJ9fXt7L2Nyb3NzTGlua319IG1peGluOlxuICogLSBgRnVuY3Rpb25gIHt7I2Nyb3NzTGluayBcIkJ1dHRvblN0eWxlL2lzQWN0aXZlXCJ9fXt7L2Nyb3NzTGlua319IHRvXG4gKiAgICBjaGVjayB0aGUgYWN0aXZlIHN0YXRlXG4gKiAtIGBGdW5jdGlvbmAge3sjY3Jvc3NMaW5rIFwiQnV0dG9uU3R5bGUvZ2V0U3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gdG9cbiAqICAgIHJldHVybiB0aGUgc3R5bGUgdGhhdCBzaG91bGQgYmUgYXBwbGllZFxuICpcbiAqIEBjbGFzcyBCdXR0b25BY3Rpb25TdHlsZVxuICovXG5jb25zdCBCdXR0b25BY3Rpb25TdHlsZSA9IHtcblx0LyoqXG5cdCAqIFJlbW92ZXMgb3IgYXBwbGllcyB0aGUgY29tcG9uZW50IHN0eWxlIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25BY3Rpb25TdHlsZVxuXHQgKiBAbWV0aG9kIGFwcGx5U3R5bGVcblx0ICovXG5cdGFwcGx5U3R5bGUoKSB7XG5cdFx0aWYgKExhbmcuaXNGdW5jdGlvbih0aGlzLmlzQWN0aXZlKSAmJiBMYW5nLmlzRnVuY3Rpb24odGhpcy5nZXRTdHlsZSkpIHtcblx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdGVkaXRvci5nZXRTZWxlY3Rpb24oKS5sb2NrKCk7XG5cblx0XHRcdGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcblx0XHRcdFx0ZWRpdG9yLnJlbW92ZVN0eWxlKHRoaXMuZ2V0U3R5bGUoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlZGl0b3IuYXBwbHlTdHlsZSh0aGlzLmdldFN0eWxlKCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRlZGl0b3IuZ2V0U2VsZWN0aW9uKCkudW5sb2NrKCk7XG5cblx0XHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0XHR9XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25BY3Rpb25TdHlsZTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuLyoqXG4gKiBCdXR0b25Db21tYW5kQWN0aXZlIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBhbiBgaXNBY3RpdmVgIG1ldGhvZCB0b1xuICogZGV0ZXJtaW5lIGlmIGEgY29udGV4dC1hd2FyZSBjb21tYW5kIGlzIGN1cnJlbnRseSBpbiBhbiBhY3RpdmUgc3RhdGUuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqL1xuY29uc3QgQnV0dG9uQ29tbWFuZEFjdGl2ZSA9IHtcblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgY29tbWFuZCBpcyBhY3RpdmUgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRBY3RpdmVcblx0ICogQG1ldGhvZCBpc0FjdGl2ZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBjb21tYW5kIGlzIGFjdGl2ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cblx0aXNBY3RpdmUoKSB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGNvbnN0IGNvbW1hbmQgPSBlZGl0b3IuZ2V0Q29tbWFuZCh0aGlzLnByb3BzLmNvbW1hbmQpO1xuXG5cdFx0cmV0dXJuIGNvbW1hbmQgPyBjb21tYW5kLnN0YXRlID09PSBDS0VESVRPUi5UUklTVEFURV9PTiA6IGZhbHNlO1xuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZEFjdGl2ZTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyoqXG4gKiBCdXR0b25Db21tYW5kIGlzIGEgbWl4aW4gdGhhdCBleGVjdXRlcyBhIGNvbW1hbmQgdmlhIENLRURJVE9SJ3MgQVBJLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db21tYW5kXG4gKi9cbmNvbnN0IEJ1dHRvbkNvbW1hbmQgPSB7XG5cdC8vIEFsbG93cyB2YWxpZGF0aW5nIHByb3BzIGJlaW5nIHBhc3NlZCB0byB0aGUgY29tcG9uZW50LlxuXHRwcm9wVHlwZXM6IHtcblx0XHQvKipcblx0XHQgKiBUaGUgY29tbWFuZCB0aGF0IHNob3VsZCBiZSBleGVjdXRlZC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25Db21tYW5kXG5cdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGNvbW1hbmRcblx0XHQgKi9cblx0XHRjb21tYW5kOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgY29tbWFuZCBtYXkgY2F1c2UgdGhlIGVkaXRvciB0byBoYXZlIGEgZGlmZmVyZW50LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRcblx0XHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IG1vZGlmaWVzU2VsZWN0aW9uXG5cdFx0ICovXG5cdFx0bW9kaWZpZXNTZWxlY3Rpb246IFByb3BUeXBlcy5ib29sLFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlcyBhIENLRWRpdG9yIGNvbW1hbmQgYW5kIGZpcmVzIGBhY3Rpb25QZXJmb3JtZWRgIGV2ZW50LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRcblx0ICogQHBhcmFtIHtPYmplY3Q9fSBkYXRhIE9wdGlvbmFsIGRhdGEgdG8gYmUgcGFzc2VkIHRvIENLRURJVE9SJ3MgYGV4ZWNDb21tYW5kYCBtZXRob2QuXG5cdCAqIEBtZXRob2QgZXhlY0NvbW1hbmRcblx0ICovXG5cdGV4ZWNDb21tYW5kKGRhdGEpIHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0ZWRpdG9yLmV4ZWNDb21tYW5kKHRoaXMucHJvcHMuY29tbWFuZCwgZGF0YSk7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5tb2RpZmllc1NlbGVjdGlvbikge1xuXHRcdFx0ZWRpdG9yLnNlbGVjdGlvbkNoYW5nZSh0cnVlKTtcblx0XHR9XG5cblx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5cbi8qKlxuICogQnV0dG9uS2V5c3Ryb2tlIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBhIGBrZXlzdHJva2VgIHByb3AgdGhhdCBhbGxvd3MgY29uZmlndXJpbmdcbiAqIGEgZnVuY3Rpb24gb2YgdGhlIGluc3RhbmNlIHRvIGJlIGludm9rZWQgdXBvbiB0aGUga2V5c3Ryb2tlIGFjdGl2YXRpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvbktleXN0cm9rZVxuICovXG5jb25zdCBCdXR0b25LZXlzdHJva2UgPSB7XG5cdC8vIEFsbG93cyB2YWxpZGF0aW5nIHByb3BzIGJlaW5nIHBhc3NlZCB0byB0aGUgY29tcG9uZW50LlxuXHRwcm9wVHlwZXM6IHtcblx0XHQvKipcblx0XHQgKiBUaGUga2V5c3Ryb2tlIGRlZmluaXRpb24uIEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0XHQgKiAtIGZuOiBUaGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWRcblx0XHQgKiAtIGtleXM6IFRoZSBrZXlzdHJva2UgZGVmaW5pdGlvbiwgYXMgZXhwZWN0ZWQgYnkgaHR0cDovL2RvY3MuY2tlZGl0b3IuY29tLyMhL2FwaS9DS0VESVRPUi5lZGl0b3ItbWV0aG9kLXNldEtleXN0cm9rZVxuXHRcdCAqIC0gbmFtZTogVGhlIG5hbWUgZm9yIHRoZSBDS0VkaXRvciBjb21tYW5kIHRoYXQgd2lsbCBiZSBjcmVhdGVkLiBJZiBlbXB0eSxcblx0XHQgKiBhIHJhbmRvbSBuYW1lIHdpbGwgYmUgY3JlYXRlZCBvbiB0aGUgZmx5XG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uS2V5c3Ryb2tlXG5cdFx0ICogQHByb3BlcnR5IHtPYmplY3R9IGtleXN0cm9rZVxuXHRcdCAqL1xuXHRcdGtleXN0cm9rZTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgYm90aCBvbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIsIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbktleXN0cm9rZVxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxNb3VudFxuXHQgKi9cblx0Y29tcG9uZW50V2lsbE1vdW50KCkge1xuXHRcdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdFx0Y29uc3Qga2V5c3Ryb2tlID0gdGhpcy5wcm9wcy5rZXlzdHJva2U7XG5cblx0XHRjb25zdCBjb21tYW5kTmFtZSA9XG5cdFx0XHRrZXlzdHJva2UubmFtZSB8fCAoKE1hdGgucmFuZG9tKCkgKiAxZTkpID4+PiAwKS50b1N0cmluZygpO1xuXG5cdFx0bGV0IGNvbW1hbmQgPSBuYXRpdmVFZGl0b3IuZ2V0Q29tbWFuZChjb21tYW5kTmFtZSk7XG5cblx0XHRpZiAoIWNvbW1hbmQpIHtcblx0XHRcdGNvbW1hbmQgPSBuZXcgQ0tFRElUT1IuY29tbWFuZChuYXRpdmVFZGl0b3IsIHtcblx0XHRcdFx0ZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0XHRcdFx0Y29uc3Qga2V5c3Ryb2tlRm4gPSBrZXlzdHJva2UuZm47XG5cblx0XHRcdFx0XHRpZiAoTGFuZy5pc1N0cmluZyhrZXlzdHJva2VGbikpIHtcblx0XHRcdFx0XHRcdHRoaXNba2V5c3Ryb2tlRm5dLmNhbGwodGhpcywgZWRpdG9yKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKExhbmcuaXNGdW5jdGlvbihrZXlzdHJva2VGbikpIHtcblx0XHRcdFx0XHRcdGtleXN0cm9rZUZuLmNhbGwodGhpcywgZWRpdG9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0uYmluZCh0aGlzKSxcblx0XHRcdH0pO1xuXG5cdFx0XHRuYXRpdmVFZGl0b3IuYWRkQ29tbWFuZChjb21tYW5kTmFtZSwgY29tbWFuZCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZGVmYXVsdEtleXN0cm9rZUNvbW1hbmQgPVxuXHRcdFx0bmF0aXZlRWRpdG9yLmtleXN0cm9rZUhhbmRsZXIua2V5c3Ryb2tlc1trZXlzdHJva2Uua2V5c107XG5cblx0XHRuYXRpdmVFZGl0b3Iuc2V0S2V5c3Ryb2tlKGtleXN0cm9rZS5rZXlzLCBjb21tYW5kTmFtZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGZyb20gdGhlIERPTS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25LZXlzdHJva2Vcblx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsVW5tb3VudFxuXHQgKi9cblx0Y29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0dGhpcy5wcm9wcy5lZGl0b3Jcblx0XHRcdC5nZXQoJ25hdGl2ZUVkaXRvcicpXG5cdFx0XHQuc2V0S2V5c3Ryb2tlKFxuXHRcdFx0XHR0aGlzLnByb3BzLmtleXN0cm9rZS5rZXlzLFxuXHRcdFx0XHR0aGlzLl9kZWZhdWx0S2V5c3Ryb2tlQ29tbWFuZFxuXHRcdFx0KTtcblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbktleXN0cm9rZTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0IEJ1dHRvbkxpbmtFZGl0IGZyb20gJy4uL2J1dHRvbnMvYnV0dG9uLWxpbmstZWRpdC5qc3gnO1xuXG4vKipcbiAqIEJ1dHRvblByb3BzIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBhIHN0eWxlIHByb3AgYW5kIHNvbWUgbWV0aG9kcyB0byBhcHBseSB0aGUgcmVzdWx0aW5nXG4gKiBzdHlsZSBhbmQgY2hlY2tpbmcgaWYgaXQgaXMgcHJlc2VudCBpbiBhIGdpdmVuIHBhdGggb3Igc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Qcm9wc1xuICovXG5jb25zdCBCdXR0b25Qcm9wcyA9IHtcblx0Ly8gQWxsb3dzIHZhbGlkYXRpbmcgcHJvcHMgYmVpbmcgcGFzc2VkIHRvIHRoZSBjb21wb25lbnQuXG5cdHByb3BUeXBlczoge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBlZGl0b3IgaW5zdGFuY2Ugd2hlcmUgdGhlIGNvbXBvbmVudCBpcyBiZWluZyB1c2VkLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvblByb3BzXG5cdFx0ICogQHByb3BlcnR5IHtPYmplY3R9IGVkaXRvclxuXHRcdCAqL1xuXHRcdGVkaXRvcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBNZXJnZXMgdGhlIHByb3BlcnRpZXMsIHBhc3NlZCB0byB0aGUgY3VycmVudCBjb21wb25lbnQgd2l0aCB1c2VyJ3MgY29uZmlndXJhdGlvblxuXHQgKiB2aWEgYGJ1dHRvbkNmZ2AgcHJvcGVydHkuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUHJvcHNcblx0ICogQG1ldGhvZCBtZXJnZUJ1dHRvbkNmZ1Byb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBUaGUgcHJvcGVydGllcyB0byBiZSBtZXJnZWQgd2l0aCB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvbiBmb3IgdGhpc1xuXHQgKiBidXR0b24uIElmIG5vdCBwYXNzZWQsIHRoZSB1c2VyIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBtZXJnZWQgd2l0aCBgdGhpcy5wcm9wc2Bcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgbWVyZ2VkIHByb3BlcnRpZXNcblx0ICovXG5cdG1lcmdlQnV0dG9uQ2ZnUHJvcHMocHJvcHMpIHtcblx0XHRwcm9wcyA9IHByb3BzIHx8IHRoaXMucHJvcHM7XG5cblx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdGNvbnN0IGJ1dHRvbkNmZyA9IG5hdGl2ZUVkaXRvci5jb25maWcuYnV0dG9uQ2ZnIHx8IHt9O1xuXHRcdGNvbnN0IHJlc3VsdCA9IENLRURJVE9SLnRvb2xzLm1lcmdlKFxuXHRcdFx0cHJvcHMsXG5cdFx0XHRidXR0b25DZmdbQnV0dG9uTGlua0VkaXQua2V5XVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uUHJvcHM7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nJztcblxuLyoqXG4gKiBCdXR0b25TdGF0ZUNsYXNzZXMgaXMgYSBtaXhpbiB0aGF0IGRlY29yYXRlcyB0aGUgZG9tRWxlbWVudCBvZiBhIGNvbXBvbmVudFxuICogd2l0aCBkaWZmZXJlbnQgQ1NTIGNsYXNzZXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogVG8gY2hlY2sgZm9yIHN0YXRlLCB0aGUgY29tcG9uZW50IGNhbiBleHBvc2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICogLSBgRnVuY3Rpb25gICoqaXNBY3RpdmUqKiB0byBjaGVjayB0aGUgYWN0aXZlIHN0YXRlXG4gKiAtIGBGdW5jdGlvbmAgKippc0Rpc2FibGVkKiogdG8gY2hlY2sgdGhlIGRpc2FibGVkIHN0YXRlXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jb25zdCBCdXR0b25TdGF0ZUNsYXNzZXMgPSB7XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHN0YXRlIGNsYXNzZXMgYXNzb2NpYXRlZCB0byB0aGUgY3VycmVudCBlbGVtZW50J3Mgc3RhdGUsIGFjY29yZGluZ1xuXHQgKiB0byB0aGUgcmVzdWx0cyBvZiB0aGUgaXNBY3RpdmUgYW5kIGlzRGlzYWJsZWQgbWV0aG9kcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdGF0ZUNsYXNzZXNcblx0ICogQG1ldGhvZCBnZXRTdGF0ZUNsYXNzZXNcblx0ICogQHJldHVybiB7U3RyaW5nfSBBIHN0cmluZyB3aXRoIHRoZSBzdGF0ZSBDU1MgY2xhc3Nlcy5cblx0ICovXG5cdGdldFN0YXRlQ2xhc3NlcygpIHtcblx0XHRsZXQgc3RhdGVDbGFzc2VzID0gJyc7XG5cblx0XHQvLyBDaGVjayBmb3IgYWN0aXZlIHN0YXRlXG5cdFx0aWYgKExhbmcuaXNGdW5jdGlvbih0aGlzLmlzQWN0aXZlKSAmJiB0aGlzLmlzQWN0aXZlKCkpIHtcblx0XHRcdHN0YXRlQ2xhc3NlcyArPSAnYWUtYnV0dG9uLXByZXNzZWQnO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZvciBkaXNhYmxlZCBzdGF0ZVxuXHRcdGlmIChMYW5nLmlzRnVuY3Rpb24odGhpcy5pc0Rpc2FibGVkKSAmJiB0aGlzLmlzRGlzYWJsZWQoKSkge1xuXHRcdFx0c3RhdGVDbGFzc2VzICs9ICcgYWUtYnV0dG9uLWRpc2FibGVkJztcblx0XHR9XG5cblx0XHRyZXR1cm4gc3RhdGVDbGFzc2VzO1xuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uU3RhdGVDbGFzc2VzO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5cbi8qKlxuICogQnV0dG9uU3R5bGUgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGEgc3R5bGUgcHJvcCBhbmQgc29tZSBtZXRob2RzIHRvXG4gKiBhcHBseSB0aGUgcmVzdWx0aW5nIHN0eWxlIGFuZCBjaGVja2luZyBpZiBpdCBpcyBwcmVzZW50IGluIGEgZ2l2ZW5cbiAqIHBhdGggb3Igc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdHlsZVxuICovXG5jb25zdCBCdXR0b25TdHlsZSA9IHtcblx0Ly8gQWxsb3dzIHZhbGlkYXRpbmcgcHJvcHMgYmVpbmcgcGFzc2VkIHRvIHRoZSBjb21wb25lbnQuXG5cdHByb3BUeXBlczoge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBzdHlsZSB0aGUgYnV0dG9uIHNob3VsZCBoYW5kbGUuIEFsbG93ZWQgdmFsdWVzIGFyZTpcblx0XHQgKiAtIE9iamVjdCBhcyBkZXNjcmliZWQgYnlcblx0XHQgKiAgIGh0dHA6Ly9kb2NzLmNrZWRpdG9yLmNvbS8jIS9hcGkvQ0tFRElUT1Iuc3R5bGUuXG5cdFx0ICogLSBTdHJpbmcgcG9pbnRpbmcgdG8gYW4gb2JqZWN0IGluc2lkZSB0aGUgZWRpdG9yIGluc3RhbmNlXG5cdFx0ICogICBjb25maWd1cmF0aW9uLiBGb3IgZXhhbXBsZSwgYHN0eWxlID0gJ2NvcmVTdHlsZXNfYm9sZCdgIHdpbGxcblx0XHQgKiAgIHRyeSB0byByZXRyaWV2ZSB0aGUgc3R5bGUgb2JqZWN0IGZyb21cblx0XHQgKiAgIGBlZGl0b3IuY29uZmlnLmNvcmVTdHlsZXNfYm9sZGAuIE5lc3RlZCBwcm9wZXJ0aWVzIHN1Y2ggYXNcblx0XHQgKiAgIGBzdHlsZSA9ICdteXBsdWdpbi5teUNvbmZpZy5teVN0eWxlJ2AgYXJlIGFsc28gc3VwcG9ydGVkXG5cdFx0ICogICBhbmQgd2lsbCB0cnkgdG8gcmV0cmlldmUgdGhlIHN0eWxlIG9iamVjdCBmcm9tIHRoZSBlZGl0b3Jcblx0XHQgKiAgIGNvbmZpZ3VyYXRpb24gYXMgd2VsbC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuXHRcdCAqIEBwcm9wZXJ0eSB7T2JqZWN0fFN0cmluZ30gc3R5bGVcblx0XHQgKi9cblx0XHRzdHlsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHN0eWxlIGZ1bmN0aW9uIHRoZSBidXR0b24gc2hvdWxkIGhhbmRsZS5cblx0XHQgKiBJZiBzcGVjaWZpZWQsIHN0eWxlIGZ1bmN0aW9uIGhhcyBoaWdoZXIgcHJpb3JpdHkgdGhhbiBzdHlsZSBwcm9wZXJ0eS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuXHRcdCAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHN0eWxlRm5cblx0XHQgKi9cblx0XHRzdHlsZUZuOiBQcm9wVHlwZXMuZnVuYyxcblx0fSxcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIGJvdGggb24gdGhlIGNsaWVudCBhbmQgc2VydmVyLFxuXHQgKiBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxNb3VudFxuXHQgKi9cblx0Y29tcG9uZW50V2lsbE1vdW50KCkge1xuXHRcdGxldCBzdHlsZSA9IHRoaXMucHJvcHMuc3R5bGU7XG5cblx0XHRpZiAoTGFuZy5pc1N0cmluZyhzdHlsZSkpIHtcblx0XHRcdGNvbnN0IHBhcnRzID0gc3R5bGUuc3BsaXQoJy4nKTtcblx0XHRcdGxldCBjdXJyZW50TWVtYmVyID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKS5jb25maWc7XG5cdFx0XHRsZXQgcHJvcGVydHkgPSBwYXJ0cy5zaGlmdCgpO1xuXG5cdFx0XHR3aGlsZSAoXG5cdFx0XHRcdHByb3BlcnR5ICYmXG5cdFx0XHRcdExhbmcuaXNPYmplY3QoY3VycmVudE1lbWJlcikgJiZcblx0XHRcdFx0TGFuZy5pc09iamVjdChjdXJyZW50TWVtYmVyW3Byb3BlcnR5XSlcblx0XHRcdCkge1xuXHRcdFx0XHRjdXJyZW50TWVtYmVyID0gY3VycmVudE1lbWJlcltwcm9wZXJ0eV07XG5cdFx0XHRcdHByb3BlcnR5ID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKExhbmcuaXNPYmplY3QoY3VycmVudE1lbWJlcikpIHtcblx0XHRcdFx0c3R5bGUgPSBjdXJyZW50TWVtYmVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3N0eWxlID0gbmV3IENLRURJVE9SLnN0eWxlKHN0eWxlKTtcblx0fSxcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWRcblx0ICogZnJvbSB0aGUgRE9NLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlXG5cdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcblx0ICovXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdHRoaXMuX3N0eWxlID0gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBpbnN0YW5jZSBvZiBDS0VESVRPUi5zdHlsZSB3aGljaCByZXByZXNlbnRzIHRoZSBjdXJyZW50XG5cdCAqIGJ1dHRvbiBzdHlsZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuXHQgKiBAbWV0aG9kIGdldFN0eWxlXG5cdCAqIEByZXR1cm4ge0NLRURJVE9SLnN0eWxlfSBUaGUgY3VycmVudCBzdHlsZSByZXByZXNlbnRhdGlvbi5cblx0ICovXG5cdGdldFN0eWxlKCkge1xuXHRcdHJldHVybiB0aGlzLl9zdHlsZTtcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHN0eWxlIGlzIGFjdGl2ZSBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVcblx0ICogQG1ldGhvZCBpc0FjdGl2ZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHN0eWxlIGlzIGFjdGl2ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cblx0aXNBY3RpdmUoKSB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGNvbnN0IGVsZW1lbnRQYXRoID0gZWRpdG9yLmVsZW1lbnRQYXRoKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmNoZWNrQWN0aXZlKGVsZW1lbnRQYXRoLCBlZGl0b3IpO1xuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uU3R5bGU7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBCdXR0b25BY3Rpb25TdHlsZX0gZnJvbSAnLi9idXR0b24tYWN0aW9uLXN0eWxlJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBCdXR0b25Db21tYW5kQWN0aXZlfSBmcm9tICcuL2J1dHRvbi1jb21tYW5kLWFjdGl2ZSc7XG5leHBvcnQge2RlZmF1bHQgYXMgQnV0dG9uQ29tbWFuZH0gZnJvbSAnLi9idXR0b24tY29tbWFuZCc7XG5leHBvcnQge2RlZmF1bHQgYXMgQnV0dG9uS2V5c3Ryb2tlfSBmcm9tICcuL2J1dHRvbi1rZXlzdHJva2UnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEJ1dHRvblByb3BzfSBmcm9tICcuL2J1dHRvbi1wcm9wcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgQnV0dG9uU3RhdGVDbGFzc2VzfSBmcm9tICcuL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBCdXR0b25TdHlsZX0gZnJvbSAnLi9idXR0b24tc3R5bGUnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFRvb2xiYXJCdXR0b25zfSBmcm9tICcuL3Rvb2xiYXItYnV0dG9ucyc7XG5leHBvcnQge2RlZmF1bHQgYXMgV2lkZ2V0QXJyb3dCb3h9IGZyb20gJy4vd2lkZ2V0LWFycm93LWJveCc7XG5leHBvcnQge2RlZmF1bHQgYXMgV2lkZ2V0RHJvcGRvd259IGZyb20gJy4vd2lkZ2V0LWRyb3Bkb3duJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBXaWRnZXRFeGNsdXNpdmV9IGZyb20gJy4vd2lkZ2V0LWV4Y2x1c2l2ZSc7XG5leHBvcnQge2RlZmF1bHQgYXMgV2lkZ2V0Rm9jdXNNYW5hZ2VyfSBmcm9tICcuL3dpZGdldC1mb2N1cy1tYW5hZ2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBXaWRnZXRJbnRlcmFjdGlvblBvaW50fSBmcm9tICcuL3dpZGdldC1pbnRlcmFjdGlvbi1wb2ludCc7XG5leHBvcnQge2RlZmF1bHQgYXMgV2lkZ2V0UG9zaXRpb259IGZyb20gJy4vd2lkZ2V0LXBvc2l0aW9uJztcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuXG4vKipcbiAqIFRvb2xiYXJCdXR0b25zIGlzIGEgbWl4aW4gd2hpY2ggcHJvdmlkZXMgYSBsaXN0IG9mIGJ1dHRvbnMgd2hpY2ggaGF2ZVxuICogdG8gYmUgZGlzcGxheWVkIG9uIHRoZSBjdXJyZW50IHRvb2xiYXIgZGVwZW5kaW5nIG9uIHVzZXIgcHJlZmVyZW5jZXNcbiAqIGFuZCBnaXZlbiBzdGF0ZS5cbiAqXG4gKiBAY2xhc3MgVG9vbGJhckJ1dHRvbnNcbiAqL1xuY29uc3QgVG9vbGJhckJ1dHRvbnMgPSB7XG5cdC8qKlxuXHQgKiBBbmFseXNlcyB0aGUgY3VycmVudCBzZWxlY3Rpb24gYW5kIHJldHVybnMgdGhlIGJ1dHRvbnMgb3IgYnV0dG9uXG5cdCAqIGdyb3VwcyB0byBiZSByZW5kZXJlZC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZXRob2QgZ2V0VG9vbGJhckJ1dHRvbkdyb3Vwc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBidXR0b25zIFRoZSBidXR0b25zIGNvdWxkIGJlIHNob3duLCBwcmlvciB0byB0aGUgc3RhdGUgZmlsdGVyaW5nLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYWRkaXRpb25hbFByb3BzIEFkZGl0aW9uYWwgcHJvcHMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIGRvd24gdG8gdGhlIGJ1dHRvbnMuXG5cdCAqIEByZXR1cm4ge0FycmF5fSBBbiBBcnJheSB3aGljaCBjb250YWlucyB0aGUgYnV0dG9ucyBvciBidXR0b24gZ3JvdXBzIHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0Z2V0VG9vbGJhckJ1dHRvbkdyb3VwcyhidXR0b25zLCBhZGRpdGlvbmFsUHJvcHMpIHtcblx0XHRjb25zdCBpbnN0YW5jZSA9IHRoaXM7XG5cblx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKGJ1dHRvbnMpKSB7XG5cdFx0XHRidXR0b25zID0gYnV0dG9ucy5jYWxsKHRoaXMpIHx8IFtdO1xuXHRcdH1cblxuXHRcdHJldHVybiBidXR0b25zLnJlZHVjZSgobGlzdCwgYnV0dG9uKSA9PiB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShidXR0b24pKSB7XG5cdFx0XHRcdGxpc3QucHVzaChpbnN0YW5jZS5nZXRUb29sYmFyQnV0dG9ucyhidXR0b24sIGFkZGl0aW9uYWxQcm9wcykpO1xuXHRcdFx0XHRyZXR1cm4gbGlzdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBpbnN0YW5jZS5nZXRUb29sYmFyQnV0dG9ucyhidXR0b25zLCBhZGRpdGlvbmFsUHJvcHMpO1xuXHRcdFx0fVxuXHRcdH0sIFtdKTtcblx0fSxcblxuXHQvKipcblx0ICogQW5hbHl6ZXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGFuZCB0aGUgYnV0dG9ucyBleGNsdXNpdmUgbW9kZSB2YWx1ZSB0byBmaWd1cmUgb3V0IHdoaWNoXG5cdCAqIGJ1dHRvbnMgc2hvdWxkIGJlIHByZXNlbnQgaW4gYSBnaXZlbiBzdGF0ZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBUb29sYmFyQnV0dG9uc1xuXHQgKiBAbWV0aG9kIGdldFRvb2xiYXJCdXR0b25zXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGJ1dHRvbnMgVGhlIGJ1dHRvbnMgY291bGQgYmUgc2hvd24sIHByaW9yIHRvIHRoZSBzdGF0ZSBmaWx0ZXJpbmcuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhZGRpdGlvbmFsUHJvcHMgQWRkaXRpb25hbCBwcm9wcyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgZG93biB0byB0aGUgYnV0dG9ucy5cblx0ICogQHJldHVybiB7QXJyYXl9IEFuIEFycmF5IHdoaWNoIGNvbnRhaW5zIHRoZSBidXR0b25zIHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0Z2V0VG9vbGJhckJ1dHRvbnMoYnV0dG9ucywgYWRkaXRpb25hbFByb3BzKSB7XG5cdFx0Y29uc3QgYnV0dG9uUHJvcHMgPSB7fTtcblxuXHRcdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdFx0Y29uc3QgYnV0dG9uQ2ZnID0gbmF0aXZlRWRpdG9yLmNvbmZpZy5idXR0b25DZmcgfHwge307XG5cblx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKGJ1dHRvbnMpKSB7XG5cdFx0XHRidXR0b25zID0gYnV0dG9ucy5jYWxsKHRoaXMpIHx8IFtdO1xuXHRcdH1cblxuXHRcdGNvbnN0IHRvb2xiYXJCdXR0b25zID0gdGhpcy5maWx0ZXJFeGNsdXNpdmUoXG5cdFx0XHRidXR0b25zXG5cdFx0XHRcdC5maWx0ZXIoYnV0dG9uID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0YnV0dG9uICYmXG5cdFx0XHRcdFx0XHQoQWxsb3lFZGl0b3IuQnV0dG9uc1tidXR0b25dIHx8XG5cdFx0XHRcdFx0XHRcdEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uLm5hbWVdKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5tYXAoYnV0dG9uID0+IHtcblx0XHRcdFx0XHRpZiAoTGFuZy5pc1N0cmluZyhidXR0b24pKSB7XG5cdFx0XHRcdFx0XHRidXR0b25Qcm9wc1tidXR0b25dID0gYnV0dG9uQ2ZnW2J1dHRvbl07XG5cdFx0XHRcdFx0XHRidXR0b24gPSBBbGxveUVkaXRvci5CdXR0b25zW2J1dHRvbl07XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChMYW5nLmlzU3RyaW5nKGJ1dHRvbi5uYW1lKSkge1xuXHRcdFx0XHRcdFx0YnV0dG9uUHJvcHNbXG5cdFx0XHRcdFx0XHRcdEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uLm5hbWVdLmtleVxuXHRcdFx0XHRcdFx0XSA9IENLRURJVE9SLnRvb2xzLm1lcmdlKGJ1dHRvbkNmZ1tidXR0b25dLCBidXR0b24uY2ZnKTtcblx0XHRcdFx0XHRcdGJ1dHRvbiA9IEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uLm5hbWVdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBidXR0b247XG5cdFx0XHRcdH0pXG5cdFx0KS5tYXAoZnVuY3Rpb24oYnV0dG9uLCBpbmRleCkge1xuXHRcdFx0bGV0IHByb3BzID0gdGhpcy5tZXJnZUV4Y2x1c2l2ZVByb3BzKFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZWRpdG9yOiB0aGlzLnByb3BzLmVkaXRvcixcblx0XHRcdFx0XHRrZXk6XG5cdFx0XHRcdFx0XHRidXR0b24ua2V5ICE9PSAnc2VwYXJhdG9yJ1xuXHRcdFx0XHRcdFx0XHQ/IGJ1dHRvbi5rZXlcblx0XHRcdFx0XHRcdFx0OiBgJHtidXR0b24ua2V5fS0ke2luZGV4fWAsXG5cdFx0XHRcdFx0dGFiS2V5OiBidXR0b24ua2V5LFxuXHRcdFx0XHRcdHRhYkluZGV4OlxuXHRcdFx0XHRcdFx0dGhpcy5wcm9wcy50cmlnZ2VyICYmXG5cdFx0XHRcdFx0XHR0aGlzLnByb3BzLnRyaWdnZXIucHJvcHMudGFiS2V5ID09PSBidXR0b24ua2V5XG5cdFx0XHRcdFx0XHRcdD8gMFxuXHRcdFx0XHRcdFx0XHQ6IC0xLFxuXHRcdFx0XHRcdHRyaWdnZXI6IHRoaXMucHJvcHMudHJpZ2dlcixcblx0XHRcdFx0fSxcblx0XHRcdFx0YnV0dG9uLmtleVxuXHRcdFx0KTtcblxuXHRcdFx0cHJvcHMgPSB0aGlzLm1lcmdlRHJvcGRvd25Qcm9wcyhwcm9wcywgYnV0dG9uLmtleSk7XG5cblx0XHRcdGlmIChhZGRpdGlvbmFsUHJvcHMpIHtcblx0XHRcdFx0cHJvcHMgPSBDS0VESVRPUi50b29scy5tZXJnZShwcm9wcywgYWRkaXRpb25hbFByb3BzKTtcblx0XHRcdH1cblxuXHRcdFx0cHJvcHMgPSBDS0VESVRPUi50b29scy5tZXJnZShwcm9wcywgYnV0dG9uUHJvcHNbYnV0dG9uLmtleV0pO1xuXG5cdFx0XHRyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChidXR0b24sIHByb3BzKTtcblx0XHR9LCB0aGlzKTtcblxuXHRcdHJldHVybiB0b29sYmFyQnV0dG9ucztcblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRvb2xiYXJCdXR0b25zO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5cbi8qKlxuICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgZGlzcGxheWluZyBXaWRnZXQgQXJyb3cgYm94IG9uIHRvcCBvciBvbiBib3R0b20gb2YgdGhlIHdpZGdldFxuICogZGVwZW5kaW5nIG9uIHRoZSBwb2ludCBvZiB1c2VyIGludGVyYWN0aW9uIHdpdGggdGhlIGVkaXRvci5cbiAqXG4gKiBAY2xhc3MgV2lkZ2V0QXJyb3dCb3hcbiAqL1xuY29uc3QgV2lkZ2V0QXJyb3dCb3ggPSB7XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGFycm93IGJveCBjbGFzc2VzIGFzc29jaWF0ZWQgdG8gdGhlIGN1cnJlbnQgZWxlbWVudCdzIHN0YXRlLiBJdCByZWxpZXNcblx0ICogb24gdGhlIGdldEludGVyYWN0aW9uUG9pbnQgbWV0aG9kIHRvIGNhbGN1bGF0ZSB0aGUgc2VsZWN0aW9uIGRpcmVjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRBcnJvd0JveFxuXHQgKiBAbWV0aG9kIGdldEFycm93Qm94Q2xhc3Nlc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHdpdGggdGhlIGFycm93IGJveCBDU1MgY2xhc3Nlcy5cblx0ICovXG5cdGdldEFycm93Qm94Q2xhc3NlcygpIHtcblx0XHRsZXQgYXJyb3dCb3hDbGFzc2VzID0gJ2FlLWFycm93LWJveCc7XG5cblx0XHRpZiAoXG5cdFx0XHRMYW5nLmlzRnVuY3Rpb24odGhpcy5nZXRJbnRlcmFjdGlvblBvaW50KSAmJlxuXHRcdFx0dGhpcy5nZXRJbnRlcmFjdGlvblBvaW50KClcblx0XHQpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0dGhpcy5nZXRJbnRlcmFjdGlvblBvaW50KCkuZGlyZWN0aW9uID09PVxuXHRcdFx0XHRDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTVxuXHRcdFx0KSB7XG5cdFx0XHRcdGFycm93Qm94Q2xhc3NlcyArPSAnIGFlLWFycm93LWJveC10b3AnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXJyb3dCb3hDbGFzc2VzICs9ICcgYWUtYXJyb3ctYm94LWJvdHRvbSc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFycm93Qm94Q2xhc3Nlcztcblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFdpZGdldEFycm93Qm94O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuLyoqXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBtYW5hZ2luZyBkaWZmZXJlbnQgZHJvcGRvd25zIGluc2lkZSBhIHdpZGdldC5cbiAqXG4gKiBAY2xhc3MgV2lkZ2V0RHJvcGRvd25cbiAqL1xuY29uc3QgV2lkZ2V0RHJvcGRvd24gPSB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZWNlaXZpbmcgbmV3IHByb3BzLlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0RHJvcGRvd25cblx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG5cdCAqL1xuXHRjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKF9uZXh0UHJvcHMpIHtcblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdGRyb3Bkb3duVHJpZ2dlcjogbnVsbCxcblx0XHRcdGl0ZW1Ecm9wZG93bjogbnVsbCxcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXREcm9wZG93blxuXHQgKiBAbWV0aG9kIGdldEluaXRpYWxTdGF0ZVxuXHQgKi9cblx0Z2V0SW5pdGlhbFN0YXRlKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRkcm9wZG93blRyaWdnZXI6IG51bGwsXG5cdFx0XHRpdGVtRHJvcGRvd246IG51bGwsXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogTWVyZ2VzIHRoZSBwcm92aWRlZCBvYmplY3Qgd2l0aCB0d28gbW9yZSBwcm9wZXJ0aWVzOlxuXHQgKiAtIGV4cGFuZGVkIC0gYm9vbGVhbiBmbGFnIHdoaWNoIGluZGljYXRlcyBpZiBhbiB3aWRnZXQgc2hvdWxkIGJlXG5cdCAqICAgcmVuZGVyZWQgZXhjbHVzaXZlbHkuXG5cdCAqIC0gdG9nZ2xlRHJvcGRvd24gLSBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIHVzZWQgYnkgYW4gd2lkZ2V0IGluXG5cdCAqICAgb3JkZXIgdG8gb2J0YWluIGV4Y2x1c2l2ZSBzdGF0ZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXREcm9wZG93blxuXHQgKiBAbWV0aG9kIG1lcmdlRHJvcGRvd25Qcm9wc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBwcm9wZXJ0aWVzIGNvbnRhaW5lciB3aGljaCBzaG91bGQgYmUgbWVyZ2VkIHdpdGggdGhlIHByb3BlcnRpZXMsIHJlbGF0ZWRcblx0ICogICAgdG8gZHJvcGRvd24gc3RhdGUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtS2V5IFRoZXkga2V5IG9mIGFuIFJlYWN0IFdpZGdldCB3aGljaCBjb250YWlucyB0aGUgZHJvcGRvd24uXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1lcmdlZCBvYmplY3QuXG5cdCAqL1xuXHRtZXJnZURyb3Bkb3duUHJvcHMob2JqLCBpdGVtS2V5KSB7XG5cdFx0cmV0dXJuIENLRURJVE9SLnRvb2xzLm1lcmdlKG9iaiwge1xuXHRcdFx0ZXhwYW5kZWQ6IHRoaXMuc3RhdGUuaXRlbURyb3Bkb3duID09PSBpdGVtS2V5ID8gdHJ1ZSA6IGZhbHNlLFxuXHRcdFx0dGFiSW5kZXg6IHRoaXMuc3RhdGUuZHJvcGRvd25UcmlnZ2VyID09PSBpdGVtS2V5ID8gMCA6IC0xLFxuXHRcdFx0dG9nZ2xlRHJvcGRvd246IHRoaXMudG9nZ2xlRHJvcGRvd24uYmluZCh0aGlzLCBpdGVtS2V5KSxcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0cyB0aGUgYWN0aXZlIGRyb3Bkb3duIG9mIHRoZSB3aWRnZXQgb3IgZGlzY2FyZHMgdGhlIHRvZ2dsZWRcblx0ICogaXRlbSBmcm9tIHRoZSBzdGF0ZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXREcm9wZG93blxuXHQgKiBAbWV0aG9kIHRvZ2dsZURyb3Bkb3duXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRHJvcGRvd24gVGhlIHdpZGdldCB3aGljaCByZXF1ZXN0cyB0byB0b2dnbGUgaXRzIGRyb3Bkb3duLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdG9nZ2xlRGlyZWN0aW9uIFVzZXIgbW92ZW1lbnQgZGlyZWN0aW9uIHdoZW4gdG9nZ2xlZCB2aWEga2V5Ym9hcmQuXG5cdCAqL1xuXHR0b2dnbGVEcm9wZG93bihpdGVtRHJvcGRvd24sIHRvZ2dsZURpcmVjdGlvbikge1xuXHRcdHRoaXMuc2V0U3RhdGUoXG5cdFx0XHR7XG5cdFx0XHRcdGRyb3Bkb3duVHJpZ2dlcjogaXRlbURyb3Bkb3duLFxuXHRcdFx0XHRpdGVtRHJvcGRvd246XG5cdFx0XHRcdFx0aXRlbURyb3Bkb3duICE9PSB0aGlzLnN0YXRlLml0ZW1Ecm9wZG93blxuXHRcdFx0XHRcdFx0PyBpdGVtRHJvcGRvd25cblx0XHRcdFx0XHRcdDogbnVsbCxcblx0XHRcdH0sXG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCF0aGlzLnN0YXRlLml0ZW1Ecm9wZG93bikge1xuXHRcdFx0XHRcdGlmICh0aGlzLm1vdmVGb2N1cykge1xuXHRcdFx0XHRcdFx0dGhpcy5tb3ZlRm9jdXModG9nZ2xlRGlyZWN0aW9uKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0UmVhY3RET00uZmluZERPTU5vZGUodGhpcykuZm9jdXMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpO1xuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0RHJvcGRvd247XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbi8qKlxuICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgbWFuYWdpbmcgZXhjbHVzaXZlIHN0YXRlIG9mIGFuIHdpZGdldC5cbiAqIFRoZSBleGNsdXNpdmUgc3RhdGUgbWVhbnMgdGhhdCBhIGJ1dHRvbiBtYXkgcmVxdWVzdCB0byBiZSB0aGUgb25seSByZW5kZXJlZFxuICogd2lkZ2V0IGluIGl0cyBwYXJlbnQgY29udGFpbmVyLiBXaWRnZXRFeGNsdXNpdmUgd2lsbCBtYW5hZ2UgdGhpcyBzdGF0ZSBieVxuICogZmlsdGVyaW5nIGFuZCBzdXBwcmVzc2luZyB0aGUgb3RoZXIgc2libGluZyB3aWRnZXRzIGZyb20gZGlzcGxheWluZy5cbiAqXG4gKiBAY2xhc3MgV2lkZ2V0RXhjbHVzaXZlXG4gKi9cbmNvbnN0IFdpZGdldEV4Y2x1c2l2ZSA9IHtcblx0LyoqXG5cdCAqIENhbmNlbHMgdGhlIGV4Y2x1c2l2ZSBzdGF0ZSBvZiBhbiB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0RXhjbHVzaXZlXG5cdCAqIEBtZXRob2QgY2FuY2VsRXhjbHVzaXZlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRXhjbHVzaXZlIFRoZSB3aWRnZXQgd2hpY2ggZXhjbHVzaXZlIHN0YXRlIHNob3VsZCBiZSBjYW5jZWxlZC5cblx0ICovXG5cdGNhbmNlbEV4Y2x1c2l2ZShpdGVtRXhjbHVzaXZlKSB7XG5cdFx0aWYgKHRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSA9PT0gaXRlbUV4Y2x1c2l2ZSkge1xuXHRcdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRcdGl0ZW1FeGNsdXNpdmU6IG51bGwsXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlY2VpdmluZyBuZXcgcHJvcHMuXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cblx0ICogQ2FsbGluZyB0aGlzLnNldFN0YXRlKCkgd2l0aGluIHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgdHJpZ2dlciBhblxuXHQgKiBhZGRpdGlvbmFsIHJlbmRlci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRFeGNsdXNpdmVcblx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBuZXh0UHJvcHMgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgc2V0IG9mIHByb3BlcnRpZXMuXG5cdCAqL1xuXHRjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKF9uZXh0UHJvcHMpIHtcblx0XHQvLyBSZWNlaXZpbmcgcHJvcGVydGllcyBtZWFucyB0aGF0IHRoZSBjb21wb25lbnQgaXMgYmVpbmdcblx0XHQvLyByZS1yZW5kZXJlZC4gIFJlLXJlbmRlcmluZyBpcyB0cmlnZ2VyZWQgYnkgZWRpdG9ySW50ZXJhY3Rpb24sXG5cdFx0Ly8gc28gd2UgaGF2ZSB0byByZXNldCB0aGUgZXhjbHVzaXZlIHN0YXRlIGFuZCByZW5kZXIgdGhlIFVJXG5cdFx0Ly8gYWNjb3JkaW5nIHRvIHRoZSBuZXcgc2VsZWN0aW9uLlxuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0aXRlbUV4Y2x1c2l2ZTogbnVsbCxcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogRmlsdGVycyB0aGUgaXRlbXMgYW5kIHJldHVybnMgb25seSB0aG9zZSB3aXRoIGV4Y2x1c2l2ZSBzdGF0ZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRFeGNsdXNpdmVcblx0ICogQG1ldGhvZCBmaWx0ZXJFeGNsdXNpdmVcblx0ICogQHBhcmFtIHtBcnJheX0gaXRlbXMgVGhlIHdpZGdldHMgdG8gYmUgZmlsdGVyZWQuXG5cdCAqIEByZXR1cm4ge0FycmF5fE9iamVjdH0gVGhlIGl0ZW0gd2l0aCBleGVjdXRpdmUgc3RhdGUuXG5cdCAqL1xuXHRmaWx0ZXJFeGNsdXNpdmUoaXRlbXMpIHtcblx0XHRyZXR1cm4gaXRlbXMuZmlsdGVyKGl0ZW0gPT4ge1xuXHRcdFx0aWYgKHRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSkge1xuXHRcdFx0XHRpZiAodGhpcy5zdGF0ZS5pdGVtRXhjbHVzaXZlID09PSBpdGVtLmtleSkge1xuXHRcdFx0XHRcdHJldHVybiBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogTWVyZ2VzIHRoZSBwcm92aWRlZCBvYmplY3Qgd2l0aCB0aHJlZSBtb3JlIHByb3BlcnRpZXM6XG5cdCAqIC0gY2FuY2VsRXhjbHVzaXZlIC0gZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSB1c2VkIGJ5IGEgd2lkZ2V0IGluXG5cdCAqICAgb3JkZXIgdG8gY2FuY2VsIGV4ZWN1dGl2ZSBzdGF0ZS5cblx0ICogLSByZW5kZXJFeGNsdXNpdmUgLSBib29sZWFuIGZsYWcgd2hpY2ggaW5kaWNhdGVzIGlmIGFuIHdpZGdldFxuXHQgKiAgIHNob3VsZCBiZSByZW5kZXJlZCBleGNsdXNpdmVseS5cblx0ICogLSByZXF1ZXN0RXhjbHVzaXZlIC0gZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSB1c2VkIGJ5IGEgd2lkZ2V0IGluXG5cdCAqICAgb3JkZXIgdG8gb2J0YWluIGV4Y2x1c2l2ZSBzdGF0ZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRFeGNsdXNpdmVcblx0ICogQG1ldGhvZCBtZXJnZUV4Y2x1c2l2ZVByb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIHByb3BlcnRpZXMgY29udGFpbmVyIHdoaWNoIHNob3VsZCBiZSBtZXJnZWQgd2l0aCB0aGUgcHJvcGVydGllcywgcmVsYXRlZFxuXHQgKiAgICB0byBleGNsdXNpdmUgc3RhdGUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtS2V5IFRoZXkga2V5IG9mIGFuIFJlYWN0IFdpZGdldCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQgZXhjbHVzaXZlbHkuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1lcmdlZCBvYmplY3QuXG5cdCAqL1xuXHRtZXJnZUV4Y2x1c2l2ZVByb3BzKG9iaiwgaXRlbUtleSkge1xuXHRcdHJldHVybiBDS0VESVRPUi50b29scy5tZXJnZShvYmosIHtcblx0XHRcdGNhbmNlbEV4Y2x1c2l2ZTogdGhpcy5jYW5jZWxFeGNsdXNpdmUuYmluZCh0aGlzLCBpdGVtS2V5KSxcblx0XHRcdHJlbmRlckV4Y2x1c2l2ZTogdGhpcy5zdGF0ZS5pdGVtRXhjbHVzaXZlID09PSBpdGVtS2V5LFxuXHRcdFx0cmVxdWVzdEV4Y2x1c2l2ZTogdGhpcy5yZXF1ZXN0RXhjbHVzaXZlLmJpbmQodGhpcywgaXRlbUtleSksXG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlcXVlc3RzIGFuZCBzZXRzIGV4Y2x1c2l2ZSBzdGF0ZSBvZiBhbiB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0RXhjbHVzaXZlXG5cdCAqIEBtZXRob2QgcmVxdWVzdEV4Y2x1c2l2ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbUV4Y2x1c2l2ZSBUaGUgd2lkZ2V0IHdoaWNoIHJlcXVlc3RzIGV4Y2x1c2l2ZSBzdGF0ZS5cblx0ICovXG5cdHJlcXVlc3RFeGNsdXNpdmUoaXRlbUV4Y2x1c2l2ZSkge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0aXRlbUV4Y2x1c2l2ZSxcblx0XHR9KTtcblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFdpZGdldEV4Y2x1c2l2ZTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5cbmNvbnN0IERJUkVDVElPTl9OT05FID0gMDtcbmNvbnN0IERJUkVDVElPTl9ORVhUID0gMTtcbmNvbnN0IERJUkVDVElPTl9QUkVWID0gLTE7XG5cbmNvbnN0IEFDVElPTl9OT05FID0gMDtcbmNvbnN0IEFDVElPTl9NT1ZFX0ZPQ1VTID0gMTtcbmNvbnN0IEFDVElPTl9ESVNNSVNTX0ZPQ1VTID0gMjtcblxuLyoqXG4gKiBXaWRnZXRGb2N1c01hbmFnZXIgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGtleWJvYXJkIG5hdmlnYXRpb24gaW5zaWRlIGEgd2lkZ2V0LiBUbyBkbyB0aGlzLFxuICogaXQgZXhwb3NlcyB0aGUgZm9sbG93aW5nIHByb3BzIGFuZCBtZXRob2RzOlxuICpcbiAqIEBjbGFzcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqL1xuY29uc3QgV2lkZ2V0Rm9jdXNNYW5hZ2VyID0ge1xuXHQvLyBBbGxvd3MgdmFsaWRhdGluZyBwcm9wcyBiZWluZyBwYXNzZWQgdG8gdGhlIGNvbXBvbmVudC5cblx0cHJvcFR5cGVzOiB7XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgbWV0aG9kIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgZm9jdXMgbWFuYWdlciBpcyB0byBiZSBkaXNtaXNzZWQuIFRoaXMgaGFwcGVuc1xuXHRcdCAqIGluIHRoZSBmb2xsb3dpbmcgc2NlbmFyaW9zIGlmIGEgZGlzbWlzcyBjYWxsYmFjayBoYXMgYmVlbiBzcGVjaWZpZWQ6XG5cdFx0ICogLSBBIGRpc21pc3Mga2V5IGhhcyBiZWVuIHByZXNzZWRcblx0XHQgKiAtIEluIGEgbm9uLWNpcmN1bGFyIGZvY3VzIG1hbmFnZXIsIHdoZW46XG5cdFx0ICogICAgIC0gVGhlIGFjdGl2ZSBkZXNjZW5kYW50IGlzIHRoZSBmaXJzdCBvbmUgYW5kIGEgcHJldiBrZXkgaGFzIGJlZW4gcHJlc3NlZC5cblx0XHQgKiAgICAgLSBUaGUgYWN0aXZlIGRlc2NlbmRhbnQgaXMgdGhlIGxhc3Qgb25lIGFuZCBhIG5leHQga2V5IGhhcyBiZWVuIHByZXNzZWQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb25EaXNtaXNzXG5cdFx0ICovXG5cdFx0b25EaXNtaXNzOiBQcm9wVHlwZXMuZnVuYyxcblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiBmb2N1cyBzaG91bGQgYmUgc2V0IHRvIHRoZSBmaXJzdC9sYXN0IGRlc2NlbmRhbnQgd2hlbiB0aGUgbGltaXRzIGFyZSByZWFjaGVkLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2lyY3VsYXJcblx0XHQgKi9cblx0XHRjaXJjdWxhcjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlIGlmIHNob3VsZCBmb2N1cyB0aGUgZmlyc3QgY2hpbGQgb2YgYSBjb250YWluZXJcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBmb2N1c0ZpcnN0Q2hpbGRcblx0XHQgKi9cblx0XHRmb2N1c0ZpcnN0Q2hpbGQ6IFByb3BUeXBlcy5ib29sLFxuXG5cdFx0LyoqXG5cdFx0ICogU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgQ1NTIHNlbGVjdG9yIHVzZWQgdG8gZGVmaW5lIHRoZSBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBoYW5kbGVkLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkZXNjZW5kYW50c1xuXHRcdCAqL1xuXHRcdGRlc2NlbmRhbnRzOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG5cblx0XHQvKipcblx0XHQgKiBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBrZXlzIHVzZWQgdG8gbmF2aWdhdGUgYmV0d2VlbiBkZXNjZW5kYW50cy4gVGhlIGZvcm1hdCBmb3IgdGhlIHByb3AgaXM6XG5cdFx0ICogYHtkaXNtaXNzOiB2YWx1ZSwgZGlzbWlzc05leHQ6IHZhbHVlLCBkaXNtaXNzUHJldjogdmFsdWUsIG5leHQ6IHZhbHVlLCBwcmV2OiB2YWx1ZX1gIHdoZXJlXG5cdFx0ICogdmFsdWUgY2FuIGJlIGJvdGggYSBudW1iZXIgb3IgYW4gYXJyYXkgb2YgbnVtYmVycyB3aXRoIHRoZSBhbGxvd2VkIGtleUNvZGVzLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBrZXlzXG5cdFx0ICovXG5cdFx0a2V5czogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50LCBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50J3MgdXBkYXRlcyBhcmUgZmx1c2hlZCB0byB0aGUgRE9NLlxuXHQgKiBSZWZyZXNoZXMgdGhlIGRlc2NlbmRhbnRzIGxpc3QuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkVXBkYXRlXG5cdCAqL1xuXHRjb21wb25lbnREaWRVcGRhdGUoKSB7XG5cdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBGb2N1c2VzIHRoZSBjdXJyZW50IGFjdGl2ZSBkZXNjZW5kYW50LlxuXHQgKlxuXHQgKiBTZXZlcmFsIFdpZGdldHMgY2FuIGJlIG5lc3RlZCBpbiBhIGNvbXBvbmVudCBoaWVyYXJjaHkgYnkgYXR0YWNoaW5nIHRoaXMgZm9jdXMgbWV0aG9kIHRvXG5cdCAqIHRoZSB3aWRnZXQgRE9NIG5vZGUsIHRyYW5zZmVycmluZyB0aGUgRE9NIGZvY3VzIGNvbnRyb2wgdG8gdGhlIGlubmVyIEZvY3VzTWFuYWdlci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0ICogQG1ldGhvZCBmb2N1c1xuXHQgKi9cblx0Zm9jdXMoZXZlbnQpIHtcblx0XHRpZiAoIWV2ZW50IHx8IHRoaXMuX2lzVmFsaWRUYXJnZXQoZXZlbnQudGFyZ2V0KSkge1xuXHRcdFx0aWYgKHRoaXMuX2Rlc2NlbmRhbnRzICYmIHRoaXMuX2Rlc2NlbmRhbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRjb25zdCBhY3RpdmVEZXNjZW5kYW50RWwgPSB0aGlzLl9kZXNjZW5kYW50c1tcblx0XHRcdFx0XHR0aGlzLl9hY3RpdmVEZXNjZW5kYW50XG5cdFx0XHRcdF07XG5cdFx0XHRcdC8vIFdoZW4gdXNlciBjbGlja3Mgd2l0aCB0aGUgbW91c2UsIHRoZSBhY3RpdmVFbGVtZW50IGlzIGFscmVhZHkgc2V0IGFuZCB0aGVyZVxuXHRcdFx0XHQvLyBpcyBubyBuZWVkIHRvIGZvY3VzIGl0LiBGb2N1c2luZyBvZiB0aGUgYWN0aXZlIGRlc2NlbmRhbnQgKHVzdWFsbHkgc29tZSBidXR0b24pIGlzIHJlcXVpcmVkXG5cdFx0XHRcdC8vIGluIGNhc2Ugb2Yga2V5Ym9hcmQgbmF2aWdhdGlvbiwgYmVjYXVzZSB0aGUgZm9jdXNlZCBlbGVtZW50IG1pZ2h0IGJlIG5vdCB0aGUgZmlyc3QgYnV0dG9uLFxuXHRcdFx0XHQvLyBidXQgdGhlIGRpdiBlbGVtZW50LCB3aGljaCBjb250YWlucyB0aGUgYnV0dG9uLlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gYWN0aXZlRGVzY2VuZGFudEVsICYmXG5cdFx0XHRcdFx0IXRoaXMucHJvcHMuZm9jdXNGaXJzdENoaWxkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdHRoaXMuX2Rlc2NlbmRhbnRzLmluZGV4T2YoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgPT09IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRhY3RpdmVEZXNjZW5kYW50RWwuZm9jdXMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZXZlbnQpIHtcblx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIHRoZSBrZXkgZXZlbnRzIG9uIGEgRE9NIG5vZGUgdG8gZXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgbmF2aWdhdGlvbiB3aGVuIG5lZWRlZC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBLZXlib2FyZCBldmVudCB0aGF0IHdhcyBkZXRlY3RlZCBvbiB0aGUgd2lkZ2V0IERPTSBub2RlLlxuXHQgKiBAbWV0aG9kIGhhbmRsZUtleVxuXHQgKi9cblx0aGFuZGxlS2V5KGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuX2lzVmFsaWRUYXJnZXQoZXZlbnQudGFyZ2V0KSAmJiB0aGlzLl9kZXNjZW5kYW50cykge1xuXHRcdFx0Y29uc3QgYWN0aW9uID0gdGhpcy5fZ2V0Rm9jdXNBY3Rpb24oZXZlbnQpO1xuXG5cdFx0XHRpZiAoYWN0aW9uLnR5cGUpIHtcblx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0aWYgKGFjdGlvbi50eXBlID09PSBBQ1RJT05fTU9WRV9GT0NVUykge1xuXHRcdFx0XHRcdHRoaXMuX21vdmVGb2N1cyhhY3Rpb24uZGlyZWN0aW9uKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChhY3Rpb24udHlwZSA9PT0gQUNUSU9OX0RJU01JU1NfRk9DVVMpIHtcblx0XHRcdFx0XHR0aGlzLnByb3BzLm9uRGlzbWlzcyhhY3Rpb24uZGlyZWN0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogTW92ZXMgdGhlIGZvY3VzIGFtb25nIGRlc2NlbmRhbnRzIGluIHRoZSBlc3BlY2lmaWVkIGRpcmVjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0ICogQG1ldGhvZCBtb3ZlRm9jdXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uICgxIG9yIC0xKSBvZiB0aGUgZm9jdXMgbW92ZW1lbnQgYW1vbmcgZGVzY2VuZGFudHMuXG5cdCAqL1xuXHRtb3ZlRm9jdXMoZGlyZWN0aW9uKSB7XG5cdFx0ZGlyZWN0aW9uID0gTGFuZy5pc051bWJlcihkaXJlY3Rpb24pID8gZGlyZWN0aW9uIDogMDtcblxuXHRcdHRoaXMuX21vdmVGb2N1cyhkaXJlY3Rpb24pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhY3Rpb24sIGlmIGFueSwgdGhhdCBhIGtleWJvYXJkIGV2ZW50IGluIHRoZSBjdXJyZW50IGZvY3VzIG1hbmFnZXIgc3RhdGVcblx0ICogc2hvdWxkIHByb2R1Y2UuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdCAqIEBtZXRob2QgX2dldEZvY3VzQWN0aW9uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgS2V5Ym9hcmQgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBhY3Rpb24gb2JqZWN0IHdpdGggdHlwZSBhbmQgZGlyZWN0aW9uIHByb3BlcnRpZXMuXG5cdCAqL1xuXHRfZ2V0Rm9jdXNBY3Rpb24oZXZlbnQpIHtcblx0XHRjb25zdCBhY3Rpb24gPSB7XG5cdFx0XHR0eXBlOiBBQ1RJT05fTk9ORSxcblx0XHR9O1xuXG5cdFx0aWYgKHRoaXMucHJvcHMua2V5cykge1xuXHRcdFx0Y29uc3QgZGlyZWN0aW9uID0gdGhpcy5fZ2V0Rm9jdXNNb3ZlRGlyZWN0aW9uKGV2ZW50KTtcblxuXHRcdFx0aWYgKGRpcmVjdGlvbikge1xuXHRcdFx0XHRhY3Rpb24uZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuXHRcdFx0XHRhY3Rpb24udHlwZSA9IEFDVElPTl9NT1ZFX0ZPQ1VTO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkaXNtaXNzQWN0aW9uID0gdGhpcy5fZ2V0Rm9jdXNEaXNtaXNzQWN0aW9uKGV2ZW50LCBkaXJlY3Rpb24pO1xuXG5cdFx0XHRpZiAoZGlzbWlzc0FjdGlvbi5kaXNtaXNzKSB7XG5cdFx0XHRcdGFjdGlvbi5kaXJlY3Rpb24gPSBkaXNtaXNzQWN0aW9uLmRpcmVjdGlvbjtcblx0XHRcdFx0YWN0aW9uLnR5cGUgPSBBQ1RJT05fRElTTUlTU19GT0NVUztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gYWN0aW9uO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkaXNtaXNzIGFjdGlvbiwgaWYgYW55LCB0aGUgZm9jdXMgbWFuYWdlciBzaG91bGQgZXhlY3V0ZSB0byB5aWVsZCB0aGUgZm9jdXMuIFRoaXNcblx0ICogd2lsbCBoYXBwZW4gaW4gYW55IG9mIHRoZXNlIHNjZW5hcmlvcyBpZiBhIGRpc21pc3MgY2FsbGJhY2sgaGFzIGJlZW4gc3BlY2lmaWVkOlxuXHQgKiAtIEEgZGlzbWlzcyBrZXkgaGFzIGJlZW4gcHJlc3NlZFxuXHQgKiAtIEluIGEgbm9uLWNpcmN1bGFyIGZvY3VzIG1hbmFnZXIsIHdoZW46XG5cdCAqICAgICAtIFRoZSBhY3RpdmUgZGVzY2VuZGFudCBpcyB0aGUgZmlyc3Qgb25lIGFuZCBhIHByZXYga2V5IGhhcyBiZWVuIHByZXNzZWQuXG5cdCAqICAgICAtIFRoZSBhY3RpdmUgZGVzY2VuZGFudCBpcyB0aGUgbGFzdCBvbmUgYW5kIGEgbmV4dCBrZXkgaGFzIGJlZW4gcHJlc3NlZC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0ICogQG1ldGhvZCBfZ2V0Rm9jdXNEaXNtaXNzQWN0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBmb2N1c01vdmVEaXJlY3Rpb24gVGhlIGZvY3VzIG1vdmVtZW50IGRpcmVjdGlvbiAoaWYgYW55KS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBLZXlib2FyZCBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgZGlzbWlzcyBhY3Rpb24gd2l0aCBkaXNtaXNzIGFuZCBkaXJlY3Rpb24gcHJvcGVydGllcy5cblx0ICovXG5cdF9nZXRGb2N1c0Rpc21pc3NBY3Rpb24oZXZlbnQsIGZvY3VzTW92ZURpcmVjdGlvbikge1xuXHRcdGNvbnN0IGRpc21pc3NBY3Rpb24gPSB7XG5cdFx0XHRkaXJlY3Rpb246IGZvY3VzTW92ZURpcmVjdGlvbixcblx0XHRcdGRpc21pc3M6IGZhbHNlLFxuXHRcdH07XG5cblx0XHRpZiAodGhpcy5wcm9wcy5vbkRpc21pc3MpIHtcblx0XHRcdGlmICh0aGlzLl9pc1ZhbGlkS2V5KGV2ZW50LmtleUNvZGUsIHRoaXMucHJvcHMua2V5cy5kaXNtaXNzKSkge1xuXHRcdFx0XHRkaXNtaXNzQWN0aW9uLmRpc21pc3MgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2lzVmFsaWRLZXkoZXZlbnQua2V5Q29kZSwgdGhpcy5wcm9wcy5rZXlzLmRpc21pc3NOZXh0KSkge1xuXHRcdFx0XHRkaXNtaXNzQWN0aW9uLmRpc21pc3MgPSB0cnVlO1xuXHRcdFx0XHRkaXNtaXNzQWN0aW9uLmRpcmVjdGlvbiA9IERJUkVDVElPTl9ORVhUO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2lzVmFsaWRLZXkoZXZlbnQua2V5Q29kZSwgdGhpcy5wcm9wcy5rZXlzLmRpc21pc3NQcmV2KSkge1xuXHRcdFx0XHRkaXNtaXNzQWN0aW9uLmRpc21pc3MgPSB0cnVlO1xuXHRcdFx0XHRkaXNtaXNzQWN0aW9uLmRpcmVjdGlvbiA9IERJUkVDVElPTl9QUkVWO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdCFkaXNtaXNzQWN0aW9uLmRpc21pc3MgJiZcblx0XHRcdFx0IXRoaXMucHJvcHMuY2lyY3VsYXIgJiZcblx0XHRcdFx0Zm9jdXNNb3ZlRGlyZWN0aW9uXG5cdFx0XHQpIHtcblx0XHRcdFx0ZGlzbWlzc0FjdGlvbi5kaXNtaXNzID1cblx0XHRcdFx0XHQoZm9jdXNNb3ZlRGlyZWN0aW9uID09PSBESVJFQ1RJT05fUFJFViAmJlxuXHRcdFx0XHRcdFx0dGhpcy5fYWN0aXZlRGVzY2VuZGFudCA9PT0gMCkgfHxcblx0XHRcdFx0XHQoZm9jdXNNb3ZlRGlyZWN0aW9uID09PSBESVJFQ1RJT05fTkVYVCAmJlxuXHRcdFx0XHRcdFx0dGhpcy5fYWN0aXZlRGVzY2VuZGFudCA9PT1cblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVzY2VuZGFudHMubGVuZ3RoIC0gMSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRpc21pc3NBY3Rpb247XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGRpcmVjdGlvbiwgaWYgYW55LCBpbiB3aGljaCB0aGUgZm9jdXMgc2hvdWxkIGJlIG1vdmVkLiBJbiBwcmVzZW5jZSBvZiB0aGVcblx0ICogc2hpZnQga2V5IG1vZGlmaWVyLCB0aGUgZGlyZWN0aW9uIG9mIHRoZSBtb3ZlbWVudCBpcyBpbnZlcnRlZC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0ICogQG1ldGhvZCBfZ2V0Rm9jdXNNb3ZlRGlyZWN0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgS2V5Ym9hcmQgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgY29tcHV0ZWQgZGlyZWN0aW9uIG9mIHRoZSBleHBlY3RlZCBmb2N1cyBtb3ZlbWVudC5cblx0ICovXG5cdF9nZXRGb2N1c01vdmVEaXJlY3Rpb24oZXZlbnQpIHtcblx0XHRsZXQgZGlyZWN0aW9uID0gRElSRUNUSU9OX05PTkU7XG5cblx0XHRpZiAodGhpcy5faXNWYWxpZEtleShldmVudC5rZXlDb2RlLCB0aGlzLnByb3BzLmtleXMubmV4dCkpIHtcblx0XHRcdGRpcmVjdGlvbiA9IERJUkVDVElPTl9ORVhUO1xuXHRcdH1cblx0XHRpZiAodGhpcy5faXNWYWxpZEtleShldmVudC5rZXlDb2RlLCB0aGlzLnByb3BzLmtleXMucHJldikpIHtcblx0XHRcdGRpcmVjdGlvbiA9IERJUkVDVElPTl9QUkVWO1xuXHRcdH1cblxuXHRcdGlmIChldmVudC5zaGlmS2V5KSB7XG5cdFx0XHRkaXJlY3Rpb24gKj0gLTE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRpcmVjdGlvbjtcblx0fSxcblxuXHQvKipcblx0ICogSW5kaWNhdGVzIGlmIGEgZ2l2ZW4ga2V5Q29kZSBpcyB2YWxpZCBmb3IgdGhlIGdpdmVuIHNldCBvZiBrZXlzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHQgKiBAbWV0aG9kIF9pc1ZhbGlkS2V5XG5cdCAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfSBrZXlzIEEga2V5IHNldC4gQ2FuIGJlIGEgbnVtYmVyIGFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBhbGxvd2VkIGtleUNvZGVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0ga2V5Q29kZSBBbiBldmVudCBrZXlDb2RlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoZSBrZXkgaXMgdmFsaWQuXG5cdCAqL1xuXHRfaXNWYWxpZEtleShrZXlDb2RlLCBrZXlzKSB7XG5cdFx0cmV0dXJuIExhbmcuaXNBcnJheShrZXlzKVxuXHRcdFx0PyBrZXlzLmluZGV4T2Yoa2V5Q29kZSkgIT09IC0xXG5cdFx0XHQ6IGtleUNvZGUgPT09IGtleXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEluZGljYXRlcyBpZiBhIGdpdmVuIGVsZW1lbnQgaXMgdmFsaWQgZm9yIGZvY3VzIG1hbmFnZW1lbnQuIFVzZXIgaW5wdXQgZWxlbWVudHMgc3VjaCBhc1xuXHQgKiBpbnB1dCwgc2VsZWN0IG9yIHRleHRhcmVhIGFyZSBleGNsdWRlZC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0ICogQG1ldGhvZCBfaXNWYWxpZEtleVxuXHQgKiBAcGFyYW0ge0RPTU5vZGV9IGVsZW1lbnQgQSBET00gZWxlbWVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBBIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyBpZiB0aGUgZWxlbWVudCBpcyB2YWxpZC5cblx0ICovXG5cdF9pc1ZhbGlkVGFyZ2V0KGVsZW1lbnQpIHtcblx0XHRjb25zdCB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0dGFnTmFtZSAhPT0gJ2lucHV0JyAmJlxuXHRcdFx0dGFnTmFtZSAhPT0gJ3NlbGVjdCcgJiZcblx0XHRcdHRhZ05hbWUgIT09ICd0ZXh0YXJlYSdcblx0XHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBNb3ZlcyB0aGUgZm9jdXMgYW1vbmcgZGVzY2VuZGFudHMgaW4gdGhlIGVzcGVjaWZpZWQgZGlyZWN0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHQgKiBAbWV0aG9kIF9tb3ZlRm9jdXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uICgxIG9yIC0xKSBvZiB0aGUgZm9jdXMgbW92ZW1lbnQgYW1vbmcgZGVzY2VuZGFudHMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9tb3ZlRm9jdXMoZGlyZWN0aW9uKSB7XG5cdFx0Y29uc3QgbnVtRGVzY2VuZGFudHMgPSB0aGlzLl9kZXNjZW5kYW50cy5sZW5ndGg7XG5cblx0XHRsZXQgZGVzY2VuZGFudCA9IHRoaXMuX2Rlc2NlbmRhbnRzW3RoaXMuX2FjdGl2ZURlc2NlbmRhbnRdO1xuXG5cdFx0ZGVzY2VuZGFudC5zZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JywgLTEpO1xuXG5cdFx0dGhpcy5fYWN0aXZlRGVzY2VuZGFudCArPSBkaXJlY3Rpb247XG5cblx0XHRpZiAodGhpcy5wcm9wcy5jaXJjdWxhcikge1xuXHRcdFx0Ly8gQ2FsY3VsYXRlIHByb3BlciBtb2R1bG8gcmVzdWx0IHNpbmNlIHJlbWFpbmRlciBvcGVyYXRvciBkb2Vzbid0IGJlaGF2ZSBpbiB0aGVcblx0XHRcdC8vIHNhbWUgd2F5IGZvciBuZWdhdGl2ZSBudW1iZXJzXG5cdFx0XHR0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID1cblx0XHRcdFx0KCh0aGlzLl9hY3RpdmVEZXNjZW5kYW50ICUgbnVtRGVzY2VuZGFudHMpICsgbnVtRGVzY2VuZGFudHMpICVcblx0XHRcdFx0bnVtRGVzY2VuZGFudHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgPSBNYXRoLm1heChcblx0XHRcdFx0TWF0aC5taW4odGhpcy5fYWN0aXZlRGVzY2VuZGFudCwgbnVtRGVzY2VuZGFudHMgLSAxKSxcblx0XHRcdFx0MFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRkZXNjZW5kYW50ID0gdGhpcy5fZGVzY2VuZGFudHNbdGhpcy5fYWN0aXZlRGVzY2VuZGFudF07XG5cblx0XHRkZXNjZW5kYW50LnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAwKTtcblx0XHRkZXNjZW5kYW50LmZvY3VzKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZnJlc2hlcyB0aGUgZGVzY2VuZGFudHMgbGlzdCBieSBleGVjdXRpbmcgdGhlIENTUyBzZWxlY3RvciBhZ2FpbiBhbmQgcmVzZXRzIHRoZSBkZXNjZW5kYW50cyB0YWJJbmRleC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0ICogQG1ldGhvZCBfcmVmcmVzaFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfcmVmcmVzaCgpIHtcblx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cblx0XHRpZiAoZG9tTm9kZSkge1xuXHRcdFx0Y29uc3QgZGVzY2VuZGFudHMgPSBkb21Ob2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXG5cdFx0XHRcdHRoaXMucHJvcHMuZGVzY2VuZGFudHNcblx0XHRcdCk7XG5cblx0XHRcdGxldCBwcmlvcml0eURlc2NlbmRhbnRzID0gW107XG5cblx0XHRcdHRoaXMuX2Rlc2NlbmRhbnRzID0gW107XG5cblx0XHRcdEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRlc2NlbmRhbnRzKS5mb3JFYWNoKGl0ZW0gPT4ge1xuXHRcdFx0XHRjb25zdCBkYXRhVGFiSW5kZXggPSBpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS10YWJpbmRleCcpO1xuXG5cdFx0XHRcdGlmIChkYXRhVGFiSW5kZXgpIHtcblx0XHRcdFx0XHRwcmlvcml0eURlc2NlbmRhbnRzLnB1c2goaXRlbSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fZGVzY2VuZGFudHMucHVzaChpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHByaW9yaXR5RGVzY2VuZGFudHMgPSBwcmlvcml0eURlc2NlbmRhbnRzLnNvcnQoKGEsIGIpID0+IHtcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRMYW5nLnRvSW50KGEuZ2V0QXR0cmlidXRlKCdkYXRhLXRhYmluZGV4JykpID5cblx0XHRcdFx0XHRMYW5nLnRvSW50KGIuZ2V0QXR0cmlidXRlKCdkYXRhLXRhYmluZGV4JykpXG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fZGVzY2VuZGFudHMgPSBwcmlvcml0eURlc2NlbmRhbnRzLmNvbmNhdCh0aGlzLl9kZXNjZW5kYW50cyk7XG5cblx0XHRcdHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgPSAwO1xuXG5cdFx0XHR0aGlzLl9kZXNjZW5kYW50cy5zb21lKChpdGVtLCBpbmRleCkgPT4ge1xuXHRcdFx0XHRpZiAoaXRlbS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgPT09ICcwJykge1xuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgPSBpbmRleDtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0Rm9jdXNNYW5hZ2VyO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKipcbiAqIFByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNhbGN1bGF0aW5nIHRoZSBwb2ludCBvZiBpbnRlcmFjdGlvbiBvZiB0aGUgdXNlciB3aXRoIHRoZSBFZGl0b3IuXG4gKlxuICogQGNsYXNzIFdpZGdldEludGVyYWN0aW9uUG9pbnRcbiAqL1xuY29uc3QgV2lkZ2V0SW50ZXJhY3Rpb25Qb2ludCA9IHtcblx0Ly8gQWxsb3dzIHZhbGlkYXRpbmcgcHJvcHMgYmVpbmcgcGFzc2VkIHRvIHRoZSBjb21wb25lbnQuXG5cdHByb3BUeXBlczoge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBwcm92aWRlZCBlZGl0b3IgZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0SW50ZXJhY3Rpb25Qb2ludFxuXHRcdCAqIEBwcm9wZXJ0eSB7U3ludGhldGljRXZlbnR9IGVkaXRvckV2ZW50XG5cdFx0ICovXG5cdFx0ZWRpdG9yRXZlbnQ6IFByb3BUeXBlcy5vYmplY3QsXG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uLCBpbiBwYWdlIGNvb3JkaW5hdGVzLCBhY2NvcmRpbmcgdG8gd2hpY2ggYSB3aWRnZXQgc2hvdWxkIGFwcGVhci5cblx0ICogRGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNlbGVjdGlvbiwgdGhlIHdkaWdldCBtYXkgYXBwZWFyIGFib3ZlIG9mIG9yIG9uIGJvdHRvbSBvZiB0aGUgc2VsZWN0aW9uLlxuXHQgKlxuXHQgKiBJdCBkZXBlbmRzIG9uIHRoZSBwcm9wcyBlZGl0b3JFdmVudCB0byBhbmFseXplIHRoZSBmb2xsb3dpbmcgdXNlci1pbnRlcmFjdGlvbiBwYXJhbWV0ZXJzOlxuXHQgKiAtIHtPYmplY3R9IHNlbGVjdGlvbkRhdGEgVGhlIGRhdGEgYWJvdXQgdGhlIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yIGFzIHJldHVybmVkIGZyb21cblx0ICoge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9zZWxlY3Rpb25yZWdpb24vZ2V0U2VsZWN0aW9uRGF0YTptZXRob2RcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogLSB7TnVtYmVyfSBwb3MgQ29udGFpbnMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb3NpdGlvbiwgY29uc2lkZXJlZCBhcyBtb3N0IGFwcHJvcHJpYXRlLlxuXHQgKiBUaGlzIG1heSBiZSB0aGUgcG9pbnQgd2hlcmUgdGhlIHVzZXIgcmVsZWFzZWQgdGhlIG1vdXNlLCBvciBqdXN0IHRoZSBiZWdpbm5pbmcgb3IgdGhlIGVuZCBvZlxuXHQgKiB0aGUgc2VsZWN0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldEludGVyYWN0aW9uUG9pbnRcblx0ICogQG1ldGhvZCBnZXRJbnRlcmFjdGlvblBvaW50XG5cdCAqIEByZXR1cm4ge09iamVjdH0gQW4gT2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0ICogZGlyZWN0aW9uLCB4LCB5LCB3aGVyZSB4IGFuZCB5IGFyZSBpbiBwYWdlIGNvb3JkaW5hdGVzIGFuZCBkaXJlY3Rpb24gY2FuIGJlIG9uZSBvZiB0aGVzZTpcblx0ICogQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1Agb3IgQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT01cblx0ICovXG5cdGdldEludGVyYWN0aW9uUG9pbnQoKSB7XG5cdFx0Y29uc3QgZXZlbnRQYXlsb2FkID0gdGhpcy5wcm9wcy5lZGl0b3JFdmVudFxuXHRcdFx0PyB0aGlzLnByb3BzLmVkaXRvckV2ZW50LmRhdGFcblx0XHRcdDogbnVsbDtcblxuXHRcdGlmICghZXZlbnRQYXlsb2FkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2VsZWN0aW9uRGF0YSA9IGV2ZW50UGF5bG9hZC5zZWxlY3Rpb25EYXRhO1xuXG5cdFx0Y29uc3QgbmF0aXZlRXZlbnQgPSBldmVudFBheWxvYWQubmF0aXZlRXZlbnQ7XG5cblx0XHRjb25zdCBwb3MgPSB7XG5cdFx0XHR4OiBldmVudFBheWxvYWQubmF0aXZlRXZlbnQucGFnZVgsXG5cdFx0XHR5OiBzZWxlY3Rpb25EYXRhLnJlZ2lvbi50b3AsXG5cdFx0fTtcblxuXHRcdGxldCBkaXJlY3Rpb24gPSBzZWxlY3Rpb25EYXRhLnJlZ2lvbi5kaXJlY3Rpb247XG5cblx0XHRjb25zdCBlbmRSZWN0ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uZW5kUmVjdDtcblxuXHRcdGNvbnN0IHN0YXJ0UmVjdCA9IHNlbGVjdGlvbkRhdGEucmVnaW9uLnN0YXJ0UmVjdDtcblxuXHRcdGlmIChlbmRSZWN0ICYmIHN0YXJ0UmVjdCAmJiBzdGFydFJlY3QudG9wID09PSBlbmRSZWN0LnRvcCkge1xuXHRcdFx0ZGlyZWN0aW9uID0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1A7XG5cdFx0fVxuXG5cdFx0bGV0IHg7XG5cdFx0bGV0IHk7XG5cblx0XHQvLyBJZiB3ZSBoYXZlIHRoZSBwb2ludCB3aGVyZSB1c2VyIHJlbGVhc2VkIHRoZSBtb3VzZSwgc2hvdyBUb29sYmFyIGF0IHRoaXMgcG9pbnRcblx0XHQvLyBvdGhlcndpc2Ugc2hvdyBpdCBvbiB0aGUgbWlkZGxlIG9mIHRoZSBzZWxlY3Rpb24uXG5cblx0XHRpZiAocG9zLnggJiYgcG9zLnkpIHtcblx0XHRcdHggPSB0aGlzLl9nZXRYUG9pbnQoc2VsZWN0aW9uRGF0YSwgcG9zLngpO1xuXG5cdFx0XHRpZiAoZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUCkge1xuXHRcdFx0XHR5ID0gTWF0aC5taW4ocG9zLnksIHNlbGVjdGlvbkRhdGEucmVnaW9uLnRvcCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR5ID0gTWF0aC5tYXgoXG5cdFx0XHRcdFx0cG9zLnksXG5cdFx0XHRcdFx0dGhpcy5fZ2V0WVBvaW50KHNlbGVjdGlvbkRhdGEsIG5hdGl2ZUV2ZW50KVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24ubGVmdCArIHNlbGVjdGlvbkRhdGEucmVnaW9uLndpZHRoIC8gMjtcblxuXHRcdFx0aWYgKGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT00pIHtcblx0XHRcdFx0eSA9IHRoaXMuX2dldFlQb2ludChzZWxlY3Rpb25EYXRhLCBuYXRpdmVFdmVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR5ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24udG9wO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRkaXJlY3Rpb24sXG5cdFx0XHR4LFxuXHRcdFx0eSxcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgV2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldEludGVyYWN0aW9uUG9pbnRcblx0ICogQG1ldGhvZCBfZ2V0WFBvaW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFggVGhlIFggY29vcmRpbmF0ZSByZWNlaXZlZCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgKG1vdXNldXApLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0aW9uRGF0YSBUaGUgZGF0YSBhYm91dCB0aGUgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgYXMgcmV0dXJuZWQgZnJvbSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRTZWxlY3Rpb25EYXRhOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNhbGN1bGF0ZWQgWCBwb2ludCBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuXHQgKi9cblx0X2dldFhQb2ludChzZWxlY3Rpb25EYXRhLCBldmVudFgpIHtcblx0XHRjb25zdCByZWdpb24gPSBzZWxlY3Rpb25EYXRhLnJlZ2lvbjtcblxuXHRcdGNvbnN0IGxlZnQgPSByZWdpb24uc3RhcnRSZWN0ID8gcmVnaW9uLnN0YXJ0UmVjdC5sZWZ0IDogcmVnaW9uLmxlZnQ7XG5cdFx0Y29uc3QgcmlnaHQgPSByZWdpb24uZW5kUmVjdCA/IHJlZ2lvbi5lbmRSZWN0LnJpZ2h0IDogcmVnaW9uLnJpZ2h0O1xuXG5cdFx0bGV0IHg7XG5cblx0XHRpZiAobGVmdCA8IGV2ZW50WCAmJiByaWdodCA+IGV2ZW50WCkge1xuXHRcdFx0eCA9IGV2ZW50WDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgbGVmdERpc3QgPSBNYXRoLmFicyhsZWZ0IC0gZXZlbnRYKTtcblx0XHRcdGNvbnN0IHJpZ2h0RGlzdCA9IE1hdGguYWJzKHJpZ2h0IC0gZXZlbnRYKTtcblxuXHRcdFx0aWYgKGxlZnREaXN0IDwgcmlnaHREaXN0KSB7XG5cdFx0XHRcdC8vIHVzZXIgcmFpc2VkIHRoZSBtb3VzZSBvbiBsZWZ0IG9uIHRoZSBzZWxlY3Rpb25cblx0XHRcdFx0eCA9IGxlZnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4ID0gcmlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBXaWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0SW50ZXJhY3Rpb25Qb2ludFxuXHQgKiBAbWV0aG9kIF9nZXRZUG9pbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IG5hdGl2ZUV2ZW50IFRoZSBkYXRhIGFib3V0IGV2ZW50IGlzIGZpcmVkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzZWxlY3Rpb25EYXRhIFRoZSBkYXRhIGFib3V0IHRoZSBzZWxlY3Rpb24gaW4gdGhlIGVkaXRvciBhcyByZXR1cm5lZCBmcm9tIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfc2VsZWN0aW9ucmVnaW9uL2dldFNlbGVjdGlvbkRhdGE6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgY2FsY3VsYXRlZCBZIHBvaW50IGluIHBhZ2UgY29vcmRpbmF0ZXMuXG5cdCAqL1xuXHRfZ2V0WVBvaW50KHNlbGVjdGlvbkRhdGEsIG5hdGl2ZUV2ZW50KSB7XG5cdFx0bGV0IHkgPSAwO1xuXG5cdFx0aWYgKHNlbGVjdGlvbkRhdGEgJiYgbmF0aXZlRXZlbnQpIHtcblx0XHRcdGNvbnN0IGVsZW1lbnRUYXJnZXQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQobmF0aXZlRXZlbnQudGFyZ2V0KTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRlbGVtZW50VGFyZ2V0LiQgJiZcblx0XHRcdFx0ZWxlbWVudFRhcmdldC5nZXRTdHlsZSgnb3ZlcmZsb3cnKSA9PT0gJ2F1dG8nXG5cdFx0XHQpIHtcblx0XHRcdFx0eSA9XG5cdFx0XHRcdFx0bmF0aXZlRXZlbnQudGFyZ2V0Lm9mZnNldFRvcCArXG5cdFx0XHRcdFx0bmF0aXZlRXZlbnQudGFyZ2V0Lm9mZnNldEhlaWdodDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHkgPSBzZWxlY3Rpb25EYXRhLnJlZ2lvbi5ib3R0b207XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHk7XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRJbnRlcmFjdGlvblBvaW50O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbmltcG9ydCBXaWRnZXRJbnRlcmFjdGlvblBvaW50IGZyb20gJy4vd2lkZ2V0LWludGVyYWN0aW9uLXBvaW50JztcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwb3NpdGlvbiB3aGVyZSBhbiBXaWRnZXQgc2hvdWxkIGJlIGRpc3BsYXllZCBiYXNlZCBvblxuICogdGhlIHBvaW50IHdoZXJlIHVzZXIgaW50ZXJhY3RlZCB3aXRoIHRoZSBlZGl0b3IuXG4gKlxuICogQGNsYXNzIFdpZGdldFBvc2l0aW9uXG4gKiBAdXNlcyBXaWRnZXRJbnRlcmFjdGlvblBvaW50XG4gKi9cbmNvbnN0IFdpZGdldFBvc2l0aW9uID0ge1xuXHRtaXhpbnM6IFtXaWRnZXRJbnRlcmFjdGlvblBvaW50XSxcblxuXHQvLyBBbGxvd3MgdmFsaWRhdGluZyBwcm9wcyBiZWluZyBwYXNzZWQgdG8gdGhlIGNvbXBvbmVudC5cblx0cHJvcFR5cGVzOiB7XG5cdFx0LyoqXG5cdFx0ICogU2hvdWxkIHRoZSB3aWRnZXQgdG8gYmUgcmVzdHJpY3RlZCB0byB0aGUgdmlld3BvcnQsIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuXHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY29uc3RyYWluVG9WaWV3cG9ydFxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHRjb25zdHJhaW5Ub1ZpZXdwb3J0OiBQcm9wVHlwZXMuYm9vbCxcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBndXR0ZXIgKHZlcnRpY2FsIGFuZCBob3Jpem9udGFsKSBiZXR3ZWVuIHRoZSBpbnRlcmFjdGlvblxuXHRcdCAqIHBvaW50IGFuZCB3aGVyZSB0aGUgd2lkZ2V0IHNob3VsZCBiZSByZW5kZXJlZC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuXHRcdCAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBndXR0ZXJcblx0XHQgKiBAZGVmYXVsdCB7XG5cdFx0ICogICAgIGxlZnQ6IDAsXG5cdFx0ICogICAgIHRvcDogMTBcblx0XHQgKiB9XG5cdFx0ICovXG5cdFx0Z3V0dGVyOiBQcm9wVHlwZXMub2JqZWN0LFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW5cblx0ICogdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKi9cblx0Z2V0RGVmYXVsdFByb3BzKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRndXR0ZXI6IHtcblx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0dG9wOiAxMCxcblx0XHRcdH0sXG5cdFx0XHRjb25zdHJhaW5Ub1ZpZXdwb3J0OiB0cnVlLFxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIENhbmNlbHMgYW4gc2NoZWR1bGVkIGFuaW1hdGlvbiBmcmFtZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuXHQgKiBAbWV0aG9kIGNhbmNlbEFuaW1hdGlvblxuXHQgKi9cblx0Y2FuY2VsQW5pbWF0aW9uKCkge1xuXHRcdGlmICh3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcblx0XHRcdHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltYXRpb25GcmFtZUlkKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCBpblxuXHQgKiBwYWdlIGNvb3JkaW5hdGVzLCByZXN0cmljdGVkIHRvIGZpdCB0byBnaXZlbiB2aWV3cG9ydC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuXHQgKiBAbWV0aG9kIGdldENvbnN0cmFpbmVkUG9zaXRpb25cblx0ICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcywgcHJvdmlkZWQgYXMgbnVtYmVyczpcblx0ICogLSBoZWlnaHRcblx0ICogLSBsZWZ0XG5cdCAqIC0gdG9wXG5cdCAqIC0gd2lkdGhcblx0ICogQHBhcmFtIHtPYmplY3R9IHZpZXdQYW5lU2l6ZSBPcHRpb25hbC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgY3VycmVudCB2aWV3cG9ydCB3aWxsIGJlIHVzZWQuIFNob3VsZCBjb250YWluIGF0IGxlYXN0IHRoZXNlIHByb3BlcnRpZXM6XG5cdCAqIC0gd2lkdGhcblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzLCB3aGljaCByZXByZXNlbnQgdGhlIGNvbnN0cmFpbmVkIHBvc2l0aW9uIG9mIHRoZVxuXHQgKiBlbGVtZW50LlxuXHQgKi9cblx0Z2V0Q29uc3RyYWluZWRQb3NpdGlvbihhdHRycywgdmlld1BhbmVTaXplKSB7XG5cdFx0dmlld1BhbmVTaXplID1cblx0XHRcdHZpZXdQYW5lU2l6ZSB8fCBuZXcgQ0tFRElUT1IuZG9tLndpbmRvdyh3aW5kb3cpLmdldFZpZXdQYW5lU2l6ZSgpO1xuXG5cdFx0bGV0IHggPSBhdHRycy5sZWZ0O1xuXHRcdGxldCB5ID0gYXR0cnMudG9wO1xuXG5cdFx0aWYgKGF0dHJzLmxlZnQgKyBhdHRycy53aWR0aCA+IHZpZXdQYW5lU2l6ZS53aWR0aCkge1xuXHRcdFx0eCAtPSBhdHRycy5sZWZ0ICsgYXR0cnMud2lkdGggLSB2aWV3UGFuZVNpemUud2lkdGg7XG5cdFx0fVxuXG5cdFx0aWYgKHkgPCAwKSB7XG5cdFx0XHR5ID0gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eCxcblx0XHRcdHksXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIFdpZGdldCB0YWtpbmcgaW4gY29uc2lkZXJhdGlvbiB0aGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiV2lkZ2V0UG9zaXRpb24vZ3V0dGVyOmF0dHJpYnV0ZVwifX17ey9jcm9zc0xpbmt9fSBhdHRyaWJ1dGUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0UG9zaXRpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kICBnZXRXaWRnZXRYWVBvaW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IFRoZSBsZWZ0IG9mZnNldCBpbiBwYWdlIGNvb3JkaW5hdGVzIHdoZXJlIFRvb2xiYXIgc2hvdWxkIGJlIHNob3duLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdG9wIFRoZSB0b3Agb2Zmc2V0IGluIHBhZ2UgY29vcmRpbmF0ZXMgd2hlcmUgVG9vbGJhciBzaG91bGQgYmUgc2hvd24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiBvZiB0aGUgc2VsZWN0aW9uLiBNYXkgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG5cdCAqIENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QIG9yIENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NXG5cdCAqIEByZXR1cm4ge0FycmF5fSBBbiBBcnJheSB3aXRoIGxlZnQgYW5kIHRvcCBvZmZzZXRzIGluIHBhZ2UgY29vcmRpbmF0ZXMuXG5cdCAqL1xuXHRnZXRXaWRnZXRYWVBvaW50KGxlZnQsIHRvcCwgZGlyZWN0aW9uKSB7XG5cdFx0Y29uc3QgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG5cdFx0Y29uc3QgZ3V0dGVyID0gdGhpcy5wcm9wcy5ndXR0ZXI7XG5cdFx0Y29uc3Qgb2Zmc2V0V2lkdGggPSBkb21Ob2RlLm9mZnNldFdpZHRoO1xuXHRcdGNvbnN0IGhhbGZXaWR0aCA9IG9mZnNldFdpZHRoIC8gMjtcblxuXHRcdGlmIChcblx0XHRcdGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT00gfHxcblx0XHRcdGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1Bcblx0XHQpIHtcblx0XHRcdGxlZnQgPSBsZWZ0IC0gZ3V0dGVyLmxlZnQgLSBoYWxmV2lkdGg7XG5cblx0XHRcdHRvcCA9XG5cdFx0XHRcdGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT01cblx0XHRcdFx0XHQ/IHRvcCArIGd1dHRlci50b3Bcblx0XHRcdFx0XHQ6IHRvcCAtIGRvbU5vZGUub2Zmc2V0SGVpZ2h0IC0gZ3V0dGVyLnRvcDtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0ZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fTEVGVF9UT19SSUdIVCB8fFxuXHRcdFx0ZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fUklHSFRfVE9fTEVGVFxuXHRcdCkge1xuXHRcdFx0bGVmdCA9XG5cdFx0XHRcdGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX0xFRlRfVE9fUklHSFRcblx0XHRcdFx0XHQ/IGxlZnQgKyBndXR0ZXIubGVmdCArIGRvbU5vZGUub2Zmc2V0SGVpZ2h0IC8gMlxuXHRcdFx0XHRcdDogbGVmdCAtICgzICogZG9tTm9kZS5vZmZzZXRIZWlnaHQpIC8gMiAtIGd1dHRlci5sZWZ0O1xuXG5cdFx0XHR0b3AgPSB0b3AgLSBndXR0ZXIudG9wIC0gZG9tTm9kZS5vZmZzZXRIZWlnaHQgLyAyO1xuXHRcdH1cblxuXHRcdGlmIChsZWZ0IDwgMCkge1xuXHRcdFx0bGVmdCA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKGxlZnQgPiBkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoIC0gaGFsZldpZHRoKSB7XG5cdFx0XHRsZWZ0ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCAtIGhhbGZXaWR0aDtcblx0XHR9XG5cblx0XHRpZiAodG9wIDwgMCkge1xuXHRcdFx0dG9wID0gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gW2xlZnQsIHRvcF07XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgd2lkZ2V0IGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZVxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHdpZGdldCBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdGlzVmlzaWJsZSgpIHtcblx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cblx0XHRpZiAoZG9tTm9kZSkge1xuXHRcdFx0Y29uc3QgZG9tRWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChkb21Ob2RlKTtcblxuXHRcdFx0cmV0dXJuIGRvbUVsZW1lbnQuaGFzQ2xhc3MoJ2FsbG95LWVkaXRvci12aXNpYmxlJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBNb3ZlcyBhIHdpZGdldCBmcm9tIGEgc3RhcnRpbmcgcG9pbnQgdG8gYSBkZXN0aW5hdGlvbiBwb2ludC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuXHQgKiBAbWV0aG9kIG1vdmVUb1BvaW50XG5cdCAqIEBwYXJhbSAge09iamVjdH0gc3RhcnRQb2ludCBUaGUgc3RhcnRpbmcgcG9pbnQgZm9yIHRoZSBtb3ZlbWVudC5cblx0ICogQHBhcmFtICB7T2JqZWN0fSBlbmRQb2ludCBUaGUgZGVzdGluYXRpb24gcG9pbnQgZm9yIHRoZSBtb3ZlbWVudC5cblx0ICovXG5cdG1vdmVUb1BvaW50KHN0YXJ0UG9pbnQsIGVuZFBvaW50KSB7XG5cdFx0Y29uc3QgZG9tRWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSk7XG5cblx0XHRkb21FbGVtZW50LnNldFN0eWxlcyh7XG5cdFx0XHRsZWZ0OiBzdGFydFBvaW50WzBdICsgJ3B4Jyxcblx0XHRcdHRvcDogc3RhcnRQb2ludFsxXSArICdweCcsXG5cdFx0XHRvcGFjaXR5OiAwLFxuXHRcdFx0cG9pbnRlckV2ZW50czogJ25vbmUnLFxuXHRcdH0pO1xuXG5cdFx0ZG9tRWxlbWVudC5yZW1vdmVDbGFzcygnYWxsb3ktZWRpdG9yLWludmlzaWJsZScpO1xuXG5cdFx0dGhpcy5fYW5pbWF0ZSgoKSA9PiB7XG5cdFx0XHRkb21FbGVtZW50LmFkZENsYXNzKCdhZS10b29sYmFyLXRyYW5zaXRpb24nKTtcblx0XHRcdGRvbUVsZW1lbnQuYWRkQ2xhc3MoJ2FsbG95LWVkaXRvci12aXNpYmxlJyk7XG5cdFx0XHRkb21FbGVtZW50LnNldFN0eWxlcyh7XG5cdFx0XHRcdGxlZnQ6IGVuZFBvaW50WzBdICsgJ3B4Jyxcblx0XHRcdFx0dG9wOiBlbmRQb2ludFsxXSArICdweCcsXG5cdFx0XHRcdG9wYWNpdHk6IDEsXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gMTUwbXMgdG8gbWF0Y2ggdHJhbnNpdGlvbi1kdXJhdGlvbiBmb3IgLmFlLXRvb2xiYXItdHJhbnNpdGlvbjpcblx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRkb21FbGVtZW50LnNldFN0eWxlcyh7XG5cdFx0XHRcdFx0cG9pbnRlckV2ZW50czogJycsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSwgMTUwKTtcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogU2hvd3MgdGhlIHdpZGdldCB3aXRoIHRoZSBkZWZhdWx0IGFuaW1hdGlvbiB0cmFuc2l0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG5cdCAqIEBtZXRob2Qgc2hvd1xuXHQgKi9cblx0c2hvdygpIHtcblx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cdFx0Y29uc3QgdWlOb2RlID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCd1aU5vZGUnKTtcblxuXHRcdGNvbnN0IHNjcm9sbFRvcCA9IHVpTm9kZSA/IHVpTm9kZS5zY3JvbGxUb3AgOiAwO1xuXG5cdFx0aWYgKCF0aGlzLmlzVmlzaWJsZSgpICYmIGRvbU5vZGUpIHtcblx0XHRcdGNvbnN0IGludGVyYWN0aW9uUG9pbnQgPSB0aGlzLmdldEludGVyYWN0aW9uUG9pbnQoKTtcblxuXHRcdFx0aWYgKGludGVyYWN0aW9uUG9pbnQpIHtcblx0XHRcdFx0Y29uc3QgZG9tRWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChkb21Ob2RlKTtcblxuXHRcdFx0XHRsZXQgZmluYWxYLCBmaW5hbFksIGluaXRpYWxYLCBpbml0aWFsWTtcblxuXHRcdFx0XHRmaW5hbFggPSBpbml0aWFsWCA9IHBhcnNlRmxvYXQoZG9tRWxlbWVudC5nZXRTdHlsZSgnbGVmdCcpKTtcblx0XHRcdFx0ZmluYWxZID0gaW5pdGlhbFkgPSBwYXJzZUZsb2F0KGRvbUVsZW1lbnQuZ2V0U3R5bGUoJ3RvcCcpKTtcblxuXHRcdFx0XHRpZiAodGhpcy5wcm9wcy5jb25zdHJhaW5Ub1ZpZXdwb3J0KSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzID0gdGhpcy5nZXRDb25zdHJhaW5lZFBvc2l0aW9uKHtcblx0XHRcdFx0XHRcdGhlaWdodDogcGFyc2VGbG9hdChkb21Ob2RlLm9mZnNldEhlaWdodCksXG5cdFx0XHRcdFx0XHRsZWZ0OiBmaW5hbFgsXG5cdFx0XHRcdFx0XHR0b3A6IGZpbmFsWSxcblx0XHRcdFx0XHRcdHdpZHRoOiBwYXJzZUZsb2F0KGRvbU5vZGUub2Zmc2V0V2lkdGgpLFxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0ZmluYWxYID0gcmVzLng7XG5cdFx0XHRcdFx0ZmluYWxZID0gcmVzLnk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0aW50ZXJhY3Rpb25Qb2ludC5kaXJlY3Rpb24gPT09XG5cdFx0XHRcdFx0Q0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT01cblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0aW5pdGlhbFkgPVxuXHRcdFx0XHRcdFx0dGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhLnJlZ2lvbi5ib3R0b20gKyBzY3JvbGxUb3A7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aW5pdGlhbFkgPSB0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGEucmVnaW9uLnRvcCArIHNjcm9sbFRvcDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubW92ZVRvUG9pbnQoW2luaXRpYWxYLCBpbml0aWFsWV0sIFtmaW5hbFgsIGZpbmFsWV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgd2lkZ2V0IHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IGludGVyYWN0aW9uIHBvaW50LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG5cdCAqIEBtZXRob2QgdXBkYXRlUG9zaXRpb25cblx0ICovXG5cdHVwZGF0ZVBvc2l0aW9uKCkge1xuXHRcdGNvbnN0IGludGVyYWN0aW9uUG9pbnQgPSB0aGlzLmdldEludGVyYWN0aW9uUG9pbnQoKTtcblxuXHRcdGNvbnN0IGRvbU5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcblxuXHRcdGlmIChpbnRlcmFjdGlvblBvaW50ICYmIGRvbU5vZGUpIHtcblx0XHRcdGNvbnN0IHVpTm9kZSA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgndWlOb2RlJykgfHwgZG9jdW1lbnQuYm9keTtcblx0XHRcdGNvbnN0IHVpTm9kZVN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh1aU5vZGUpO1xuXHRcdFx0Y29uc3QgdWlOb2RlTWFyZ2luTGVmdCA9IHBhcnNlSW50KFxuXHRcdFx0XHR1aU5vZGVTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tbGVmdCcpLFxuXHRcdFx0XHQxMFxuXHRcdFx0KTtcblx0XHRcdGNvbnN0IHVpTm9kZU1hcmdpblJpZ2h0ID0gcGFyc2VJbnQoXG5cdFx0XHRcdHVpTm9kZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ21hcmdpbi1yaWdodCcpLFxuXHRcdFx0XHQxMFxuXHRcdFx0KTtcblx0XHRcdGNvbnN0IHRvdGFsV2lkdGggPVxuXHRcdFx0XHR1aU5vZGVNYXJnaW5MZWZ0ICsgdWlOb2RlLmNsaWVudFdpZHRoICsgdWlOb2RlTWFyZ2luUmlnaHQ7XG5cblx0XHRcdGNvbnN0IHNjcm9sbFRvcCA9IHVpTm9kZS50YWdOYW1lICE9PSAnQk9EWScgPyB1aU5vZGUuc2Nyb2xsVG9wIDogMDtcblxuXHRcdFx0Y29uc3QgeHkgPSB0aGlzLmdldFdpZGdldFhZUG9pbnQoXG5cdFx0XHRcdGludGVyYWN0aW9uUG9pbnQueCxcblx0XHRcdFx0aW50ZXJhY3Rpb25Qb2ludC55LFxuXHRcdFx0XHRpbnRlcmFjdGlvblBvaW50LmRpcmVjdGlvblxuXHRcdFx0KTtcblx0XHRcdHh5WzFdICs9IHNjcm9sbFRvcDtcblxuXHRcdFx0aWYgKHh5WzBdIDwgMCkge1xuXHRcdFx0XHR4eVswXSA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoeHlbMF0gPiB0b3RhbFdpZHRoIC0gZG9tTm9kZS5vZmZzZXRXaWR0aCkge1xuXHRcdFx0XHR4eVswXSA9IHRvdGFsV2lkdGggLSBkb21Ob2RlLm9mZnNldFdpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHRuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoZG9tTm9kZSkuc2V0U3R5bGVzKHtcblx0XHRcdFx0bGVmdDogeHlbMF0gKyAncHgnLFxuXHRcdFx0XHR0b3A6IHh5WzFdICsgJ3B4Jyxcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmVxdWVzdHMgYW4gYW5pbWF0aW9uIGZyYW1lLCBpZiBwb3NzaWJsZSwgdG8gc2ltdWxhdGUgYW4gYW5pbWF0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG5cdCAqIEBtZXRob2QgX2FuaW1hdGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzY2hlZHVsZWQgZnJhbWUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9hbmltYXRlKGNhbGxiYWNrKSB7XG5cdFx0aWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcblx0XHRcdHRoaXMuX2FuaW1hdGlvbkZyYW1lSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHR9XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRQb3NpdGlvbjtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgV2lkZ2V0RXhjbHVzaXZlIGZyb20gJy4vYmFzZS93aWRnZXQtZXhjbHVzaXZlJztcbmltcG9ydCBXaWRnZXRGb2N1c01hbmFnZXIgZnJvbSAnLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyJztcblxuLyoqXG4gKiBUaGUgbWFpbiBlZGl0b3IgVUkgY2xhc3MgbWFuYWdlcyBhIGhpZXJhcmNoeSBvZiB3aWRnZXRzICh0b29sYmFycyBhbmQgYnV0dG9ucykuXG4gKlxuICogQGNsYXNzIFVJXG4gKiBAdXNlcyBXaWRnZXRFeGNsdXNpdmVcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBVSSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFVJXG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y2lyY3VsYXI6IHRydWUsXG5cdFx0ZGVzY2VuZGFudHM6ICdbY2xhc3NePWFlLXRvb2xiYXItXScsXG5cdFx0ZXZlbnRzRGVsYXk6IDAsXG5cdFx0a2V5czoge1xuXHRcdFx0bmV4dDogOSxcblx0XHR9LFxuXHR9O1xuXG5cdHN0YXRpYyBwcm9wVHlwZXMgPSB7XG5cdFx0LyoqXG5cdFx0ICogTG9jYWxpemVkIG1lc3NhZ2VzIGZvciBsaXZlIGFyaWEgdXBkYXRlcy4gU2hvdWxkIGluY2x1ZGUgdGhlIGZvbGxvd2luZyBtZXNzYWdlczpcblx0XHQgKiAtIG5vVG9vbGJhcjogTm90aWZpY2F0aW9uIGZvciBubyBhdmFpbGFibGUgdG9vbGJhciBpbiB0aGUgZWRpdG9yLlxuXHRcdCAqIC0gb25lVG9vbGJhcjogTm90aWZpY2F0aW9uIGZvciBqdXN0IG9uZSBhdmFpbGFibGUgdG9vbGJhciBpbiB0aGUgZWRpdG9yLlxuXHRcdCAqIC0gbWFueVRvb2xiYXJzOiBOb3RpZmljYXRpb24gZm9yIG1vcmUgdGhhbiBvbmUgYXZhaWxhYmxlIHRvb2xiYXIgaW4gdGhlIGVkaXRvci5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBVSVxuXHRcdCAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhcmlhVXBkYXRlc1xuXHRcdCAqL1xuXHRcdGFyaWFVcGRhdGVzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGRlbGF5IChtcyksIGFmdGVyIHdoaWNoIGtleSBvciBtb3VzZSBldmVudHMgd2lsbCBiZSBwcm9jZXNzZWQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgVUlcblx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gZXZlbnRzRGVsYXlcblx0XHQgKi9cblx0XHRldmVudHNEZWxheTogUHJvcFR5cGVzLm51bWJlcixcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0b29sYmFycyBjb25maWd1cmF0aW9uIGZvciB0aGlzIGVkaXRvciBpbnN0YW5jZVxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFVJXG5cdFx0ICogQHByb3BlcnR5IHtPYmplY3R9IHRvb2xiYXJzXG5cdFx0ICovXG5cdFx0dG9vbGJhcnM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblx0fTtcblxuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdHRoaXMuc3RhdGUgPSB7XG5cdFx0XHRoaWRkZW46IGZhbHNlLFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBVSVxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRlZGl0b3Iub24oJ2VkaXRvckludGVyYWN0aW9uJywgdGhpcy5fb25FZGl0b3JJbnRlcmFjdGlvbiwgdGhpcyk7XG5cdFx0ZWRpdG9yLm9uKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzLl9vbkFjdGlvblBlcmZvcm1lZCwgdGhpcyk7XG5cdFx0ZWRpdG9yLm9uKCdrZXknLCB0aGlzLl9vbkVkaXRvcktleSwgdGhpcyk7XG5cblx0XHQvLyBTZXQgdXAgZXZlbnRzIGZvciBoaWRpbmcgdGhlIFVJIHdoZW4gdXNlciBzdG9wcyBpbnRlcmFjdGluZyB3aXRoIHRoZSBlZGl0b3IuXG5cdFx0Ly8gVGhpcyBtYXkgaGFwcGVuIHdoZW4gaGUganVzdCBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgZWRpdG9yLiBIb3dldmVyLFxuXHRcdC8vIHRoaXMgZG9lcyBub3QgaW5jbHVkZSBhIHNpdHVhdGlvbiB3aGVuIGhlIGNsaWNrcyBvbiBzb21lIGJ1dHRvbiwgcGFydCBvZlxuXHRcdC8vIGVkaXRvcidzIFVJLlxuXG5cdFx0Ly8gSXQgaXMgbm90IGVhc3kgdG8gZGVib3VuY2UgX3NldFVJSGlkZGVuIG9uIG1vdXNlZG93biwgYmVjYXVzZSBpZiB3ZVxuXHRcdC8vIGRlYm91bmNlIGl0LCB3aGVuIHRoZSBoYW5kbGVyIGlzIGJlaW5nIGludm9rZWQsIHRoZSB0YXJnZXQgbWlnaHQgYmUgbm8gbW9yZSBwYXJ0XG5cdFx0Ly8gb2YgdGhlIGVkaXRvcidzIFVJIC0gb25BY3Rpb25QZXJmb3JtZWQgY2F1c2VzIHJlLXJlbmRlci5cblx0XHR0aGlzLl9tb3VzZWRvd25MaXN0ZW5lciA9IGV2ZW50ID0+IHtcblx0XHRcdHRoaXMuX3NldFVJSGlkZGVuKGV2ZW50LnRhcmdldCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuX2tleURvd25MaXN0ZW5lciA9IENLRURJVE9SLnRvb2xzLmRlYm91bmNlKFxuXHRcdFx0X2V2ZW50ID0+IHtcblx0XHRcdFx0dGhpcy5fc2V0VUlIaWRkZW4oZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG5cdFx0XHR9LFxuXHRcdFx0dGhpcy5wcm9wcy5ldmVudHNEZWxheSxcblx0XHRcdHRoaXNcblx0XHQpO1xuXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fbW91c2Vkb3duTGlzdGVuZXIpO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlEb3duTGlzdGVuZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50J3MgdXBkYXRlcyBhcmUgZmx1c2hlZCB0byB0aGUgRE9NLlxuXHQgKiBGaXJlcyBgYXJpYVVwZGF0ZWAgZXZlbnQgcGFzc2luZyBBUklBIHJlbGF0ZWQgbWVzc2FnZXMuXG5cdCAqIEZpcmVzIGBlZGl0b3JVcGRhdGVgIGV2ZW50IHBhc3NpbmcgdGhlIHByZXZpb3VzIGFuZCBjdXJyZW50IHByb3BlcnRpZXMgYW5kIHN0YXRlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFVJXG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkVXBkYXRlXG5cdCAqL1xuXHRjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcblx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRpZiAoZG9tTm9kZSkge1xuXHRcdFx0ZWRpdG9yLmZpcmUoJ2FyaWFVcGRhdGUnLCB7XG5cdFx0XHRcdG1lc3NhZ2U6IHRoaXMuX2dldEF2YWlsYWJsZVRvb2xiYXJzTWVzc2FnZShkb21Ob2RlKSxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGVkaXRvci5maXJlKCdlZGl0b3JVcGRhdGUnLCB7XG5cdFx0XHRwcmV2UHJvcHMsXG5cdFx0XHRwcmV2U3RhdGUsXG5cdFx0XHRwcm9wczogdGhpcy5wcm9wcyxcblx0XHRcdHN0YXRlOiB0aGlzLnN0YXRlLFxuXHRcdH0pO1xuXHR9XG5cblx0X2dldEFyaWFVcGRhdGVUZW1wbGF0ZShhcmlhVXBkYXRlKSB7XG5cdFx0aWYgKCF0aGlzLl9hcmlhVXBkYXRlVGVtcGxhdGVzKSB7XG5cdFx0XHR0aGlzLl9hcmlhVXBkYXRlVGVtcGxhdGVzID0ge307XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9hcmlhVXBkYXRlVGVtcGxhdGVzW2FyaWFVcGRhdGVdKSB7XG5cdFx0XHR0aGlzLl9hcmlhVXBkYXRlVGVtcGxhdGVzW2FyaWFVcGRhdGVdID0gbmV3IENLRURJVE9SLnRlbXBsYXRlKFxuXHRcdFx0XHR0aGlzLl9nZXRBcmlhVXBkYXRlcygpW2FyaWFVcGRhdGVdXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9hcmlhVXBkYXRlVGVtcGxhdGVzW2FyaWFVcGRhdGVdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRlbXBsYXRlcyBmb3IgQVJJQSBtZXNzYWdlcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBVSVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX2dldEFyaWFVcGRhdGVzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQVJJQSByZWxhdGVzIG1lc3NhZ2VzLiBEZWZhdWx0OlxuXHQgKiB7XG5cdCAqICAgICAgbm9Ub29sYmFyOiBBbGxveUVkaXRvci5TdHJpbmdzLmFyaWFVcGRhdGVOb1Rvb2xiYXIsXG5cdCAqICAgICAgb25lVG9vbGJhcjogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlT25lVG9vbGJhcixcblx0ICogICAgICBtYW55VG9vbGJhcnM6IEFsbG95RWRpdG9yLlN0cmluZ3MuYXJpYVVwZGF0ZU1hbnlUb29sYmFyc1xuXHQgKiAgfVxuXHQgKi9cblx0X2dldEFyaWFVcGRhdGVzKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLmFyaWFVcGRhdGVzIHx8IHtcblx0XHRcdFx0bm9Ub29sYmFyOiBBbGxveUVkaXRvci5TdHJpbmdzLmFyaWFVcGRhdGVOb1Rvb2xiYXIsXG5cdFx0XHRcdG9uZVRvb2xiYXI6IEFsbG95RWRpdG9yLlN0cmluZ3MuYXJpYVVwZGF0ZU9uZVRvb2xiYXIsXG5cdFx0XHRcdG1hbnlUb29sYmFyczogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlTWFueVRvb2xiYXJzLFxuXHRcdFx0fVxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBBUklBIG1lc3NhZ2Ugd2hpY2ggcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIGN1cnJlbnRseSBhdmFpbGFibGUgdG9vbGJhcnMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVUlcblx0ICogQG1ldGhvZCBfZ2V0QXZhaWxhYmxlVG9vbGJhcnNNZXNzYWdlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZG9tTm9kZSBUaGUgRE9NIG5vZGUgZnJvbSB3aGljaCB0aGUgYXZhaWxhYmxlIHRvb2xiYXJzIHdpbGwgYmUgcmV0cmlldmVkLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBBUklBIG1lc3NhZ2UgZm9yIHRoZSBudW1iZXIgb2YgYXZhaWxhYmxlIHRvb2xiYXJzXG5cdCAqL1xuXHRfZ2V0QXZhaWxhYmxlVG9vbGJhcnNNZXNzYWdlKGRvbU5vZGUpIHtcblx0XHRjb25zdCB0b29sYmFyc05vZGVMaXN0ID0gZG9tTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cInRvb2xiYXJcIl0nKTtcblxuXHRcdGlmICghdG9vbGJhcnNOb2RlTGlzdC5sZW5ndGgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9nZXRBcmlhVXBkYXRlcygpLm5vVG9vbGJhcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgdG9vbGJhck5hbWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG5cdFx0XHRcdC5jYWxsKHRvb2xiYXJzTm9kZUxpc3QpXG5cdFx0XHRcdC5tYXAodG9vbGJhciA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIHRvb2xiYXIuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRjb25zdCBhcmlhVXBkYXRlID1cblx0XHRcdFx0dG9vbGJhck5hbWVzLmxlbmd0aCA9PT0gMSA/ICdvbmVUb29sYmFyJyA6ICdtYW55VG9vbGJhcnMnO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5fZ2V0QXJpYVVwZGF0ZVRlbXBsYXRlKGFyaWFVcGRhdGUpLm91dHB1dCh7XG5cdFx0XHRcdHRvb2xiYXJzOiB0b29sYmFyTmFtZXNcblx0XHRcdFx0XHQuam9pbignLCcpXG5cdFx0XHRcdFx0LnJlcGxhY2UoLywoW14sXSopJC8sICcgYW5kICcgKyAnJDEnKSxcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgaW1tZWRpYXRlbHkgYmVmb3JlIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBmcm9tIHRoZSBET00uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVUlcblx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsVW5tb3VudFxuXHQgKi9cblx0Y29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0aWYgKHRoaXMuX21vdXNlZG93bkxpc3RlbmVyKSB7XG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9tb3VzZWRvd25MaXN0ZW5lcik7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2tleURvd25MaXN0ZW5lcikge1xuXHRcdFx0dGhpcy5fa2V5RG93bkxpc3RlbmVyLmRldGFjaCgpO1xuXHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleURvd25MaXN0ZW5lcik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGVkaXRvci4gVGhpcyBtYXkgaW5jbHVkZSBzZXZlcmFsIHRvb2xiYXJzIGFuZCBidXR0b25zLlxuXHQgKiBUaGUgZWRpdG9yJ3MgVUkgYWxzbyB0YWtlcyBjYXJlIG9mIHJlbmRlcmluZyB0aGUgaXRlbXMgaW4gZXhjbHVzaXZlIG1vZGUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVUlcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0aWYgKHRoaXMuc3RhdGUuaGlkZGVuKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRsZXQgdG9vbGJhcnMgPSBPYmplY3Qua2V5cyh0aGlzLnByb3BzLnRvb2xiYXJzKS5tYXAodG9vbGJhciA9PiB7XG5cdFx0XHRyZXR1cm4gQWxsb3lFZGl0b3IuVG9vbGJhcnNbdG9vbGJhcl0gfHwgd2luZG93W3Rvb2xiYXJdO1xuXHRcdH0pO1xuXG5cdFx0dG9vbGJhcnMgPSB0aGlzLmZpbHRlckV4Y2x1c2l2ZSh0b29sYmFycykubWFwKHRvb2xiYXIgPT4ge1xuXHRcdFx0Y29uc3QgcHJvcHMgPSB0aGlzLm1lcmdlRXhjbHVzaXZlUHJvcHMoXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25maWc6IHRoaXMucHJvcHMudG9vbGJhcnNbdG9vbGJhci5rZXldLFxuXHRcdFx0XHRcdGVkaXRvcjogdGhpcy5jb250ZXh0LmVkaXRvcixcblx0XHRcdFx0XHRlZGl0b3JFdmVudDogdGhpcy5zdGF0ZS5lZGl0b3JFdmVudCxcblx0XHRcdFx0XHRrZXk6IHRvb2xiYXIua2V5LFxuXHRcdFx0XHRcdG9uRGlzbWlzczogdGhpcy5fb25EaXNtaXNzVG9vbGJhckZvY3VzLFxuXHRcdFx0XHRcdHNlbGVjdGlvbkRhdGE6IHRoaXMuc3RhdGUuc2VsZWN0aW9uRGF0YSxcblx0XHRcdFx0fSxcblx0XHRcdFx0dG9vbGJhci5rZXlcblx0XHRcdCk7XG5cblx0XHRcdHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHRvb2xiYXIsIHByb3BzKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLXRvb2xiYXJzXCIgb25LZXlEb3duPXt0aGlzLmhhbmRsZUtleX0+XG5cdFx0XHRcdHt0b29sYmFyc31cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlzdGVuZXIgdG8gdGhlIGVkaXRvcidzIGBhY3Rpb25QZXJmb3JtZWRgIGV2ZW50LiBTZXRzIHN0YXRlIGFuZCByZWRyYXdzIHRoZSBVSSBvZiB0aGUgZWRpdG9yLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFVJXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCBfb25BY3Rpb25QZXJmb3JtZWRcblx0ICogQHBhcmFtIHtTeW50ZXRpY0V2ZW50fSBldmVudCBUaGUgcHJvdmlkZWQgZXZlbnRcblx0ICovXG5cdF9vbkFjdGlvblBlcmZvcm1lZChfZXZlbnQpIHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRlZGl0b3IuZm9jdXMoKTtcblxuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0aXRlbUV4Y2x1c2l2ZTogbnVsbCxcblx0XHRcdHNlbGVjdGlvbkRhdGE6IGVkaXRvci5nZXRTZWxlY3Rpb25EYXRhKCksXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogRXhlY3V0ZWQgd2hlbiBhIGRpc21pc3Mga2V5IGlzIHByZXNzZWQgb3ZlciBhIHRvb2xiYXIgdG8gcmV0dXJuIHRoZSBmb2N1cyB0byB0aGUgZWRpdG9yLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFVJXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCBfb25EaXNtaXNzVG9vbGJhckZvY3VzXG5cdCAqL1xuXHRfb25EaXNtaXNzVG9vbGJhckZvY3VzID0gKCkgPT4ge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGVkaXRvci5mb2N1cygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBMaXN0ZW5lciB0byB0aGUgZWRpdG9yJ3MgYHVzZXJJbnRlcmFjdGlvbmAgZXZlbnQuIFJldHJpZXZlcyB0aGUgZGF0YSBhYm91dCB0aGUgdXNlciBzZWxlY3Rpb24gYW5kXG5cdCAqIHByb3ZpZGVzIGl0IHZpYSBjb21wb25lbnQncyBzdGF0ZSBwcm9wZXJ0eS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBVSVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX29uRWRpdG9ySW50ZXJhY3Rpb25cblx0ICogQHBhcmFtIHtTeW50ZXRpY0V2ZW50fSBldmVudCBUaGUgcHJvdmlkZWQgZXZlbnRcblx0ICovXG5cdF9vbkVkaXRvckludGVyYWN0aW9uKGV2ZW50KSB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRlZGl0b3JFdmVudDogZXZlbnQsXG5cdFx0XHRoaWRkZW46IGZhbHNlLFxuXHRcdFx0aXRlbUV4Y2x1c2l2ZTogbnVsbCxcblx0XHRcdHNlbGVjdGlvbkRhdGE6IGV2ZW50LmRhdGEuc2VsZWN0aW9uRGF0YSxcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGb2N1c2VzIG9uIHRoZSBhY3RpdmUgdG9vbGJhciB3aGVuIHRoZSBjb21iaW5hdGlvbiBBTFQrRjEwIGlzIHByZXNzZWQgaW5zaWRlIHRoZSBlZGl0b3IuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVUlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kIF9vbkVkaXRvcktleVxuXHQgKi9cblx0X29uRWRpdG9yS2V5KGV2ZW50KSB7XG5cdFx0Y29uc3QgbmF0aXZlRXZlbnQgPSBldmVudC5kYXRhLmRvbUV2ZW50LiQ7XG5cblx0XHRpZiAobmF0aXZlRXZlbnQuYWx0S2V5ICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IDEyMSkge1xuXHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIHRhcmdldCB3aXRoIHdoaWNoIHRoZSB1c2VyIGludGVyYWN0ZWQgaXMgcGFydCBvZiBlZGl0b3IncyBVSSBvciBpdCBpc1xuXHQgKiB0aGUgZWRpdGFibGUgYXJlYS4gSWYgbm9uZSBvZiB0aGVzZSwgc2V0cyB0aGUgc3RhdGUgb2YgZWRpdG9yJ3MgVUkgdG8gYmUgaGlkZGVuLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFVJXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCBfc2V0VUlIaWRkZW5cblx0ICogQHBhcmFtIHtET01FbGVtZW50fSB0YXJnZXQgVGhlIERPTSBlbGVtZW50IHdpdGggd2hpY2ggdXNlciBpbnRlcmFjdGVkIGxhc3RseS5cblx0ICovXG5cdF9zZXRVSUhpZGRlbih0YXJnZXQpIHtcblx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cblx0XHRpZiAoZG9tTm9kZSkge1xuXHRcdFx0Y29uc3QgZWRpdGFibGUgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJykuZWRpdGFibGUoKTtcblx0XHRcdGNvbnN0IHBhcmVudE5vZGUgPSB0YXJnZXQucGFyZW50Tm9kZTtcblx0XHRcdGNvbnN0IHRhcmdldE5vZGUgPSBuZXcgQ0tFRElUT1IuZG9tLm5vZGUodGFyZ2V0KTtcblxuXHRcdFx0aWYgKCFlZGl0YWJsZSkge1xuXHRcdFx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdFx0XHRoaWRkZW46IHRydWUsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGV0IHJlcyA9XG5cdFx0XHRcdFx0ZWRpdGFibGUuJCA9PT0gdGFyZ2V0IHx8XG5cdFx0XHRcdFx0ZWRpdGFibGUuY29udGFpbnModGFyZ2V0Tm9kZSkgfHxcblx0XHRcdFx0XHRuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoZG9tTm9kZSkuY29udGFpbnModGFyZ2V0Tm9kZSk7XG5cblx0XHRcdFx0aWYgKHBhcmVudE5vZGUpIHtcblx0XHRcdFx0XHRyZXMgPSByZXMgfHwgcGFyZW50Tm9kZS5pZCA9PT0gJ2NraW1ncnN6Jztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghcmVzKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRcdFx0XHRoaWRkZW46IHRydWUsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBGaXJlZCB3aGVuIGNvbXBvbmVudCB1cGRhdGVzIGFuZCB3aGVuIGl0IGlzIHJlbmRlcmVkIGluIHRoZSBET00uXG4gKiBUaGUgcGF5bG9hZCBjb25zaXN0cyBmcm9tIGEgYG1lc3NhZ2VgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIEFSSUEgbWVzc2FnZS5cbiAqXG4gKiBAZXZlbnQgYXJpYVVwZGF0ZVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiBjb21wb25lbnQgdXBkYXRlcy4gVGhlIHBheWxvYWQgY29uc2lzdHMgZnJvbSBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICogLSBwcmV2UHJvcHMgLSBUaGUgcHJldmlvdXMgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50XG4gKiAtIHByZXZTdGF0ZSAtIFRoZSBwcmV2aW91cyBzdGF0ZSBvZiB0aGUgY29tcG9uZW50XG4gKiAtIHByb3BzIC0gVGhlIGN1cnJlbnQgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50XG4gKiAtIHN0YXRlIC0gVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNvbXBvbmVudFxuICpcbiAqIEBldmVudCBhcmlhVXBkYXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0RXhjbHVzaXZlKFdpZGdldEZvY3VzTWFuYWdlcihVSSkpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgVG9vbGJhckFkZCBmcm9tICcuL3Rvb2xiYXItYWRkLmpzeCc7XG5pbXBvcnQgVG9vbGJhclN0eWxlcyBmcm9tICcuL3Rvb2xiYXItc3R5bGVzLmpzeCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0W1Rvb2xiYXJBZGQua2V5XTogVG9vbGJhckFkZCxcblx0W1Rvb2xiYXJTdHlsZXMua2V5XTogVG9vbGJhclN0eWxlcyxcbn07XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgVG9vbGJhckJ1dHRvbnMgZnJvbSAnLi4vYmFzZS90b29sYmFyLWJ1dHRvbnMnO1xuaW1wb3J0IFdpZGdldERyb3Bkb3duIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWRyb3Bkb3duJztcbmltcG9ydCBXaWRnZXRFeGNsdXNpdmUgZnJvbSAnLi4vYmFzZS93aWRnZXQtZXhjbHVzaXZlJztcbmltcG9ydCBXaWRnZXRGb2N1c01hbmFnZXIgZnJvbSAnLi4vYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlcic7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuLi9idXR0b25zL2J1dHRvbi1pY29uLmpzeCc7XG5cbmNvbnN0IFBPU0lUSU9OX0xFRlQgPSAxO1xuY29uc3QgUE9TSVRJT05fUklHSFQgPSAyO1xuXG4vKipcbiAqIFRoZSBUb29sYmFyQWRkIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGFkZGluZyBjb250ZW50IHRvIHRoZSBlZGl0b3IuXG4gKlxuICogQGNsYXNzIFRvb2xiYXJBZGRcbiAqIEB1c2VzIFRvb2xiYXJCdXR0b25zXG4gKiBAdXNlcyBXaWRnZXREcm9wZG93blxuICogQHVzZXMgV2lkZ2V0RXhjbHVzaXZlXG4gKiBAdXNlcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqL1xuY2xhc3MgVG9vbGJhckFkZCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHR0aGlzLnN0YXRlID0ge307XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCAobm90IG9uIHRoZSBzZXJ2ZXIpLFxuXHQgKiBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcblx0ICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuXHQgKi9cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbXBvbmVudCdzIHVwZGF0ZXMgYXJlIGZsdXNoZWQgdG8gdGhlIERPTS5cblx0ICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcblx0ICogQG1ldGhvZCBjb21wb25lbnREaWRVcGRhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHByZXZQcm9wcyBUaGUgcHJldmlvdXMgc3RhdGUgb2YgdGhlIGNvbXBvbmVudCdzIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2U3RhdGUgQ29tcG9uZW50J3MgcHJldmlvdXMgc3RhdGUuXG5cdCAqL1xuXHRjb21wb25lbnREaWRVcGRhdGUoX3ByZXZQcm9wcywgX3ByZXZTdGF0ZSkge1xuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG5cblx0XHQvLyBJbiBjYXNlIG9mIGV4Y2x1c2l2ZSByZW5kZXJpbmcsIGZvY3VzIHRoZSBmaXJzdCBkZXNjZW5kYW50IChidXR0b24pXG5cdFx0Ly8gc28gdGhlIHVzZXIgd2lsbCBiZSBhYmxlIHRvIHN0YXJ0IGludGVyYWN0aW5nIHdpdGggdGhlIGJ1dHRvbnMgaW1tZWRpYXRlbHkuXG5cdFx0aWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlKSB7XG5cdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgYnV0dG9ucyBmb3IgYWRkaW5nIGNvbnRlbnQgb3IgaGlkZXMgdGhlIHRvb2xiYXJcblx0ICogaWYgdXNlciBpbnRlcmFjdGVkIHdpdGggYSBub24tZWRpdGFibGUgZWxlbWVudC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdHxudWxsfSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Ly8gU29tZSBvcGVyYXRpb25zIHN1Y2ggYXMgYHJlcXVlc3RFeGNsdXNpdmVgIG1heSBmb3JjZSBlZGl0b3IgdG8gYmx1ciB3aGljaCB3aWxsXG5cdFx0Ly8gaW52YWxpZGF0ZSB0aGUgYHByb3BzLmVkaXRvckV2ZW50YCBzdG9yZWQgdmFsdWUsIHdpdGhvdXQgY2F1c2luZyBhIGBwcm9wc2AgY2hhbmdlLlxuXHRcdC8vIEZvciBleGFtcGxlLCBpZiB0aGUgZWRpdG9yIGlzIGVtcHR5LCBgYWVfcGxhY2Vob2xkZXJgIHBsdWdpbiB3aWxsIHJlbW92ZVxuXHRcdC8vIHRoZSB0YXJnZXQgZnJvbSB0aGUgRE9NIGFuZCB3aWxsIHByZXZlbnQgYGFkZGAgdG9vbGJhciBmcm9tIHJlbmRlcmluZy5cblx0XHQvL1xuXHRcdC8vIEl0IHNob3VsZCBiZSBzYWZlIHRvIGFzc3VtZSB0aGF0IGlmIHlvdSBoYXZlIGJlZW4gYWJsZSB0byByZW5kZXIgdGhlIHRvb2xiYXJcblx0XHQvLyBhbmQgcmVxdWVzdCB0aGUgZXhjbHVzaXZlIG1vZGUsIHRoZW4gcmVuZGVyaW5nIG1pZ2h0IGJlIGtlcHQgdW50aWwgdGhlIGV4Y2x1c2l2ZSBtb2RlIGlzIGxlZnQuXG5cdFx0aWYgKFxuXHRcdFx0IXRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSAmJlxuXHRcdFx0dGhpcy5wcm9wcy5lZGl0b3JFdmVudCAmJlxuXHRcdFx0dGhpcy5wcm9wcy5lZGl0b3JFdmVudC5kYXRhLm5hdGl2ZUV2ZW50LnRhcmdldCAmJlxuXHRcdFx0IXRoaXMucHJvcHMuZWRpdG9yRXZlbnQuZGF0YS5uYXRpdmVFdmVudC50YXJnZXQuaXNDb250ZW50RWRpdGFibGVcblx0XHQpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGNvbnN0IGJ1dHRvbnMgPSB0aGlzLl9nZXRCdXR0b25zKCk7XG5cdFx0Y29uc3QgY2xhc3NOYW1lID0gdGhpcy5fZ2V0VG9vbGJhckNsYXNzTmFtZSgpO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXZcblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hZGR9XG5cdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuXHRcdFx0XHRkYXRhLXRhYmluZGV4PXt0aGlzLnByb3BzLmNvbmZpZy50YWJJbmRleCB8fCAwfVxuXHRcdFx0XHRvbkZvY3VzPXt0aGlzLmZvY3VzLmJpbmQodGhpcyl9XG5cdFx0XHRcdG9uS2V5RG93bj17dGhpcy5oYW5kbGVLZXkuYmluZCh0aGlzKX1cblx0XHRcdFx0cm9sZT1cInRvb2xiYXJcIlxuXHRcdFx0XHR0YWJJbmRleD1cIi0xXCI+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyXCI+e2J1dHRvbnN9PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBsaXN0IG9mIGJ1dHRvbnMgdGhhdCB3aWxsIGV2ZW50dWFsbHkgcmVuZGVyIHRvIEhUTUwuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVG9vbGJhckFkZFxuXHQgKiBAbWV0aG9kIF9nZXRCdXR0b25zXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgYnV0dG9ucyB3aGljaCBoYXZlIHRvIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0X2dldEJ1dHRvbnMoKSB7XG5cdFx0bGV0IGJ1dHRvbnM7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcblx0XHRcdGJ1dHRvbnMgPSB0aGlzLmdldFRvb2xiYXJCdXR0b25zKHRoaXMucHJvcHMuY29uZmlnLmJ1dHRvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhICYmIHRoaXMucHJvcHMuc2VsZWN0aW9uRGF0YS5yZWdpb24pIHtcblx0XHRcdFx0YnV0dG9ucyA9IChcblx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFkZH1cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvbiBhZS1idXR0b24tYWRkXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMucHJvcHMucmVxdWVzdEV4Y2x1c2l2ZS5iaW5kKFxuXHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRUb29sYmFyQWRkLmtleVxuXHRcdFx0XHRcdFx0KX1cblx0XHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFkZH0+XG5cdFx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJwbHVzXCIgLz5cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gYnV0dG9ucztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjbGFzcyBuYW1lIG9mIHRoZSB0b29sYmFyIGluIGNhc2Ugb2YgYm90aCBleGNsdXNpdmUgYW5kIG5vcm1hbCBtb2RlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcblx0ICogQG1ldGhvZCBfZ2V0VG9vbGJhckNsYXNzTmFtZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGNsYXNzIG5hbWUgd2hpY2ggaGF2ZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBET00gZWxlbWVudC5cblx0ICovXG5cdF9nZXRUb29sYmFyQ2xhc3NOYW1lKCkge1xuXHRcdGxldCBjc3NDbGFzcyA9ICdhZS10b29sYmFyLWFkZCc7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcblx0XHRcdGNzc0NsYXNzID0gJ2FlLXRvb2xiYXIgJyArIHRoaXMuZ2V0QXJyb3dCb3hDbGFzc2VzKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNzc0NsYXNzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZXMgYW5kIHNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sYmFyIGluIGV4Y2x1c2l2ZSBvciBub3JtYWwgbW9kZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVBvc2l0aW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF91cGRhdGVQb3NpdGlvbigpIHtcblx0XHRsZXQgcmVnaW9uO1xuXG5cdFx0Ly8gSWYgY29tcG9uZW50IGlzIG5vdCBtb3VudGVkLCB0aGVyZSBpcyBub3RoaW5nIHRvIGRvXG5cdFx0aWYgKCFSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuXHRcdFx0dGhpcy51cGRhdGVQb3NpdGlvbigpO1xuXHRcdFx0dGhpcy5zaG93KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGEpIHtcblx0XHRcdFx0cmVnaW9uID0gdGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhLnJlZ2lvbjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJlZ2lvbikge1xuXHRcdFx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cblx0XHRcdFx0Y29uc3QgZG9tRWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChkb21Ob2RlKTtcblxuXHRcdFx0XHRjb25zdCBzdGFydFJlY3QgPSByZWdpb24uc3RhcnRSZWN0IHx8IHJlZ2lvbjtcblxuXHRcdFx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdFx0Y29uc3QgY2xpZW50UmVjdCA9IG5hdGl2ZUVkaXRvci5lZGl0YWJsZSgpLmdldENsaWVudFJlY3QoKTtcblxuXHRcdFx0XHRsZXQgb2Zmc2V0TGVmdDtcblxuXHRcdFx0XHRjb25zdCBwb3NpdGlvbiA9XG5cdFx0XHRcdFx0dGhpcy5wcm9wcy5jb25maWcucG9zaXRpb24gfHwgdGhpcy5wcm9wcy5wb3NpdGlvbjtcblxuXHRcdFx0XHRpZiAocG9zaXRpb24gPT09IFBPU0lUSU9OX0xFRlQpIHtcblx0XHRcdFx0XHRvZmZzZXRMZWZ0ID1cblx0XHRcdFx0XHRcdGNsaWVudFJlY3QubGVmdCAtXG5cdFx0XHRcdFx0XHRkb21Ob2RlLm9mZnNldFdpZHRoIC1cblx0XHRcdFx0XHRcdHRoaXMucHJvcHMuZ3V0dGVyRXhjbHVzaXZlLmxlZnQgK1xuXHRcdFx0XHRcdFx0J3B4Jztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvZmZzZXRMZWZ0ID1cblx0XHRcdFx0XHRcdGNsaWVudFJlY3QucmlnaHQgK1xuXHRcdFx0XHRcdFx0dGhpcy5wcm9wcy5ndXR0ZXJFeGNsdXNpdmUubGVmdCArXG5cdFx0XHRcdFx0XHQncHgnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZG9tTm9kZS5zdHlsZS5sZWZ0ID0gb2Zmc2V0TGVmdDtcblxuXHRcdFx0XHRkb21Ob2RlLnN0eWxlLnRvcCA9XG5cdFx0XHRcdFx0TWF0aC5mbG9vcigocmVnaW9uLmJvdHRvbSArIHJlZ2lvbi50b3ApIC8gMikgKyAncHgnO1xuXG5cdFx0XHRcdGNvbnN0IHVpTm9kZSA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCd1aU5vZGUnKTtcblxuXHRcdFx0XHRjb25zdCBzY3JvbGxUb3AgPSB1aU5vZGUgPyB1aU5vZGUuc2Nyb2xsVG9wIDogMDtcblxuXHRcdFx0XHRpZiAobmF0aXZlRWRpdG9yLmVsZW1lbnQuZ2V0U3R5bGUoJ292ZXJmbG93JykgIT09ICdhdXRvJykge1xuXHRcdFx0XHRcdGRvbU5vZGUuc3R5bGUudG9wID1cblx0XHRcdFx0XHRcdE1hdGguZmxvb3IoXG5cdFx0XHRcdFx0XHRcdHJlZ2lvbi50b3AgLVxuXHRcdFx0XHRcdFx0XHRcdGRvbU5vZGUub2Zmc2V0SGVpZ2h0IC8gMiArXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRSZWN0LmhlaWdodCAvIDIgK1xuXHRcdFx0XHRcdFx0XHRcdHNjcm9sbFRvcFxuXHRcdFx0XHRcdFx0KSArICdweCc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZG9tTm9kZS5zdHlsZS50b3AgPVxuXHRcdFx0XHRcdFx0TWF0aC5mbG9vcihcblx0XHRcdFx0XHRcdFx0bmF0aXZlRWRpdG9yLmVsZW1lbnQuJC5vZmZzZXRUb3AgK1xuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0UmVjdC5oZWlnaHQgLyAyIC1cblx0XHRcdFx0XHRcdFx0XHRkb21Ob2RlLm9mZnNldEhlaWdodCAvIDJcblx0XHRcdFx0XHRcdCkgKyAncHgnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZG9tTm9kZS5zdHlsZS5vcGFjaXR5ID0gMTtcblxuXHRcdFx0XHRkb21FbGVtZW50LnJlbW92ZUNsYXNzKCdhZS1hcnJvdy1ib3gnKTtcblxuXHRcdFx0XHR0aGlzLmNhbmNlbEFuaW1hdGlvbigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGFkZFxuICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuVG9vbGJhckFkZC5rZXkgPSAnYWRkJztcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBjb25zdGFudCBmb3IgcG9zaXRpb25pbmcgdGhlIFRvb2xiYXIgb24gbGVmdCBvZiB0aGUgZWRpdGFibGUgYXJlYS5cbiAqXG4gKiBAZGVmYXVsdCAxXG4gKiBAbWVtYmVyb2YgVG9vbGJhckFkZFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGxlZnRcbiAqIEBzdGF0aWNcbiAqL1xuVG9vbGJhckFkZC5sZWZ0ID0gUE9TSVRJT05fTEVGVDtcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBjb25zdGFudCBmb3IgcG9zaXRpb25pbmcgdGhlIFRvb2xiYXIgb24gcmlnaHQgb2YgdGhlIGVkaXRhYmxlIGFyZWEuXG4gKlxuICogQGRlZmF1bHQgMlxuICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByaWdodFxuICogQHN0YXRpY1xuICovXG5Ub29sYmFyQWRkLnJpZ2h0ID0gUE9TSVRJT05fUklHSFQ7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgVG9vbGJhckFkZFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuVG9vbGJhckFkZC5kZWZhdWx0UHJvcHMgPSB7XG5cdGNpcmN1bGFyOiB0cnVlLFxuXHRkZXNjZW5kYW50czogJy5hZS1idXR0b24nLFxuXHRndXR0ZXJFeGNsdXNpdmU6IHtcblx0XHRsZWZ0OiAxMCxcblx0XHR0b3A6IDAsXG5cdH0sXG5cdGtleXM6IHtcblx0XHRkaXNtaXNzOiBbMjddLFxuXHRcdG5leHQ6IFszOSwgNDBdLFxuXHRcdHByZXY6IFszNywgMzhdLFxuXHR9LFxuXHRwb3NpdGlvbjogUE9TSVRJT05fTEVGVCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFdpZGdldERyb3Bkb3duKFxuXHRXaWRnZXRFeGNsdXNpdmUoV2lkZ2V0Rm9jdXNNYW5hZ2VyKFRvb2xiYXJCdXR0b25zKFRvb2xiYXJBZGQpKSlcbik7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5pbXBvcnQgVG9vbGJhckJ1dHRvbnMgZnJvbSAnLi4vYmFzZS90b29sYmFyLWJ1dHRvbnMnO1xuaW1wb3J0IFdpZGdldERyb3Bkb3duIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWRyb3Bkb3duJztcbmltcG9ydCBXaWRnZXRFeGNsdXNpdmUgZnJvbSAnLi4vYmFzZS93aWRnZXQtZXhjbHVzaXZlJztcbmltcG9ydCBXaWRnZXRGb2N1c01hbmFnZXIgZnJvbSAnLi4vYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlcic7XG5cbi8qKlxuICogVGhlIFRvb2xiYXJTdHlsZXMgY2xhc3MgaG9zdHMgdGhlIGJ1dHRvbnMgZm9yIHN0eWxpbmcgYSB0ZXh0IHNlbGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgVG9vbGJhclN0eWxlc1xuICogQHVzZXMgVG9vbGJhckJ1dHRvbnNcbiAqIEB1c2VzIFdpZGdldERyb3Bkb3duXG4gKiBAdXNlcyBXaWRnZXRFeGNsdXNpdmVcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBUb29sYmFyU3R5bGVzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdHRoaXMuc3RhdGUgPSB7fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50IChub3Qgb24gdGhlIHNlcnZlciksXG5cdCAqIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVG9vbGJhclN0eWxlc1xuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50J3MgdXBkYXRlcyBhcmUgZmx1c2hlZCB0byB0aGUgRE9NLlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVG9vbGJhclN0eWxlc1xuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZFVwZGF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJldlByb3BzIFRoZSBwcmV2aW91cyBzdGF0ZSBvZiB0aGUgY29tcG9uZW50J3MgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IHByZXZTdGF0ZSBDb21wb25lbnQncyBwcmV2aW91cyBzdGF0ZS5cblx0ICovXG5cdGNvbXBvbmVudERpZFVwZGF0ZShfcHJldlByb3BzLCBfcHJldlN0YXRlKSB7XG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIGJ1dHRvbnMgZm9yIGFkZGluZyBjb250ZW50IG9yIGhpZGVzIHRoZSB0b29sYmFyXG5cdCAqIGlmIHVzZXIgaW50ZXJhY3RlZCB3aXRoIGEgbm9uLWVkaXRhYmxlIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVG9vbGJhclN0eWxlc1xuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R8bnVsbH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGN1cnJlbnRTZWxlY3Rpb24gPSB0aGlzLl9nZXRDdXJyZW50U2VsZWN0aW9uKCk7XG5cblx0XHRpZiAoY3VycmVudFNlbGVjdGlvbikge1xuXHRcdFx0Y29uc3QgZ2V0QXJyb3dCb3hDbGFzc2VzRm4gPSB0aGlzLl9nZXRTZWxlY3Rpb25GdW5jdGlvbihcblx0XHRcdFx0Y3VycmVudFNlbGVjdGlvbi5nZXRBcnJvd0JveENsYXNzZXNcblx0XHRcdCk7XG5cdFx0XHRsZXQgYXJyb3dCb3hDbGFzc2VzO1xuXG5cdFx0XHRpZiAoZ2V0QXJyb3dCb3hDbGFzc2VzRm4pIHtcblx0XHRcdFx0YXJyb3dCb3hDbGFzc2VzID0gZ2V0QXJyb3dCb3hDbGFzc2VzRm4oKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFycm93Qm94Q2xhc3NlcyA9IHRoaXMuZ2V0QXJyb3dCb3hDbGFzc2VzKCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNzc0NsYXNzZXMgPSAnYWUtdG9vbGJhci1zdHlsZXMgJyArIGFycm93Qm94Q2xhc3NlcztcblxuXHRcdFx0bGV0IGJ1dHRvbnMgPSBjdXJyZW50U2VsZWN0aW9uLmJ1dHRvbnM7XG5cblx0XHRcdGlmICh0eXBlb2YgYnV0dG9ucyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYnV0dG9ucykpIHtcblx0XHRcdFx0YnV0dG9ucyA9XG5cdFx0XHRcdFx0YnV0dG9uc1t0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbW9kZScpXSB8fFxuXHRcdFx0XHRcdGJ1dHRvbnNbJ3NpbXBsZSddO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBidXR0b25zR3JvdXAgPSB0aGlzLmdldFRvb2xiYXJCdXR0b25Hcm91cHMoYnV0dG9ucywge1xuXHRcdFx0XHRtYW51YWxTZWxlY3Rpb246IHRoaXMucHJvcHMuZWRpdG9yRXZlbnRcblx0XHRcdFx0XHQ/IHRoaXMucHJvcHMuZWRpdG9yRXZlbnQuZGF0YS5tYW51YWxTZWxlY3Rpb25cblx0XHRcdFx0XHQ6IG51bGwsXG5cdFx0XHRcdHNlbGVjdGlvblR5cGU6IGN1cnJlbnRTZWxlY3Rpb24ubmFtZSxcblx0XHRcdH0pO1xuXG5cdFx0XHRjb25zdCBoYXNHcm91cHMgPVxuXHRcdFx0XHRidXR0b25zR3JvdXAuZmlsdGVyKGJ1dHRvbiA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkoYnV0dG9uKTtcblx0XHRcdFx0fSkubGVuZ3RoID4gMDtcblxuXHRcdFx0bGV0IGNsYXNzTmFtZSA9ICdhZS1jb250YWluZXInO1xuXG5cdFx0XHRpZiAoaGFzR3JvdXBzKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSArPSAnIGFlLWNvbnRhaW5lci1jb2x1bW4nO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5zdHlsZXN9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc2VzfVxuXHRcdFx0XHRcdGRhdGEtdGFiaW5kZXg9e3RoaXMucHJvcHMuY29uZmlnLnRhYkluZGV4IHx8IDB9XG5cdFx0XHRcdFx0b25Gb2N1cz17dGhpcy5mb2N1cy5iaW5kKHRoaXMpfVxuXHRcdFx0XHRcdG9uS2V5RG93bj17dGhpcy5oYW5kbGVLZXkuYmluZCh0aGlzKX1cblx0XHRcdFx0XHRyb2xlPVwidG9vbGJhclwiXG5cdFx0XHRcdFx0dGFiSW5kZXg9XCItMVwiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9PlxuXHRcdFx0XHRcdFx0e2J1dHRvbnNHcm91cC5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1yb3dcIiBrZXk9e2luZGV4fT5cblx0XHRcdFx0XHRcdFx0XHRcdFx0e3ZhbHVlLm1hcChidXR0b24gPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBidXR0b247XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pfVxuXHRcdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogUmV0cmlldmUgYSBmdW5jdGlvbiBmcm9tIFN0cmluZy4gSXQgY29udmVydHMgYSBmdWxseSBxdWFsaWZpZWQgc3RyaW5nIGludG8gdGhlIG1hcHBlZCBmdW5jdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG5cdCAqIEBtZXRob2QgX2dldFNlbGVjdGlvbkZ1bmN0aW9uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBzZWxlY3Rpb25GbiBBIGZ1bmN0aW9uLCBvciBhIGZ1bGx5IHF1YWxpZmllZCBzdHJpbmcgcG9pbnRpbmcgdG8gdGhlIGRlc2lyZWQgb25lIChlLmcuICdBbGxveUVkaXRvci5TZWxlY3Rpb25UZXN0LmltYWdlJykuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBtYXBwZWQgZnVuY3Rpb24uXG5cdCAqL1xuXHRfZ2V0U2VsZWN0aW9uRnVuY3Rpb24oc2VsZWN0aW9uRm4pIHtcblx0XHRsZXQgc2VsZWN0aW9uRnVuY3Rpb247XG5cblx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKHNlbGVjdGlvbkZuKSkge1xuXHRcdFx0c2VsZWN0aW9uRnVuY3Rpb24gPSBzZWxlY3Rpb25Gbjtcblx0XHR9IGVsc2UgaWYgKExhbmcuaXNTdHJpbmcoc2VsZWN0aW9uRm4pKSB7XG5cdFx0XHRjb25zdCBwYXJ0cyA9IHNlbGVjdGlvbkZuLnNwbGl0KCcuJyk7XG5cdFx0XHRsZXQgY3VycmVudE1lbWJlciA9IHdpbmRvdztcblx0XHRcdGxldCBwcm9wZXJ0eSA9IHBhcnRzLnNoaWZ0KCk7XG5cblx0XHRcdHdoaWxlIChcblx0XHRcdFx0cHJvcGVydHkgJiZcblx0XHRcdFx0TGFuZy5pc09iamVjdChjdXJyZW50TWVtYmVyKSAmJlxuXHRcdFx0XHRMYW5nLmlzT2JqZWN0KGN1cnJlbnRNZW1iZXJbcHJvcGVydHldKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGN1cnJlbnRNZW1iZXIgPSBjdXJyZW50TWVtYmVyW3Byb3BlcnR5XTtcblx0XHRcdFx0cHJvcGVydHkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKGN1cnJlbnRNZW1iZXIpKSB7XG5cdFx0XHRcdHNlbGVjdGlvbkZ1bmN0aW9uID0gY3VycmVudE1lbWJlcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc2VsZWN0aW9uRnVuY3Rpb247XG5cdH1cblxuXHQvKipcblx0ICogQW5hbHl6ZXMgdGhlIGN1cnJlbnQgZWRpdG9yIHNlbGVjdGlvbiBhbmQgcmV0dXJucyB0aGUgc2VsZWN0aW9uIGNvbmZpZ3VyYXRpb24gdGhhdCBtYXRjaGVzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFRvb2xiYXJTdHlsZXNcblx0ICogQG1ldGhvZCBfZ2V0Q3VycmVudFNlbGVjdGlvblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1hdGNoZWQgc2VsZWN0aW9uIGNvbmZpZ3VyYXRpb24uXG5cdCAqL1xuXHRfZ2V0Q3VycmVudFNlbGVjdGlvbigpIHtcblx0XHRjb25zdCBldmVudFBheWxvYWQgPSB0aGlzLnByb3BzLmVkaXRvckV2ZW50XG5cdFx0XHQ/IHRoaXMucHJvcHMuZWRpdG9yRXZlbnQuZGF0YVxuXHRcdFx0OiBudWxsO1xuXHRcdGxldCBzZWxlY3Rpb247XG5cblx0XHRpZiAoZXZlbnRQYXlsb2FkKSB7XG5cdFx0XHR0aGlzLnByb3BzLmNvbmZpZy5zZWxlY3Rpb25zLnNvbWUoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRjb25zdCB0ZXN0Rm4gPSB0aGlzLl9nZXRTZWxlY3Rpb25GdW5jdGlvbihpdGVtLnRlc3QpO1xuXHRcdFx0XHRsZXQgcmVzdWx0O1xuXG5cdFx0XHRcdGlmICh0ZXN0Rm4pIHtcblx0XHRcdFx0XHRyZXN1bHQgPVxuXHRcdFx0XHRcdFx0ZXZlbnRQYXlsb2FkLm1hbnVhbFNlbGVjdGlvbiA9PT0gaXRlbS5uYW1lIHx8XG5cdFx0XHRcdFx0XHR0ZXN0Rm4oe1xuXHRcdFx0XHRcdFx0XHRkYXRhOiBldmVudFBheWxvYWQsXG5cdFx0XHRcdFx0XHRcdGVkaXRvcjogdGhpcy5jb250ZXh0LmVkaXRvcixcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHRcdHNlbGVjdGlvbiA9IGl0ZW07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlbGVjdGlvbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGVzIGFuZCBzZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbGJhci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVBvc2l0aW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF91cGRhdGVQb3NpdGlvbigpIHtcblx0XHQvLyBJZiBjb21wb25lbnQgaXMgbm90IG1vdW50ZWQsIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG9cblx0XHRpZiAoIVJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgY3VycmVudFNlbGVjdGlvbiA9IHRoaXMuX2dldEN1cnJlbnRTZWxlY3Rpb24oKTtcblx0XHRsZXQgcmVzdWx0O1xuXG5cdFx0Ly8gSWYgY3VycmVudCBzZWxlY3Rpb24gaGFzIGEgZnVuY3Rpb24gY2FsbGVkIGBzZXRQb3NpdGlvbmAsIGNhbGwgaXRcblx0XHQvLyBhbmQgY2hlY2sgdGhlIHJldHVybmVkIHZhbHVlLiBJZiBmYWxzZSwgZmFsbGJhY2sgdG8gdGhlIGRlZmF1bHQgcG9zaXRpb25pbmcgbG9naWMuXG5cdFx0aWYgKGN1cnJlbnRTZWxlY3Rpb24pIHtcblx0XHRcdGNvbnN0IHNldFBvc2l0aW9uRm4gPSB0aGlzLl9nZXRTZWxlY3Rpb25GdW5jdGlvbihcblx0XHRcdFx0Y3VycmVudFNlbGVjdGlvbi5zZXRQb3NpdGlvblxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKHNldFBvc2l0aW9uRm4pIHtcblx0XHRcdFx0cmVzdWx0ID0gc2V0UG9zaXRpb25Gbi5jYWxsKHRoaXMsIHtcblx0XHRcdFx0XHRlZGl0b3I6IHRoaXMuY29udGV4dC5lZGl0b3IsXG5cdFx0XHRcdFx0ZWRpdG9yRXZlbnQ6IHRoaXMucHJvcHMuZWRpdG9yRXZlbnQsXG5cdFx0XHRcdFx0c2VsZWN0aW9uRGF0YTogdGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhLFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIXJlc3VsdCkge1xuXHRcdFx0dGhpcy51cGRhdGVQb3NpdGlvbigpO1xuXHRcdFx0dGhpcy5zaG93KCk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgVG9vbGJhclN0eWxlc1xuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuVG9vbGJhclN0eWxlcy5kZWZhdWx0UHJvcHMgPSB7XG5cdGNpcmN1bGFyOiB0cnVlLFxuXHRkZXNjZW5kYW50czogJy5hZS1pbnB1dCwgLmFlLWJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIC5hZS10b29sYmFyLWVsZW1lbnQnLFxuXHRrZXlzOiB7XG5cdFx0ZGlzbWlzczogWzI3XSxcblx0XHRuZXh0OiBbMzksIDQwXSxcblx0XHRwcmV2OiBbMzcsIDM4XSxcblx0fSxcbn07XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgc3R5bGVzXG4gKiBAbWVtYmVyb2YgVG9vbGJhclN0eWxlc1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5Ub29sYmFyU3R5bGVzLmtleSA9ICdzdHlsZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXREcm9wZG93bihcblx0V2lkZ2V0RXhjbHVzaXZlKFdpZGdldEZvY3VzTWFuYWdlcihUb29sYmFyQnV0dG9ucyhUb29sYmFyU3R5bGVzKSkpXG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9idXR0b25icmlkZ2UnKSkge1xuXHRjb25zdCBCVVRUT05fREVGUyA9IHt9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBCdXR0b25CcmlkZ2UgUmVhY3QgY2xhc3MgZm9yIGEgZ2l2ZW4gYnV0dG9uIGRlZmluaXRpb24gaWYgaXQgaGFzIG5vdCBiZWVuXG5cdCAqIGFscmVhZHkgY3JlYXRlZCBiYXNlZCBvbiB0aGUgYnV0dG9uIG5hbWUgYW5kIGRlZmluaXRpb24uXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBtZXRob2QgZ2VuZXJhdGVCdXR0b25CcmlkZ2Vcblx0ICogQHBhcmFtIHtTdHJpbmd9IGJ1dHRvbk5hbWUgVGhlIGJ1dHRvbidzIG5hbWVcblx0ICogQHBhcmFtIHtPYmplY3R9IGJ1dHRvbkRlZmluaXRpb24gVGhlIGJ1dHRvbidzIGRlZmluaXRpb25cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZ2VuZXJhdGVkIG9yIGFscmVhZHkgZXhpc3RpbmcgUmVhY3QgQnV0dG9uIENsYXNzXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlQnV0dG9uQnJpZGdlKGJ1dHRvbk5hbWUsIGJ1dHRvbkRlZmluaXRpb24sIGVkaXRvcikge1xuXHRcdGxldCBCdXR0b25CcmlkZ2UgPSBBbGxveUVkaXRvci5CdXR0b25zW2J1dHRvbk5hbWVdO1xuXG5cdFx0QlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdID0gQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdIHx8IHt9O1xuXHRcdEJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVtidXR0b25OYW1lXSA9XG5cdFx0XHRCVVRUT05fREVGU1tlZGl0b3IubmFtZV1bYnV0dG9uTmFtZV0gfHwgYnV0dG9uRGVmaW5pdGlvbjtcblxuXHRcdGlmICghQnV0dG9uQnJpZGdlKSB7XG5cdFx0XHRCdXR0b25CcmlkZ2UgPSBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdFx0XHRcdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0XHRcdFx0c3RhdGljIGRpc3BsYXlOYW1lID0gYnV0dG9uTmFtZTtcblxuXHRcdFx0XHRzdGF0aWMga2V5ID0gYnV0dG9uTmFtZTtcblxuXHRcdFx0XHQvLyBBUEkgbm90IHlldCBpbXBsZW1lbnRlZCBpbnNpZGUgdGhlIGJ1dHRvblxuXHRcdFx0XHQvLyBicmlkZ2UuIEJ5IG1vY2tpbmcgdGhlIHVuc3VwcG9ydGVkIG1ldGhvZCwgd2UgcHJldmVudFxuXHRcdFx0XHQvLyBwbHVnaW5zIGZyb20gY3Jhc2hpbmcgaWYgdGhleSBtYWtlIHVzZSBvZiBpdC5cblx0XHRcdFx0dG9GZWF0dXJlKCkge31cblxuXHRcdFx0XHRyZW5kZXIoKSB7XG5cdFx0XHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0XHRcdFx0Y29uc3QgYnV0dG9uQ2xhc3NOYW1lID0gJ2FlLWJ1dHRvbiBhZS1idXR0b24tYnJpZGdlJztcblxuXHRcdFx0XHRcdGNvbnN0IGJ1dHRvbkRpc3BsYXlOYW1lID1cblx0XHRcdFx0XHRcdEJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVtidXR0b25OYW1lXS5uYW1lIHx8XG5cdFx0XHRcdFx0XHRCVVRUT05fREVGU1tlZGl0b3IubmFtZV1bYnV0dG9uTmFtZV0uY29tbWFuZCB8fFxuXHRcdFx0XHRcdFx0YnV0dG9uTmFtZTtcblxuXHRcdFx0XHRcdGNvbnN0IGJ1dHRvbkxhYmVsID1cblx0XHRcdFx0XHRcdEJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVtidXR0b25OYW1lXS5sYWJlbDtcblxuXHRcdFx0XHRcdGNvbnN0IGJ1dHRvblR5cGUgPSAnYnV0dG9uLScgKyBidXR0b25EaXNwbGF5TmFtZTtcblxuXHRcdFx0XHRcdGNvbnN0IGljb25DbGFzc05hbWUgPSAnYWUtaWNvbi0nICsgYnV0dG9uRGlzcGxheU5hbWU7XG5cblx0XHRcdFx0XHRjb25zdCBpY29uU3R5bGUgPSB7fTtcblxuXHRcdFx0XHRcdGNvbnN0IGNzc1N0eWxlID0gQ0tFRElUT1Iuc2tpbi5nZXRJY29uU3R5bGUoXG5cdFx0XHRcdFx0XHRidXR0b25EaXNwbGF5TmFtZVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAoY3NzU3R5bGUpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGNzc1N0eWxlUGFydHMgPSBjc3NTdHlsZS5zcGxpdCgnOycpO1xuXG5cdFx0XHRcdFx0XHRpY29uU3R5bGUuYmFja2dyb3VuZEltYWdlID0gY3NzU3R5bGVQYXJ0c1swXS5zdWJzdHJpbmcoXG5cdFx0XHRcdFx0XHRcdGNzc1N0eWxlUGFydHNbMF0uaW5kZXhPZignOicpICsgMVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGljb25TdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSBjc3NTdHlsZVBhcnRzWzFdLnN1YnN0cmluZyhcblx0XHRcdFx0XHRcdFx0Y3NzU3R5bGVQYXJ0c1sxXS5pbmRleE9mKCc6JykgKyAxXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0aWNvblN0eWxlLmJhY2tncm91bmRTaXplID0gY3NzU3R5bGVQYXJ0c1syXS5zdWJzdHJpbmcoXG5cdFx0XHRcdFx0XHRcdGNzc1N0eWxlUGFydHNbMl0uaW5kZXhPZignOicpICsgMVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRhcmlhLWxhYmVsPXtidXR0b25MYWJlbH1cblx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXtidXR0b25DbGFzc05hbWV9XG5cdFx0XHRcdFx0XHRcdGRhdGEtdHlwZT17YnV0dG9uVHlwZX1cblx0XHRcdFx0XHRcdFx0b25DbGljaz17dGhpcy5faGFuZGxlQ2xpY2t9XG5cdFx0XHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHRcdFx0XHR0aXRsZT17YnV0dG9uTGFiZWx9PlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9e2ljb25DbGFzc05hbWV9IHN0eWxlPXtpY29uU3R5bGV9IC8+XG5cdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2hhbmRsZUNsaWNrID0gKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0XHRcdGNvbnN0IGJ1dHRvbkNvbW1hbmQgPVxuXHRcdFx0XHRcdFx0QlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW2J1dHRvbk5hbWVdLmNvbW1hbmQ7XG5cblx0XHRcdFx0XHRjb25zdCBidXR0b25PbkNsaWNrID1cblx0XHRcdFx0XHRcdEJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVtidXR0b25OYW1lXS5vbkNsaWNrO1xuXG5cdFx0XHRcdFx0aWYgKGJ1dHRvbk9uQ2xpY2spIHtcblx0XHRcdFx0XHRcdGJ1dHRvbk9uQ2xpY2suY2FsbCh0aGlzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWRpdG9yLmV4ZWNDb21tYW5kKGJ1dHRvbkNvbW1hbmQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHRcdEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uTmFtZV0gPSBCdXR0b25CcmlkZ2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIEJ1dHRvbkJyaWRnZTtcblx0fVxuXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdGlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2J1dHRvbicpKSB7XG5cdFx0Q0tFRElUT1IuVUlfQlVUVE9OID0gJ2J1dHRvbic7XG5cblx0XHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYnV0dG9uJywge30pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENLRWRpdG9yIHBsdWdpbiB0aGF0IGJyaWRnZXMgdGhlIHN1cHBvcnQgb2ZmZXJlZCBieSBDS0VkaXRvciBCdXR0b24gcGx1Z2luLiBJdCB0YWtlcyBvdmVyIHRoZVxuXHQgKiByZXNwb25zaWJpbGl0eSBvZiByZWdpc3RlcmluZyBhbmQgY3JlYXRpbmcgYnV0dG9ucyB2aWE6XG5cdCAqIC0gZWRpdG9yLnVpLmFkZEJ1dHRvbihuYW1lLCBkZWZpbml0aW9uKVxuXHQgKiAtIGVkaXRvci51aS5hZGQobmFtZSwgQ0tFRElUT1IuVUlfQlVUVE9OLCBkZWZpbml0aW9uKVxuXHQgKlxuXHQgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9idXR0b25icmlkZ2Vcblx0ICogQHJlcXVpcmVzIENLRURJVE9SLnBsdWdpbnMuYWVfdWlicmlkZ2Vcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfYnV0dG9uYnJpZGdlJywge1xuXHRcdHJlcXVpcmVzOiBbJ2FlX3VpYnJpZGdlJ10sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIGFkZCBoYW5kbGVyIGZvciBVSV9CVVRUT04gdG8gb3VyIG93bi4gV2UgZG8gdGhpcyBpbiB0aGUgaW5pdCBwaGFzZSB0byBvdmVycmlkZVxuXHRcdCAqIHRoZSBvbmUgaW4gdGhlIG5hdGl2ZSBwbHVnaW4gaW4gY2FzZSBpdCdzIHByZXNlbnQuXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIGluaXRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBDS0VkaXRvciBpbnN0YW5jZSBiZWluZyBpbml0aWFsaXplZFxuXHRcdCAqL1xuXHRcdGJlZm9yZUluaXQoZWRpdG9yKSB7XG5cdFx0XHRlZGl0b3IudWkuYWRkQnV0dG9uID0gZnVuY3Rpb24oYnV0dG9uTmFtZSwgYnV0dG9uRGVmaW5pdGlvbikge1xuXHRcdFx0XHR0aGlzLmFkZChidXR0b25OYW1lLCBDS0VESVRPUi5VSV9CVVRUT04sIGJ1dHRvbkRlZmluaXRpb24pO1xuXHRcdFx0fTtcblxuXHRcdFx0ZWRpdG9yLnVpLmFkZEhhbmRsZXIoQ0tFRElUT1IuVUlfQlVUVE9OLCB7XG5cdFx0XHRcdGFkZDogZ2VuZXJhdGVCdXR0b25CcmlkZ2UsXG5cdFx0XHRcdGNyZWF0ZShidXR0b25EZWZpbml0aW9uKSB7XG5cdFx0XHRcdFx0Y29uc3QgYnV0dG9uTmFtZSA9XG5cdFx0XHRcdFx0XHQnYnV0dG9uQnJpZGdlJyArICgoTWF0aC5yYW5kb20oKSAqIDFlOSkgPj4+IDApO1xuXHRcdFx0XHRcdGNvbnN0IEJ1dHRvbkJyaWRnZSA9IGdlbmVyYXRlQnV0dG9uQnJpZGdlKFxuXHRcdFx0XHRcdFx0YnV0dG9uTmFtZSxcblx0XHRcdFx0XHRcdGJ1dHRvbkRlZmluaXRpb25cblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBCdXR0b25CcmlkZ2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXHRcdH0sXG5cdH0pO1xufVxuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgJy4vYnV0dG9uLmpzeCc7XG5cbmltcG9ydCAnLi9tZW51LWJ1dHRvbi5qc3gnO1xuXG5pbXBvcnQgJy4vbWVudS5qc3gnO1xuXG5pbXBvcnQgJy4vcGFuZWwtbWVudS1idXR0b24uanN4JztcblxuaW1wb3J0ICcuL3JpY2hjb21iby5qc3gnO1xuXG5pbXBvcnQgJy4vdWlicmlkZ2UnO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBCdXR0b25Ecm9wZG93biBmcm9tICcuLi9idXR0b25zL2J1dHRvbi1kcm9wZG93bi5qc3gnO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX21lbnVidXR0b25icmlkZ2UnKSkge1xuXHRjb25zdCBNRU5VQlVUVE9OX0RFRlMgPSB7fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGVzIGEgTWVudUJ1dHRvbkJyaWRnZSBSZWFjdCBjbGFzcyBmb3IgYSBnaXZlbiBtZW51QnV0dG9uIGRlZmluaXRpb24gaWYgaXQgaGFzIG5vdCBiZWVuXG5cdCAqIGFscmVhZHkgY3JlYXRlZCBiYXNlZCBvbiB0aGUgYnV0dG9uIG5hbWUgYW5kIGRlZmluaXRpb24uXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBtZXRob2QgZ2VuZXJhdGVNZW51QnV0dG9uQnJpZGdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBtZW51QnV0dG9uTmFtZSBUaGUgbWVudUJ1dHRvbidzIG5hbWVcblx0ICogQHBhcmFtIHtPYmplY3R9IG1lbnVCdXR0b25EZWZpbml0aW9uIFRoZSBtZW51QnV0dG9uJ3MgZGVmaW5pdGlvblxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBnZW5lcmF0ZWQgb3IgYWxyZWFkeSBleGlzdGluZyBSZWFjdCBNZW51QnV0dG9uIENsYXNzXG5cdCAqL1xuXHRmdW5jdGlvbiBnZW5lcmF0ZU1lbnVCdXR0b25CcmlkZ2UoXG5cdFx0bWVudUJ1dHRvbk5hbWUsXG5cdFx0bWVudUJ1dHRvbkRlZmluaXRpb24sXG5cdFx0ZWRpdG9yXG5cdCkge1xuXHRcdGxldCBNZW51QnV0dG9uQnJpZGdlID0gQWxsb3lFZGl0b3IuQnV0dG9uc1ttZW51QnV0dG9uTmFtZV07XG5cblx0XHRNRU5VQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdID0gTUVOVUJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXSB8fCB7fTtcblx0XHRNRU5VQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW21lbnVCdXR0b25OYW1lXSA9XG5cdFx0XHRNRU5VQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW21lbnVCdXR0b25OYW1lXSB8fFxuXHRcdFx0bWVudUJ1dHRvbkRlZmluaXRpb247XG5cblx0XHRpZiAoIU1lbnVCdXR0b25CcmlkZ2UpIHtcblx0XHRcdE1lbnVCdXR0b25CcmlkZ2UgPSBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdFx0XHRcdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0XHRcdFx0c3RhdGljIGRpc3BsYXlOYW1lID0gbWVudUJ1dHRvbk5hbWU7XG5cblx0XHRcdFx0c3RhdGljIGtleSA9IG1lbnVCdXR0b25OYW1lO1xuXG5cdFx0XHRcdC8vIEFQSSBub3QgeWV0IGltcGxlbWVudGVkIGluc2lkZSB0aGUgbWVudWJ1dHRvblxuXHRcdFx0XHQvLyBicmlkZ2UuIEJ5IG1vY2tpbmcgdGhlIHVuc3VwcG9ydGVkIG1ldGhvZCwgd2UgcHJldmVudFxuXHRcdFx0XHQvLyBwbHVnaW5zIGZyb20gY3Jhc2hpbmcgaWYgdGhleSBtYWtlIHVzZSBvZiBpdC5cblx0XHRcdFx0dG9GZWF0dXJlKCkge31cblxuXHRcdFx0XHRyZW5kZXIoKSB7XG5cdFx0XHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0XHRcdFx0Y29uc3QgcGFuZWxNZW51QnV0dG9uRGlzcGxheU5hbWUgPVxuXHRcdFx0XHRcdFx0TUVOVUJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVttZW51QnV0dG9uTmFtZV0ubmFtZSB8fFxuXHRcdFx0XHRcdFx0TUVOVUJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVttZW51QnV0dG9uTmFtZV0uY29tbWFuZCB8fFxuXHRcdFx0XHRcdFx0bWVudUJ1dHRvbk5hbWU7XG5cblx0XHRcdFx0XHRjb25zdCBidXR0b25DbGFzc05hbWUgPSAnYWUtYnV0dG9uIGFlLWJ1dHRvbi1icmlkZ2UnO1xuXG5cdFx0XHRcdFx0Y29uc3QgaWNvbkNsYXNzTmFtZSA9XG5cdFx0XHRcdFx0XHQnYWUtaWNvbi0nICsgcGFuZWxNZW51QnV0dG9uRGlzcGxheU5hbWU7XG5cblx0XHRcdFx0XHRjb25zdCBpY29uU3R5bGUgPSB7fTtcblxuXHRcdFx0XHRcdGNvbnN0IGNzc1N0eWxlID0gQ0tFRElUT1Iuc2tpbi5nZXRJY29uU3R5bGUoXG5cdFx0XHRcdFx0XHRwYW5lbE1lbnVCdXR0b25EaXNwbGF5TmFtZVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAoY3NzU3R5bGUpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGNzc1N0eWxlUGFydHMgPSBjc3NTdHlsZS5zcGxpdCgnOycpO1xuXG5cdFx0XHRcdFx0XHRpY29uU3R5bGUuYmFja2dyb3VuZEltYWdlID0gY3NzU3R5bGVQYXJ0c1swXS5zdWJzdHJpbmcoXG5cdFx0XHRcdFx0XHRcdGNzc1N0eWxlUGFydHNbMF0uaW5kZXhPZignOicpICsgMVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGljb25TdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSBjc3NTdHlsZVBhcnRzWzFdLnN1YnN0cmluZyhcblx0XHRcdFx0XHRcdFx0Y3NzU3R5bGVQYXJ0c1sxXS5pbmRleE9mKCc6JykgKyAxXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0aWNvblN0eWxlLmJhY2tncm91bmRTaXplID0gY3NzU3R5bGVQYXJ0c1syXS5zdWJzdHJpbmcoXG5cdFx0XHRcdFx0XHRcdGNzc1N0eWxlUGFydHNbMl0uaW5kZXhPZignOicpICsgMVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXIgYWUtaGFzLWRyb3Bkb3duXCI+XG5cdFx0XHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdFx0XHRhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfVxuXHRcdFx0XHRcdFx0XHRcdGFyaWEtbGFiZWw9e1xuXHRcdFx0XHRcdFx0XHRcdFx0TUVOVUJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVttZW51QnV0dG9uTmFtZV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0LmxhYmVsXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17YnV0dG9uQ2xhc3NOYW1lfVxuXHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259XG5cdFx0XHRcdFx0XHRcdFx0cm9sZT1cImNvbWJvYm94XCJcblx0XHRcdFx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHRcdFx0XHR0aXRsZT17XG5cdFx0XHRcdFx0XHRcdFx0XHRNRU5VQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW21lbnVCdXR0b25OYW1lXVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQubGFiZWxcblx0XHRcdFx0XHRcdFx0XHR9PlxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9e2ljb25DbGFzc05hbWV9XG5cdFx0XHRcdFx0XHRcdFx0XHRzdHlsZT17aWNvblN0eWxlfVxuXHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHRcdFx0XHR7dGhpcy5wcm9wcy5leHBhbmRlZCAmJiAoXG5cdFx0XHRcdFx0XHRcdFx0PEJ1dHRvbkRyb3Bkb3duXG5cdFx0XHRcdFx0XHRcdFx0XHRvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259PlxuXHRcdFx0XHRcdFx0XHRcdFx0e3RoaXMuX2dldE1lbnVJdGVtcygpfVxuXHRcdFx0XHRcdFx0XHRcdDwvQnV0dG9uRHJvcGRvd24+XG5cdFx0XHRcdFx0XHRcdCl9XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2dldE1lbnVJdGVtcygpIHtcblx0XHRcdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdFx0XHRcdFx0Y29uc3QgaXRlbXMgPSBtZW51QnV0dG9uRGVmaW5pdGlvbi5vbk1lbnUoKTtcblx0XHRcdFx0XHRjb25zdCBtZW51SXRlbXMgPSBPYmplY3Qua2V5cyhpdGVtcykubWFwKGtleSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBtZW51SXRlbSA9IGVkaXRvci5nZXRNZW51SXRlbShrZXkpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIW1lbnVJdGVtKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb25zdCBtZW51SXRlbURlZmluaXRpb24gPVxuXHRcdFx0XHRcdFx0XHRtZW51SXRlbS5kZWZpbml0aW9uIHx8IG1lbnVJdGVtO1xuXHRcdFx0XHRcdFx0Y29uc3QgbWVudUl0ZW1TdGF0ZSA9IGl0ZW1zW2tleV07XG5cblx0XHRcdFx0XHRcdGNvbnN0IGNsYXNzTmFtZSA9XG5cdFx0XHRcdFx0XHRcdCdhZS10b29sYmFyLWVsZW1lbnQgJyArXG5cdFx0XHRcdFx0XHRcdChtZW51SXRlbVN0YXRlID09PSBDS0VESVRPUi5UUklTVEFURV9PTlxuXHRcdFx0XHRcdFx0XHRcdD8gJ2FjdGl2ZSdcblx0XHRcdFx0XHRcdFx0XHQ6ICcnKTtcblx0XHRcdFx0XHRcdGNvbnN0IGRpc2FibGVkID1cblx0XHRcdFx0XHRcdFx0bWVudUl0ZW1TdGF0ZSA9PT0gQ0tFRElUT1IuVFJJU1RBVEVfRElTQUJMRUQ7XG5cdFx0XHRcdFx0XHRjb25zdCBvbkNsaWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChtZW51SXRlbURlZmluaXRpb24uY29tbWFuZCkge1xuXHRcdFx0XHRcdFx0XHRcdGVkaXRvci5leGVjQ29tbWFuZChtZW51SXRlbURlZmluaXRpb24uY29tbWFuZCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobWVudUl0ZW1EZWZpbml0aW9uLm9uQ2xpY2spIHtcblx0XHRcdFx0XHRcdFx0XHRtZW51SXRlbURlZmluaXRpb24ub25DbGljay5hcHBseShcblx0XHRcdFx0XHRcdFx0XHRcdG1lbnVJdGVtRGVmaW5pdGlvblxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRcdDxsaSBrZXk9e21lbnVJdGVtLm5hbWV9IHJvbGU9XCJvcHRpb25cIj5cblx0XHRcdFx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzTmFtZX1cblx0XHRcdFx0XHRcdFx0XHRcdGRpc2FibGVkPXtkaXNhYmxlZH1cblx0XHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9e29uQ2xpY2t9PlxuXHRcdFx0XHRcdFx0XHRcdFx0e21lbnVJdGVtRGVmaW5pdGlvbi5sYWJlbH1cblx0XHRcdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRyZXR1cm4gbWVudUl0ZW1zO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRBbGxveUVkaXRvci5CdXR0b25zW21lbnVCdXR0b25OYW1lXSA9IE1lbnVCdXR0b25CcmlkZ2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIE1lbnVCdXR0b25CcmlkZ2U7XG5cdH1cblxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXHRpZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdtZW51YnV0dG9uJykpIHtcblx0XHRDS0VESVRPUi5VSV9NRU5VX0JVVFRPTiA9ICdtZW51YnV0dG9uJztcblxuXHRcdENLRURJVE9SLnBsdWdpbnMuYWRkKCdtZW51YnV0dG9uJywge30pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENLRWRpdG9yIHBsdWdpbiB0aGF0IGJyaWRnZXMgdGhlIHN1cHBvcnQgb2ZmZXJlZCBieSBDS0VkaXRvciBNZW51QnV0dG9uIHBsdWdpbi4gSXQgdGFrZXMgb3ZlciB0aGVcblx0ICogcmVzcG9uc2liaWxpdHkgb2YgcmVnaXN0ZXJpbmcgYW5kIGNyZWF0aW5nIG1lbnVCdXR0b25zIHZpYTpcblx0ICogLSBlZGl0b3IudWkuYWRkTWVudUJ1dHRvbihuYW1lLCBkZWZpbml0aW9uKVxuXHQgKiAtIGVkaXRvci51aS5hZGQobmFtZSwgQ0tFRElUT1IuVUlfTUVOVUJVVFRPTiwgZGVmaW5pdGlvbilcblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfbWVudWJ1dHRvbmJyaWRnZVxuXHQgKiBAcmVxdWlyZXMgQ0tFRElUT1IucGx1Z2lucy5hZV91aWJyaWRnZVxuXHQgKiBAcmVxdWlyZXMgQ0tFRElUT1IucGx1Z2lucy5hZV9tZW51YnJpZGdlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX21lbnVidXR0b25icmlkZ2UnLCB7XG5cdFx0cmVxdWlyZXM6IFsnYWVfdWlicmlkZ2UnLCAnYWVfbWVudWJyaWRnZSddLFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBhZGQgaGFuZGxlciBmb3IgVUlfTUVOVUJVVFRPTiB0byBvdXIgb3duLiBXZSBkbyB0aGlzIGluIHRoZSBpbml0IHBoYXNlIHRvIG92ZXJyaWRlXG5cdFx0ICogdGhlIG9uZSBpbiB0aGUgbmF0aXZlIHBsdWdpbiBpbiBjYXNlIGl0J3MgcHJlc2VudC5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgaW5pdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIENLRWRpdG9yIGluc3RhbmNlIGJlaW5nIGluaXRpYWxpemVkXG5cdFx0ICovXG5cdFx0YmVmb3JlSW5pdChlZGl0b3IpIHtcblx0XHRcdGVkaXRvci51aS5hZGRNZW51QnV0dG9uID0gZnVuY3Rpb24oXG5cdFx0XHRcdG1lbnVCdXR0b25OYW1lLFxuXHRcdFx0XHRtZW51QnV0dG9uRGVmaW5pdGlvblxuXHRcdFx0KSB7XG5cdFx0XHRcdHRoaXMuYWRkKFxuXHRcdFx0XHRcdG1lbnVCdXR0b25OYW1lLFxuXHRcdFx0XHRcdENLRURJVE9SLlVJX01FTlVCVVRUT04sXG5cdFx0XHRcdFx0bWVudUJ1dHRvbkRlZmluaXRpb25cblx0XHRcdFx0KTtcblx0XHRcdH07XG5cblx0XHRcdGVkaXRvci51aS5hZGRIYW5kbGVyKENLRURJVE9SLlVJX01FTlVCVVRUT04sIHtcblx0XHRcdFx0YWRkOiBnZW5lcmF0ZU1lbnVCdXR0b25CcmlkZ2UsXG5cdFx0XHRcdGNyZWF0ZShtZW51QnV0dG9uRGVmaW5pdGlvbikge1xuXHRcdFx0XHRcdGNvbnN0IG1lbnVCdXR0b25OYW1lID1cblx0XHRcdFx0XHRcdCdidXR0b25CcmlkZ2UnICsgKChNYXRoLnJhbmRvbSgpICogMWU5KSA+Pj4gMCk7XG5cdFx0XHRcdFx0Y29uc3QgTWVudUJ1dHRvbkJyaWRnZSA9IGdlbmVyYXRlTWVudUJ1dHRvbkJyaWRnZShcblx0XHRcdFx0XHRcdG1lbnVCdXR0b25OYW1lLFxuXHRcdFx0XHRcdFx0bWVudUJ1dHRvbkRlZmluaXRpb25cblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBNZW51QnV0dG9uQnJpZGdlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblx0XHR9LFxuXHR9KTtcbn1cbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9tZW51YnJpZGdlJykpIHtcblx0LyoqXG5cdCAqIENLRWRpdG9yIHBsdWdpbiB0aGF0IGJyaWRnZXMgdGhlIHN1cHBvcnQgb2ZmZXJlZCBieSBDS0VkaXRvciBNZW51IHBsdWdpbi4gSXQgdGFrZXMgb3ZlciB0aGVcblx0ICogcmVzcG9uc2liaWxpdHkgb2YgYWRkaW5nLCByZW1vdmluZyBhbmQgcmV0cmlldmluZyBtZW51IGdyb3VwcyBhbmQgaXRlbXNcblx0ICogLSBlZGl0b3IuYWRkTWVudUdyb3VwKG5hbWUsIG9yZGVyKVxuXHQgKiAtIGVkaXRvci5hZGRNZW51SXRlbShuYW1lLCBkZWZpbml0aW9uKVxuXHQgKiAtIGVkaXRvci5hZGRNZW51SXRlbXMoZGVmaW5pdGlvbnMpXG5cdCAqIC0gZWRpdG9yLmdldE1lbnVJdGVtKG5hbWUpXG5cdCAqIC0gZWRpdG9yLnJlbW92ZU1lbnVJdGVtKG5hbWUpXG5cdCAqXG5cdCAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX21lbnVicmlkZ2Vcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfbWVudWJyaWRnZScsIHtcblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIGFkZCBoYW5kbGVyIGZvciBVSV9CVVRUT04gdG8gb3VyIG93bi4gV2UgZG8gdGhpcyBpbiB0aGUgaW5pdCBwaGFzZSB0byBvdmVycmlkZVxuXHRcdCAqIHRoZSBvbmUgaW4gdGhlIG5hdGl2ZSBwbHVnaW4gaW4gY2FzZSBpdCdzIHByZXNlbnQuXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIGluaXRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBDS0VkaXRvciBpbnN0YW5jZSBiZWluZyBpbml0aWFsaXplZFxuXHRcdCAqL1xuXHRcdGJlZm9yZUluaXQoZWRpdG9yKSB7XG5cdFx0XHQvLyBEbyBub3RoaW5nIGlmIHRoZSByZWFsIG1lbnUgcGx1Z2luIGlzIHByZXNlbnRcblx0XHRcdGlmIChDS0VESVRPUi5wbHVnaW5zLmdldCgnbWVudScpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZ3JvdXBzID0gW107XG5cdFx0XHRjb25zdCBncm91cHNPcmRlciA9IChlZGl0b3IuXy5tZW51R3JvdXBzID0ge30pO1xuXHRcdFx0Y29uc3QgbWVudUl0ZW1zID0gKGVkaXRvci5fLm1lbnVJdGVtcyA9IHt9KTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Z3JvdXBzT3JkZXJbZ3JvdXBzW2ldXSA9IGkgKyAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJlZ2lzdGVycyBhbiBpdGVtIGdyb3VwIHRvIHRoZSBlZGl0b3IgY29udGV4dCBtZW51IGluIG9yZGVyIHRvIG1ha2UgaXRcblx0XHRcdCAqIHBvc3NpYmxlIHRvIGFzc29jaWF0ZSBpdCB3aXRoIG1lbnUgaXRlbXMgbGF0ZXIuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1ldGhvZCBhZGRNZW51R3JvdXBcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFNwZWNpZnkgYSBncm91cCBuYW1lLlxuXHRcdFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcmRlcj0xMDBdIERlZmluZSB0aGUgZGlzcGxheSBzZXF1ZW5jZSBvZiB0aGlzIGdyb3VwXG5cdFx0XHQgKiBpbnNpZGUgdGhlIG1lbnUuIEEgc21hbGxlciB2YWx1ZSBnZXRzIGRpc3BsYXllZCBmaXJzdC5cblx0XHRcdCAqL1xuXHRcdFx0ZWRpdG9yLmFkZE1lbnVHcm91cCA9IGZ1bmN0aW9uKG5hbWUsIG9yZGVyKSB7XG5cdFx0XHRcdGdyb3Vwc09yZGVyW25hbWVdID0gb3JkZXIgfHwgMTAwO1xuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBZGRzIGFuIGl0ZW0gZnJvbSB0aGUgc3BlY2lmaWVkIGRlZmluaXRpb24gdG8gdGhlIGVkaXRvciBjb250ZXh0IG1lbnUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1ldGhvZCBhZGRNZW51SXRlbVxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG1lbnUgaXRlbSBuYW1lLlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGRlZmluaXRpb24gVGhlIG1lbnUgaXRlbSBkZWZpbml0aW9uLlxuXHRcdFx0ICovXG5cdFx0XHRlZGl0b3IuYWRkTWVudUl0ZW0gPSBmdW5jdGlvbihuYW1lLCBkZWZpbml0aW9uKSB7XG5cdFx0XHRcdGlmIChncm91cHNPcmRlcltkZWZpbml0aW9uLmdyb3VwXSkge1xuXHRcdFx0XHRcdG1lbnVJdGVtc1tuYW1lXSA9IHtcblx0XHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0XHRkZWZpbml0aW9uLFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQWRkcyBvbmUgb3IgbW9yZSBpdGVtcyBmcm9tIHRoZSBzcGVjaWZpZWQgZGVmaW5pdGlvbiBvYmplY3QgdG8gdGhlIGVkaXRvciBjb250ZXh0IG1lbnUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1ldGhvZCBhZGRNZW51SXRlbXNcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbml0aW9ucyBPYmplY3Qgd2hlcmUga2V5cyBhcmUgdXNlZCBhcyBpdGVtTmFtZSBhbmQgY29ycmVzcG9uZGluZyB2YWx1ZXMgYXMgZGVmaW5pdGlvbiBmb3IgYSB7QGxpbmsgI2FkZE1lbnVJdGVtfSBjYWxsLlxuXHRcdFx0ICovXG5cdFx0XHRlZGl0b3IuYWRkTWVudUl0ZW1zID0gZnVuY3Rpb24oZGVmaW5pdGlvbnMpIHtcblx0XHRcdFx0Zm9yIChjb25zdCBpdGVtTmFtZSBpbiBkZWZpbml0aW9ucykge1xuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcblx0XHRcdFx0XHRcdFx0ZGVmaW5pdGlvbnMsXG5cdFx0XHRcdFx0XHRcdGl0ZW1OYW1lXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHR0aGlzLmFkZE1lbnVJdGVtKGl0ZW1OYW1lLCBkZWZpbml0aW9uc1tpdGVtTmFtZV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXRyaWV2ZXMgYSBwYXJ0aWN1bGFyIG1lbnUgaXRlbSBkZWZpbml0aW9uIGZyb20gdGhlIGVkaXRvciBjb250ZXh0IG1lbnUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1ldGhvZCBnZXRNZW51SXRlbVxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlc2lyZWQgbWVudSBpdGVtLlxuXHRcdFx0ICogQHJldHVybiB7T2JqZWN0fVxuXHRcdFx0ICovXG5cdFx0XHRlZGl0b3IuZ2V0TWVudUl0ZW0gPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRcdHJldHVybiBtZW51SXRlbXNbbmFtZV07XG5cdFx0XHR9O1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJlbW92ZXMgYSBwYXJ0aWN1bGFyIG1lbnUgaXRlbSBhZGRlZCBiZWZvcmUgZnJvbSB0aGUgZWRpdG9yIGNvbnRleHQgbWVudS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWV0aG9kICByZW1vdmVNZW51SXRlbVxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlc2lyZWQgbWVudSBpdGVtLlxuXHRcdFx0ICovXG5cdFx0XHRlZGl0b3IucmVtb3ZlTWVudUl0ZW0gPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRcdGRlbGV0ZSBtZW51SXRlbXNbbmFtZV07XG5cdFx0XHR9O1xuXHRcdH0sXG5cdH0pO1xufVxuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBCdXR0b25Ecm9wZG93biBmcm9tICcuLi9idXR0b25zL2J1dHRvbi1kcm9wZG93bi5qc3gnO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3BhbmVsbWVudWJ1dHRvbmJyaWRnZScpKSB7XG5cdGNvbnN0IFBBTkVMX01FTlVfREVGUyA9IHt9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBQYW5lbE1lbnVCdXR0b25CcmlkZ2UgUmVhY3QgY2xhc3MgZm9yIGEgZ2l2ZW4gcGFuZWxtZW51YnV0dG9uIGRlZmluaXRpb24gaWYgaXQgaGFzIG5vdCBiZWVuXG5cdCAqIGFscmVhZHkgY3JlYXRlZCBiYXNlZCBvbiB0aGUgcGFuZWxtZW51YnV0dG9uIG5hbWUgYW5kIGRlZmluaXRpb24uXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBtZXRob2QgZ2VuZXJhdGVQYW5lbE1lbnVCdXR0b25CcmlkZ2Vcblx0ICogQHBhcmFtIHtTdHJpbmd9IHBhbmVsTWVudUJ1dHRvbk5hbWUgVGhlIHBhbmVsIGJ1dHRvbiBuYW1lXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYW5lbE1lbnVCdXR0b25EZWZpbml0aW9uIFRoZSBwYW5lbCBidXR0b24gZGVmaW5pdGlvblxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBnZW5lcmF0ZWQgb3IgYWxyZWFkeSBleGlzdGluZyBSZWFjdCBQYW5lbE1lbnVCdXR0b24gQ2xhc3Ncblx0ICovXG5cdGNvbnN0IGdlbmVyYXRlUGFuZWxNZW51QnV0dG9uQnJpZGdlID0gZnVuY3Rpb24oXG5cdFx0cGFuZWxNZW51QnV0dG9uTmFtZSxcblx0XHRwYW5lbE1lbnVCdXR0b25EZWZpbml0aW9uLFxuXHRcdGVkaXRvclxuXHQpIHtcblx0XHRsZXQgUGFuZWxNZW51QnV0dG9uQnJpZGdlID0gQWxsb3lFZGl0b3IuQnV0dG9uc1twYW5lbE1lbnVCdXR0b25OYW1lXTtcblxuXHRcdFBBTkVMX01FTlVfREVGU1tlZGl0b3IubmFtZV0gPSBQQU5FTF9NRU5VX0RFRlNbZWRpdG9yLm5hbWVdIHx8IHt9O1xuXHRcdFBBTkVMX01FTlVfREVGU1tlZGl0b3IubmFtZV1bcGFuZWxNZW51QnV0dG9uTmFtZV0gPVxuXHRcdFx0UEFORUxfTUVOVV9ERUZTW2VkaXRvci5uYW1lXVtwYW5lbE1lbnVCdXR0b25OYW1lXSB8fFxuXHRcdFx0cGFuZWxNZW51QnV0dG9uRGVmaW5pdGlvbjtcblxuXHRcdGlmICghUGFuZWxNZW51QnV0dG9uQnJpZGdlKSB7XG5cdFx0XHRQYW5lbE1lbnVCdXR0b25CcmlkZ2UgPSBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdFx0XHRcdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0XHRcdFx0c3RhdGljIGRpc3BsYXlOYW1lID0gcGFuZWxNZW51QnV0dG9uTmFtZTtcblxuXHRcdFx0XHRzdGF0aWMga2V5ID0gcGFuZWxNZW51QnV0dG9uTmFtZTtcblxuXHRcdFx0XHQvLyBBUEkgbm90IHlldCBpbXBsZW1lbnRlZCBpbnNpZGUgdGhlIHBhbmVsIG1lbnUgYnV0dG9uIGJyaWRnZS4gQnkgbW9ja2luZyB0aGUgdW5zdXBwb3J0ZWQgbWV0aG9kcywgd2Vcblx0XHRcdFx0Ly8gcHJldmVudCBwbHVnaW5zIGZyb20gY3Jhc2hpbmcgaWYgdGhleSBtYWtlIHVzZSBvZiB0aGVtLlxuXHRcdFx0XHRjcmVhdGVQYW5lbCgpIHt9XG5cblx0XHRcdFx0cmVuZGVyKCkge1xuXHRcdFx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0XHRcdGNvbnN0IHBhbmVsTWVudUJ1dHRvbkRpc3BsYXlOYW1lID1cblx0XHRcdFx0XHRcdFBBTkVMX01FTlVfREVGU1tlZGl0b3IubmFtZV1bcGFuZWxNZW51QnV0dG9uTmFtZV1cblx0XHRcdFx0XHRcdFx0Lm5hbWUgfHxcblx0XHRcdFx0XHRcdFBBTkVMX01FTlVfREVGU1tlZGl0b3IubmFtZV1bcGFuZWxNZW51QnV0dG9uTmFtZV1cblx0XHRcdFx0XHRcdFx0LmNvbW1hbmQgfHxcblx0XHRcdFx0XHRcdHBhbmVsTWVudUJ1dHRvbk5hbWU7XG5cblx0XHRcdFx0XHRjb25zdCBidXR0b25DbGFzc05hbWUgPSAnYWUtYnV0dG9uIGFlLWJ1dHRvbi1icmlkZ2UnO1xuXG5cdFx0XHRcdFx0Y29uc3QgaWNvbkNsYXNzTmFtZSA9XG5cdFx0XHRcdFx0XHQnYWUtaWNvbi0nICsgcGFuZWxNZW51QnV0dG9uRGlzcGxheU5hbWU7XG5cblx0XHRcdFx0XHRjb25zdCBpY29uU3R5bGUgPSB7fTtcblxuXHRcdFx0XHRcdGNvbnN0IGNzc1N0eWxlID0gQ0tFRElUT1Iuc2tpbi5nZXRJY29uU3R5bGUoXG5cdFx0XHRcdFx0XHRwYW5lbE1lbnVCdXR0b25EaXNwbGF5TmFtZVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAoY3NzU3R5bGUpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGNzc1N0eWxlUGFydHMgPSBjc3NTdHlsZS5zcGxpdCgnOycpO1xuXG5cdFx0XHRcdFx0XHRpY29uU3R5bGUuYmFja2dyb3VuZEltYWdlID0gY3NzU3R5bGVQYXJ0c1swXS5zdWJzdHJpbmcoXG5cdFx0XHRcdFx0XHRcdGNzc1N0eWxlUGFydHNbMF0uaW5kZXhPZignOicpICsgMVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGljb25TdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSBjc3NTdHlsZVBhcnRzWzFdLnN1YnN0cmluZyhcblx0XHRcdFx0XHRcdFx0Y3NzU3R5bGVQYXJ0c1sxXS5pbmRleE9mKCc6JykgKyAxXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0aWNvblN0eWxlLmJhY2tncm91bmRTaXplID0gY3NzU3R5bGVQYXJ0c1syXS5zdWJzdHJpbmcoXG5cdFx0XHRcdFx0XHRcdGNzc1N0eWxlUGFydHNbMl0uaW5kZXhPZignOicpICsgMVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsZXQgcGFuZWw7XG5cblx0XHRcdFx0XHRpZiAodGhpcy5wcm9wcy5leHBhbmRlZCkge1xuXHRcdFx0XHRcdFx0cGFuZWwgPSB0aGlzLl9nZXRQYW5lbCgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lciBhZS1oYXMtZHJvcGRvd25cIj5cblx0XHRcdFx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRcdGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9XG5cdFx0XHRcdFx0XHRcdFx0YXJpYS1sYWJlbD17XG5cdFx0XHRcdFx0XHRcdFx0XHRQQU5FTF9NRU5VX0RFRlNbZWRpdG9yLm5hbWVdW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYW5lbE1lbnVCdXR0b25OYW1lXG5cdFx0XHRcdFx0XHRcdFx0XHRdLmxhYmVsXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17YnV0dG9uQ2xhc3NOYW1lfVxuXHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259XG5cdFx0XHRcdFx0XHRcdFx0cm9sZT1cImNvbWJvYm94XCJcblx0XHRcdFx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHRcdFx0XHR0aXRsZT17XG5cdFx0XHRcdFx0XHRcdFx0XHRQQU5FTF9NRU5VX0RFRlNbZWRpdG9yLm5hbWVdW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYW5lbE1lbnVCdXR0b25OYW1lXG5cdFx0XHRcdFx0XHRcdFx0XHRdLmxhYmVsXG5cdFx0XHRcdFx0XHRcdFx0fT5cblx0XHRcdFx0XHRcdFx0XHQ8c3BhblxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXtpY29uQ2xhc3NOYW1lfVxuXHRcdFx0XHRcdFx0XHRcdFx0c3R5bGU9e2ljb25TdHlsZX1cblx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHRcdFx0e3BhbmVsfVxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nZXRQYW5lbCgpIHtcblx0XHRcdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdFx0XHRjb25zdCBwYW5lbE1lbnVCdXR0b25PbkJsb2NrID1cblx0XHRcdFx0XHRcdFBBTkVMX01FTlVfREVGU1tlZGl0b3IubmFtZV1bcGFuZWxNZW51QnV0dG9uTmFtZV1cblx0XHRcdFx0XHRcdFx0Lm9uQmxvY2s7XG5cblx0XHRcdFx0XHRjb25zdCBwYW5lbCA9IHtcblx0XHRcdFx0XHRcdGhpZGU6IHRoaXMucHJvcHMudG9nZ2xlRHJvcGRvd24sXG5cdFx0XHRcdFx0XHRzaG93OiB0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3duLFxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRjb25zdCBibG9ja0VsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoJ2RpdicpO1xuXG5cdFx0XHRcdFx0Y29uc3QgYmxvY2sgPSB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiBibG9ja0VsZW1lbnQsXG5cdFx0XHRcdFx0XHRrZXlzOiB7fSxcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0XHRcdFx0XHRpZiAocGFuZWxNZW51QnV0dG9uT25CbG9jaykge1xuXHRcdFx0XHRcdFx0cGFuZWxNZW51QnV0dG9uT25CbG9jay5jYWxsKHRoaXMsIHBhbmVsLCBibG9jayk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gVE9ET1xuXHRcdFx0XHRcdC8vIFVzZSBibG9jay5rZXlzIHRvIGNvbmZpZ3VyZSB0aGUgcGFuZWwga2V5Ym9hcmQgbmF2aWdhdGlvblxuXG5cdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdDxCdXR0b25Ecm9wZG93biBvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259PlxuXHRcdFx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXtibG9ja0VsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpfVxuXHRcdFx0XHRcdFx0XHRcdGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7XG5cdFx0XHRcdFx0XHRcdFx0XHRfX2h0bWw6IGJsb2NrRWxlbWVudC5nZXRIdG1sKCksXG5cdFx0XHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdDwvQnV0dG9uRHJvcGRvd24+XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0QWxsb3lFZGl0b3IuQnV0dG9uc1twYW5lbE1lbnVCdXR0b25OYW1lXSA9IFBhbmVsTWVudUJ1dHRvbkJyaWRnZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gUGFuZWxNZW51QnV0dG9uQnJpZGdlO1xuXHR9O1xuXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdGlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ3BhbmVsbWVudWJ1dHRvbicpKSB7XG5cdFx0Q0tFRElUT1IuVUlfUEFORUxCVVRUT04gPSAncGFuZWxtZW51YnV0dG9uJztcblxuXHRcdENLRURJVE9SLnBsdWdpbnMuYWRkKCdwYW5lbG1lbnVidXR0b24nLCB7fSk7XG5cdH1cblxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXHRpZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdwYW5lbGJ1dHRvbicpKSB7XG5cdFx0Q0tFRElUT1IuVUlfUEFORUxCVVRUT04gPSAncGFuZWxidXR0b24nO1xuXG5cdFx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ3BhbmVsYnV0dG9uJywge30pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENLRWRpdG9yIHBsdWdpbiB0aGF0IGJyaWRnZXMgdGhlIHN1cHBvcnQgb2ZmZXJlZCBieSBDS0VkaXRvciBQYW5lbEJ1dHRvbiBwbHVnaW4uIEl0IHRha2VzIG92ZXIgdGhlXG5cdCAqIHJlc3BvbnNpYmlsaXR5IG9mIHJlZ2lzdGVyaW5nIGFuZCBjcmVhdGluZyBidXR0b25zIHZpYTpcblx0ICogLSBlZGl0b3IudWkuYWRkUGFuZWxNZW51QnV0dG9uKG5hbWUsIGRlZmluaXRpb24pXG5cdCAqIC0gZWRpdG9yLnVpLmFkZChuYW1lLCBDS0VESVRPUi5VSV9QQU5FTEJVVFRPTiwgZGVmaW5pdGlvbilcblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfcGFuZWxtZW51YnV0dG9uYnJpZGdlXG5cdCAqIEByZXF1aXJlcyBDS0VESVRPUi5wbHVnaW5zLmFlX3VpYnJpZGdlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX3BhbmVsbWVudWJ1dHRvbmJyaWRnZScsIHtcblx0XHRyZXF1aXJlczogWydhZV91aWJyaWRnZSddLFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBhZGQgaGFuZGxlciBmb3IgVUlfUEFORUxCVVRUT04gdG8gb3VyIG93bi4gV2UgZG8gdGhpcyBpbiB0aGUgaW5pdCBwaGFzZSB0byBvdmVycmlkZVxuXHRcdCAqIHRoZSBvbmUgaW4gdGhlIG5hdGl2ZSBwbHVnaW4gaW4gY2FzZSBpdCdzIHByZXNlbnRcblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgaW5pdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIENLRWRpdG9yIGluc3RhbmNlIGJlaW5nIGluaXRpYWxpemVkXG5cdFx0ICovXG5cdFx0YmVmb3JlSW5pdChlZGl0b3IpIHtcblx0XHRcdGVkaXRvci51aS5hZGRQYW5lbE1lbnVCdXR0b24gPSBmdW5jdGlvbihcblx0XHRcdFx0cGFuZWxNZW51QnV0dG9uTmFtZSxcblx0XHRcdFx0cGFuZWxNZW51QnV0dG9uRGVmaW5pdGlvblxuXHRcdFx0KSB7XG5cdFx0XHRcdHRoaXMuYWRkKFxuXHRcdFx0XHRcdHBhbmVsTWVudUJ1dHRvbk5hbWUsXG5cdFx0XHRcdFx0Q0tFRElUT1IuVUlfUEFORUxCVVRUT04sXG5cdFx0XHRcdFx0cGFuZWxNZW51QnV0dG9uRGVmaW5pdGlvblxuXHRcdFx0XHQpO1xuXHRcdFx0fTtcblxuXHRcdFx0ZWRpdG9yLnVpLmFkZEhhbmRsZXIoQ0tFRElUT1IuVUlfUEFORUxCVVRUT04sIHtcblx0XHRcdFx0YWRkOiBnZW5lcmF0ZVBhbmVsTWVudUJ1dHRvbkJyaWRnZSxcblx0XHRcdFx0Y3JlYXRlKHBhbmVsTWVudUJ1dHRvbkRlZmluaXRpb24pIHtcblx0XHRcdFx0XHRjb25zdCBwYW5lbE1lbnVCdXR0b25OYW1lID1cblx0XHRcdFx0XHRcdCdwYW5lbE1lbnVCdXR0b25CcmlkZ2UnICsgKChNYXRoLnJhbmRvbSgpICogMWU5KSA+Pj4gMCk7XG5cdFx0XHRcdFx0Y29uc3QgUGFuZWxNZW51QnV0dG9uQnJpZGdlID0gZ2VuZXJhdGVQYW5lbE1lbnVCdXR0b25CcmlkZ2UoXG5cdFx0XHRcdFx0XHRwYW5lbE1lbnVCdXR0b25OYW1lLFxuXHRcdFx0XHRcdFx0cGFuZWxNZW51QnV0dG9uRGVmaW5pdGlvblxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFBhbmVsTWVudUJ1dHRvbkJyaWRnZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IEJ1dHRvbkRyb3Bkb3duIGZyb20gJy4uL2J1dHRvbnMvYnV0dG9uLWRyb3Bkb3duLmpzeCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuLi9idXR0b25zL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfcmljaGNvbWJvYnJpZGdlJykpIHtcblx0Y29uc3QgUklDSF9DT01CT19ERUZTID0ge307XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhIFJpY2hDb21ib0JyaWRnZSBSZWFjdCBjbGFzcyBmb3IgYSBnaXZlbiByaWNoY29tYm8gZGVmaW5pdGlvbiBpZiBpdCBoYXMgbm90IGJlZW5cblx0ICogYWxyZWFkeSBjcmVhdGVkIGJhc2VkIG9uIHRoZSByaWNoY29tYm8gbmFtZSBhbmQgZGVmaW5pdGlvbi5cblx0ICpcblx0ICogQG1ldGhvZCBnZW5lcmF0ZVJpY2hDb21ib0JyaWRnZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcmljaENvbWJvTmFtZSBUaGUgcmljaCBjb21ibyBuYW1lXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByaWNoQ29tYm9EZWZpbml0aW9uIFRoZSByaWNoIGNvbWJvIGRlZmluaXRpb25cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZ2VuZXJhdGVkIG9yIGFscmVhZHkgZXhpc3RpbmcgUmVhY3QgUmljaENvbWJvIENsYXNzXG5cdCAqL1xuXHRjb25zdCBnZW5lcmF0ZVJpY2hDb21ib0JyaWRnZSA9IGZ1bmN0aW9uKFxuXHRcdHJpY2hDb21ib05hbWUsXG5cdFx0cmljaENvbWJvRGVmaW5pdGlvbixcblx0XHRlZGl0b3Jcblx0KSB7XG5cdFx0bGV0IFJpY2hDb21ib0JyaWRnZSA9IEFsbG95RWRpdG9yLkJ1dHRvbnNbcmljaENvbWJvTmFtZV07XG5cblx0XHRSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdID0gUklDSF9DT01CT19ERUZTW2VkaXRvci5uYW1lXSB8fCB7fTtcblx0XHRSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW3JpY2hDb21ib05hbWVdID1cblx0XHRcdFJJQ0hfQ09NQk9fREVGU1tlZGl0b3IubmFtZV1bcmljaENvbWJvTmFtZV0gfHwgcmljaENvbWJvRGVmaW5pdGlvbjtcblx0XHRSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW3JpY2hDb21ib05hbWVdLmN1cnJlbnRWYWx1ZSA9IHVuZGVmaW5lZDtcblxuXHRcdGlmICghUmljaENvbWJvQnJpZGdlKSB7XG5cdFx0XHRSaWNoQ29tYm9CcmlkZ2UgPSBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdFx0XHRcdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0XHRcdFx0c3RhdGljIGRpc3BsYXlOYW1lID0gcmljaENvbWJvTmFtZTtcblxuXHRcdFx0XHRzdGF0aWMga2V5ID0gcmljaENvbWJvTmFtZTtcblxuXHRcdFx0XHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdFx0XHRcdHN1cGVyKHByb3BzKTtcblx0XHRcdFx0XHR0aGlzLnN0YXRlID0ge1xuXHRcdFx0XHRcdFx0dmFsdWU6XG5cdFx0XHRcdFx0XHRcdFJJQ0hfQ09NQk9fREVGU1tlZGl0b3IubmFtZV1bcmljaENvbWJvTmFtZV1cblx0XHRcdFx0XHRcdFx0XHQuY3VycmVudFZhbHVlLFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBUEkgbm90IHlldCBpbXBsZW1lbnRlZCBpbnNpZGUgdGhlIHJpY2hjb21ibyBicmlkZ2UuIEJ5IG1vY2tpbmcgdGhlIHVuc3VwcG9ydGVkIG1ldGhvZHMsIHdlXG5cdFx0XHRcdC8vIHByZXZlbnQgcGx1Z2lucyBmcm9tIGNyYXNoaW5nIGlmIHRoZXkgbWFrZSB1c2Ugb2YgdGhlbS5cblx0XHRcdFx0Y29tbWl0KCkge31cblx0XHRcdFx0Y3JlYXRlUGFuZWwoKSB7fVxuXHRcdFx0XHRkaXNhYmxlKCkge31cblx0XHRcdFx0ZW5hYmxlKCkge31cblx0XHRcdFx0Z2V0U3RhdGUoKSB7fVxuXHRcdFx0XHRoaWRlR3JvdXAoKSB7fVxuXHRcdFx0XHRoaWRlSXRlbSgpIHt9XG5cdFx0XHRcdG1hcmsoKSB7fVxuXHRcdFx0XHRzaG93QWxsKCkge31cblx0XHRcdFx0c3RhcnRHcm91cCgpIHt9XG5cdFx0XHRcdHVubWFya0FsbCgpIHt9XG5cblx0XHRcdFx0YWRkKHZhbHVlLCBwcmV2aWV3LCB0aXRsZSkge1xuXHRcdFx0XHRcdHRoaXMuX2l0ZW1zLnB1c2goe1xuXHRcdFx0XHRcdFx0cHJldmlldyxcblx0XHRcdFx0XHRcdHRpdGxlLFxuXHRcdFx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb21wb25lbnRXaWxsTW91bnQoKSB7XG5cdFx0XHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0XHRcdFx0Y29uc3QgZWRpdG9yQ29tYm8gPVxuXHRcdFx0XHRcdFx0UklDSF9DT01CT19ERUZTW2VkaXRvci5uYW1lXVtyaWNoQ29tYm9OYW1lXTtcblxuXHRcdFx0XHRcdHRoaXMuX2l0ZW1zID0gW107XG5cblx0XHRcdFx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWU7XG5cblx0XHRcdFx0XHRpZiAoZWRpdG9yQ29tYm8uaW5pdCkge1xuXHRcdFx0XHRcdFx0ZWRpdG9yQ29tYm8uaW5pdC5jYWxsKHRoaXMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChlZGl0b3JDb21iby5vblJlbmRlcikge1xuXHRcdFx0XHRcdFx0ZWRpdG9yQ29tYm8ub25SZW5kZXIuY2FsbCh0aGlzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0XHRcdFx0XHR0aGlzLl9jYWNoZVZhbHVlKHRoaXMuc3RhdGUudmFsdWUpO1xuXG5cdFx0XHRcdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuX2NhY2hlVmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZXRWYWx1ZSgpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zdGF0ZS52YWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlbmRlcigpIHtcblx0XHRcdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdFx0XHRjb25zdCByaWNoQ29tYm9MYWJlbCA9XG5cdFx0XHRcdFx0XHRSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW3JpY2hDb21ib05hbWVdXG5cdFx0XHRcdFx0XHRcdC5jdXJyZW50VmFsdWUgfHwgcmljaENvbWJvRGVmaW5pdGlvbi5sYWJlbDtcblxuXHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1kcm9wZG93biBhZS1oYXMtZHJvcGRvd25cIj5cblx0XHRcdFx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRcdGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9XG5cdFx0XHRcdFx0XHRcdFx0YXJpYS1sYWJlbD17cmljaENvbWJvTGFiZWx9XG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtdG9vbGJhci1lbGVtZW50XCJcblx0XHRcdFx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdFx0XHRcdHJvbGU9XCJjb21ib2JveFwiXG5cdFx0XHRcdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0XHRcdFx0dGl0bGU9e3JpY2hDb21ib0xhYmVsfT5cblx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lclwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWRyb3Bkb3duLXNlbGVjdGVkLWl0ZW1cIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0e3JpY2hDb21ib0xhYmVsfVxuXHRcdFx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiY2FyZXQtYm90dG9tXCIgLz5cblx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0XHRcdHt0aGlzLnByb3BzLmV4cGFuZGVkICYmIChcblx0XHRcdFx0XHRcdFx0XHQ8QnV0dG9uRHJvcGRvd25cblx0XHRcdFx0XHRcdFx0XHRcdG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn0+XG5cdFx0XHRcdFx0XHRcdFx0XHR7dGhpcy5fZ2V0SXRlbXMoKX1cblx0XHRcdFx0XHRcdFx0XHQ8L0J1dHRvbkRyb3Bkb3duPlxuXHRcdFx0XHRcdFx0XHQpfVxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9jYWNoZVZhbHVlKHZhbHVlKSB7XG5cdFx0XHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0XHRcdFx0UklDSF9DT01CT19ERUZTW2VkaXRvci5uYW1lXVtcblx0XHRcdFx0XHRcdHJpY2hDb21ib05hbWVcblx0XHRcdFx0XHRdLmN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2dldEl0ZW1zKCkge1xuXHRcdFx0XHRcdGNvbnN0IHJpY2hDb21ibyA9IHRoaXM7XG5cblx0XHRcdFx0XHRjb25zdCBpdGVtcyA9IHRoaXMuX2l0ZW1zLm1hcChpdGVtID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGNsYXNzTmFtZSA9XG5cdFx0XHRcdFx0XHRcdCdhZS10b29sYmFyLWVsZW1lbnQgJyArXG5cdFx0XHRcdFx0XHRcdChpdGVtLnZhbHVlID09PSB0aGlzLnN0YXRlLnZhbHVlID8gJ2FjdGl2ZScgOiAnJyk7XG5cblx0XHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRcdDxsaSBrZXk9e2l0ZW0udGl0bGV9IHJvbGU9XCJvcHRpb25cIj5cblx0XHRcdFx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzTmFtZX1cblx0XHRcdFx0XHRcdFx0XHRcdGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9faHRtbDogaXRlbS5wcmV2aWV3LFxuXHRcdFx0XHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRcdFx0XHRcdGRhdGEtdmFsdWU9e2l0ZW0udmFsdWV9XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkNsaWNrPXtyaWNoQ29tYm8uX29uQ2xpY2t9XG5cdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfb25DbGljayA9IGV2ZW50ID0+IHtcblx0XHRcdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdFx0XHRjb25zdCBlZGl0b3JDb21ibyA9XG5cdFx0XHRcdFx0XHRSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW3JpY2hDb21ib05hbWVdO1xuXG5cdFx0XHRcdFx0aWYgKGVkaXRvckNvbWJvLm9uQ2xpY2spIHtcblx0XHRcdFx0XHRcdGNvbnN0IG5ld1ZhbHVlID0gZXZlbnQuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdFx0XHRcdCdkYXRhLXZhbHVlJ1xuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0ZWRpdG9yQ29tYm8ub25DbGljay5jYWxsKHRoaXMsIG5ld1ZhbHVlKTtcblxuXHRcdFx0XHRcdFx0UklDSF9DT01CT19ERUZTW2VkaXRvci5uYW1lXVtcblx0XHRcdFx0XHRcdFx0cmljaENvbWJvTmFtZVxuXHRcdFx0XHRcdFx0XS5jdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcblxuXHRcdFx0XHRcdFx0ZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRfc2V0VmFsdWUodmFsdWUpIHtcblx0XHRcdFx0XHR0aGlzLl9jYWNoZVZhbHVlKHZhbHVlKTtcblxuXHRcdFx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdEFsbG95RWRpdG9yLkJ1dHRvbnNbcmljaENvbWJvTmFtZV0gPSBSaWNoQ29tYm9CcmlkZ2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFJpY2hDb21ib0JyaWRnZTtcblx0fTtcblxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXHRpZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdyaWNoY29tYm8nKSkge1xuXHRcdENLRURJVE9SLlVJX1JJQ0hDT01CTyA9ICdyaWNoY29tYm8nO1xuXG5cdFx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ3JpY2hjb21ibycsIHt9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gdGhhdCBicmlkZ2VzIHRoZSBzdXBwb3J0IG9mZmVyZWQgYnkgQ0tFZGl0b3IgUmljaENvbWJvIHBsdWdpbi4gSXQgdGFrZXMgb3ZlciB0aGVcblx0ICogcmVzcG9uc2liaWxpdHkgb2YgcmVnaXN0ZXJpbmcgYW5kIGNyZWF0aW5nIHJpY2ggY29tYm8gZWxlbWVudHMgdmlhOlxuXHQgKiAtIGVkaXRvci51aS5hZGRSaWNoQ29tYm8obmFtZSwgZGVmaW5pdGlvbilcblx0ICogLSBlZGl0b3IudWkuYWRkKG5hbWUsIENLRURJVE9SLlVJX1JJQ0hDT01CTywgZGVmaW5pdGlvbilcblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfcmljaGNvbWJvYnJpZGdlXG5cdCAqIEByZXF1aXJlcyBDS0VESVRPUi5wbHVnaW5zLmFlX3VpYnJpZGdlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX3JpY2hjb21ib2JyaWRnZScsIHtcblx0XHRyZXF1aXJlczogWydhZV91aWJyaWRnZSddLFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBhZGQgaGFuZGxlciBmb3IgVUlfUklDSENPTUJPIHRvIG91ciBvd24uIFdlIGRvIHRoaXMgaW4gdGhlIGluaXQgcGhhc2UgdG8gb3ZlcnJpZGVcblx0XHQgKiB0aGUgb25lIGluIHRoZSBvcmlnaW5hbCBwbHVnaW4gaW4gY2FzZSBpdCdzIHByZXNlbnRcblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgaW5pdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIENLRWRpdG9yIGluc3RhbmNlIGJlaW5nIGluaXRpYWxpemVkXG5cdFx0ICovXG5cdFx0YmVmb3JlSW5pdChlZGl0b3IpIHtcblx0XHRcdGVkaXRvci51aS5hZGRSaWNoQ29tYm8gPSBmdW5jdGlvbihcblx0XHRcdFx0cmljaENvbWJvTmFtZSxcblx0XHRcdFx0cmljaENvbWJvRGVmaW5pdGlvblxuXHRcdFx0KSB7XG5cdFx0XHRcdHRoaXMuYWRkKFxuXHRcdFx0XHRcdHJpY2hDb21ib05hbWUsXG5cdFx0XHRcdFx0Q0tFRElUT1IuVUlfUklDSENPTUJPLFxuXHRcdFx0XHRcdHJpY2hDb21ib0RlZmluaXRpb25cblx0XHRcdFx0KTtcblx0XHRcdH07XG5cblx0XHRcdGVkaXRvci51aS5hZGRIYW5kbGVyKENLRURJVE9SLlVJX1JJQ0hDT01CTywge1xuXHRcdFx0XHRhZGQ6IGdlbmVyYXRlUmljaENvbWJvQnJpZGdlLFxuXHRcdFx0XHRjcmVhdGUocmljaENvbWJvRGVmaW5pdGlvbikge1xuXHRcdFx0XHRcdGNvbnN0IHJpY2hDb21ib05hbWUgPVxuXHRcdFx0XHRcdFx0J3JpY2hDb21ib0JyaWRnZScgKyAoKE1hdGgucmFuZG9tKCkgKiAxZTkpID4+PiAwKTtcblx0XHRcdFx0XHRjb25zdCBSaWNoQ29tYm9CcmlkZ2UgPSBnZW5lcmF0ZVJpY2hDb21ib0JyaWRnZShcblx0XHRcdFx0XHRcdHJpY2hDb21ib05hbWUsXG5cdFx0XHRcdFx0XHRyaWNoQ29tYm9EZWZpbml0aW9uXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgUmljaENvbWJvQnJpZGdlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblx0XHR9LFxuXHR9KTtcbn1cbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV91aWJyaWRnZScpKSB7XG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gdGhhdCBleHRlbmRzIENLRURJVE9SLnVpLmFkZCBmdW5jdGlvbiBzbyBhbiBhZGQgaGFuZGxlciBjYW4gYmUgc3BlY2lmaWVkXG5cdCAqIG9uIHRvcCBvZiB0aGUgb3JpZ2luYWwgb25lcy4gSXQgYnJpZGdlcyB0aGUgY2FsbHMgdG8gYWRkIGNvbXBvbmVudHMgdmlhOlxuXHQgKiAtIGVkaXRvci51aS5hZGQobmFtZSwgdHlwZSwgZGVmaW5pdGlvbilcblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfdWlicmlkZ2Vcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfdWlicmlkZ2UnLCB7XG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS0VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBiZWZvcmVJbml0XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2Vcblx0XHQgKi9cblx0XHRiZWZvcmVJbml0KGVkaXRvcikge1xuXHRcdFx0Y29uc3Qgb3JpZ2luYWxVSUFkZEZuID0gZWRpdG9yLnVpLmFkZDtcblxuXHRcdFx0ZWRpdG9yLnVpLmFkZCA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUsIGRlZmluaXRpb24pIHtcblx0XHRcdFx0b3JpZ2luYWxVSUFkZEZuLmNhbGwodGhpcywgbmFtZSwgdHlwZSwgZGVmaW5pdGlvbik7XG5cblx0XHRcdFx0Y29uc3QgdHlwZUhhbmRsZXIgPSB0aGlzLl8uaGFuZGxlcnNbdHlwZV07XG5cblx0XHRcdFx0aWYgKHR5cGVIYW5kbGVyICYmIHR5cGVIYW5kbGVyLmFkZCkge1xuXHRcdFx0XHRcdHR5cGVIYW5kbGVyLmFkZChuYW1lLCBkZWZpbml0aW9uLCBlZGl0b3IpO1xuXHRcdFx0XHRcdEFsbG95RWRpdG9yLnJlZ2lzdGVyQnJpZGdlQnV0dG9uKFxuXHRcdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRcdGVkaXRvci5fX3Byb2Nlc3NpbmdQbHVnaW5fXy5wbHVnaW4ubmFtZVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbi8qKlxuICogRGVib3VuY2UgdXRpbCBmdW5jdGlvbi4gSWYgYSBmdW5jdGlvbiBleGVjdXRpb24gaXMgZXhwZW5zaXZlLCBpdCBtaWdodCBiZSBkZWJvdW5jZWQuIFRoaXMgbWVhbnNcbiAqIHRoYXQgaXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBzb21lIGFtb3VudCBvZiB0aW1lIGFmdGVyIGl0cyBsYXN0IGNhbGwuIEZvciBleGFtcGxlLCBpZiB3ZSBhdHRhY2ggYVxuICogYSBmdW5jdGlvbiBvbiBzY3JvbGwgZXZlbnQsIGl0IG1pZ2h0IGJlIGNhbGxlZCBodW5kcmVkcyB0aW1lcyBwZXIgc2Vjb25kLiBJbiB0aGlzIGNhc2UgaXQgbWF5IGJlXG4gKiBkZWJvdW5jZWQgd2l0aCwgbGV0J3Mgc2F5IDEwMG1zLiBUaGUgcmVhbCBleGVjdXRpb24gb2YgdGhpcyBmdW5jdGlvbiB3aWxsIGhhcHBlbiAxMDBtcyBhZnRlciBsYXN0XG4gKiBzY3JvbGwgZXZlbnQuXG4gKlxuICogQG1lbWJlcm9mIENLRURJVE9SLnRvb2xzXG4gKiBAbWV0aG9kIGRlYm91bmNlXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB3aGljaCB0aGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHdoaWNoIGhhcyB0byBiZSBjYWxsZWQgYWZ0ZXIgZ2l2ZW4gdGltZW91dC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0IFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBjb250ZXh0IGluIHdoaWNoIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZC4gVGhpcyBhcmd1bWVudCBpcyBvcHRpb25hbC5cbiAqIEBzdGF0aWNcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoY2FsbGJhY2ssIHRpbWVvdXQsIGNvbnRleHQsIGFyZ3MgPSBbXSkge1xuXHRsZXQgZGVib3VuY2VIYW5kbGU7XG5cblx0Y29uc3QgY2FsbEZuID0gZnVuY3Rpb24oLi4uY2FsbEFyZ3MpIHtcblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblx0XHRjb25zdCBjYWxsQ29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcblx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG5cdFx0Y2xlYXJUaW1lb3V0KGRlYm91bmNlSGFuZGxlKTtcblxuXHRcdGRlYm91bmNlSGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRjYWxsYmFjay5hcHBseShjYWxsQ29udGV4dCwgWy4uLmNhbGxBcmdzLCAuLi5hcmdzXSk7XG5cdFx0fSwgdGltZW91dCk7XG5cdH07XG5cblx0Y2FsbEZuLmRldGFjaCA9IGZ1bmN0aW9uKCkge1xuXHRcdGNsZWFyVGltZW91dChkZWJvdW5jZUhhbmRsZSk7XG5cdH07XG5cblx0cmV0dXJuIGNhbGxGbjtcbn1cblxuQ0tFRElUT1IudG9vbHMuZGVib3VuY2UgPSBDS0VESVRPUi50b29scy5kZWJvdW5jZSB8fCBkZWJvdW5jZTtcblxuZXhwb3J0IGRlZmF1bHQgZGVib3VuY2U7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBkZWJvdW5jZSBmcm9tICcuL2RlYm91bmNlJztcblxuaW1wb3J0ICcuL2xpbmsnO1xuXG5pbXBvcnQgJy4vcGx1Z2lucyc7XG5cbmltcG9ydCAnLi9zZWxlY3Rpb24tcmVnaW9uJztcblxuaW1wb3J0ICcuL3RhYmxlJztcblxuaW1wb3J0ICcuL3Rvb2xzJztcblxuaW1wb3J0ICcuL3VpY29yZSc7XG5cbmV4cG9ydCB7ZGVib3VuY2V9O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5jb25zdCBSRUdFWF9CT09LTUFSS19TQ0hFTUUgPSAvXiMuKi9pO1xuY29uc3QgUkVHRVhfRU1BSUxfU0NIRU1FID0gL15bYS16MC05XFx1MDQzMC1cXHUwNDRGLl8tXStAL2k7XG5jb25zdCBSRUdFWF9VUklfU0NIRU1FID0gL14oPzpbYS16XVthLXowLTkrXFwtLl0qKTp8XlxcLy9pO1xuXG4vKipcbiAqIExpbmsgY2xhc3MgdXRpbGl0eS4gUHJvdmlkZXMgbWV0aG9kcyBmb3IgY3JlYXRlLCBkZWxldGUgYW5kIHVwZGF0ZSBsaW5rcy5cbiAqXG4gKiBAY2xhc3MgQ0tFRElUT1IuTGlua1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBDS0VkaXRvciBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gTGluayhlZGl0b3IsIGNvbmZpZykge1xuXHR0aGlzLl9lZGl0b3IgPSBlZGl0b3I7XG5cdHRoaXMuYXBwZW5kUHJvdG9jb2wgPVxuXHRcdGNvbmZpZyAmJiBjb25maWcuYXBwZW5kUHJvdG9jb2wgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xufVxuXG5MaW5rLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IExpbmssXG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSBlZGl0b3Igc2VsZWN0aW9uIHRvIHRoZSBuZXh0IGF2YWlsYWJsZSBwb3NpdGlvbiBhZnRlciBhXG5cdCAqIGdpdmVuIGxpbmsgb3IgdGhlIG9uZSBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IuTGlua1xuXHQgKiBAbWV0aG9kIGFkdmFuY2VTZWxlY3Rpb25cblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gbGluayBUaGUgbGluayBlbGVtZW50IHdoaWNoIGxpbmsgc3R5bGUgc2hvdWxkIGJlIHJlbW92ZWQuXG5cdCAqL1xuXHRhZHZhbmNlU2VsZWN0aW9uKGxpbmspIHtcblx0XHRsaW5rID0gbGluayB8fCB0aGlzLmdldEZyb21TZWxlY3Rpb24oKTtcblxuXHRcdGNvbnN0IHJhbmdlID0gdGhpcy5fZWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFJhbmdlcygpWzBdO1xuXG5cdFx0aWYgKGxpbmspIHtcblx0XHRcdHJhbmdlLm1vdmVUb0VsZW1lbnRFZGl0RW5kKGxpbmspO1xuXG5cdFx0XHRjb25zdCBuZXh0Tm9kZSA9IHJhbmdlLmdldE5leHRFZGl0YWJsZU5vZGUoKTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXh0Tm9kZSAmJlxuXHRcdFx0XHQhdGhpcy5fZWRpdG9yLmVsZW1lbnQuZXF1YWxzKG5leHROb2RlLmdldENvbW1vbkFuY2VzdG9yKGxpbmspKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGNvbnN0IHdoaXRlc3BhY2UgPSAvXFxzLy5leGVjKG5leHROb2RlLmdldFRleHQoKSk7XG5cblx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gd2hpdGVzcGFjZSA/IHdoaXRlc3BhY2UuaW5kZXggKyAxIDogMDtcblxuXHRcdFx0XHRyYW5nZS5zZXRTdGFydChuZXh0Tm9kZSwgb2Zmc2V0KTtcblx0XHRcdFx0cmFuZ2Uuc2V0RW5kKG5leHROb2RlLCBvZmZzZXQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2VkaXRvci5nZXRTZWxlY3Rpb24oKS5zZWxlY3RSYW5nZXMoW3JhbmdlXSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGxpbmsgd2l0aCBnaXZlbiBVUkkgYXMgaHJlZi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5MaW5rXG5cdCAqIEBtZXRob2QgY3JlYXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyBBIGNvbmZpZyBvYmplY3Qgd2l0aCBsaW5rIGF0dHJpYnV0ZXMuIFRoZXNlIG1pZ2h0IGJlIGFyYml0cmFyeSBET00gYXR0cmlidXRlcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IG1vZGlmeVNlbGVjdGlvbiBBIGNvbmZpZyBvYmplY3Qgd2l0aCBhbiBhZHZhbmNlIGF0dHJpYnV0ZSB0byBpbmRpY2F0ZSBpZiB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBtb3ZlZCBhZnRlciB0aGUgbGluayBjcmVhdGlvbi5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFVSSSBUaGUgVVJJIG9mIHRoZSBsaW5rLlxuXHQgKi9cblx0Y3JlYXRlKFVSSSwgYXR0cnMsIG1vZGlmeVNlbGVjdGlvbikge1xuXHRcdGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuX2VkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlcygpWzBdO1xuXG5cdFx0aWYgKHJhbmdlLmNvbGxhcHNlZCkge1xuXHRcdFx0Y29uc3QgdGV4dCA9IG5ldyBDS0VESVRPUi5kb20udGV4dChVUkksIHRoaXMuX2VkaXRvci5kb2N1bWVudCk7XG5cdFx0XHRyYW5nZS5pbnNlcnROb2RlKHRleHQpO1xuXHRcdFx0cmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKHRleHQpO1xuXHRcdH1cblxuXHRcdFVSSSA9IHRoaXMuX2dldENvbXBsZXRlVVJJKFVSSSk7XG5cblx0XHRjb25zdCBsaW5rQXR0cnMgPSBDS0VESVRPUi50b29scy5tZXJnZShcblx0XHRcdHtcblx0XHRcdFx0J2RhdGEtY2tlLXNhdmVkLWhyZWYnOiBVUkksXG5cdFx0XHRcdGhyZWY6IFVSSSxcblx0XHRcdH0sXG5cdFx0XHRhdHRyc1xuXHRcdCk7XG5cblx0XHRjb25zdCBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZSh7XG5cdFx0XHRhdHRyaWJ1dGVzOiBsaW5rQXR0cnMsXG5cdFx0XHRlbGVtZW50OiAnYScsXG5cdFx0fSk7XG5cblx0XHRzdHlsZS50eXBlID0gQ0tFRElUT1IuU1RZTEVfSU5MSU5FO1xuXHRcdHN0eWxlLmFwcGx5VG9SYW5nZShyYW5nZSwgdGhpcy5fZWRpdG9yKTtcblxuXHRcdGlmIChtb2RpZnlTZWxlY3Rpb24gJiYgbW9kaWZ5U2VsZWN0aW9uLmFkdmFuY2UpIHtcblx0XHRcdHRoaXMuYWR2YW5jZVNlbGVjdGlvbigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyYW5nZS5zZWxlY3QoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyBhIGxpbmsgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IuTGlua1xuXHQgKiBAbWV0aG9kIGdldEZyb21TZWxlY3Rpb25cblx0ICogQHJldHVybiB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IFRoZSByZXRyaWV2ZWQgbGluayBvciBudWxsIGlmIG5vdCBmb3VuZC5cblx0ICovXG5cdGdldEZyb21TZWxlY3Rpb24oKSB7XG5cdFx0Y29uc3Qgc2VsZWN0aW9uID0gdGhpcy5fZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0Y29uc3Qgc2VsZWN0ZWRFbGVtZW50ID0gc2VsZWN0aW9uLmdldFNlbGVjdGVkRWxlbWVudCgpO1xuXG5cdFx0aWYgKHNlbGVjdGVkRWxlbWVudCAmJiBzZWxlY3RlZEVsZW1lbnQuaXMoJ2EnKSkge1xuXHRcdFx0cmV0dXJuIHNlbGVjdGVkRWxlbWVudDtcblx0XHR9XG5cblx0XHRpZiAoc2VsZWN0ZWRFbGVtZW50ICYmIENLRURJVE9SLmVudi5pZSkge1xuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBzZWxlY3RlZEVsZW1lbnQuZ2V0Q2hpbGRyZW4oKTtcblxuXHRcdFx0Y29uc3QgY291bnQgPSBjaGlsZHJlbi5jb3VudCgpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHRcdFx0Y29uc3Qgbm9kZSA9IGNoaWxkcmVuLmdldEl0ZW0oaSk7XG5cblx0XHRcdFx0aWYgKG5vZGUuaXMoJ2EnKSkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VzKClbMF07XG5cblx0XHRpZiAocmFuZ2UpIHtcblx0XHRcdHJhbmdlLnNocmluayhDS0VESVRPUi5TSFJJTktfVEVYVCk7XG5cblx0XHRcdHJldHVybiB0aGlzLl9lZGl0b3Jcblx0XHRcdFx0LmVsZW1lbnRQYXRoKHJhbmdlLmdldENvbW1vbkFuY2VzdG9yKCkpXG5cdFx0XHRcdC5jb250YWlucygnYScsIDEpO1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGEgbGluayBmcm9tIHRoZSBlZGl0b3IuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IuTGlua1xuXHQgKiBAbWV0aG9kIHJlbW92ZVxuXHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBsaW5rIFRoZSBsaW5rIGVsZW1lbnQgd2hpY2ggbGluayBzdHlsZSBzaG91bGQgYmUgcmVtb3ZlZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG1vZGlmeVNlbGVjdGlvbiBBIGNvbmZpZyBvYmplY3Qgd2l0aCBhbiBhZHZhbmNlIGF0dHJpYnV0ZSB0byBpbmRpY2F0ZSBpZiB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBtb3ZlZCBhZnRlciB0aGUgbGluayBjcmVhdGlvbi5cblx0ICovXG5cdHJlbW92ZShsaW5rLCBtb2RpZnlTZWxlY3Rpb24pIHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG5cblx0XHRpZiAobGluaykge1xuXHRcdFx0aWYgKG1vZGlmeVNlbGVjdGlvbiAmJiBtb2RpZnlTZWxlY3Rpb24uYWR2YW5jZSkge1xuXHRcdFx0XHR0aGlzLmFkdmFuY2VTZWxlY3Rpb24oKTtcblx0XHRcdH1cblxuXHRcdFx0bGluay5yZW1vdmUoZWRpdG9yKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3Qgc3R5bGUgPSBuZXcgQ0tFRElUT1Iuc3R5bGUoe1xuXHRcdFx0XHRhbHdheXNSZW1vdmVFbGVtZW50OiAxLFxuXHRcdFx0XHRlbGVtZW50OiAnYScsXG5cdFx0XHRcdHR5cGU6IENLRURJVE9SLlNUWUxFX0lOTElORSxcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyAncmVtb3ZlU3R5bGUoKScgcmVtb3ZlcyB0aGUgc3R5bGUgZnJvbSB0aGUgZWRpdG9yJ3MgY3VycmVudCBzZWxlY3Rpb24uXG5cdFx0XHQvLyAgV2UgbmVlZCB0byBmb3JjZSB0aGUgc2VsZWN0aW9uIHRvIGJlIHRoZSB3aG9sZSBsaW5rIGVsZW1lbnRcblx0XHRcdC8vICB0byByZW1vdmUgaXQgcHJvcGVybHkuXG5cblx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdHNlbGVjdGlvbi5zZWxlY3RFbGVtZW50KHNlbGVjdGlvbi5nZXRTdGFydEVsZW1lbnQoKSk7XG5cblx0XHRcdGVkaXRvci5yZW1vdmVTdHlsZShzdHlsZSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBocmVmIG9mIGFuIGFscmVhZHkgZXhpc3RpbmcgbGluay5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5MaW5rXG5cdCAqIEBtZXRob2QgdXBkYXRlXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGxpbmsgVGhlIGxpbmsgZWxlbWVudCB3aGljaCBocmVmIHNob3VsZCBiZSByZW1vdmVkLlxuXHQgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGF0dHJzIFRoZSBhdHRyaWJ1dGVzIHRvIHVwZGF0ZSBvciByZW1vdmUuIEF0dHJpYnV0ZXMgd2l0aCBudWxsIHZhbHVlcyB3aWxsIGJlIHJlbW92ZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtb2RpZnlTZWxlY3Rpb24gQSBjb25maWcgb2JqZWN0IHdpdGggYW4gYWR2YW5jZSBhdHRyaWJ1dGUgdG8gaW5kaWNhdGUgaWYgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgbW92ZWQgYWZ0ZXIgdGhlIGxpbmsgY3JlYXRpb24uXG5cdCAqL1xuXHR1cGRhdGUoYXR0cnMsIGxpbmssIG1vZGlmeVNlbGVjdGlvbikge1xuXHRcdGNvbnN0IGluc3RhbmNlID0gdGhpcztcblxuXHRcdGxpbmsgPSBsaW5rIHx8IHRoaXMuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXG5cdFx0aWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGNvbnN0IHVyaSA9IGluc3RhbmNlLl9nZXRDb21wbGV0ZVVSSShhdHRycyk7XG5cblx0XHRcdGxpbmsuc2V0QXR0cmlidXRlcyh7XG5cdFx0XHRcdCdkYXRhLWNrZS1zYXZlZC1ocmVmJzogdXJpLFxuXHRcdFx0XHRocmVmOiB1cmksXG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGNvbnN0IHJlbW92ZUF0dHJzID0gW107XG5cblx0XHRcdGNvbnN0IHNldEF0dHJzID0ge307XG5cblx0XHRcdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0XHRcdGlmIChhdHRyc1trZXldID09PSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKGtleSA9PT0gJ2hyZWYnKSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVBdHRycy5wdXNoKCdkYXRhLWNrZS1zYXZlZC1ocmVmJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVtb3ZlQXR0cnMucHVzaChrZXkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChrZXkgPT09ICdocmVmJykge1xuXHRcdFx0XHRcdFx0Y29uc3QgdXJpID0gaW5zdGFuY2UuX2dldENvbXBsZXRlVVJJKGF0dHJzW2tleV0pO1xuXG5cdFx0XHRcdFx0XHRzZXRBdHRyc1snZGF0YS1ja2Utc2F2ZWQtaHJlZiddID0gdXJpO1xuXHRcdFx0XHRcdFx0c2V0QXR0cnNba2V5XSA9IHVyaTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2V0QXR0cnNba2V5XSA9IGF0dHJzW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0bGluay5yZW1vdmVBdHRyaWJ1dGVzKHJlbW92ZUF0dHJzKTtcblx0XHRcdGxpbmsuc2V0QXR0cmlidXRlcyhzZXRBdHRycyk7XG5cdFx0fVxuXG5cdFx0aWYgKG1vZGlmeVNlbGVjdGlvbiAmJiBtb2RpZnlTZWxlY3Rpb24uYWR2YW5jZSkge1xuXHRcdFx0dGhpcy5hZHZhbmNlU2VsZWN0aW9uKGxpbmspO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBVUkkgYmVnaW5zIHdpdGggYSAnIycgc3ltYm9sIHRvIGRldGVybWluZSBpZiBpdCdzIGFuIG9uIHBhZ2UgYm9va21hcmsuXG5cdCAqIElmIGl0IGRvZXNuJ3QsIGl0IHRoZW4gY2hlY2tzIGlmIHRoZSBVUkkgaGFzIGFuICdAJyBzeW1ib2wuIElmIGl0IGRvZXMgYW5kIHRoZSBVUklcblx0ICogbG9va3MgbGlrZSBhbiBlbWFpbCBhbmQgZG9lc24ndCBoYXZlICdtYWlsdG86JywgJ21haWx0bzonIGlzIGFkZGVkIHRvIHRoZSBVUkkuXG5cdCAqIElmIGl0IGRvZXNuJ3QgYW5kIHRoZSBVUkkgZG9lc24ndCBoYXZlIGEgc2NoZW1lLCB0aGUgZGVmYXVsdCAnaHR0cCcgc2NoZW1lIHdpdGhcblx0ICogaGllcmFyY2hpY2FsIHBhdGggJy8vJyBpcyBhZGRlZCB0byB0aGUgVVJJLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLkxpbmtcblx0ICogQG1ldGhvZCBfZ2V0Q29tcGxldGVVUklcblx0ICogQHBhcmFtIHtTdHJpbmd9IFVSSSBUaGUgVVJJIG9mIHRoZSBsaW5rLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIFVSSSB1cGRhdGVkIHdpdGggdGhlIHByb3RvY29sLlxuXHQgKi9cblx0X2dldENvbXBsZXRlVVJJKFVSSSkge1xuXHRcdGlmIChSRUdFWF9CT09LTUFSS19TQ0hFTUUudGVzdChVUkkpKSB7XG5cdFx0XHRyZXR1cm4gVVJJO1xuXHRcdH0gZWxzZSBpZiAoUkVHRVhfRU1BSUxfU0NIRU1FLnRlc3QoVVJJKSkge1xuXHRcdFx0VVJJID0gJ21haWx0bzonICsgVVJJO1xuXHRcdH0gZWxzZSBpZiAoIVJFR0VYX1VSSV9TQ0hFTUUudGVzdChVUkkpKSB7XG5cdFx0XHRVUkkgPSB0aGlzLmFwcGVuZFByb3RvY29sID8gJ2h0dHA6Ly8nICsgVVJJIDogVVJJO1xuXHRcdH1cblxuXHRcdHJldHVybiBVUkk7XG5cdH0sXG59O1xuXG5DS0VESVRPUi5MaW5rID0gQ0tFRElUT1IuTGluayB8fCBMaW5rO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG4vLyBXcmFwcyBlYWNoIG9mIHRoZSBwbHVnaW4gbGlmZWN5Y2xlIG1ldGhvZHMgaW4gYSBjbG9zdXJlIHRoYXQgd2lsbFxuLy8gc2V0IHVwIHRoZSBlZGl0b3IuX19wcm9jZXNzaW5nUGx1Z2luX18gdmFyaWFibGUgc28gaXQgY2FuIGJlIGdsb2JhbGx5XG4vLyBhY2Nlc3NlZCBleHBvc2luZyB0aGUgcGx1Z2luIGJlaW5nIHByb2Nlc3NlZCBhbmQgdGhlIGxpZmVjeWNsZSBwaGFzZVxuLy8gaW4gd2hpY2ggaXQgaXMgaGFwcGVuaW5nXG4vL1xuLy8gQHBhcmFtIHtPYmplY3R9IHBsdWdpbiBUaGUgcGx1Z2luIHRvIHdyYXAgbGlmZWN5Y2xlIG1ldGhvZHNcbmNvbnN0IHdyYXBQbHVnaW5MaWZlY3ljbGUgPSBmdW5jdGlvbihwbHVnaW4pIHtcblx0Y29uc3QgbWV0aG9kcyA9IFsnYmVmb3JlSW5pdCcsICdpbml0JywgJ2FmdGVySW5pdCddO1xuXG5cdG1ldGhvZHMuZm9yRWFjaChtZXRob2ROYW1lID0+IHtcblx0XHRpZiAocGx1Z2luW21ldGhvZE5hbWVdKSB7XG5cdFx0XHRwbHVnaW5bbWV0aG9kTmFtZV0gPSBDS0VESVRPUi50b29scy5vdmVycmlkZShcblx0XHRcdFx0cGx1Z2luW21ldGhvZE5hbWVdLFxuXHRcdFx0XHRvcmlnaW5hbFBsdWdpbk1ldGhvZCA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgcGF5bG9hZCA9IHtcblx0XHRcdFx0XHRcdHBoYXNlOiBtZXRob2ROYW1lLFxuXHRcdFx0XHRcdFx0cGx1Z2luLFxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRlZGl0b3IuX19wcm9jZXNzaW5nUGx1Z2luX18gPSBwYXlsb2FkO1xuXG5cdFx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW52YWxpZC10aGlzXG5cdFx0XHRcdFx0XHRvcmlnaW5hbFBsdWdpbk1ldGhvZC5jYWxsKHRoaXMsIGVkaXRvcik7XG5cblx0XHRcdFx0XHRcdGVkaXRvci5fX3Byb2Nlc3NpbmdQbHVnaW5fXyA9IG51bGw7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdH0pO1xufTtcblxuLy8gRmlsdGVycyB0aGUgcmVxdWlyZXMgb2JqZWN0IHRvIHJlbW92ZSB1bndhbnRlZCBkZXBlbmRlbmNpZXMuIEF0IHRoaXMgcG9pbnRcbi8vIG9ubHkgJ3Rvb2xiYXInIGhhcyBiZWVuIGlkZW50aWZpZWQsIGJ1dCBtb3JlIGNhbiBhcHBlYXIuIEFuIHVud2FudGVkIHBsdWdpblxuLy8gZGVwZW5kZW5jeSBpcyBvbmUgdGhhdCBwcmV2ZW50cyBhIG5lY2Vzc2FyeSBwbHVnaW4gZnJvbSBiZWluZyByZW1vdmVkXG4vL1xuLy8gQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gcmVxdWlyZXMgVGhlIHJlcXVpcmVzIG9iamVjdFxuLy8gQHJldHVybiB7c3RyaW5nfSBUaGUgZmlsdGVyZWQgcmVxdWlyZXMgb2JqZWN0XG5jb25zdCBmaWx0ZXJVbndhbnRlZERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uKHJlcXVpcmVzKSB7XG5cdGlmICh0eXBlb2YgcmVxdWlyZXMgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmVxdWlyZXMgPSByZXF1aXJlcy5zcGxpdCgnLCcpO1xuXHR9XG5cblx0cmV0dXJuIHJlcXVpcmVzLmZpbHRlcihyZXF1aXJlID0+IHtcblx0XHRyZXR1cm4gcmVxdWlyZSAhPT0gJ3Rvb2xiYXInO1xuXHR9KTtcbn07XG5cbi8qKlxuICogQ0tFRElUT1IucGx1Z2lucyBjbGFzcyB1dGlsaXR5IHdoaWNoIGFkZHMgYWRkaXRpb25hbCBtZXRob2RzIHRvIHRob3NlIG9mIENLRWRpdG9yLlxuICpcbiAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zXG4gKi9cblxuLyoqXG4gKiBPdmVycmlkZXMgQ0tFRElUT1IucGx1Z2lucy5sb2FkIG1ldGhvZCBzbyB3ZSBjYW4gZXh0ZW5kIHRoZSBsaWZlY3ljbGUgbWV0aG9kcyBvZlxuICogdGhlIGxvYWRlZCBwbHVnaW5zIHRvIGFkZCBzb21lIG1ldGFpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGx1Z2luIGJlaW5nIHByb2Nlc3NlZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nL0FycmF5fSBuYW1lcyBUaGUgbmFtZSBvZiB0aGUgcmVzb3VyY2UgdG8gbG9hZC4gSXQgbWF5IGJlIGFcbiAqIHN0cmluZyB3aXRoIGEgc2luZ2xlIHJlc291cmNlIG5hbWUsIG9yIGFuIGFycmF5IHdpdGggc2V2ZXJhbCBuYW1lcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gYWxsIHJlc291cmNlc1xuICogYXJlIGxvYWRlZC4gVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSBhbiBhcnJheSBjb250YWluaW5nIGFsbCBsb2FkZWQgbmFtZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBUaGUgc2NvcGUgb2JqZWN0IHRvIGJlIHVzZWQgZm9yIHRoZSBjYWxsYmFjayBjYWxsLlxuICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnNcbiAqIEBtZXRob2QgbG9hZFxuICogQHN0YXRpY1xuICovXG5DS0VESVRPUi5wbHVnaW5zLmxvYWQgPSBDS0VESVRPUi50b29scy5vdmVycmlkZShcblx0Q0tFRElUT1IucGx1Z2lucy5sb2FkLFxuXHRwbHVnaW5zTG9hZCA9PiB7XG5cdFx0Ly8gV3JhcCBvcmlnaW5hbCBsb2FkIGZ1bmN0aW9uIHNvIHdlIGNhbiB0cmFuc2Zvcm0gdGhlIHBsdWdpbiBpbnB1dCBwYXJhbWV0ZXJcblx0XHQvLyBiZWZvcmUgcGFzc2luZyBpdCBkb3duIHRvIHRoZSBvcmlnaW5hbCBjYWxsYmFja1xuXHRcdHJldHVybiBmdW5jdGlvbihuYW1lcywgY2FsbGJhY2ssIHNjb3BlKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW52YWxpZC10aGlzXG5cdFx0XHRwbHVnaW5zTG9hZC5jYWxsKHRoaXMsIG5hbWVzLCBwbHVnaW5zID0+IHtcblx0XHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0T2JqZWN0LmtleXMocGx1Z2lucykuZm9yRWFjaChwbHVnaW5OYW1lID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbcGx1Z2luTmFtZV07XG5cblx0XHRcdFx0XHRcdGlmIChwbHVnaW4ucmVxdWlyZXMpIHtcblx0XHRcdFx0XHRcdFx0cGx1Z2luLnJlcXVpcmVzID0gZmlsdGVyVW53YW50ZWREZXBlbmRlbmNpZXMoXG5cdFx0XHRcdFx0XHRcdFx0cGx1Z2luLnJlcXVpcmVzXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHdyYXBQbHVnaW5MaWZlY3ljbGUocGx1Z2luKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoc2NvcGUsIHBsdWdpbnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9XG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9zZWxlY3Rpb25yZWdpb24nKSkge1xuXHRDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTSA9IDA7XG5cdENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QID0gMTtcblx0Q0tFRElUT1IuU0VMRUNUSU9OX0xFRlRfVE9fUklHSFQgPSAyO1xuXHRDS0VESVRPUi5TRUxFQ1RJT05fUklHSFRfVE9fTEVGVCA9IDM7XG5cblx0LyoqXG5cdCAqIFNlbGVjdGlvblJlZ2lvbiB1dGlsaXR5IGNsYXNzIHdoaWNoIHByb3ZpZGVzIG1ldGFkYXRhIGFib3V0IHRoZSBzZWxlY3Rpb24uIFRoZSBtZXRhZGF0YSBtYXkgYmUgdGhlIHN0YXJ0IGFuZCBlbmRcblx0ICogcmVjdGFuZ2xlcywgY2FyZXQgcmVnaW9uLCBldGMuICoqVGhpcyBjbGFzcyBpcyBub3QgaW50ZW5kZWQgdG8gYmUgdXNlZCBzdGFuZGFsb25lLiBJdHMgZnVuY3Rpb25zIHdpbGxcblx0ICogYmUgbWVyZ2VkIGludG8gZWFjaCBlZGl0b3IgaW5zdGFuY2UsIHNvIHRoZSBkZXZlbG9wZXIgbWF5IHVzZSB0aGVtIGRpcmVjdGx5IHZpYSB0aGUgZWRpdG9yLCB3aXRob3V0IG1ha2luZ1xuXHQgKiBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzKiouXG5cdCAqXG5cdCAqIEBjbGFzcyBTZWxlY3Rpb25SZWdpb25cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBTZWxlY3Rpb25SZWdpb24oKSB7fVxuXG5cdFNlbGVjdGlvblJlZ2lvbi5wcm90b3R5cGUgPSB7XG5cdFx0Y29uc3RydWN0b3I6IFNlbGVjdGlvblJlZ2lvbixcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgc2VsZWN0aW9uIGZyb20gdHdvIHBvaW50cyBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFNlbGVjdGlvblJlZ2lvblxuXHRcdCAqIEBtZXRob2QgY3JlYXRlU2VsZWN0aW9uRnJvbVBvaW50XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHggWCBwb2ludCBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgcG9pbnQgaW4gcGFnZSBjb29yZGluYXRlcy5cblx0XHQgKi9cblx0XHRjcmVhdGVTZWxlY3Rpb25Gcm9tUG9pbnQoeCwgeSkge1xuXHRcdFx0dGhpcy5jcmVhdGVTZWxlY3Rpb25Gcm9tUmFuZ2UoeCwgeSwgeCwgeSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgc2VsZWN0aW9uIGZyb20gcmFuZ2UuIEEgcmFuZ2UgY29uc2lzdHMgZnJvbSB0d28gcG9pbnRzIGluIHBhZ2UgY29vcmRpbmF0ZXMuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgU2VsZWN0aW9uUmVnaW9uXG5cdFx0ICogQG1ldGhvZCBjcmVhdGVTZWxlY3Rpb25Gcm9tUmFuZ2Vcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRYIFggY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgcG9pbnQuXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0WSBZIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBlbmRYIFggY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBlbmRZIFkgY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxuXHRcdCAqL1xuXHRcdGNyZWF0ZVNlbGVjdGlvbkZyb21SYW5nZShzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSkge1xuXHRcdFx0bGV0IGVuZDtcblx0XHRcdGxldCBlbmRDb250YWluZXI7XG5cdFx0XHRsZXQgZW5kT2Zmc2V0O1xuXHRcdFx0bGV0IHJhbmdlO1xuXHRcdFx0bGV0IHN0YXJ0O1xuXHRcdFx0bGV0IHN0YXJ0Q29udGFpbmVyO1xuXHRcdFx0bGV0IHN0YXJ0T2Zmc2V0O1xuXG5cdFx0XHRpZiAodHlwZW9mIGRvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0c3RhcnQgPSBkb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHN0YXJ0WCwgc3RhcnRZKTtcblx0XHRcdFx0ZW5kID0gZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludChlbmRYLCBlbmRZKTtcblxuXHRcdFx0XHRzdGFydENvbnRhaW5lciA9IHN0YXJ0Lm9mZnNldE5vZGU7XG5cdFx0XHRcdGVuZENvbnRhaW5lciA9IGVuZC5vZmZzZXROb2RlO1xuXG5cdFx0XHRcdHN0YXJ0T2Zmc2V0ID0gc3RhcnQub2Zmc2V0O1xuXHRcdFx0XHRlbmRPZmZzZXQgPSBlbmQub2Zmc2V0O1xuXG5cdFx0XHRcdHJhbmdlID0gdGhpcy5jcmVhdGVSYW5nZSgpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRzdGFydCA9IGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQoc3RhcnRYLCBzdGFydFkpO1xuXHRcdFx0XHRlbmQgPSBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50KGVuZFgsIGVuZFkpO1xuXG5cdFx0XHRcdHN0YXJ0Q29udGFpbmVyID0gc3RhcnQuc3RhcnRDb250YWluZXI7XG5cdFx0XHRcdGVuZENvbnRhaW5lciA9IGVuZC5zdGFydENvbnRhaW5lcjtcblxuXHRcdFx0XHRzdGFydE9mZnNldCA9IHN0YXJ0LnN0YXJ0T2Zmc2V0O1xuXHRcdFx0XHRlbmRPZmZzZXQgPSBlbmQuc3RhcnRPZmZzZXQ7XG5cblx0XHRcdFx0cmFuZ2UgPSB0aGlzLmNyZWF0ZVJhbmdlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyYW5nZSAmJiBkb2N1bWVudC5nZXRTZWxlY3Rpb24pIHtcblx0XHRcdFx0cmFuZ2Uuc2V0U3RhcnQoXG5cdFx0XHRcdFx0bmV3IENLRURJVE9SLmRvbS5ub2RlKHN0YXJ0Q29udGFpbmVyKSxcblx0XHRcdFx0XHRzdGFydE9mZnNldFxuXHRcdFx0XHQpO1xuXHRcdFx0XHRyYW5nZS5zZXRFbmQobmV3IENLRURJVE9SLmRvbS5ub2RlKGVuZENvbnRhaW5lciksIGVuZE9mZnNldCk7XG5cblx0XHRcdFx0dGhpcy5nZXRTZWxlY3Rpb24oKS5zZWxlY3RSYW5nZXMoW3JhbmdlXSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC5ib2R5LmNyZWF0ZVRleHRSYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjb25zdCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0XHRcdHNlbGVjdGlvbi51bmxvY2soKTtcblxuXHRcdFx0XHRyYW5nZSA9IGRvY3VtZW50LmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XG5cdFx0XHRcdHJhbmdlLm1vdmVUb1BvaW50KHN0YXJ0WCwgc3RhcnRZKTtcblxuXHRcdFx0XHRjb25zdCBlbmRSYW5nZSA9IHJhbmdlLmR1cGxpY2F0ZSgpO1xuXHRcdFx0XHRlbmRSYW5nZS5tb3ZlVG9Qb2ludChlbmRYLCBlbmRZKTtcblxuXHRcdFx0XHRyYW5nZS5zZXRFbmRQb2ludCgnRW5kVG9FbmQnLCBlbmRSYW5nZSk7XG5cdFx0XHRcdHJhbmdlLnNlbGVjdCgpO1xuXG5cdFx0XHRcdHRoaXMuZ2V0U2VsZWN0aW9uKCkubG9jaygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSByZWdpb24gb2YgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGNhcmV0LiBUaGUgcG9pbnRzIGFyZSBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFNlbGVjdGlvblJlZ2lvblxuXHRcdCAqIEBtZXRob2QgZ2V0Q2FyZXRSZWdpb25cblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXHRcdCAqIC0gYm90dG9tXG5cdFx0ICogLSBsZWZ0XG5cdFx0ICogLSByaWdodFxuXHRcdCAqIC0gdG9wXG5cdFx0ICovXG5cdFx0Z2V0Q2FyZXRSZWdpb24oKSB7XG5cdFx0XHRjb25zdCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0XHRsZXQgcmVnaW9uID0ge1xuXHRcdFx0XHRib3R0b206IDAsXG5cdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdHJpZ2h0OiAwLFxuXHRcdFx0XHR0b3A6IDAsXG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCBib29rbWFya3MgPSBzZWxlY3Rpb24uY3JlYXRlQm9va21hcmtzKCk7XG5cblx0XHRcdGlmICghYm9va21hcmtzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gcmVnaW9uO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBib29rbWFya05vZGVFbCA9IGJvb2ttYXJrc1swXS5zdGFydE5vZGUuJDtcblxuXHRcdFx0Ym9va21hcmtOb2RlRWwuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuXG5cdFx0XHRyZWdpb24gPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoYm9va21hcmtOb2RlRWwpLmdldENsaWVudFJlY3QoKTtcblxuXHRcdFx0Ym9va21hcmtOb2RlRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChib29rbWFya05vZGVFbCk7XG5cblx0XHRcdGNvbnN0IHNjcm9sbFBvcyA9IG5ldyBDS0VESVRPUi5kb20ud2luZG93KFxuXHRcdFx0XHR3aW5kb3dcblx0XHRcdCkuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcblxuXHRcdFx0cmVnaW9uLmJvdHRvbSA9IHNjcm9sbFBvcy55ICsgcmVnaW9uLmJvdHRvbTtcblx0XHRcdHJlZ2lvbi5sZWZ0ID0gc2Nyb2xsUG9zLnggKyByZWdpb24ubGVmdDtcblx0XHRcdHJlZ2lvbi5yaWdodCA9IHNjcm9sbFBvcy54ICsgcmVnaW9uLnJpZ2h0O1xuXHRcdFx0cmVnaW9uLnRvcCA9IHNjcm9sbFBvcy55ICsgcmVnaW9uLnRvcDtcblxuXHRcdFx0cmV0dXJuIHJlZ2lvbjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBkYXRhIGZvciB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgU2VsZWN0aW9uUmVnaW9uXG5cdFx0ICogQG1ldGhvZCBnZXRTZWxlY3Rpb25EYXRhXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fG51bGx9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBkYXRhOlxuXHRcdCAqIC0gZWxlbWVudCAtIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZWxlbWVudCwgaWYgYW55XG5cdFx0ICogLSB0ZXh0IC0gVGhlIHNlbGVjdGVkIHRleHRcblx0XHQgKiAtIHJlZ2lvbiAtIFRoZSBkYXRhLCByZXR1cm5lZCBmcm9tIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfc2VsZWN0aW9ucmVnaW9uL2dldFNlbGVjdGlvblJlZ2lvbjptZXRob2RcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKi9cblx0XHRnZXRTZWxlY3Rpb25EYXRhKCkge1xuXHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdFx0aWYgKCFzZWxlY3Rpb24uZ2V0TmF0aXZlKCkpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJlc3VsdCA9IHtcblx0XHRcdFx0ZWxlbWVudDogc2VsZWN0aW9uLmdldFNlbGVjdGVkRWxlbWVudCgpLFxuXHRcdFx0XHR0ZXh0OiBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRUZXh0KCksXG5cdFx0XHR9O1xuXG5cdFx0XHRyZXN1bHQucmVnaW9uID0gdGhpcy5nZXRTZWxlY3Rpb25SZWdpb24oc2VsZWN0aW9uKTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgcmVnaW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cblx0XHQgKiBAbWV0aG9kIGdldFNlbGVjdGlvblJlZ2lvblxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBvYmplY3Qgd2hpY2ggaXMgYmVpbmcgcmV0dXJuZWQgZnJvbVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfc2VsZWN0aW9ucmVnaW9uL2dldENsaWVudFJlY3RzUmVnaW9uOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fSB3aXRoIHRocmVlIG1vcmUgcHJvcGVydGllczpcblx0XHQgKiAtIGRpcmVjdGlvbiAtIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNlbGVjdGlvbi4gQ2FuIGJlIG9uZSBvZiB0aGVzZTpcblx0XHQgKiAgIDEuIENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NXG5cdFx0ICogICAyLiBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUFxuXHRcdCAqIC0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgc2VsZWN0aW9uIHJlZ2lvblxuXHRcdCAqIC0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHNlbGVjdGlvbiByZWdpb25cblx0XHQgKi9cblx0XHRnZXRTZWxlY3Rpb25SZWdpb24oKSB7XG5cdFx0XHRjb25zdCByZWdpb24gPSB0aGlzLmdldENsaWVudFJlY3RzUmVnaW9uKCk7XG5cblx0XHRcdHJlZ2lvbi5kaXJlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbkRpcmVjdGlvbigpO1xuXG5cdFx0XHRyZWdpb24uaGVpZ2h0ID0gcmVnaW9uLmJvdHRvbSAtIHJlZ2lvbi50b3A7XG5cdFx0XHRyZWdpb24ud2lkdGggPSByZWdpb24ucmlnaHQgLSByZWdpb24ubGVmdDtcblxuXHRcdFx0cmV0dXJuIHJlZ2lvbjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBlbXB0eSwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFNlbGVjdGlvblJlZ2lvblxuXHRcdCAqIEBtZXRob2QgaXNTZWxlY3Rpb25FbXB0eVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgZW1wdHksIGZhbHNlIG90aGVyd2lzZS5cblx0XHQgKi9cblx0XHRpc1NlbGVjdGlvbkVtcHR5KCkge1xuXHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdFx0aWYgKHNlbGVjdGlvbi5nZXRUeXBlKCkgPT09IENLRURJVE9SLlNFTEVDVElPTl9OT05FKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCByYW5nZXMgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VzKCk7XG5cdFx0XHRyZXR1cm4gcmFuZ2VzICYmIHJhbmdlcy5sZW5ndGggPT09IDEgJiYgcmFuZ2VzWzBdLmNvbGxhcHNlZDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBvYmplY3Qgd2l0aCBkYXRhIGFib3V0IHRoZSBbY2xpZW50IHJlY3RhbmdsZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50LmdldENsaWVudFJlY3RzKSBvZiB0aGUgc2VsZWN0aW9uLFxuXHRcdCAqIG5vcm1hbGl6ZWQgYWNyb3NzIGJyb3dzZXMuIEFsbCBvZmZzZXRzIGJlbG93IGFyZSBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFNlbGVjdGlvblJlZ2lvblxuXHRcdCAqIEBtZXRob2QgZ2V0Q2xpZW50UmVjdHNSZWdpb25cblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBkYXRhOlxuXHRcdCAqIC0gYm90dG9tIC0gYm90dG9tIG9mZnNldCBvZiBhbGwgY2xpZW50IHJlY3RhbmdsZXNcblx0XHQgKiAtIGxlZnQgLSBsZWZ0IG9mZnNldCBvZiBhbGwgY2xpZW50IHJlY3RhbmdsZXNcblx0XHQgKiAtIHJpZ2h0IC0gcmlnaHQgb2Zmc2V0IG9mIGFsbCBjbGllbnQgcmVjdGFuZ2xlc1xuXHRcdCAqIC0gdG9wIC0gdG9wIG9mZnNldCBvZiBhbGwgY2xpZW50IHJlY3RhbmdsZXNcblx0XHQgKiAtIHN0YXJ0UmVjdCAtIEFuIE9iamVjdCwgd2hpY2ggY29udGFpbnMgdGhlIGZvbGxvd2luZyBpbmZvcm1hdGlvbjpcblx0XHQgKiAgICAgKyBib3R0b20gLSBib3R0b20gb2Zmc2V0XG5cdFx0ICogICAgICsgaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG5cdFx0ICogICAgICsgbGVmdCAtIGxlZnQgb2Zmc2V0IG9mIHRoZSBzZWxlY3Rpb25cblx0XHQgKiAgICAgKyByaWdodCAtIHJpZ2h0IG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uXG5cdFx0ICogICAgICsgdG9wIC0gdG9wIG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uXG5cdFx0ICogICAgICsgd2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuXHRcdCAqIC0gZW5kUmVjdCAtIEFuIE9iamVjdCwgd2hpY2ggY29udGFpbnMgdGhlIGZvbGxvd2luZyBpbmZvcm1hdGlvbjpcblx0XHQgKiAgICAgKyBib3R0b20gLSBib3R0b20gb2Zmc2V0XG5cdFx0ICogICAgICsgaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG5cdFx0ICogICAgICsgbGVmdCAtIGxlZnQgb2Zmc2V0IG9mIHRoZSBzZWxlY3Rpb25cblx0XHQgKiAgICAgKyByaWdodCAtIHJpZ2h0IG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uXG5cdFx0ICogICAgICsgdG9wIC0gdG9wIG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uXG5cdFx0ICogICAgICsgd2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuXHRcdCAqXG5cdFx0ICogSWYgdGhlcmUgaXMgbm8gbmF0aXZlIHNlbGVjdGlvbiwgdGhlIG9iamVjdHMgd2lsbCBiZSBmaWxsZWQgd2l0aCAwLlxuXHRcdCAqL1xuXHRcdGdldENsaWVudFJlY3RzUmVnaW9uKCkge1xuXHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdGNvbnN0IG5hdGl2ZVNlbGVjdGlvbiA9IHNlbGVjdGlvbi5nZXROYXRpdmUoKTtcblxuXHRcdFx0Y29uc3QgZGVmYXVsdFJlY3QgPSB7XG5cdFx0XHRcdGJvdHRvbTogMCxcblx0XHRcdFx0aGVpZ2h0OiAwLFxuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRyaWdodDogMCxcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHR3aWR0aDogMCxcblx0XHRcdH07XG5cblx0XHRcdGxldCByZWdpb24gPSB7XG5cdFx0XHRcdGJvdHRvbTogMCxcblx0XHRcdFx0ZW5kUmVjdDogZGVmYXVsdFJlY3QsXG5cdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdHJpZ2h0OiAwLFxuXHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdHN0YXJ0UmVjdDogZGVmYXVsdFJlY3QsXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIW5hdGl2ZVNlbGVjdGlvbikge1xuXHRcdFx0XHRyZXR1cm4gcmVnaW9uO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgYm90dG9tID0gMDtcblx0XHRcdGxldCBjbGllbnRSZWN0cztcblx0XHRcdGxldCBsZWZ0ID0gSW5maW5pdHk7XG5cdFx0XHRsZXQgcmlnaHQgPSAtSW5maW5pdHk7XG5cdFx0XHRsZXQgdG9wID0gSW5maW5pdHk7XG5cblx0XHRcdGlmIChuYXRpdmVTZWxlY3Rpb24uY3JlYXRlUmFuZ2UpIHtcblx0XHRcdFx0Y2xpZW50UmVjdHMgPSBuYXRpdmVTZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS5nZXRDbGllbnRSZWN0cygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xpZW50UmVjdHMgPVxuXHRcdFx0XHRcdG5hdGl2ZVNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMFxuXHRcdFx0XHRcdFx0PyBuYXRpdmVTZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKS5nZXRDbGllbnRSZWN0cygpXG5cdFx0XHRcdFx0XHQ6IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2xpZW50UmVjdHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHJlZ2lvbiA9IHRoaXMuZ2V0Q2FyZXRSZWdpb24oKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBjbGllbnRSZWN0cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGl0ZW0gPSBjbGllbnRSZWN0c1tpXTtcblxuXHRcdFx0XHRcdGlmIChpdGVtLmxlZnQgPCBsZWZ0KSB7XG5cdFx0XHRcdFx0XHRsZWZ0ID0gaXRlbS5sZWZ0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChpdGVtLnJpZ2h0ID4gcmlnaHQpIHtcblx0XHRcdFx0XHRcdHJpZ2h0ID0gaXRlbS5yaWdodDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoaXRlbS50b3AgPCB0b3ApIHtcblx0XHRcdFx0XHRcdHRvcCA9IGl0ZW0udG9wO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChpdGVtLmJvdHRvbSA+IGJvdHRvbSkge1xuXHRcdFx0XHRcdFx0Ym90dG9tID0gaXRlbS5ib3R0b207XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3Qgc2Nyb2xsUG9zID0gbmV3IENLRURJVE9SLmRvbS53aW5kb3coXG5cdFx0XHRcdFx0d2luZG93XG5cdFx0XHRcdCkuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcblxuXHRcdFx0XHRyZWdpb24uYm90dG9tID0gc2Nyb2xsUG9zLnkgKyBib3R0b207XG5cdFx0XHRcdHJlZ2lvbi5sZWZ0ID0gc2Nyb2xsUG9zLnggKyBsZWZ0O1xuXHRcdFx0XHRyZWdpb24ucmlnaHQgPSBzY3JvbGxQb3MueCArIHJpZ2h0O1xuXHRcdFx0XHRyZWdpb24udG9wID0gc2Nyb2xsUG9zLnkgKyB0b3A7XG5cblx0XHRcdFx0aWYgKGNsaWVudFJlY3RzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGNvbnN0IGVuZFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcblx0XHRcdFx0XHRjb25zdCBzdGFydFJlY3QgPSBjbGllbnRSZWN0c1swXTtcblxuXHRcdFx0XHRcdHJlZ2lvbi5lbmRSZWN0ID0ge1xuXHRcdFx0XHRcdFx0Ym90dG9tOiBzY3JvbGxQb3MueSArIGVuZFJlY3QuYm90dG9tLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBlbmRSZWN0LmhlaWdodCxcblx0XHRcdFx0XHRcdGxlZnQ6IHNjcm9sbFBvcy54ICsgZW5kUmVjdC5sZWZ0LFxuXHRcdFx0XHRcdFx0cmlnaHQ6IHNjcm9sbFBvcy54ICsgZW5kUmVjdC5yaWdodCxcblx0XHRcdFx0XHRcdHRvcDogc2Nyb2xsUG9zLnkgKyBlbmRSZWN0LnRvcCxcblx0XHRcdFx0XHRcdHdpZHRoOiBlbmRSZWN0LndpZHRoLFxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRyZWdpb24uc3RhcnRSZWN0ID0ge1xuXHRcdFx0XHRcdFx0Ym90dG9tOiBzY3JvbGxQb3MueSArIHN0YXJ0UmVjdC5ib3R0b20sXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IHN0YXJ0UmVjdC5oZWlnaHQsXG5cdFx0XHRcdFx0XHRsZWZ0OiBzY3JvbGxQb3MueCArIHN0YXJ0UmVjdC5sZWZ0LFxuXHRcdFx0XHRcdFx0cmlnaHQ6IHNjcm9sbFBvcy54ICsgc3RhcnRSZWN0LnJpZ2h0LFxuXHRcdFx0XHRcdFx0dG9wOiBzY3JvbGxQb3MueSArIHN0YXJ0UmVjdC50b3AsXG5cdFx0XHRcdFx0XHR3aWR0aDogc3RhcnRSZWN0LndpZHRoLFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlZ2lvbjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0cmlldmVzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNlbGVjdGlvbi4gVGhlIGRpcmVjdGlvbiBpcyBmcm9tIHRvcCB0byBib3R0b20gb3IgZnJvbSBib3R0b20gdG8gdG9wLlxuXHRcdCAqIEZvciBJRSA8IDkgaXQgaXMgbm90IHBvc3NpYmxlLCBzbyB0aGUgZGlyZWN0aW9uIGZvciB0aGVzZSBicm93c2VycyB3aWxsIGJlIGFsd2F5cyBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cblx0XHQgKiBAbWV0aG9kIGdldFNlbGVjdGlvbkRpcmVjdGlvblxuXHRcdCAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyBhIG51bWJlciB3aGljaCByZXByZXNlbnRzIHNlbGVjdGlvbiBkaXJlY3Rpb24uIEl0IG1pZ2h0IGJlIG9uZSBvZiB0aGVzZTpcblx0XHQgKiAtIENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NO1xuXHRcdCAqIC0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1A7XG5cdFx0ICovXG5cdFx0Z2V0U2VsZWN0aW9uRGlyZWN0aW9uKCkge1xuXHRcdFx0bGV0IGRpcmVjdGlvbiA9IENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NO1xuXHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdGNvbnN0IG5hdGl2ZVNlbGVjdGlvbiA9IHNlbGVjdGlvbi5nZXROYXRpdmUoKTtcblxuXHRcdFx0aWYgKCFuYXRpdmVTZWxlY3Rpb24pIHtcblx0XHRcdFx0cmV0dXJuIGRpcmVjdGlvbjtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGFuY2hvck5vZGU7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0KGFuY2hvck5vZGUgPSBuYXRpdmVTZWxlY3Rpb24uYW5jaG9yTm9kZSkgJiZcblx0XHRcdFx0YW5jaG9yTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdFx0KSB7XG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gYW5jaG9yTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihcblx0XHRcdFx0XHRuYXRpdmVTZWxlY3Rpb24uZm9jdXNOb2RlXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCghcG9zaXRpb24gJiZcblx0XHRcdFx0XHRcdG5hdGl2ZVNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPlxuXHRcdFx0XHRcdFx0XHRuYXRpdmVTZWxlY3Rpb24uZm9jdXNPZmZzZXQpIHx8XG5cdFx0XHRcdFx0cG9zaXRpb24gPT09IE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGRpcmVjdGlvbiA9IENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkaXJlY3Rpb247XG5cdFx0fSxcblx0fTtcblxuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfc2VsZWN0aW9ucmVnaW9uJywge1xuXHRcdGluaXQoZWRpdG9yKSB7XG5cdFx0XHRsZXQgYXR0cjtcblx0XHRcdGNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRcdFx0Zm9yIChhdHRyIGluIFNlbGVjdGlvblJlZ2lvbi5wcm90b3R5cGUpIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGhhc093blByb3BlcnR5LmNhbGwoU2VsZWN0aW9uUmVnaW9uLnByb3RvdHlwZSwgYXR0cikgJiZcblx0XHRcdFx0XHR0eXBlb2YgZWRpdG9yW2F0dHJdID09PSAndW5kZWZpbmVkJ1xuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRlZGl0b3JbYXR0cl0gPSBTZWxlY3Rpb25SZWdpb24ucHJvdG90eXBlW2F0dHJdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmNvbnN0IElFX05PTl9ESVJFQ1RMWV9FRElUQUJMRV9FTEVNRU5UID0ge1xuXHR0YWJsZTogMSxcblx0Y29sOiAxLFxuXHRjb2xncm91cDogMSxcblx0dGJvZHk6IDEsXG5cdHRkOiAxLFxuXHR0Zm9vdDogMSxcblx0dGg6IDEsXG5cdHRoZWFkOiAxLFxuXHR0cjogMSxcbn07XG5cbi8qKlxuICogVGFibGUgY2xhc3MgdXRpbGl0eS4gUHJvdmlkZXMgbWV0aG9kcyBmb3IgY3JlYXRlLCBkZWxldGUgYW5kIHVwZGF0ZSB0YWJsZXMuXG4gKlxuICogQGNsYXNzIENLRURJVE9SLlRhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIENLRWRpdG9yIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIFRhYmxlKGVkaXRvcikge1xuXHR0aGlzLl9lZGl0b3IgPSBlZGl0b3I7XG59XG5cblRhYmxlLkhFQURJTkdfQk9USCA9ICdCb3RoJztcblRhYmxlLkhFQURJTkdfQ09MID0gJ0NvbHVtbic7XG5UYWJsZS5IRUFESU5HX05PTkUgPSAnTm9uZSc7XG5UYWJsZS5IRUFESU5HX1JPVyA9ICdSb3cnO1xuXG5UYWJsZS5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUYWJsZSxcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHRhYmxlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLlRhYmxlXG5cdCAqIEBtZXRob2QgY3JlYXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGFibGUgY29uZmlndXJhdGlvbiBvYmplY3Rcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY3JlYXRlZCB0YWJsZVxuXHQgKi9cblx0Y3JlYXRlKGNvbmZpZykge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcblx0XHRjb25zdCB0YWJsZSA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG5cblx0XHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0XHQvLyBHZW5lcmF0ZSB0aGUgcm93cyBhbmQgY29scy5cblx0XHRjb25zdCB0Ym9keSA9IHRhYmxlLmFwcGVuZCh0aGlzLl9jcmVhdGVFbGVtZW50KCd0Ym9keScpKTtcblx0XHRjb25zdCByb3dzID0gY29uZmlnLnJvd3MgfHwgMTtcblx0XHRjb25zdCBjb2xzID0gY29uZmlnLmNvbHMgfHwgMTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG5cdFx0XHRjb25zdCByb3cgPSB0Ym9keS5hcHBlbmQodGhpcy5fY3JlYXRlRWxlbWVudCgndHInKSk7XG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7IGorKykge1xuXHRcdFx0XHRjb25zdCBjZWxsID0gcm93LmFwcGVuZCh0aGlzLl9jcmVhdGVFbGVtZW50KCd0ZCcpKTtcblxuXHRcdFx0XHRjZWxsLmFwcGVuZEJvZ3VzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGVzKHRhYmxlLCBjb25maWcuYXR0cnMpO1xuXHRcdHRoaXMuc2V0SGVhZGluZyh0YWJsZSwgY29uZmlnLmhlYWRpbmcpO1xuXG5cdFx0Ly8gSW5zZXJ0IHRoZSB0YWJsZSBlbGVtZW50IGlmIHdlJ3JlIGNyZWF0aW5nIG9uZS5cblx0XHRlZGl0b3IuaW5zZXJ0RWxlbWVudCh0YWJsZSk7XG5cblx0XHRjb25zdCBmaXJzdENlbGwgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQodGFibGUuJC5yb3dzWzBdLmNlbGxzWzBdKTtcblx0XHRjb25zdCByYW5nZSA9IGVkaXRvci5jcmVhdGVSYW5nZSgpO1xuXHRcdHJhbmdlLm1vdmVUb1Bvc2l0aW9uKGZpcnN0Q2VsbCwgQ0tFRElUT1IuUE9TSVRJT05fQUZURVJfU1RBUlQpO1xuXHRcdHJhbmdlLnNlbGVjdCgpO1xuXG5cdFx0cmV0dXJuIHRhYmxlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgYSB0YWJsZSBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuXHQgKiBAbWV0aG9kIGdldEZyb21TZWxlY3Rpb25cblx0ICogQHJldHVybiB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IFRoZSByZXRyaWV2ZWQgdGFibGUgb3IgbnVsbCBpZiBub3QgZm91bmQuXG5cdCAqL1xuXHRnZXRGcm9tU2VsZWN0aW9uKCkge1xuXHRcdGxldCB0YWJsZTtcblx0XHRjb25zdCBzZWxlY3Rpb24gPSB0aGlzLl9lZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0Y29uc3Qgc2VsZWN0ZWQgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRFbGVtZW50KCk7XG5cblx0XHRpZiAoc2VsZWN0ZWQgJiYgc2VsZWN0ZWQuaXMoJ3RhYmxlJykpIHtcblx0XHRcdHRhYmxlID0gc2VsZWN0ZWQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IHJhbmdlcyA9IHNlbGVjdGlvbi5nZXRSYW5nZXMoKTtcblxuXHRcdFx0aWYgKHJhbmdlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdC8vIFdlYmtpdCBjb3VsZCByZXBvcnQgdGhlIGZvbGxvd2luZyByYW5nZSBvbiBjZWxsIHNlbGVjdGlvbiAoIzQ5NDgpOlxuXHRcdFx0XHQvLyA8dGFibGU+PHRyPjx0ZD5bJm5ic3A7PC90ZD48L3RyPjwvdGFibGU+XVxuXG5cdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdFx0XHRcdGlmIChDS0VESVRPUi5lbnYud2Via2l0KSB7XG5cdFx0XHRcdFx0cmFuZ2VzWzBdLnNocmluayhDS0VESVRPUi5OT0RFX0VMRU1FTlQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFibGUgPSB0aGlzLl9lZGl0b3Jcblx0XHRcdFx0XHQuZWxlbWVudFBhdGgocmFuZ2VzWzBdLmdldENvbW1vbkFuY2VzdG9yKHRydWUpKVxuXHRcdFx0XHRcdC5jb250YWlucygndGFibGUnLCAxKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFibGU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBhIGdpdmVuIHRhYmxlIGNhbiBiZSBjb25zaWRlcmVkIGFzIGVkaXRhYmxlLiBUaGlzIG1ldGhvZFxuXHQgKiB3b3JrYXJvdW5kcyBhIGxpbWl0YXRpb24gb2YgSUUgd2hlcmUgZm9yIHNvbWUgZWxlbWVudHMgKGxpa2UgdGFibGUpLFxuXHQgKiBgaXNDb250ZW50RWRpdGFibGVgIHJldHVybnMgYWx3YXlzIGZhbHNlLiBUaGlzIGlzIGJlY2F1c2UgSUUgZG9lcyBub3Qgc3VwcG9ydFxuXHQgKiBgY29udGVudGVkaXRhYmxlYCBvbiBzdWNoIGVsZW1lbnRzLiBIb3dldmVyLCBkZXNwaXRlIHN1Y2ggZWxlbWVudHNcblx0ICogY2Fubm90IGJlIHNldCBhcyBjb250ZW50IGVkaXRhYmxlIGRpcmVjdGx5LCBhIGNvbnRlbnQgZWRpdGFibGUgU1BBTixcblx0ICogb3IgRElWIGVsZW1lbnQgY2FuIGJlIHBsYWNlZCBpbnNpZGUgdGhlIGluZGl2aWR1YWwgdGFibGUgY2VsbHMuXG5cdCAqIFNlZSBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM3ODM3JTI4dj1WUy44NSUyOS5hc3B4XG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IuVGFibGVcblx0ICogQG1ldGhvZCBpc0VkaXRhYmxlXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGVsIFRoZSB0YWJsZSBlbGVtZW50IHRvIHRlc3QgaWYgZWRpdGFibGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGlzRWRpdGFibGUoZWwpIHtcblx0XHRpZiAoIUNLRURJVE9SLmVudi5pZSB8fCAhZWwuaXMoSUVfTk9OX0RJUkVDVExZX0VESVRBQkxFX0VMRU1FTlQpKSB7XG5cdFx0XHRyZXR1cm4gIWVsLmlzUmVhZE9ubHkoKTtcblx0XHR9XG5cblx0XHRpZiAoZWwuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSkge1xuXHRcdFx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgIT09ICdmYWxzZSc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuaXNFZGl0YWJsZShlbC5nZXRQYXJlbnQoKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hpY2ggaGVhZGluZyBzdHlsZSBpcyBzZXQgZm9yIHRoZSBnaXZlbiB0YWJsZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuXHQgKiBAbWV0aG9kIGdldEhlYWRpbmdcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gdGFibGUgVGhlIHRhYmxlIHRvIGdhdGhlciB0aGUgaGVhZGluZyBmcm9tLiBJZiBudWxsLCBpdCB3aWxsIGJlIHJldHJpZXZlZCBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgaGVhZGluZyBvZiB0aGUgdGFibGUuIEV4cGVjdGVkIHZhbHVlcyBhcmUgYENLRURJVE9SLlRhYmxlLk5PTkVgLCBgQ0tFRElUT1IuVGFibGUuUk9XYCwgYENLRURJVE9SLlRhYmxlLkNPTGAgYW5kIGBDS0VESVRPUi5UYWJsZS5CT1RIYC5cblx0ICovXG5cdGdldEhlYWRpbmcodGFibGUpIHtcblx0XHR0YWJsZSA9IHRhYmxlIHx8IHRoaXMuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXG5cdFx0aWYgKCF0YWJsZSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgcm93SGVhZGluZ1NldHRpbmdzID0gdGFibGUuJC50SGVhZCAhPT0gbnVsbDtcblxuXHRcdGxldCBjb2xIZWFkaW5nU2V0dGluZ3MgPSB0cnVlO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgYWxsIG9mIHRoZSBmaXJzdCBjZWxscyBpbiBldmVyeSByb3cgYXJlIFRIXG5cdFx0Zm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGFibGUuJC5yb3dzLmxlbmd0aDsgcm93KyspIHtcblx0XHRcdC8vIElmIGp1c3Qgb25lIGNlbGwgaXNuJ3QgYSBUSCB0aGVuIGl0IGlzbid0IGEgaGVhZGVyIGNvbHVtblxuXHRcdFx0Y29uc3QgY2VsbCA9IHRhYmxlLiQucm93c1tyb3ddLmNlbGxzWzBdO1xuXG5cdFx0XHRpZiAoY2VsbCAmJiBjZWxsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICd0aCcpIHtcblx0XHRcdFx0Y29sSGVhZGluZ1NldHRpbmdzID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCBoZWFkaW5nU2V0dGluZ3MgPSBUYWJsZS5IRUFESU5HX05PTkU7XG5cblx0XHRpZiAocm93SGVhZGluZ1NldHRpbmdzKSB7XG5cdFx0XHRoZWFkaW5nU2V0dGluZ3MgPSBUYWJsZS5IRUFESU5HX1JPVztcblx0XHR9XG5cblx0XHRpZiAoY29sSGVhZGluZ1NldHRpbmdzKSB7XG5cdFx0XHRoZWFkaW5nU2V0dGluZ3MgPVxuXHRcdFx0XHRoZWFkaW5nU2V0dGluZ3MgPT09IFRhYmxlLkhFQURJTkdfUk9XXG5cdFx0XHRcdFx0PyBUYWJsZS5IRUFESU5HX0JPVEhcblx0XHRcdFx0XHQ6IFRhYmxlLkhFQURJTkdfQ09MO1xuXHRcdH1cblxuXHRcdHJldHVybiBoZWFkaW5nU2V0dGluZ3M7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYSB0YWJsZSBmcm9tIHRoZSBlZGl0b3IuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IuVGFibGVcblx0ICogQG1ldGhvZCByZW1vdmVcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gdGFibGUgVGhlIHRhYmxlIGVsZW1lbnQgd2hpY2ggdGFibGUgc3R5bGUgc2hvdWxkIGJlIHJlbW92ZWQuXG5cdCAqL1xuXHRyZW1vdmUodGFibGUpIHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG5cblx0XHRpZiAodGFibGUpIHtcblx0XHRcdHRhYmxlLnJlbW92ZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YWJsZSA9IGVkaXRvci5lbGVtZW50UGF0aCgpLmNvbnRhaW5zKCd0YWJsZScsIDEpO1xuXG5cdFx0XHRpZiAodGFibGUpIHtcblx0XHRcdFx0Ly8gSWYgdGhlIHRhYmxlJ3MgcGFyZW50IGhhcyBvbmx5IG9uZSBjaGlsZCByZW1vdmUgaXQgYXMgd2VsbCAodW5sZXNzIGl0J3MgYSB0YWJsZSBjZWxsLCBvciB0aGUgZWRpdGFibGUgZWxlbWVudCkgKCM1NDE2LCAjNjI4OSwgIzEyMTEwKVxuXHRcdFx0XHRjb25zdCBwYXJlbnQgPSB0YWJsZS5nZXRQYXJlbnQoKTtcblx0XHRcdFx0Y29uc3QgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cGFyZW50LmdldENoaWxkQ291bnQoKSA9PT0gMSAmJlxuXHRcdFx0XHRcdCFwYXJlbnQuaXMoJ3RkJywgJ3RoJykgJiZcblx0XHRcdFx0XHQhcGFyZW50LmVxdWFscyhlZGl0YWJsZSlcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0dGFibGUgPSBwYXJlbnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCByYW5nZSA9IGVkaXRvci5jcmVhdGVSYW5nZSgpO1xuXHRcdFx0XHRyYW5nZS5tb3ZlVG9Qb3NpdGlvbih0YWJsZSwgQ0tFRElUT1IuUE9TSVRJT05fQkVGT1JFX1NUQVJUKTtcblx0XHRcdFx0dGFibGUucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBBc3NpZ25zIHByb3ZpZGVkIGF0dHJpYnV0ZXMgdG8gYSB0YWJsZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuXHQgKiBAbWV0aG9kIHNldEF0dHJpYnV0ZXNcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhYmxlIFRoZSB0YWJsZSB0byB3aGljaCB0aGUgYXR0cmlidXRlcyBzaG91bGQgYmUgYXNzaWduZWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIFRoZSBhdHRyaWJ1dGVzIHdoaWNoIGhhdmUgdG8gYmUgYXNzaWduZWQgdG8gdGhlIHRhYmxlXG5cdCAqL1xuXHRzZXRBdHRyaWJ1dGVzKHRhYmxlLCBhdHRycykge1xuXHRcdGlmIChhdHRycykge1xuXHRcdFx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goYXR0ciA9PiB7XG5cdFx0XHRcdHRhYmxlLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGFwcHJvcHJpYXRlIHRhYmxlIGhlYWRpbmcgc3R5bGUgdG8gYSB0YWJsZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuXHQgKiBAbWV0aG9kIHNldEhlYWRpbmdcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gdGFibGUgVGhlIHRhYmxlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGhlYWRpbmcgc2hvdWxkIGJlIHNldC4gSWYgbnVsbCwgaXQgd2lsbCBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkaW5nIFRoZSB0YWJsZSBoZWFkaW5nIHRvIGJlIHNldC4gQWNjZXB0ZWQgdmFsdWVzIGFyZTogYENLRURJVE9SLlRhYmxlLk5PTkVgLCBgQ0tFRElUT1IuVGFibGUuUk9XYCwgYENLRURJVE9SLlRhYmxlLkNPTGAgYW5kIGBDS0VESVRPUi5UYWJsZS5CT1RIYC5cblx0ICovXG5cdHNldEhlYWRpbmcodGFibGUsIGhlYWRpbmcpIHtcblx0XHR0YWJsZSA9IHRhYmxlIHx8IHRoaXMuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IG5ld0NlbGw7XG5cdFx0bGV0IHRhYmxlSGVhZDtcblx0XHRjb25zdCB0YWJsZUJvZHkgPSB0YWJsZS5nZXRFbGVtZW50c0J5VGFnKCd0Ym9keScpLmdldEl0ZW0oMCk7XG5cblx0XHRsZXQgdGFibGVIZWFkaW5nID0gdGhpcy5nZXRIZWFkaW5nKHRhYmxlKTtcblx0XHRjb25zdCBoYWRDb2xIZWFkaW5nID1cblx0XHRcdHRhYmxlSGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19DT0wgfHxcblx0XHRcdHRhYmxlSGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19CT1RIO1xuXG5cdFx0Y29uc3QgbmVlZENvbEhlYWRpbmcgPVxuXHRcdFx0aGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19DT0wgfHwgaGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19CT1RIO1xuXHRcdGNvbnN0IG5lZWRSb3dIZWFkaW5nID1cblx0XHRcdGhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfUk9XIHx8IGhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfQk9USDtcblxuXHRcdC8vIElmIHdlIG5lZWQgcm93IGhlYWRpbmcgYW5kIGRvbid0IGhhdmUgYSA8dGhlYWQ+IGVsZW1lbnQgeWV0LCBtb3ZlIHRoZVxuXHRcdC8vIGZpcnN0IHJvdyBvZiB0aGUgdGFibGUgdG8gdGhlIGhlYWQgYW5kIGNvbnZlcnQgdGhlIG5vZGVzIHRvIDx0aD4gb25lcy5cblx0XHRpZiAoIXRhYmxlLiQudEhlYWQgJiYgbmVlZFJvd0hlYWRpbmcpIHtcblx0XHRcdGNvbnN0IHRhYmxlRmlyc3RSb3cgPSB0YWJsZUJvZHkuZ2V0RWxlbWVudHNCeVRhZygndHInKS5nZXRJdGVtKDApO1xuXHRcdFx0Y29uc3QgdGFibGVGaXJzdFJvd0NoaWxkQ291bnQgPSB0YWJsZUZpcnN0Um93LmdldENoaWxkQ291bnQoKTtcblxuXHRcdFx0Ly8gQ2hhbmdlIFREIHRvIFRIOlxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHRhYmxlRmlyc3RSb3dDaGlsZENvdW50OyBpKyspIHtcblx0XHRcdFx0Y29uc3QgY2VsbCA9IHRhYmxlRmlyc3RSb3cuZ2V0Q2hpbGQoaSk7XG5cblx0XHRcdFx0Ly8gU2tpcCBib29rbWFyayBub2Rlcy4gKCM2MTU1KVxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0Y2VsbC50eXBlID09PSBDS0VESVRPUi5OT0RFX0VMRU1FTlQgJiZcblx0XHRcdFx0XHQhY2VsbC5kYXRhKCdja2UtYm9va21hcmsnKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjZWxsLnJlbmFtZU5vZGUoJ3RoJyk7XG5cdFx0XHRcdFx0Y2VsbC5zZXRBdHRyaWJ1dGUoJ3Njb3BlJywgJ2NvbCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRhYmxlSGVhZCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQodGFibGUuJC5jcmVhdGVUSGVhZCgpKTtcblx0XHRcdHRhYmxlSGVhZC5hcHBlbmQodGFibGVGaXJzdFJvdy5yZW1vdmUoKSk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZG9uJ3QgbmVlZCByb3cgaGVhZGluZyBhbmQgd2UgaGF2ZSBhIDx0aGVhZD4gZWxlbWVudCwgbW92ZSB0aGVcblx0XHQvLyByb3cgb3V0IG9mIHRoZXJlIGFuZCBpbnRvIHRoZSA8dGJvZHk+IGVsZW1lbnQuXG5cdFx0aWYgKHRhYmxlLiQudEhlYWQgIT09IG51bGwgJiYgIW5lZWRSb3dIZWFkaW5nKSB7XG5cdFx0XHQvLyBNb3ZlIHRoZSByb3cgb3V0IG9mIHRoZSBUSGVhZCBhbmQgcHV0IGl0IGluIHRoZSBUQm9keTpcblx0XHRcdHRhYmxlSGVhZCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQodGFibGUuJC50SGVhZCk7XG5cblx0XHRcdGNvbnN0IHByZXZpb3VzRmlyc3RSb3cgPSB0YWJsZUJvZHkuZ2V0Rmlyc3QoKTtcblxuXHRcdFx0d2hpbGUgKHRhYmxlSGVhZC5nZXRDaGlsZENvdW50KCkgPiAwKSB7XG5cdFx0XHRcdGNvbnN0IG5ld0ZpcnN0Um93ID0gdGFibGVIZWFkLmdldEZpcnN0KCk7XG5cdFx0XHRcdGNvbnN0IG5ld0ZpcnN0Um93Q2hpbGRDb3VudCA9IG5ld0ZpcnN0Um93LmdldENoaWxkQ291bnQoKTtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbmV3Rmlyc3RSb3dDaGlsZENvdW50OyBpKyspIHtcblx0XHRcdFx0XHRuZXdDZWxsID0gbmV3Rmlyc3RSb3cuZ2V0Q2hpbGQoaSk7XG5cblx0XHRcdFx0XHRpZiAobmV3Q2VsbC50eXBlID09PSBDS0VESVRPUi5OT0RFX0VMRU1FTlQpIHtcblx0XHRcdFx0XHRcdG5ld0NlbGwucmVuYW1lTm9kZSgndGQnKTtcblx0XHRcdFx0XHRcdG5ld0NlbGwucmVtb3ZlQXR0cmlidXRlKCdzY29wZScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG5ld0ZpcnN0Um93Lmluc2VydEJlZm9yZShwcmV2aW91c0ZpcnN0Um93KTtcblx0XHRcdH1cblxuXHRcdFx0dGFibGVIZWFkLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdHRhYmxlSGVhZGluZyA9IHRoaXMuZ2V0SGVhZGluZyh0YWJsZSk7XG5cdFx0Y29uc3QgaGFzQ29sSGVhZGluZyA9XG5cdFx0XHR0YWJsZUhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfQ09MIHx8XG5cdFx0XHR0YWJsZUhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfQk9USDtcblxuXHRcdC8vIElmIHdlIG5lZWQgY29sdW1uIGhlYWRpbmcgYW5kIHRoZSB0YWJsZSBkb2Vzbid0IGhhdmUgaXQsIGNvbnZlcnQgZXZlcnkgZmlyc3QgY2VsbCBpblxuXHRcdC8vIGV2ZXJ5IHJvdyBpbnRvIGEgYDx0aCBzY29wZT1cInJvd1wiPmAgZWxlbWVudC5cblx0XHRpZiAoIWhhc0NvbEhlYWRpbmcgJiYgbmVlZENvbEhlYWRpbmcpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCB0YWJsZS4kLnJvd3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHRhYmxlLiQucm93c1tpXS5jZWxsc1swXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAndGgnKSB7XG5cdFx0XHRcdFx0bmV3Q2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChcblx0XHRcdFx0XHRcdHRhYmxlLiQucm93c1tpXS5jZWxsc1swXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0bmV3Q2VsbC5yZW5hbWVOb2RlKCd0aCcpO1xuXHRcdFx0XHRcdG5ld0NlbGwuc2V0QXR0cmlidXRlKCdzY29wZScsICdyb3cnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIHdlIGRvbid0IG5lZWQgY29sdW1uIGhlYWRpbmcgYnV0IHRoZSB0YWJsZSBoYXMgaXQsIGNvbnZlcnQgZXZlcnkgZmlyc3QgY2VsbCBpbiBldmVyeVxuXHRcdC8vIHJvdyBiYWNrIGludG8gYSBgPHRkPmAgZWxlbWVudC5cblx0XHRpZiAoaGFkQ29sSGVhZGluZyAmJiAhbmVlZENvbEhlYWRpbmcpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCB0YWJsZS4kLnJvd3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3Qgcm93ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHRhYmxlLiQucm93c1tpXSk7XG5cblx0XHRcdFx0aWYgKHJvdy5nZXRQYXJlbnQoKS5nZXROYW1lKCkgPT09ICd0Ym9keScpIHtcblx0XHRcdFx0XHRuZXdDZWxsID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHJvdy4kLmNlbGxzWzBdKTtcblx0XHRcdFx0XHRuZXdDZWxsLnJlbmFtZU5vZGUoJ3RkJyk7XG5cdFx0XHRcdFx0bmV3Q2VsbC5yZW1vdmVBdHRyaWJ1dGUoJ3Njb3BlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQgdXNpbmcgdGhlIHBhc3NlZCB0YWcgbmFtZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX2NyZWF0ZUVsZW1lbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIHRhZyBuYW1lIGZyb20gd2hpY2ggYW4gZWxlbWVudCBzaG91bGQgYmUgY3JlYXRlZFxuXHQgKiBAcmV0dXJuIHtDS0VESVRPUi5kb20uZWxlbWVudH0gSW5zdGFuY2Ugb2YgQ0tFRElUT1IgRE9NIGVsZW1lbnQgY2xhc3Ncblx0ICovXG5cdF9jcmVhdGVFbGVtZW50KG5hbWUpIHtcblx0XHRyZXR1cm4gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KG5hbWUsIHRoaXMuX2VkaXRvci5kb2N1bWVudCk7XG5cdH0sXG59O1xuXG5DS0VESVRPUi5vbignaW5zdGFuY2VSZWFkeScsIGV2ZW50ID0+IHtcblx0Y29uc3QgaGVhZGluZ0NvbW1hbmRzID0gW1xuXHRcdFRhYmxlLkhFQURJTkdfTk9ORSxcblx0XHRUYWJsZS5IRUFESU5HX1JPVyxcblx0XHRUYWJsZS5IRUFESU5HX0NPTCxcblx0XHRUYWJsZS5IRUFESU5HX0JPVEgsXG5cdF07XG5cblx0Y29uc3QgdGFibGVVdGlscyA9IG5ldyBUYWJsZShldmVudC5lZGl0b3IpO1xuXG5cdGhlYWRpbmdDb21tYW5kcy5mb3JFYWNoKGhlYWRpbmcgPT4ge1xuXHRcdGV2ZW50LmVkaXRvci5hZGRDb21tYW5kKCd0YWJsZUhlYWRpbmcnICsgaGVhZGluZywge1xuXHRcdFx0ZXhlYyhfZWRpdG9yKSB7XG5cdFx0XHRcdHRhYmxlVXRpbHMuc2V0SGVhZGluZyhudWxsLCBoZWFkaW5nKTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cdH0pO1xufSk7XG5cbkNLRURJVE9SLlRhYmxlID0gQ0tFRElUT1IuVGFibGUgfHwgVGFibGU7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbi8qKlxuICogQ0tFRElUT1IudG9vbHMgY2xhc3MgdXRpbGl0eSB3aGljaCBhZGRzIGFkZGl0aW9uYWwgbWV0aG9kcyB0byB0aG9zZSBvZiBDS0VkaXRvci5cbiAqXG4gKiBAY2xhc3MgQ0tFRElUT1IudG9vbHNcbiAqL1xuXG4vKipcbiAqIFNlbmRzIGEgcmVxdWVzdCB1c2luZyB0aGUgSlNPTlAgdGVjaG5pcXVlLlxuICpcbiAqIEBtZW1iZXJvZiBDS0VESVRPUi50b29sc1xuICogQG1ldGhvZCBqc29ucFxuICogQHBhcmFtIHtDS0VESVRPUi50ZW1wbGF0ZX0gdXJsVGVtcGxhdGUgVGhlIHRlbXBsYXRlIG9mIHRoZSBVUkwgdG8gYmUgcmVxdWVzdGVkLiBBbGwgcHJvcGVydGllcyBwYXNzZWQgaW4gYHVybFBhcmFtc2AgY2FuIGJlIHVzZWQsIHBsdXMgYSBge2NhbGxiYWNrfWAsIHdoaWNoIHJlcHJlc2VudCBhIEpTT05QIGNhbGxiYWNrLCBtdXN0IGJlIGRlZmluZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpbiBjYXNlIG9mIHN1Y2Nlc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvckNhbGxiYWNrIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSB1cmxQYXJhbXMgUGFyYW1ldGVycyB0byBiZSBwYXNzZWQgdG8gdGhlIGB1cmxUZW1wbGF0ZWAuXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqICAtIGlkOiB0aGUgdHJhbnNhY3Rpb24gSURcbiAqICAtIGEgYGNhbmNlbCgpYCBtZXRob2RcbiAqIEBzdGF0aWNcbiAqL1xuQ0tFRElUT1IudG9vbHMuanNvbnAgPSBmdW5jdGlvbihcblx0dXJsVGVtcGxhdGUsXG5cdHVybFBhcmFtcyxcblx0Y2FsbGJhY2ssXG5cdGVycm9yQ2FsbGJhY2tcbikge1xuXHRjb25zdCBjYWxsYmFja0tleSA9IENLRURJVE9SLnRvb2xzLmdldE5leHROdW1iZXIoKTtcblxuXHR1cmxQYXJhbXMgPSB1cmxQYXJhbXMgfHwge307XG5cdHVybFBhcmFtcy5jYWxsYmFjayA9ICdDS0VESVRPUi5fLmpzb25wQ2FsbGJhY2tzWycgKyBjYWxsYmFja0tleSArICddJztcblxuXHRpZiAoIUNLRURJVE9SLl8uanNvbnBDYWxsYmFja3MpIHtcblx0XHRDS0VESVRPUi5fLmpzb25wQ2FsbGJhY2tzID0ge307XG5cdH1cblxuXHRDS0VESVRPUi5fLmpzb25wQ2FsbGJhY2tzW2NhbGxiYWNrS2V5XSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRjbGVhblVwKCk7XG5cblx0XHRcdGNhbGxiYWNrKHJlc3BvbnNlKTtcblx0XHR9KTtcblx0fTtcblxuXHRsZXQgc2NyaXB0RWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCgnc2NyaXB0Jyk7XG5cdHNjcmlwdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcmMnLCB1cmxUZW1wbGF0ZS5vdXRwdXQodXJsUGFyYW1zKSk7XG5cdHNjcmlwdEVsZW1lbnQub24oJ2Vycm9yJywgKCkgPT4ge1xuXHRcdGNsZWFuVXAoKTtcblxuXHRcdGlmIChlcnJvckNhbGxiYWNrKSB7XG5cdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBjbGVhblVwKCkge1xuXHRcdGlmIChzY3JpcHRFbGVtZW50KSB7XG5cdFx0XHRzY3JpcHRFbGVtZW50LnJlbW92ZSgpO1xuXHRcdFx0ZGVsZXRlIENLRURJVE9SLl8uanNvbnBDYWxsYmFja3NbY2FsbGJhY2tLZXldO1xuXHRcdFx0c2NyaXB0RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0Q0tFRElUT1IuZG9jdW1lbnQuZ2V0Qm9keSgpLmFwcGVuZChzY3JpcHRFbGVtZW50KTtcblxuXHRyZXR1cm4ge1xuXHRcdGNhbmNlbDogY2xlYW5VcCxcblx0XHRpZDogY2FsbGJhY2tLZXksXG5cdH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIG9mIGFsbCB0aGUgc3VwcGxpZWRcbiAqIG9iamVjdHMuIFRoZSBwcm9wZXJ0aWVzIGZyb20gbGF0ZXIgb2JqZWN0cyB3aWxsIG92ZXJ3cml0ZSB0aG9zZSBpbiBlYXJsaWVyXG4gKiBvYmplY3RzLlxuICpcbiAqIFBhc3NpbmcgaW4gYSBzaW5nbGUgb2JqZWN0IHdpbGwgY3JlYXRlIGEgc2hhbGxvdyBjb3B5IG9mIGl0LlxuICpcbiAqIEBtZW1iZXJvZiBDS0VESVRPUi50b29sc1xuICogQG1ldGhvZCBtZXJnZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdHMqIE9uZSBvciBtb3JlIG9iamVjdHMgdG8gbWVyZ2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG1lcmdlZCBvYmplY3QuXG4gKiBAc3RhdGljXG4gKi9cbkNLRURJVE9SLnRvb2xzLm1lcmdlID1cblx0Q0tFRElUT1IudG9vbHMubWVyZ2UgfHxcblx0ZnVuY3Rpb24oLi4uYXJncykge1xuXHRcdGNvbnN0IHJlc3VsdCA9IHt9O1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRjb25zdCBvYmogPSBhcmdzW2ldO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcblx0XHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcblx0XHRcdFx0XHRyZXN1bHRba2V5XSA9IG9ialtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuLyoqXG4gKiBTaW11bGF0ZXMgZXZlbnQgb24gYSBET00gZWxlbWVudC5cbiAqXG4gKiBAbWVtYmVyb2YgQ0tFRElUT1IudG9vbHNcbiAqIEBtZXRob2Qgc2ltdWxhdGVcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCBvbiB3aGljaCB0aGUgZXZlbnQgc2hvdWQgYmUgc2ltdWFsdGVkLlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBuYW1lIG9mIHRoZSBldmVudCB3aGljaCBoYXZlIHRvIGJlIHNpbXVsYXRlZC5cbiAqIEBzdGF0aWNcbiAqL1xuQ0tFRElUT1IudG9vbHMuc2ltdWxhdGUgPSBmdW5jdGlvbihlbGVtZW50LCBldmVudCkge1xuXHRjb25zdCBldmVudEluc3RhbmNlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50cycpO1xuXHRldmVudEluc3RhbmNlLmluaXRFdmVudChldmVudCwgdHJ1ZSwgZmFsc2UpO1xuXHRlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnRJbnN0YW5jZSk7XG59O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV91aWNvcmUnKSkge1xuXHQvKipcblx0ICogVUlDb3JlIGNsYXNzIHdoaWNoIHdpbGwgaGFuZGxlIHVzZXIgaW50ZXJhY3Rpb25zIHdpdGggdGhlIGVkaXRvci4gVGhlc2UgaW50ZXJhY3Rpb25zXG5cdCAqIG1pZ2h0IGJlIHRyaWdnZXJlZCB2aWEgbW91c2UsIGtleWJvYXJkIG9yIHRvdWNoIGRldmljZXMuIFRoZSBjbGFzcyBmaWxsIGZpcmUgYW4gZXZlbnQgdmlhXG5cdCAqIENLRWRpdG9yJ3MgZXZlbnQgc3lzdGVtIC0gXCJlZGl0b3JJbnRlcmFjdGlvblwiLiBUaGUgVUkgbWF5IGxpc3RlbiB0byB0aGlzIGV2ZW50IGFuZFxuXHQgKiBleGVjdXRlIHNvbWUgYWN0aW9ucyAtIGZvciBleGFtcGxlIHRvIHNob3cvaGlkZSB0b29sYmFycy5cblx0ICpcblx0ICogQnkgZGVmYXVsdCBpZiB1c2VyIHByZXNzZXMgdGhlIEVzYyBrZXksICdlZGl0b3JJbnRlcmFjdGlvbicgZXZlbnQgd29uJ3QgYmUgZmlyZWQuIEhvd2V2ZXIsIHRoaXMgYmVoYXZpb3VyIGNhbiBiZSBjaGFuZ2VkXG5cdCAqIGJ5IHNldHRpbmcge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV91aWNvcmUvYWxsb3dFc2M6YXR0cmlidXRlXCJ9fXt7L2Nyb3NzTGlua319IGNvbmZpZyBwcm9wZXJ0eSBpbiBlZGl0b3IncyBjb25maWd1cmF0aW9uIHRvIHRydWUuXG5cdCAqXG5cdCAqIEBjbGFzcyBhZV91aWNvcmVcblx0ICovXG5cblx0LyoqXG5cdCAqIEZpcmVkIHdoZW4gdXNlciBpbnRlcmFjdHMgc29tZWhvdyB3aXRoIHRoZSBicm93c2VyLiBUaGlzIG1heSBiZSBjbGlja2luZyB3aXRoIHRoZSBtb3VzZSwgcHJlc3Npbmcga2V5Ym9hcmQgYnV0dG9uLFxuXHQgKiBvciB0b3VjaGluZyBzY3JlZW4uIFRoaXMgZXZlbiB3aWxsIGJlIG5vdCBmaXJlZCBhZnRlciBlYWNoIGludGVyYWN0aW9uLiBJdCB3aWxsIGJlIGRlYm91bmNlZC4gQnkgZGVmYXVsdCB0aGUgdGltZW91dFxuXHQgKiBpcyA1MG1zLiBUaGlzIHZhbHVlIGNhbiBiZSBvdmVyd3JpdHRlbiB2aWEge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV91aWNvcmUvdGltZW91dDphdHRyaWJ1dGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogcHJvcGVydHkgb2YgZWRpdG9yJ3MgY29uZmlndXJhdGlvbiwgbGlrZTogZWRpdG9yLmNvbmZpZy51aWNvcmUudGltZW91dCA9IDEwMFxuXHQgKlxuXHQgKiBAbWVtYmVyb2YgYWVfdWljb3JlXG5cdCAqIEBldmVudCBhZV91aWNvcmUjZWRpdG9ySW50ZXJhY3Rpb25cblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0ICogLSBuYXRpdmVFdmVudCAtIFRoZSBldmVudCBhcyByZWNlaXZlZCBmcm9tIENLRWRpdG9yLlxuXHQgKiAtIHNlbGVjdGlvbkRhdGEgLSBUaGUgZGF0YSwgcmV0dXJuZWQgZnJvbSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRTZWxlY3Rpb25EYXRhOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKi9cblxuXHQvKipcblx0ICogRmlyZWQgYnkgVUkgZWxlbWVudHMgbGlrZSBUb29sYmFycyBvciBCdXR0b25zIHdoZW4gdGhlaXIgc3RhdGUgY2hhbmdlcy4gVGhlIGxpc3RlbmVyIHVwZGF0ZXMgdGhlIGxpdmUgcmVnaW9uIHdpdGggdGhlIHByb3ZpZGVkIGRhdGEuXG5cdCAqXG5cdCAqIEBtZW1iZXJvZiBhZV91aWNvcmVcblx0ICogQGV2ZW50IGFlX3VpY29yZSNhcmlhVXBkYXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFuIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cdCAqIC0gbWVzc2FnZSAtIFRoZSBwcm92aWRlZCBtZXNzYWdlIGZyb20gdGhlIFVJIGVsZW1lbnQuXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGVkaXRvciB3aWxsIHN0aWxsIGZpcmUge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV91aWNvcmUvZWRpdG9ySW50ZXJhY3Rpb246ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQsXG5cdCAqIGlmIHVzZXIgcHJlc3NlcyBFc2Mga2V5LlxuXHQgKlxuXHQgKiBAbWVtYmVyb2YgYWVfdWljb3JlXG5cdCAqIEBhdHRyaWJ1dGUgYWxsb3dFc2Ncblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICogQHR5cGUgQm9vbGVhblxuXHQgKi9cblxuXHQvKipcblx0ICogU3BlY2lmaWVzIHRoZSBkZWZhdWx0IHRpbWVvdXQgYWZ0ZXIgd2hpY2ggdGhlIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfdWljb3JlL2VkaXRvckludGVyYWN0aW9uOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50XG5cdCAqIHdpbGwgYmUgZmlyZWQuXG5cdCAqXG5cdCAqIEBtZW1iZXJvZiBhZV91aWNvcmVcblx0ICogQGF0dHJpYnV0ZSB0aW1lb3V0XG5cdCAqIEBkZWZhdWx0IDUwIChtcylcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXG5cdENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV91aWNvcmUnLCB7XG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZXIgbGlmZWN5Y2xlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgVUlDb3JlIHBsdWdpbi5cblx0XHQgKlxuXHRcdCAqIEBtZW1iZXJvZiBhZV91aWNvcmVcblx0XHQgKiBAbWV0aG9kIGluaXRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IENLRWRpdG9yIGluc3RhbmNlLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRpbml0KGVkaXRvcikge1xuXHRcdFx0bGV0IGFyaWFTdGF0ZSA9IFtdO1xuXG5cdFx0XHRjb25zdCBhcmlhRWxlbWVudCA9IHRoaXMuX2NyZWF0ZUFyaWFFbGVtZW50KGVkaXRvci5pZCk7XG5cblx0XHRcdGNvbnN0IHVpVGFza3NUaW1lb3V0ID0gZWRpdG9yLmNvbmZpZy51aWNvcmVcblx0XHRcdFx0PyBlZGl0b3IuY29uZmlnLnVpY29yZS50aW1lb3V0XG5cdFx0XHRcdDogNTA7XG5cblx0XHRcdGNvbnN0IGhhbmRsZVVJID0gQ0tFRElUT1IudG9vbHMuZGVib3VuY2UoZXZlbnQgPT4ge1xuXHRcdFx0XHRhcmlhU3RhdGUgPSBbXTtcblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ZXZlbnQubmFtZSAhPT0gJ2tleXVwJyB8fFxuXHRcdFx0XHRcdGV2ZW50LmRhdGEuJC5rZXlDb2RlICE9PSAyNyB8fFxuXHRcdFx0XHRcdGVkaXRvci5jb25maWcuYWxsb3dFc2Ncblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uRGF0YSA9IGVkaXRvci5nZXRTZWxlY3Rpb25EYXRhKCk7XG5cblx0XHRcdFx0XHRpZiAoc2VsZWN0aW9uRGF0YSkge1xuXHRcdFx0XHRcdFx0ZWRpdG9yLmZpcmUoJ2VkaXRvckludGVyYWN0aW9uJywge1xuXHRcdFx0XHRcdFx0XHRuYXRpdmVFdmVudDogZXZlbnQuZGF0YS4kLFxuXHRcdFx0XHRcdFx0XHRzZWxlY3Rpb25EYXRhLFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LCB1aVRhc2tzVGltZW91dCk7XG5cblx0XHRcdGNvbnN0IGhhbmRsZUFyaWEgPSBDS0VESVRPUi50b29scy5kZWJvdW5jZShfZXZlbnQgPT4ge1xuXHRcdFx0XHRhcmlhRWxlbWVudC5pbm5lckhUTUwgPSBhcmlhU3RhdGUuam9pbignLiAnKTtcblx0XHRcdH0sIHVpVGFza3NUaW1lb3V0KTtcblxuXHRcdFx0Y29uc3QgaGFuZGxlTW91c2VMZWF2ZSA9IENLRURJVE9SLnRvb2xzLmRlYm91bmNlKGV2ZW50ID0+IHtcblx0XHRcdFx0Y29uc3QgYWVVSU5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmFlLXVpJyk7XG5cblx0XHRcdFx0bGV0IGZvdW5kO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYWVVSU5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGFlVUlOb2Rlc1tpXS5jb250YWlucyhldmVudC5kYXRhLiQucmVsYXRlZFRhcmdldCkpIHtcblx0XHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghZm91bmQpIHtcblx0XHRcdFx0XHRoYW5kbGVVSShldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHVpVGFza3NUaW1lb3V0KTtcblxuXHRcdFx0ZWRpdG9yLm9uKCdhcmlhVXBkYXRlJywgZXZlbnQgPT4ge1xuXHRcdFx0XHQvLyBoYW5kbGVBcmlhIGlzIGRlYm91bmNlZCBmdW5jdGlvbiwgc28gaWYgaXQgaXMgYmVpbmcgY2FsbGVkIG11bHRpcGxlIHRpbWVzLCBpdCB3aWxsXG5cdFx0XHRcdC8vIGJlIGNhbmNlbGVkIHVudGlsIHNvbWUgdGltZSBwYXNzZXMuXG5cdFx0XHRcdC8vIEZvciB0aGF0IHJlYXNvbiBoZXJlIHdlIGV4cGxpY2l0bHkgYXBwZW5kIHRoZSBjdXJyZW50IG1lc3NhZ2UgdG8gdGhlIGxpc3Qgb2YgbWVzc2FnZXNcblx0XHRcdFx0Ly8gYW5kIGNhbGwgaGFuZGxlQXJpYS4gU2luY2UgaXQgaXMgZGVib3VuY2VkLCB3aGVuIHNvbWUgdGltZW91dCBwYXNzZXMsXG5cdFx0XHRcdC8vIGFsbCB0aGUgbWVzc2FnZXMgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBsaXZlIHJlZ2lvbiBhbmQgbm90IG9ubHkgdGhlIGxhc3Qgb25lLlxuXG5cdFx0XHRcdGFyaWFTdGF0ZS5wdXNoKGV2ZW50LmRhdGEubWVzc2FnZSk7XG5cblx0XHRcdFx0aGFuZGxlQXJpYSgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGVkaXRvci5vbmNlKCdjb250ZW50RG9tJywgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRcdGNvbnN0IGZvY3VzSGFuZGxlciA9IGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKFxuXHRcdFx0XHRcdGVkaXRhYmxlLFxuXHRcdFx0XHRcdCdmb2N1cycsXG5cdFx0XHRcdFx0ZXZlbnQgPT4ge1xuXHRcdFx0XHRcdFx0Zm9jdXNIYW5kbGVyLnJlbW92ZUxpc3RlbmVyKCk7XG5cblx0XHRcdFx0XHRcdGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKGVkaXRhYmxlLCAna2V5dXAnLCBoYW5kbGVVSSk7XG5cdFx0XHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ21vdXNldXAnLCBoYW5kbGVVSSk7XG5cdFx0XHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0XHRcdFx0ZWRpdGFibGUsXG5cdFx0XHRcdFx0XHRcdCdtb3VzZWxlYXZlJyxcblx0XHRcdFx0XHRcdFx0aGFuZGxlTW91c2VMZWF2ZVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0aGFuZGxlVUkoZXZlbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRlZGl0b3Iub24oJ2Rlc3Ryb3knLCBfZXZlbnQgPT4ge1xuXHRcdFx0XHRhcmlhRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGFyaWFFbGVtZW50KTtcblxuXHRcdFx0XHRoYW5kbGVVSS5kZXRhY2goKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGFuZCBhcHBsaWVzIGFuIEhUTUwgZWxlbWVudCB0byB0aGUgYm9keSBvZiB0aGUgZG9jdW1lbnQgd2hpY2ggd2lsbCBjb250YWluIEFSSUEgbWVzc2FnZXMuXG5cdFx0ICpcblx0XHQgKiBAbWVtYmVyb2YgYWVfdWljb3JlXG5cdFx0ICogQG1ldGhvZCBfY3JlYXRlQXJpYUVsZW1lbnRcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIHByb3ZpZGVkIGlkIG9mIHRoZSBlbGVtZW50LiBJdCB3aWxsIGJlIHVzZWQgYXMgcHJlZml4IGZvciB0aGUgZmluYWwgZWxlbWVudCBJZC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFRoZSBjcmVhdGVkIGFuZCBhcHBsaWVkIHRvIERPTSBlbGVtZW50LlxuXHRcdCAqL1xuXHRcdF9jcmVhdGVBcmlhRWxlbWVudChpZCkge1xuXHRcdFx0Y29uc3Qgc3RhdHVzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG5cdFx0XHRzdGF0dXNFbGVtZW50LmNsYXNzTmFtZSA9ICdhZS1zci1vbmx5JztcblxuXHRcdFx0c3RhdHVzRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdwb2xpdGUnKTtcblx0XHRcdHN0YXR1c0VsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3N0YXR1cycpO1xuXHRcdFx0c3RhdHVzRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQgKyAnTGl2ZVJlZ2lvbicpO1xuXG5cdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXR1c0VsZW1lbnQpO1xuXG5cdFx0XHRyZXR1cm4gc3RhdHVzRWxlbWVudDtcblx0XHR9LFxuXHR9KTtcbn1cbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IExhbmcgZnJvbSAnLi9sYW5nJztcblxuLyoqXG4gKiBBdHRyaWJ1dGUgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGNsYXNzIEF0dHJpYnV0ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEF0dHJpYnV0ZShjb25maWcpIHtcblx0dGhpcy5fX2NvbmZpZ19fID0gY29uZmlnIHx8IHt9O1xuXHR0aGlzLl9fQVRUUlNfXyA9IHt9O1xufVxuXG5BdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogQXR0cmlidXRlLFxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBBdHRyaWJ1dGVcblx0ICogQG1ldGhvZCBnZXRcblx0ICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgVGhlIGF0dHJpYnV0ZSB3aGljaCB2YWx1ZSBzaG91bGQgYmUgcmV0cmlldmVkLlxuXHQgKiBAcmV0dXJuIHtBbnl9IFRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLlxuXHQgKi9cblx0Z2V0KGF0dHIpIHtcblx0XHRjb25zdCBjdXJyZW50QXR0ciA9IHRoaXMuY29uc3RydWN0b3IuQVRUUlNbYXR0cl07XG5cblx0XHRpZiAoIWN1cnJlbnRBdHRyKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9pc0luaXRpYWxpemVkKGF0dHIpKSB7XG5cdFx0XHR0aGlzLl9pbml0KGF0dHIpO1xuXHRcdH1cblxuXHRcdGxldCBjdXJWYWx1ZSA9IHRoaXMuX19BVFRSU19fW2F0dHJdO1xuXG5cdFx0aWYgKGN1cnJlbnRBdHRyLmdldHRlcikge1xuXHRcdFx0Y3VyVmFsdWUgPSB0aGlzLl9jYWxsU3RyaW5nT3JGdW5jdGlvbihjdXJyZW50QXR0ci5nZXR0ZXIsIGN1clZhbHVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY3VyVmFsdWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBBdHRyaWJ1dGVcblx0ICogQG1ldGhvZCBzZXRcblx0ICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgVGhlIGF0dHJpYnV0ZSB3aGljaCB2YWx1ZSBzaG91bGQgYmUgc2V0LlxuXHQgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIHNob3VsZCBiZSBzZXQgdG8gdGhlIGF0dHJpYnV0ZS5cblx0ICovXG5cdHNldChhdHRyLCB2YWx1ZSkge1xuXHRcdGNvbnN0IGN1cnJlbnRBdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5BVFRSU1thdHRyXTtcblxuXHRcdGlmICghY3VycmVudEF0dHIpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQoYXR0cikpIHtcblx0XHRcdHRoaXMuX2luaXQoYXR0cik7XG5cdFx0fVxuXG5cdFx0aWYgKGN1cnJlbnRBdHRyLnJlYWRPbmx5KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGN1cnJlbnRBdHRyLndyaXRlT25jZSAmJiB0aGlzLl9pc0luaXRpYWxpemVkKGF0dHIpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0Y3VycmVudEF0dHIudmFsaWRhdG9yICYmXG5cdFx0XHQhdGhpcy5fY2FsbFN0cmluZ09yRnVuY3Rpb24oY3VycmVudEF0dHIudmFsaWRhdG9yLCB2YWx1ZSlcblx0XHQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoY3VycmVudEF0dHIuc2V0dGVyKSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMuX2NhbGxTdHJpbmdPckZ1bmN0aW9uKGN1cnJlbnRBdHRyLnNldHRlciwgdmFsdWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX19BVFRSU19fW2F0dHJdID0gdmFsdWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENhbGxzIHRoZSBwcm92aWRlZCBwYXJhbSBhcyBmdW5jdGlvbiB3aXRoIHRoZSBzdXBwbGllZCBhcmd1bWVudHMuXG5cdCAqIElmIHBhcmFtIHByb3ZpZGVkIGFzIHN0cmluZywgYSBjb3JyZXNwb25kaW5nIGZ1bmN0aW9uIGluIHRoaXMgb2JqZWN0IHdpbGxcblx0ICogYmUgY2FsbGVkLiBJZiBwcm92aWRlZCBwYXJhbSBpcyBhIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGRpcmVjdGx5IGNhbGxlZC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBBdHRyaWJ1dGVcblx0ICogQG1ldGhvZCBfY2FsbFN0cmluZ09yRnVuY3Rpb25cblx0ICogQHBhcmFtICB7QW55fEFycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgd2hpY2ggd2lsbCBiZSBwcm92aWRlZCB0byB0aGUgY2FsbGVkIGZ1bmN0aW9uXG5cdCAqIEBwYXJhbSAge1N0cmluZ3xGdW5jdGlvbn0gc3RyaW5nT3JGdW5jdGlvbiBUaGUgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIGJlIGNhbGxlZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0FueX0gVGhlIHJldHVybmVkIHZhbHVlIGZyb20gdGhlIGNhbGxlZCBmdW5jdGlvblxuXHQgKi9cblx0X2NhbGxTdHJpbmdPckZ1bmN0aW9uKHN0cmluZ09yRnVuY3Rpb24sIGFyZ3MpIHtcblx0XHRsZXQgcmVzdWx0ID0gbnVsbDtcblxuXHRcdGlmICghTGFuZy5pc0FycmF5KGFyZ3MpKSB7XG5cdFx0XHRhcmdzID0gW2FyZ3NdO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdExhbmcuaXNTdHJpbmcoc3RyaW5nT3JGdW5jdGlvbikgJiZcblx0XHRcdExhbmcuaXNGdW5jdGlvbih0aGlzW3N0cmluZ09yRnVuY3Rpb25dKVxuXHRcdCkge1xuXHRcdFx0cmVzdWx0ID0gdGhpc1tzdHJpbmdPckZ1bmN0aW9uXSguLi5hcmdzKTtcblx0XHR9IGVsc2UgaWYgKExhbmcuaXNGdW5jdGlvbihzdHJpbmdPckZ1bmN0aW9uKSkge1xuXHRcdFx0cmVzdWx0ID0gc3RyaW5nT3JGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyBhbiBhdHRyaWJ1dGUuIFNldHMgaXRzIGRlZmF1bHQgdmFsdWUgZGVwZW5kaW5nIG9uIHRoZSBmbGFncyBvZiB0aGVcblx0ICogYXR0cmlidXRlIGFuZCB0aGUgcGFzc2VkIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHRvIHRoZSBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBBdHRyaWJ1dGVcblx0ICogQG1ldGhvZCBfaW5pdFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHdoaWNoIGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9pbml0KGF0dHIpIHtcblx0XHRsZXQgdmFsdWU7XG5cblx0XHRjb25zdCBjdXJyZW50QXR0ciA9IHRoaXMuY29uc3RydWN0b3IuQVRUUlNbYXR0cl07XG5cblx0XHQvLyBDaGVjayBpZiB0aGVyZSBpcyBkZWZhdWx0IHZhbHVlIG9yIHBhc3NlZCBvbmUgdmlhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG5cdFx0Y29uc3QgaGFzRGVmYXVsdFZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuXHRcdFx0Y3VycmVudEF0dHIsXG5cdFx0XHQndmFsdWUnXG5cdFx0KTtcblx0XHRjb25zdCBoYXNQYXNzZWRWYWx1ZVZpYUNvbmZpZyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcblx0XHRcdHRoaXMuX19jb25maWdfXyxcblx0XHRcdGF0dHJcblx0XHQpO1xuXG5cdFx0Ly8gSWYgdGhlcmUgaXMgdmFsdWVGbiwgc2V0IHRoZSB2YWx1ZSB0byBiZSB0aGUgcmVzdWx0IG9mIGludm9jYXRpb24gb2YgdGhpcyBmdW5jdGlvblxuXHRcdGlmIChjdXJyZW50QXR0ci52YWx1ZUZuKSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMuX2NhbGxTdHJpbmdPckZ1bmN0aW9uKGN1cnJlbnRBdHRyLnZhbHVlRm4sIHZhbHVlKTtcblxuXHRcdFx0dGhpcy5fX0FUVFJTX19bYXR0cl0gPSB2YWx1ZTtcblx0XHR9XG5cdFx0Ly8gZWxzZSBpZiB0aGUgYXR0cmlidXRlIGhhcyByZWFkT25seSBmbGFnLCBzZXQgdGhlIGRlZmF1bHQgdmFsdWUgZnJvbSB0aGUgYXR0cmlidXRlLFxuXHRcdC8vIHJlZ2FyZGxlc3MgaWYgdGhlcmUgaXMgdmFsdWUgb3Igbm90XG5cdFx0ZWxzZSBpZiAoY3VycmVudEF0dHIucmVhZE9ubHkpIHtcblx0XHRcdHZhbHVlID0gY3VycmVudEF0dHIudmFsdWU7XG5cdFx0fVxuXHRcdC8vIGVsc2UgaWYgdGhlIGF0dHJpYnV0ZSBoYXMgd3JpdGVPbmNlIHZhbHVlLCBzZXQgaXQgZnJvbSB0aGUgcGFzc2VkIGNvbmZpZ3VyYXRpb24gb3IgZnJvbSB0aGVcblx0XHQvLyBkZWZhdWx0IHZhbHVlLCBpbiB0aGlzIG9yZGVyLiBPdGhlcndpc2UsIHJldHVybiBtaXNlcmFibGUuXG5cdFx0ZWxzZSBpZiAoY3VycmVudEF0dHIud3JpdGVPbmNlKSB7XG5cdFx0XHRpZiAoaGFzUGFzc2VkVmFsdWVWaWFDb25maWcpIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLl9fY29uZmlnX19bYXR0cl07XG5cdFx0XHR9IGVsc2UgaWYgKGhhc0RlZmF1bHRWYWx1ZSkge1xuXHRcdFx0XHR2YWx1ZSA9IGN1cnJlbnRBdHRyLnZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBUaGVzZSB0d28gY2FzZXMgYmVsb3cgYXJlIGVhc3kgLSBzZXQgdGhlIHZhbHVlIHRvIGJlIGZyb20gdGhlIHBhc3NlZCBjb25maWcgb3Jcblx0XHQvLyBmcm9tIHRoZSBkZWZhdWx0IHZhbHVlLCBpbiB0aGlzIG9yZGVyLlxuXHRcdGVsc2UgaWYgKGhhc1Bhc3NlZFZhbHVlVmlhQ29uZmlnKSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMuX19jb25maWdfX1thdHRyXTtcblx0XHR9IGVsc2UgaWYgKGhhc0RlZmF1bHRWYWx1ZSkge1xuXHRcdFx0dmFsdWUgPSBjdXJyZW50QXR0ci52YWx1ZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBpcyB2YWxpZGF0b3IsIGFuZCB1c2VyIHBhc3NlZCBjb25maWcgb2JqZWN0IC0gY2hlY2sgdGhlIHJldHVybmVkIHZhbHVlLlxuXHRcdC8vIElmIGl0IGlzIGZhbHNlLCB0aGVuIHNldCBhcyBpbml0aWFsIHZhbHVlIHRoZSBkZWZhdWx0IG9uZS5cblx0XHQvLyBIb3dldmVyLCBpZiB0aGVyZSBpcyBubyBkZWZhdWx0IHZhbHVlLCBqdXN0IHJldHVybi5cblx0XHRpZiAoXG5cdFx0XHRjdXJyZW50QXR0ci52YWxpZGF0b3IgJiZcblx0XHRcdGhhc1Bhc3NlZFZhbHVlVmlhQ29uZmlnICYmXG5cdFx0XHQhdGhpcy5fY2FsbFN0cmluZ09yRnVuY3Rpb24oY3VycmVudEF0dHIudmFsaWRhdG9yLCB2YWx1ZSlcblx0XHQpIHtcblx0XHRcdGlmIChoYXNEZWZhdWx0VmFsdWUpIHtcblx0XHRcdFx0dmFsdWUgPSBjdXJyZW50QXR0ci52YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBpcyBzZXR0ZXIgYW5kIHVzZXIgcGFzc2VkIGNvbmZpZyBvYmplY3QgLSBwYXNzIHRoZSB2YWx1ZSB0aG91Z2h0IHRoZSBzZXR0ZXIuXG5cdFx0Ly8gVGhlIHZhbHVlIG1pZ2h0IGJlIG9uZSBmcm9tIGRlZmF1bHRGbiwgZGVmYXVsdCB2YWx1ZSBvciBwcm92aWRlZCBmcm9tIHRoZSBjb25maWcuXG5cdFx0aWYgKGN1cnJlbnRBdHRyLnNldHRlciAmJiBoYXNQYXNzZWRWYWx1ZVZpYUNvbmZpZykge1xuXHRcdFx0dmFsdWUgPSB0aGlzLl9jYWxsU3RyaW5nT3JGdW5jdGlvbihjdXJyZW50QXR0ci5zZXR0ZXIsIHZhbHVlKTtcblx0XHR9XG5cblx0XHQvLyBGaW5hbGx5LCBzZXQgdGhlIHZhbHVlIGFzIGluaXRpYWwgdmFsdWUgdG8gdGhlIHN0b3JhZ2Ugd2l0aCB2YWx1ZXMuXG5cdFx0dGhpcy5fX0FUVFJTX19bYXR0cl0gPSB2YWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGFuIGF0dHJpYnV0ZSBpcyBpbml0aWFsaXplZC4gQW4gYXR0cmlidXRlIGlzIGNvbnNpZGVyZWQgYXMgaW5pdGlhbGl6ZWRcblx0ICogd2hlbiB0aGVyZSBpcyBhbiBvd24gcHJvcGVydHkgd2l0aCB0aGlzIG5hbWUgaW4gdGhlIGxvY2FsIGNvbGxlY3Rpb24gb2YgYXR0cmlidXRlIHZhbHVlc1xuXHQgKiBmb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQXR0cmlidXRlXG5cdCAqIEBtZXRob2QgX2lzSW5pdGlhbGl6ZWRcblx0ICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgVGhlIGF0dHJpYnV0ZSB3aGljaCBzaG91bGQgYmUgY2hlY2tlZCBpZiBpdCBpcyBpbml0aWFsaXplZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGF0dHJpYnV0ZSBoYXMgYmVlbiBpbml0aWFsaXplZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cblx0X2lzSW5pdGlhbGl6ZWQoYXR0cikge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fX0FUVFJTX18sIGF0dHIpO1xuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQXR0cmlidXRlO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgQXR0cmlidXRlIGZyb20gJy4vYXR0cmlidXRlJztcbmltcG9ydCBMYW5nIGZyb20gJy4vbGFuZyc7XG5pbXBvcnQgZXh0ZW5kIGZyb20gJy4vb29wJztcblxuLyoqXG4gKiBRdWljayBhbmQgZGlydHkgaW1wbCBvZiBCYXNlIGNsYXNzLlxuICpcbiAqIEBjbGFzcyBCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQmFzZShjb25maWcpIHtcblx0QmFzZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgY29uZmlnKTtcblxuXHR0aGlzLmluaXQoY29uZmlnKTtcbn1cblxuZXh0ZW5kKEJhc2UsIEF0dHJpYnV0ZSwge1xuXHQvKipcblx0ICogQ2FsbHMgdGhlIGBpbml0aWFsaXplcmAgbWV0aG9kIG9mIGVhY2ggY2xhc3Mgd2hpY2ggZXh0ZW5kcyBCYXNlIHN0YXJ0aW5nIGZyb20gdGhlIHBhcmVudCB0byB0aGUgY2hpbGQuXG5cdCAqIFdpbGwgcGFzcyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgdG8gZWFjaCBpbml0aWFsaXplciBtZXRob2QuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQmFzZVxuXHQgKiBAbWV0aG9kIGluaXRcblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdFxuXHQgKi9cblx0aW5pdChjb25maWcpIHtcblx0XHR0aGlzLl9jYWxsQ2hhaW4oJ2luaXRpYWxpemVyJywgY29uZmlnKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2FsbHMgdGhlIGBkZXN0cnVjdG9yYCBtZXRob2Qgb2YgZWFjaCBjbGFzcyB3aGljaCBleHRlbmRzIEJhc2Ugc3RhcnRpbmcgZnJvbSB0aGUgcGFyZW50IHRvIHRoZSBjaGlsZC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCYXNlXG5cdCAqIEBtZXRob2QgZGVzdHJveVxuXHQgKi9cblx0ZGVzdHJveSgpIHtcblx0XHR0aGlzLl9jYWxsQ2hhaW4oJ2Rlc3RydWN0b3InKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2FsbHMgYSBtZXRob2Qgb2YgZWFjaCBjbGFzcywgd2hpY2ggaXMgYmVpbmcgcHJlc2VudCBpbiB0aGUgaGllcmFyY2h5IHN0YXJ0aW5nIGZyb20gcGFyZW50IHRvIHRoZSBjaGlsZC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCYXNlXG5cdCAqIEBtZXRob2QgX2NhbGxDaGFpblxuXHQgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHdpdGggd2hpY2ggdGhlIG1ldGhvZCBzaG91bGQgYmUgaW52b2tlZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gd2F0ICBUaGUgbWV0aG9kLCB3aGljaCBzaG91bGQgYmUgaW52b2tlZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfY2FsbENoYWluKHdhdCwgYXJncykge1xuXHRcdGxldCBhcnIgPSBbXTtcblxuXHRcdGxldCBjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcblxuXHRcdHdoaWxlIChjdG9yKSB7XG5cdFx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKGN0b3IucHJvdG90eXBlW3dhdF0pKSB7XG5cdFx0XHRcdGFyci5wdXNoKGN0b3IucHJvdG90eXBlW3dhdF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRjdG9yID0gY3Rvci5zdXBlcmNsYXNzID8gY3Rvci5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yIDogbnVsbDtcblx0XHR9XG5cblx0XHRhcnIgPSBhcnIucmV2ZXJzZSgpO1xuXG5cdFx0YXJncyA9IExhbmcuaXNBcnJheShhcmdzKSA/IGFyZ3MgOiBbYXJnc107XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgaXRlbSA9IGFycltpXTtcblxuXHRcdFx0aXRlbS5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHR9XG5cdH0sXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQmFzZTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuLyoqXG4gKiBQcm92aWRlcyBjb3JlIGxhbmd1YWdlIHV0aWxpdGllcy5cbiAqXG4gKiBAY2xhc3MgTGFuZ1xuICovXG5jb25zdCBMYW5nID0ge1xuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhbiBhcnJheS5cblx0ICpcblx0ICogQG1lbWJlcm9mIExhbmdcblx0ICogQG1ldGhvZCBpc0FycmF5XG5cdCAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggaGF2ZSB0byBiZSBjaGVja2VkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gYXJyYXksIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0aXNBcnJheSh2YWx1ZSkge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGJvb2xlYW4uXG5cdCAqXG5cdCAqIEBtZW1iZXJvZiBMYW5nXG5cdCAqIEBtZXRob2QgaXNCb29sZWFuXG5cdCAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggaGF2ZSB0byBiZSBjaGVja2VkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYm9vbGVhbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRpc0Jvb2xlYW4odmFsdWUpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBmdW5jdGlvbi5cblx0ICpcblx0ICogQG1lbWJlcm9mIExhbmdcblx0ICogQG1ldGhvZCBpc0Z1bmN0aW9uXG5cdCAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggaGF2ZSB0byBiZSBjaGVja2VkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBmdW5jdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRpc0Z1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBOVUxMLlxuXHQgKlxuXHQgKiBAbWVtYmVyb2YgTGFuZ1xuXHQgKiBAbWV0aG9kIGlzTnVsbFxuXHQgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIGhhdmUgdG8gYmUgY2hlY2tlZC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIE5VTEwsIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0aXNOdWxsKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlID09PSBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIG51bWJlci5cblx0ICpcblx0ICogQG1lbWJlcm9mIExhbmdcblx0ICogQG1ldGhvZCBpc051bWJlclxuXHQgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIGhhdmUgdG8gYmUgY2hlY2tlZC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRpc051bWJlcih2YWx1ZSkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhbiBvYmplY3Rcblx0ICpcblx0ICogQG1lbWJlcm9mIExhbmdcblx0ICogQG1ldGhvZCBpc09iamVjdFxuXHQgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIGhhdmUgdG8gYmUgY2hlY2tlZC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRpc09iamVjdCh2YWx1ZSkge1xuXHRcdGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdHJldHVybiB2YWx1ZSAmJiAodmFsdWVUeXBlID09PSAnb2JqZWN0JyB8fCBMYW5nLmlzRnVuY3Rpb24odmFsdWUpKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIHN0cmluZy5cblx0ICpcblx0ICogQG1lbWJlcm9mIExhbmdcblx0ICogQG1ldGhvZCBpc1N0cmluZ1xuXHQgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIGhhdmUgdG8gYmUgY2hlY2tlZC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgc3RyaW5nLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdGlzU3RyaW5nKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFkZHMgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc3VwcGxpZXIgdG8gdGhlIHJlY2VpdmVyLlxuXHQgKiBUaGUgZnVuY3Rpb24gd2lsbCBhZGQgYWxsIHByb3BlcnRpZXMsIG5vdCBvbmx5IHRoZXNlIG93bmVkIGJ5IHRoZSBzdXBwbGllci5cblx0ICpcblx0ICogQG1lbWJlcm9mIExhbmdcblx0ICogQG1ldGhvZCBtaXhcblx0ICogQHBhcmFtIHtPYmplY3R9IHJlY2VpdmVyIFRoZSBvYmplY3Qgd2hpY2ggd2lsbCByZWNlaXZlIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdXBwbGllciBUaGUgb2JqZWN0IHdoaWNoIHByb3ZpZGVzIHByb3BlcnRpZXMuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1vZGlmaWVkIHJlY2VpdmVyLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRtaXgocmVjZWl2ZXIsIHN1cHBsaWVyKSB7XG5cdFx0Y29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gc3VwcGxpZXIpIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHN1cHBsaWVyLCBrZXkpKSB7XG5cdFx0XHRcdHJlY2VpdmVyW2tleV0gPSBzdXBwbGllcltrZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQ29udmVydHMgdmFsdWUgdG8gSW50ZWdlci5cblx0ICpcblx0ICogQG1lbWJlcm9mIExhbmdcblx0ICogQG1ldGhvZCB0b0ludFxuXHQgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIGhhdmUgdG8gYmUgY29udmVydGVkIHRvIEludGVnZXIuXG5cdCAqIEByZXR1cm4ge0ludGVnZXJ9IFRoZSBjb252ZXJ0ZWQgdmFsdWUuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHRvSW50KHZhbHVlKSB7XG5cdFx0cmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBMYW5nO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgTGFuZyBmcm9tICcuL2xhbmcnO1xuXG4vKipcbiAqIFNldHMgdGhlIHByb3RvdHlwZSwgY29uc3RydWN0b3IgYW5kIHN1cGVyY2xhc3MgcHJvcGVydGllcyB0byBzdXBwb3J0IGFuIGluaGVyaXRhbmNlIHN0cmF0ZWd5XG4gKiB0aGF0IGNhbiBjaGFpbiBjb25zdHJ1Y3RvcnMgYW5kIG1ldGhvZHMuIFN0YXRpYyBtZW1iZXJzIHdpbGwgbm90IGJlIGluaGVyaXRlZC5cbiAqXG4gKiBAbWVtYmVyb2YgT09QXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVjZWl2ZXIgVGhlIGNsYXNzIHdoaWNoIHdpbGwgZXh0ZW5kIGFub3RoZXIgY2xhc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdXBwbGllciBUaGUgY2xhc3Mgd2hpY2ggd2lsbCBwcm92aWRlIHRoZSBwcm9wZXJ0aWVzIHRoZSBjaGlsZCBjbGFzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1Byb3BzIFByb3RvdHlwZSBwcm9wZXJ0aWVzIHRvIGFkZC9vdmVycmlkZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0aWNQcm9wcyBTdGF0aWMgcHJvcGVydGllcyB0byBhZGQvb3ZlcndyaXRlLlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBleHRlbmRlZCBjbGFzcy5cbiAqIEBzdGF0aWNcbiAqL1xuY29uc3QgZXh0ZW5kID0gZnVuY3Rpb24ocmVjZWl2ZXIsIHN1cHBsaWVyLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuXHRpZiAoIXN1cHBsaWVyIHx8ICFyZWNlaXZlcikge1xuXHRcdHRocm93IG5ldyBFcnJvcignZXh0ZW5kIGZhaWxlZCwgdmVyaWZ5IGRlcGVuZGVuY2llcycpO1xuXHR9XG5cblx0Y29uc3Qgc3VwcGxpZXJQcm90byA9IHN1cHBsaWVyLnByb3RvdHlwZTtcblxuXHRjb25zdCByZWNlaXZlclByb3RvID0gT2JqZWN0LmNyZWF0ZShzdXBwbGllclByb3RvKTtcblx0cmVjZWl2ZXIucHJvdG90eXBlID0gcmVjZWl2ZXJQcm90bztcblxuXHRyZWNlaXZlclByb3RvLmNvbnN0cnVjdG9yID0gcmVjZWl2ZXI7XG5cdHJlY2VpdmVyLnN1cGVyY2xhc3MgPSBzdXBwbGllclByb3RvO1xuXG5cdC8vIGFzc2lnbiBjb25zdHJ1Y3RvciBwcm9wZXJ0eVxuXHRpZiAoXG5cdFx0c3VwcGxpZXIgIT09IE9iamVjdCAmJlxuXHRcdHN1cHBsaWVyUHJvdG8uY29uc3RydWN0b3IgPT09IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3Jcblx0KSB7XG5cdFx0c3VwcGxpZXJQcm90by5jb25zdHJ1Y3RvciA9IHN1cHBsaWVyO1xuXHR9XG5cblx0Ly8gYWRkIHByb3RvdHlwZSBvdmVycmlkZXNcblx0aWYgKHByb3RvUHJvcHMpIHtcblx0XHRMYW5nLm1peChyZWNlaXZlclByb3RvLCBwcm90b1Byb3BzKTtcblx0fVxuXG5cdC8vIGFkZCBvYmplY3Qgb3ZlcnJpZGVzXG5cdGlmIChzdGF0aWNQcm9wcykge1xuXHRcdExhbmcubWl4KHJlY2VpdmVyLCBzdGF0aWNQcm9wcyk7XG5cdH1cblxuXHRyZXR1cm4gcmVjZWl2ZXI7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBleHRlbmQ7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmNsYXNzIERyYWdFdmVudCB7XG5cdGNvbnN0cnVjdG9yKHdpbmRvdywgZG9jdW1lbnQpIHtcblx0XHR0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG5cdFx0dGhpcy53aW5kb3cgPSB3aW5kb3c7XG5cblx0XHR0aGlzLmV2ZW50cyA9IHtcblx0XHRcdGtleWRvd246IHRoaXMua2V5ZG93bi5iaW5kKHRoaXMpLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLm1vdXNlbW92ZS5iaW5kKHRoaXMpLFxuXHRcdFx0bW91c2V1cDogdGhpcy5tb3VzZXVwLmJpbmQodGhpcyksXG5cdFx0fTtcblx0fVxuXG5cdHN0YXJ0KGV2ZW50KSB7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdHRoaXMudGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0dGhpcy5jbGFzc05hbWUgPSB0aGlzLnRhcmdldC5jbGFzc05hbWU7XG5cblx0XHR0aGlzLnN0YXJ0UG9zID0ge1xuXHRcdFx0eDogZXZlbnQuY2xpZW50WCxcblx0XHRcdHk6IGV2ZW50LmNsaWVudFksXG5cdFx0fTtcblxuXHRcdHRoaXMudXBkYXRlKGV2ZW50KTtcblxuXHRcdHRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuZXZlbnRzLmtleWRvd24sIGZhbHNlKTtcblx0XHR0aGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG5cdFx0XHQnbW91c2Vtb3ZlJyxcblx0XHRcdHRoaXMuZXZlbnRzLm1vdXNlbW92ZSxcblx0XHRcdGZhbHNlXG5cdFx0KTtcblx0XHR0aGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmV2ZW50cy5tb3VzZXVwLCBmYWxzZSk7XG5cblx0XHR0aGlzLmRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChgZHJhZ2dpbmctJHt0aGlzLmNsYXNzTmFtZX1gKTtcblxuXHRcdGlmICh0eXBlb2YgdGhpcy5vblN0YXJ0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLm9uU3RhcnQoKTtcblx0XHR9XG5cdH1cblxuXHR1cGRhdGUoZXZlbnQpIHtcblx0XHR0aGlzLmN1cnJlbnRQb3MgPSB7XG5cdFx0XHR4OiBldmVudC5jbGllbnRYLFxuXHRcdFx0eTogZXZlbnQuY2xpZW50WSxcblx0XHR9O1xuXG5cdFx0dGhpcy5kZWx0YSA9IHtcblx0XHRcdHg6IGV2ZW50LmNsaWVudFggLSB0aGlzLnN0YXJ0UG9zLngsXG5cdFx0XHR5OiBldmVudC5jbGllbnRZIC0gdGhpcy5zdGFydFBvcy55LFxuXHRcdH07XG5cblx0XHR0aGlzLmtleXMgPSB7XG5cdFx0XHRhbHQ6IGV2ZW50LmFsdEtleSxcblx0XHRcdGN0cmw6IGV2ZW50LmN0cmxLZXksXG5cdFx0XHRzaGlmdDogZXZlbnQuc2hpZnRLZXksXG5cdFx0fTtcblx0fVxuXG5cdG1vdXNlbW92ZShldmVudCkge1xuXHRcdHRoaXMudXBkYXRlKGV2ZW50KTtcblxuXHRcdGlmICh0eXBlb2YgdGhpcy5vbkRyYWcgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRoaXMub25EcmFnKCk7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LndoaWNoID09PSAwKSB7XG5cdFx0XHR0aGlzLm1vdXNldXAoZXZlbnQpO1xuXHRcdH1cblx0fVxuXG5cdGtleWRvd24oZXZlbnQpIHtcblx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdHRoaXMucmVsZWFzZSgpO1xuXHRcdH1cblx0fVxuXG5cdG1vdXNldXAoZXZlbnQpIHtcblx0XHR0aGlzLnVwZGF0ZShldmVudCk7XG5cblx0XHR0aGlzLnJlbGVhc2UoKTtcblxuXHRcdGlmICh0eXBlb2YgdGhpcy5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLm9uQ29tcGxldGUoKTtcblx0XHR9XG5cdH1cblxuXHRyZWxlYXNlKCkge1xuXHRcdHRoaXMuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKGBkcmFnZ2luZy0ke3RoaXMuY2xhc3NOYW1lfWApO1xuXG5cdFx0dGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuXHRcdFx0J2tleWRvd24nLFxuXHRcdFx0dGhpcy5ldmVudHMua2V5ZG93bixcblx0XHRcdGZhbHNlXG5cdFx0KTtcblx0XHR0aGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG5cdFx0XHQnbW91c2Vtb3ZlJyxcblx0XHRcdHRoaXMuZXZlbnRzLm1vdXNlbW92ZSxcblx0XHRcdGZhbHNlXG5cdFx0KTtcblx0XHR0aGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG5cdFx0XHQnbW91c2V1cCcsXG5cdFx0XHR0aGlzLmV2ZW50cy5tb3VzZXVwLFxuXHRcdFx0ZmFsc2Vcblx0XHQpO1xuXG5cdFx0aWYgKHR5cGVvZiB0aGlzLm9uUmVsZWFzZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dGhpcy5vblJlbGVhc2UoKTtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IHtEcmFnRXZlbnR9O1xuZXhwb3J0IGRlZmF1bHQgRHJhZ0V2ZW50O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgRHJhZ0V2ZW50IGZyb20gJy4vRHJhZ0V2ZW50LmVzJztcblxuY29uc3QgSU1BR0VfSEFORExFUyA9IFsndGwnLCAndHInLCAnYmwnLCAnYnInXTtcblxuY29uc3QgUE9TSVRJT05fRUxFTUVOVF9GTiA9IHtcblx0YmwoaGFuZGxlLCBsZWZ0LCB0b3AsIGJveCkge1xuXHRcdHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIC0zICsgbGVmdCwgYm94LmhlaWdodCAtIDQgKyB0b3ApO1xuXHR9LFxuXHRicihoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG5cdFx0cG9zaXRpb25FbGVtZW50KGhhbmRsZSwgYm94LndpZHRoIC0gNCArIGxlZnQsIGJveC5oZWlnaHQgLSA0ICsgdG9wKTtcblx0fSxcblx0cm0oaGFuZGxlLCBsZWZ0LCB0b3AsIGJveCkge1xuXHRcdHBvc2l0aW9uRWxlbWVudChcblx0XHRcdGhhbmRsZSxcblx0XHRcdGJveC53aWR0aCAtIDQgKyBsZWZ0LFxuXHRcdFx0TWF0aC5yb3VuZChib3guaGVpZ2h0IC8gMikgLSAzICsgdG9wXG5cdFx0KTtcblx0fSxcblx0dGwoaGFuZGxlLCBsZWZ0LCB0b3AsIF9ib3gpIHtcblx0XHRwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCBsZWZ0IC0gMywgdG9wIC0gMyk7XG5cdH0sXG5cdHRyKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcblx0XHRwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCBib3gud2lkdGggLSA0ICsgbGVmdCwgLTMgKyB0b3ApO1xuXHR9LFxufTtcblxuY29uc3QgcG9zaXRpb25FbGVtZW50ID0gKGVsLCBsZWZ0LCB0b3ApID0+IHtcblx0ZWwuc3R5bGUubGVmdCA9IGAke2xlZnR9cHhgO1xuXHRlbC5zdHlsZS50b3AgPSBgJHt0b3B9cHhgO1xufTtcblxuY29uc3QgZ2V0Qm91bmRpbmdCb3ggPSAod2luZG93LCBlbCkgPT4ge1xuXHRjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0cmV0dXJuIHtcblx0XHRoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuXHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCxcblx0XHR0b3A6IHJlY3QudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxuXHRcdHdpZHRoOiByZWN0LndpZHRoLFxuXHR9O1xufTtcblxuY2xhc3MgUmVzaXplciB7XG5cdGNvbnN0cnVjdG9yKGVkaXRvciwgY2ZnID0ge30pIHtcblx0XHR0aGlzLmNmZyA9IGNmZztcblx0XHR0aGlzLmVkaXRvciA9IGVkaXRvcjtcblxuXHRcdHRoaXMuZG9jdW1lbnQgPSBlZGl0b3IuZG9jdW1lbnQgPyBlZGl0b3IuZG9jdW1lbnQuJCA6IGRvY3VtZW50O1xuXHRcdHRoaXMud2luZG93ID0gZWRpdG9yLndpbmRvdyA/IGVkaXRvci53aW5kb3cuJCA6IHdpbmRvdztcblxuXHRcdHRoaXMuYm94ID0gbnVsbDtcblx0XHR0aGlzLmNvbnRhaW5lciA9IG51bGw7XG5cdFx0dGhpcy5oYW5kbGVzID0ge307XG5cdFx0dGhpcy5wcmV2aWV3ID0gbnVsbDtcblx0XHR0aGlzLnByZXZpZXdCb3ggPSBudWxsO1xuXHRcdHRoaXMucmVzdWx0ID0gbnVsbDtcblxuXHRcdHRoaXMuaW5pdCgpO1xuXHR9XG5cblx0aW5pdCgpIHtcblx0XHR0aGlzLmNvbnRhaW5lciA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0dGhpcy5jb250YWluZXIuaWQgPSAnY2tpbWdyc3onO1xuXG5cdFx0dGhpcy5wcmV2aWV3ID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cblx0XHR0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnByZXZpZXcpO1xuXG5cdFx0dGhpcy5oYW5kbGVzID0ge307XG5cblx0XHRJTUFHRV9IQU5ETEVTLmZvckVhY2goaGFuZGxlTmFtZSA9PiB7XG5cdFx0XHR0aGlzLmhhbmRsZXNbaGFuZGxlTmFtZV0gPSB0aGlzLmNyZWF0ZUhhbmRsZShoYW5kbGVOYW1lKTtcblx0XHR9KTtcblxuXHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmhhbmRsZXMpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmhhbmRsZXNba2V5c1tpXV0pO1xuXHRcdH1cblx0fVxuXG5cdGNyZWF0ZUhhbmRsZShuYW1lKSB7XG5cdFx0Y29uc3QgZWwgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2knKTtcblxuXHRcdGVsLmNsYXNzTGlzdC5hZGQobmFtZSk7XG5cblx0XHRyZXR1cm4gZWw7XG5cdH1cblxuXHRpc0hhbmRsZShlbCkge1xuXHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmhhbmRsZXMpO1xuXG5cdFx0bGV0IHJlc3VsdCA9IGZhbHNlO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5oYW5kbGVzW2tleXNbaV1dID09PSBlbCkge1xuXHRcdFx0XHRyZXN1bHQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRzaG93KGVsKSB7XG5cdFx0Y29uc3QgdWlOb2RlID0gdGhpcy5lZGl0b3IuY29uZmlnLnVpTm9kZSB8fCBkb2N1bWVudC5ib2R5O1xuXG5cdFx0dGhpcy5lbCA9IGVsO1xuXG5cdFx0dGhpcy5ib3ggPSBnZXRCb3VuZGluZ0JveCh0aGlzLndpbmRvdywgdGhpcy5lbCk7XG5cblx0XHRwb3NpdGlvbkVsZW1lbnQoXG5cdFx0XHR0aGlzLmNvbnRhaW5lcixcblx0XHRcdHRoaXMuYm94LmxlZnQsXG5cdFx0XHR0aGlzLmJveC50b3AgKyB1aU5vZGUuc2Nyb2xsVG9wXG5cdFx0KTtcblxuXHRcdHVpTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG5cblx0XHR0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2NraW1ncnN6Jyk7XG5cblx0XHR0aGlzLnNob3dIYW5kbGVzKCk7XG5cdH1cblxuXHRoaWRlKCkge1xuXHRcdGNvbnN0IGVsZW1lbnRzID0gdGhpcy5kb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdja2ltZ3JzeicpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZWxlbWVudHNbaV0uY2xhc3NMaXN0LnJlbW92ZSgnY2tpbWdyc3onKTtcblx0XHR9XG5cblx0XHR0aGlzLmhpZGVIYW5kbGVzKCk7XG5cblx0XHRpZiAodGhpcy5jb250YWluZXIucGFyZW50Tm9kZSkge1xuXHRcdFx0dGhpcy5jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG5cdFx0fVxuXHR9XG5cblx0aW5pdERyYWcoZXZlbnQpIHtcblx0XHRpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgZHJhZyA9IG5ldyBEcmFnRXZlbnQodGhpcy53aW5kb3csIHRoaXMuZG9jdW1lbnQpO1xuXG5cdFx0ZHJhZy5vblN0YXJ0ID0gKCkgPT4ge1xuXHRcdFx0dGhpcy5zaG93UHJldmlldygpO1xuXG5cdFx0XHR0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLmVkaXRvci5nZXRTZWxlY3Rpb24oKS5sb2NrKCk7XG5cdFx0fTtcblxuXHRcdGRyYWcub25EcmFnID0gKCkgPT4ge1xuXHRcdFx0dGhpcy5jYWxjdWxhdGVTaXplKGRyYWcpO1xuXG5cdFx0XHRjb25zdCBlZGl0b3JCb3VuZHMgPSB0aGlzLmVkaXRvci5lbGVtZW50LiQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRcdGlmICh0aGlzLnByZXZpZXdCb3gud2lkdGggPj0gZWRpdG9yQm91bmRzLndpZHRoKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy51cGRhdGVQcmV2aWV3KCk7XG5cblx0XHRcdGNvbnN0IGJveCA9IHRoaXMucHJldmlld0JveDtcblxuXHRcdFx0dGhpcy51cGRhdGVIYW5kbGVzKGJveCwgYm94LmxlZnQsIGJveC50b3ApO1xuXHRcdH07XG5cblx0XHRkcmFnLm9uUmVsZWFzZSA9ICgpID0+IHtcblx0XHRcdHRoaXMuaGlkZVByZXZpZXcoKTtcblxuXHRcdFx0dGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG5cblx0XHRcdHRoaXMuaGlkZSgpO1xuXG5cdFx0XHR0aGlzLmVkaXRvci5nZXRTZWxlY3Rpb24oKS51bmxvY2soKTtcblxuXHRcdFx0dGhpcy5lZGl0b3IuZmlyZSgnc2F2ZVNuYXBzaG90Jyk7XG5cdFx0fTtcblxuXHRcdGRyYWcub25Db21wbGV0ZSA9ICgpID0+IHtcblx0XHRcdHRoaXMucmVzaXplQ29tcGxldGUoKTtcblxuXHRcdFx0dGhpcy5lZGl0b3IuZmlyZSgnc2F2ZVNuYXBzaG90Jyk7XG5cdFx0fTtcblxuXHRcdGRyYWcuc3RhcnQoZXZlbnQpO1xuXHR9XG5cblx0dXBkYXRlSGFuZGxlcyhib3gsIGxlZnQgPSAwLCB0b3AgPSAwKSB7XG5cdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuaGFuZGxlcyk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFBPU0lUSU9OX0VMRU1FTlRfRk5ba2V5c1tpXV0odGhpcy5oYW5kbGVzW2tleXNbaV1dLCBsZWZ0LCB0b3AsIGJveCk7XG5cdFx0fVxuXHR9XG5cblx0c2hvd0hhbmRsZXMoKSB7XG5cdFx0dGhpcy51cGRhdGVIYW5kbGVzKHRoaXMuYm94KTtcblxuXHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmhhbmRsZXMpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLmhhbmRsZXNba2V5c1tpXV0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0fVxuXHR9XG5cblx0aGlkZUhhbmRsZXMoKSB7XG5cdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuaGFuZGxlcyk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuaGFuZGxlc1trZXlzW2ldXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdH1cblx0fVxuXG5cdHNob3dQcmV2aWV3KCkge1xuXHRcdHRoaXMuY2FsY3VsYXRlU2l6ZSgpO1xuXG5cdFx0dGhpcy51cGRhdGVQcmV2aWV3KCk7XG5cblx0XHR0aGlzLnByZXZpZXcuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdH1cblxuXHR1cGRhdGVQcmV2aWV3KCkge1xuXHRcdHBvc2l0aW9uRWxlbWVudChcblx0XHRcdHRoaXMucHJldmlldyxcblx0XHRcdHRoaXMucHJldmlld0JveC5sZWZ0LFxuXHRcdFx0dGhpcy5wcmV2aWV3Qm94LnRvcFxuXHRcdCk7XG5cblx0XHR0aGlzLnByZXZpZXcuc3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5wcmV2aWV3Qm94LmhlaWdodH1weGA7XG5cdFx0dGhpcy5wcmV2aWV3LnN0eWxlLndpZHRoID0gYCR7dGhpcy5wcmV2aWV3Qm94LndpZHRofXB4YDtcblx0fVxuXG5cdGhpZGVQcmV2aWV3KCkge1xuXHRcdGNvbnN0IGJveCA9IGdldEJvdW5kaW5nQm94KHRoaXMud2luZG93LCB0aGlzLnByZXZpZXcpO1xuXG5cdFx0dGhpcy5yZXN1bHQgPSB7XG5cdFx0XHRoZWlnaHQ6IGJveC5oZWlnaHQsXG5cdFx0XHR3aWR0aDogYm94LndpZHRoLFxuXHRcdH07XG5cblx0XHR0aGlzLnByZXZpZXcuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0fVxuXG5cdGNhbGN1bGF0ZVNpemUoZGF0YSkge1xuXHRcdHRoaXMucHJldmlld0JveCA9IHtcblx0XHRcdGhlaWdodDogdGhpcy5ib3guaGVpZ2h0LFxuXHRcdFx0bGVmdDogMCxcblx0XHRcdHRvcDogMCxcblx0XHRcdHdpZHRoOiB0aGlzLmJveC53aWR0aCxcblx0XHR9O1xuXG5cdFx0aWYgKCFkYXRhKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgY2xhc3NOYW1lID0gZGF0YS50YXJnZXQuY2xhc3NOYW1lO1xuXG5cdFx0aWYgKGNsYXNzTmFtZS5pbmRleE9mKCdyJykgPj0gMCkge1xuXHRcdFx0dGhpcy5wcmV2aWV3Qm94LndpZHRoID0gTWF0aC5tYXgoMzIsIHRoaXMuYm94LndpZHRoICsgZGF0YS5kZWx0YS54KTtcblx0XHR9XG5cblx0XHRpZiAoY2xhc3NOYW1lLmluZGV4T2YoJ2InKSA+PSAwKSB7XG5cdFx0XHR0aGlzLnByZXZpZXdCb3guaGVpZ2h0ID0gTWF0aC5tYXgoXG5cdFx0XHRcdDMyLFxuXHRcdFx0XHR0aGlzLmJveC5oZWlnaHQgKyBkYXRhLmRlbHRhLnlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGNsYXNzTmFtZS5pbmRleE9mKCdsJykgPj0gMCkge1xuXHRcdFx0dGhpcy5wcmV2aWV3Qm94LndpZHRoID0gTWF0aC5tYXgoMzIsIHRoaXMuYm94LndpZHRoIC0gZGF0YS5kZWx0YS54KTtcblx0XHR9XG5cblx0XHRpZiAoY2xhc3NOYW1lLmluZGV4T2YoJ3QnKSA+PSAwKSB7XG5cdFx0XHR0aGlzLnByZXZpZXdCb3guaGVpZ2h0ID0gTWF0aC5tYXgoXG5cdFx0XHRcdDMyLFxuXHRcdFx0XHR0aGlzLmJveC5oZWlnaHQgLSBkYXRhLmRlbHRhLnlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGNsYXNzTmFtZS5pbmRleE9mKCdtJykgPCAwICYmICFkYXRhLmtleXMuc2hpZnQpIHtcblx0XHRcdGNvbnN0IHJhdGlvID0gdGhpcy5ib3gud2lkdGggLyB0aGlzLmJveC5oZWlnaHQ7XG5cblx0XHRcdGlmICh0aGlzLnByZXZpZXdCb3gud2lkdGggLyB0aGlzLnByZXZpZXdCb3guaGVpZ2h0ID4gcmF0aW8pIHtcblx0XHRcdFx0dGhpcy5wcmV2aWV3Qm94LmhlaWdodCA9IE1hdGgucm91bmQoXG5cdFx0XHRcdFx0dGhpcy5wcmV2aWV3Qm94LndpZHRoIC8gcmF0aW9cblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucHJldmlld0JveC53aWR0aCA9IE1hdGgucm91bmQoXG5cdFx0XHRcdFx0dGhpcy5wcmV2aWV3Qm94LmhlaWdodCAqIHJhdGlvXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNsYXNzTmFtZS5pbmRleE9mKCdsJykgPj0gMCkge1xuXHRcdFx0dGhpcy5wcmV2aWV3Qm94LmxlZnQgPSB0aGlzLmJveC53aWR0aCAtIHRoaXMucHJldmlld0JveC53aWR0aDtcblx0XHR9XG5cblx0XHRpZiAoY2xhc3NOYW1lLmluZGV4T2YoJ3QnKSA+PSAwKSB7XG5cdFx0XHR0aGlzLnByZXZpZXdCb3gudG9wID0gdGhpcy5ib3guaGVpZ2h0IC0gdGhpcy5wcmV2aWV3Qm94LmhlaWdodDtcblx0XHR9XG5cdH1cblxuXHRyZXNpemVDb21wbGV0ZSgpIHtcblx0XHR0aGlzLmNmZy5vbkNvbXBsZXRlKHRoaXMuZWwsIHRoaXMucmVzdWx0LndpZHRoLCB0aGlzLnJlc3VsdC5oZWlnaHQpO1xuXHR9XG59XG5cbmV4cG9ydCB7UmVzaXplcn07XG5leHBvcnQgZGVmYXVsdCBSZXNpemVyO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5jb25zdCBpc0lFID0gQ0tFRElUT1IuZW52LmllO1xuXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9hZGRpbWFnZXMnKSkge1xuXHQvKipcblx0ICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIGFsbG93cyBEcmFnJkRyb3Agb2YgaW1hZ2VzIGRpcmVjdGx5IGludG8gdGhlIGVkaXRhYmxlIGFyZWEuIFRoZSBpbWFnZSB3aWxsIGJlIGVuY29kZWRcblx0ICogYXMgRGF0YSBVUkkuIEFuIGV2ZW50IGBiZWZvcmVJbWFnZUFkZGAgd2lsbCBiZSBmaXJlZCB3aXRoIHRoZSBsaXN0IG9mIGRyb3BwZWQgaW1hZ2VzLiBJZiBhbnkgb2YgdGhlIGxpc3RlbmVyc1xuXHQgKiByZXR1cm5zIGBmYWxzZWAgb3IgY2FuY2VscyB0aGUgZXZlbnQsIHRoZSBpbWFnZXMgd29uJ3QgYmUgYWRkZWQgdG8gdGhlIGNvbnRlbnQuIE90aGVyd2lzZSxcblx0ICogYW4gZXZlbnQgYGltYWdlQWRkYCB3aWxsIGJlIGZpcmVkIHdpdGggdGhlIGluc2VydGVkIGVsZW1lbnQgaW50byB0aGUgZWRpdGFibGUgYXJlYS5cblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBGaXJlZCBiZWZvcmUgYWRkaW5nIGltYWdlcyB0byB0aGUgZWRpdG9yLlxuXHQgKlxuXHQgKiBAZXZlbnQgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXMjYmVmb3JlSW1hZ2VBZGRcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBpbWFnZUZpbGVzIEFycmF5IG9mIGltYWdlIGZpbGVzXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBGaXJlZCB3aGVuIGFuIGltYWdlIGlzIGJlaW5nIGFkZGVkIHRvIHRoZSBlZGl0b3Igc3VjY2Vzc2Z1bGx5LlxuXHQgKlxuXHQgKiBAZXZlbnQgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXMjaW1hZ2VBZGRcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuXHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBlbCBUaGUgY3JlYXRlZCBpbWFnZSB3aXRoIHNyYyBhcyBEYXRhIFVSSVxuXHQgKiBAcGFyYW0ge0ZpbGV9IGZpbGUgVGhlIGltYWdlIGZpbGVcblx0ICovXG5cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX2FkZGltYWdlcycsIHtcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXphdGlvbiBvZiB0aGUgcGx1Z2luLCBwYXJ0IG9mIENLRWRpdG9yIHBsdWdpbiBsaWZlY3ljbGUuXG5cdFx0ICogVGhlIGZ1bmN0aW9uIHJlZ2lzdGVycyBhICdkcmFnZW50ZXInLCAnZHJhZ292ZXInLCAnZHJvcCcgYW5kIGBwYXN0ZWAgZXZlbnRzIG9uIHRoZSBlZGl0aW5nIGFyZWEuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcblx0XHQgKiBAbWV0aG9kIGluaXRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuXHRcdCAqL1xuXHRcdGluaXQoZWRpdG9yKSB7XG5cdFx0XHRlZGl0b3Iub25jZSgnY29udGVudERvbScsICgpID0+IHtcblx0XHRcdFx0Y29uc3QgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuXHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0XHRlZGl0YWJsZSxcblx0XHRcdFx0XHQnZHJhZ2VudGVyJyxcblx0XHRcdFx0XHR0aGlzLl9vbkRyYWdFbnRlcixcblx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGVkaXRvcixcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0ZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoXG5cdFx0XHRcdFx0ZWRpdGFibGUsXG5cdFx0XHRcdFx0J2RyYWdvdmVyJyxcblx0XHRcdFx0XHR0aGlzLl9vbkRyYWdPdmVyLFxuXHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZWRpdG9yLFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblxuXHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0XHRlZGl0YWJsZSxcblx0XHRcdFx0XHQnZHJvcCcsXG5cdFx0XHRcdFx0dGhpcy5fb25EcmFnRHJvcCxcblx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGVkaXRvcixcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0ZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoXG5cdFx0XHRcdFx0ZWRpdGFibGUsXG5cdFx0XHRcdFx0J3Bhc3RlJyxcblx0XHRcdFx0XHR0aGlzLl9vblBhc3RlLFxuXHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZWRpdG9yLFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBY2NlcHRzIGFuIGFycmF5IG9mIGRyb3BwZWQgZmlsZXMgdG8gdGhlIGVkaXRvci4gVGhlbiwgaXQgZmlsdGVycyB0aGUgaW1hZ2VzIGFuZCBzZW5kcyB0aGVtIGZvciBmdXJ0aGVyXG5cdFx0ICogcHJvY2Vzc2luZyB0byB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlcy9fcHJvY2Vzc0ZpbGU6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICpcblx0XHQgKiBAZmlyZXMgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXMjYmVmb3JlSW1hZ2VBZGRcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcblx0XHQgKiBAbWV0aG9kIF9oYW5kbGVGaWxlc1xuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IGZpbGVzIEFycmF5IG9mIGRyb3BwZWQgZmlsZXMuIE9ubHkgdGhlIGltYWdlcyBmcm9tIHRoaXMgbGlzdCB3aWxsIGJlIHByb2Nlc3NlZC5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRfaGFuZGxlRmlsZXMoZmlsZXMsIGVkaXRvcikge1xuXHRcdFx0bGV0IGZpbGU7XG5cdFx0XHRsZXQgaTtcblxuXHRcdFx0Y29uc3QgaW1hZ2VGaWxlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZmlsZSA9IGZpbGVzW2ldO1xuXG5cdFx0XHRcdGlmIChmaWxlLnR5cGUuaW5kZXhPZignaW1hZ2UnKSA9PT0gMCkge1xuXHRcdFx0XHRcdGltYWdlRmlsZXMucHVzaChmaWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCByZXN1bHQgPSBlZGl0b3IuZmlyZSgnYmVmb3JlSW1hZ2VBZGQnLCB7XG5cdFx0XHRcdGltYWdlRmlsZXMsXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgaW1hZ2VGaWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGZpbGUgPSBpbWFnZUZpbGVzW2ldO1xuXG5cdFx0XHRcdFx0dGhpcy5fcHJvY2Vzc0ZpbGUoZmlsZSwgZWRpdG9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXMgZHJhZyBkcm9wIGV2ZW50LiBUaGUgZnVuY3Rpb24gd2lsbCBjcmVhdGUgYSBzZWxlY3Rpb24gZnJvbSB0aGUgY3VycmVudFxuXHRcdCAqIHBvaW50IGFuZCB3aWxsIHNlbmQgYSBsaXN0IG9mIGZpbGVzIHRvIGJlIHByb2Nlc3NlZCB0b1xuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzL19oYW5kbGVGaWxlczptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG5cdFx0ICogQG1ldGhvZCBfb25EcmFnRHJvcFxuXHRcdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmV2ZW50fSBldmVudCBkcmFnZHJvcCBldmVudCwgYXMgcmVjZWl2ZWQgbmF0aXZlbHkgZnJvbSBDS0VkaXRvclxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRfb25EcmFnRHJvcChldmVudCkge1xuXHRcdFx0Y29uc3QgbmF0aXZlRXZlbnQgPSBldmVudC5kYXRhLiQ7XG5cblx0XHRcdGNvbnN0IHRyYW5zZmVyRmlsZXMgPSBuYXRpdmVFdmVudC5kYXRhVHJhbnNmZXIuZmlsZXM7XG5cblx0XHRcdGlmICh0cmFuc2ZlckZpbGVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0bmV3IENLRURJVE9SLmRvbS5ldmVudChuYXRpdmVFdmVudCkucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHRjb25zdCBlZGl0b3IgPSBldmVudC5saXN0ZW5lckRhdGEuZWRpdG9yO1xuXG5cdFx0XHRcdGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3IuY3JlYXRlU2VsZWN0aW9uRnJvbVBvaW50KFxuXHRcdFx0XHRcdG5hdGl2ZUV2ZW50LmNsaWVudFgsXG5cdFx0XHRcdFx0bmF0aXZlRXZlbnQuY2xpZW50WVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdHRoaXMuX2hhbmRsZUZpbGVzKHRyYW5zZmVyRmlsZXMsIGVkaXRvcik7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXMgZHJhZyBlbnRlciBldmVudC4gSW4gY2FzZSBvZiBJRSwgdGhpcyBmdW5jdGlvbiB3aWxsIHByZXZlbnQgdGhlIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG5cdFx0ICogQG1ldGhvZCBfb25EcmFnRW50ZXJcblx0XHQgKiBAcGFyYW0ge0RPTSBldmVudH0gZXZlbnQgZHJhZ2VudGVyIGV2ZW50LCBhcyByZWNlaXZlZCBuYXRpdmVseSBmcm9tIENLRWRpdG9yXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9vbkRyYWdFbnRlcihldmVudCkge1xuXHRcdFx0aWYgKGlzSUUpIHtcblx0XHRcdFx0dGhpcy5fcHJldmVudEV2ZW50KGV2ZW50KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlcyBkcmFnIG92ZXIgZXZlbnQuIEluIGNhc2Ugb2YgSUUsIHRoaXMgZnVuY3Rpb24gd2lsbCBwcmV2ZW50IHRoZSBldmVudC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuXHRcdCAqIEBtZXRob2QgX29uRHJhZ092ZXJcblx0XHQgKiBAcGFyYW0ge0RPTSBldmVudH0gZXZlbnQgZHJhZ292ZXIgZXZlbnQsIGFzIHJlY2VpdmVkIG5hdGl2ZWx5IGZyb20gQ0tFZGl0b3Jcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X29uRHJhZ092ZXIoZXZlbnQpIHtcblx0XHRcdGlmIChpc0lFKSB7XG5cdFx0XHRcdHRoaXMuX3ByZXZlbnRFdmVudChldmVudCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrcyBpZiB0aGUgcGFzdGVkIGRhdGEgaXMgaW1hZ2UgYW5kIHBhc3NlcyBpdCB0b1xuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzL19wcm9jZXNzRmlsZTptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0gZm9yIHByb2Nlc3NpbmcuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcblx0XHQgKiBAbWV0aG9kIF9vblBhc3RlXG5cdFx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZXZlbnR9IGV2ZW50IEEgYHBhc3RlYCBldmVudCwgYXMgcmVjZWl2ZWQgbmF0aXZlbHkgZnJvbSBDS0VkaXRvclxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRfb25QYXN0ZShldmVudCkge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRldmVudC5kYXRhICYmXG5cdFx0XHRcdGV2ZW50LmRhdGEuJCAmJlxuXHRcdFx0XHRldmVudC5kYXRhLiQuY2xpcGJvYXJkRGF0YSAmJlxuXHRcdFx0XHRldmVudC5kYXRhLiQuY2xpcGJvYXJkRGF0YS5pdGVtcyAmJlxuXHRcdFx0XHRldmVudC5kYXRhLiQuY2xpcGJvYXJkRGF0YS5pdGVtcy5sZW5ndGggPiAwXG5cdFx0XHQpIHtcblx0XHRcdFx0Y29uc3QgcGFzdGVkRGF0YSA9IGV2ZW50LmRhdGEuJC5jbGlwYm9hcmREYXRhLml0ZW1zWzBdO1xuXG5cdFx0XHRcdGlmIChwYXN0ZWREYXRhLnR5cGUuaW5kZXhPZignaW1hZ2UnKSA9PT0gMCkge1xuXHRcdFx0XHRcdGNvbnN0IGltYWdlRmlsZSA9IHBhc3RlZERhdGEuZ2V0QXNGaWxlKCk7XG5cblx0XHRcdFx0XHR0aGlzLl9wcm9jZXNzRmlsZShpbWFnZUZpbGUsIGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFByZXZlbnRzIGEgbmF0aXZlIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG5cdFx0ICogQG1ldGhvZCBfcHJldmVudEV2ZW50XG5cdFx0ICogQHBhcmFtIHtET00gZXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBiZSBwcmV2ZW50ZWQuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9wcmV2ZW50RXZlbnQoZXZlbnQpIHtcblx0XHRcdGV2ZW50ID0gbmV3IENLRURJVE9SLmRvbS5ldmVudChldmVudC5kYXRhLiQpO1xuXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFByb2Nlc3NlcyBhbiBpbWFnZSBmaWxlLiBUaGUgZnVuY3Rpb24gY3JlYXRlcyBhbiBpbWcgZWxlbWVudCBhbmQgc2V0cyBhcyBzb3VyY2Vcblx0XHQgKiBhIERhdGEgVVJJLCB0aGVuIGZpcmVzIGFuICdpbWFnZUFkZCcgZXZlbnQgdmlhIENLRWRpdG9yJ3MgZXZlbnQgc3lzdGVtLlxuXHRcdCAqXG5cdFx0ICogQGZpcmVzIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzI2ltYWdlQWRkXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG5cdFx0ICogQG1ldGhvZCBfcHJldmVudEV2ZW50XG5cdFx0ICogQHBhcmFtIHtET00gZXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBiZSBwcmV2ZW50ZWQuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9wcm9jZXNzRmlsZShmaWxlLCBlZGl0b3IpIHtcblx0XHRcdGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cblx0XHRcdHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBiaW4gPSByZWFkZXIucmVzdWx0O1xuXG5cdFx0XHRcdGNvbnN0IGVsID0gQ0tFRElUT1IuZG9tLmVsZW1lbnQuY3JlYXRlRnJvbUh0bWwoXG5cdFx0XHRcdFx0JzxpbWcgc3JjPVwiJyArIGJpbiArICdcIj4nXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0ZWRpdG9yLmluc2VydEVsZW1lbnQoZWwpO1xuXG5cdFx0XHRcdGNvbnN0IGltYWdlRGF0YSA9IHtcblx0XHRcdFx0XHRlbCxcblx0XHRcdFx0XHRmaWxlLFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGVkaXRvci5maXJlKCdpbWFnZUFkZCcsIGltYWdlRGF0YSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2F1dG9saW5rJykpIHtcblx0Ly8gRGlzYWJsZXMgdGhlIGF1dG8gVVJMIGRldGVjdGlvbiBmZWF0dXJlIGluIElFLCB0aGVpciBsYWNrcyBmdW5jdGlvbmFsaXR5OlxuXHQvLyBUaGV5IGNvbnZlcnQgdGhlIGxpbmtzIG9ubHkgb24gc3BhY2UuIFdlIGRvIG9uIHNwYWNlLCBjb21tYSwgc2VtaWNvbG9uIGFuZCBFbnRlci5cblx0aWYgKC9NU0lFIChbXjtdKil8VHJpZGVudC4qOyBydjooWzAtOS5dKykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcblx0XHRkb2N1bWVudC5leGVjQ29tbWFuZCgnQXV0b1VybERldGVjdCcsIGZhbHNlLCBmYWxzZSk7XG5cdH1cblxuXHRjb25zdCBLRVlfQkFDSyA9IDg7XG5cblx0Y29uc3QgS0VZX0NPTU1BID0gMTg4O1xuXG5cdGNvbnN0IEtFWV9FTlRFUiA9IDEzO1xuXG5cdGNvbnN0IEtFWV9TRU1JQ09MT04gPSAxODY7XG5cblx0Y29uc3QgS0VZX1NQQUNFID0gMzI7XG5cblx0Y29uc3QgREVMSU1JVEVSUyA9IFtLRVlfQ09NTUEsIEtFWV9FTlRFUiwgS0VZX1NFTUlDT0xPTiwgS0VZX1NQQUNFXTtcblxuXHRjb25zdCBSRUdFWF9MQVNUX1dPUkQgPSAvW15cXHNdKy9naW07XG5cblx0Ly8gU2VlbiBhdCBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTcxNzEzMy8yMTAzOTk2XG5cdGNvbnN0IFJFR0VYX1VSTCA9XG5cdFx0J14oaHR0cHM/OlxcXFwvXFxcXC8pPycgKyAvLyBwcm90b2NvbFxuXHRcdCcoKChbYS16XFxcXGRdKFthLXpcXFxcZC1dKlthLXpcXFxcZF0pKilcXFxcLikrW2Etel17Mix9fCcgKyAvLyBkb21haW4gbmFtZVxuXHRcdCcoKFxcXFxkezEsM31cXFxcLil7M31cXFxcZHsxLDN9KSknICsgLy8gT1IgaXAgKHY0KSBhZGRyZXNzXG5cdFx0JyhcXFxcOlxcXFxkKyk/KFxcXFwvWy1hLXpcXFxcZCVfLn4rXSopKicgKyAvLyBwb3J0IGFuZCBwYXRoXG5cdFx0JyhcXFxcP1s7JmEtelxcXFxkJV8ufis9LV0qKT8nICsgLy8gcXVlcnkgc3RyaW5nXG5cdFx0JyhcXFxcI1stYS16XFxcXGRfXSopPyQnO1xuXG5cdGNvbnN0IFJFR0VYX0VNQUlMID0gL1thLXpBLVowLTkuXy1dK0BbYS16QS1aMC05Li1dK1xcLlthLXpBLVpdezIsNH0vaTtcblxuXHQvKipcblx0ICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVzIGxpbmtzIHdoZW4gdXNlciB0eXBlcyB0ZXh0IHdoaWNoIGxvb2tzIGxpa2UgVVJMLlxuXHQgKlxuXHQgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlua1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV9hdXRvbGluaycsIHtcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXphdGlvbiBvZiB0aGUgcGx1Z2luLCBwYXJ0IG9mIENLRWRpdG9yIHBsdWdpbiBsaWZlY3ljbGUuXG5cdFx0ICogVGhlIGZ1bmN0aW9uIHJlZ2lzdGVycyB0aGUgYGtleXVwYCBldmVudCBvbiB0aGUgZWRpdGluZyBhcmVhLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcblx0XHQgKiBAbWV0aG9kIGluaXRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuXHRcdCAqL1xuXHRcdGluaXQoZWRpdG9yKSB7XG5cdFx0XHRlZGl0b3Iub25jZSgnY29udGVudERvbScsICgpID0+IHtcblx0XHRcdFx0Y29uc3QgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuXHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0XHRlZGl0YWJsZSxcblx0XHRcdFx0XHQna2V5dXAnLFxuXHRcdFx0XHRcdHRoaXMuX29uS2V5VXAsXG5cdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRlZGl0b3IsXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGVkaXRvci5vbigncGFzdGUnLCBldmVudCA9PiB7XG5cdFx0XHRcdGlmIChldmVudC5kYXRhLm1ldGhvZCA9PT0gJ3Bhc3RlJykge1xuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdGV2ZW50LmRhdGEuZGF0YVZhbHVlLmluZGV4T2YoJzwnKSA+IC0xIHx8XG5cdFx0XHRcdFx0XHRldmVudC5kYXRhLmRhdGFWYWx1ZS5pbmRleE9mKCcmbHQ7JykgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRldmVudC5kYXRhLmRhdGFWYWx1ZS5pbmRleE9mKCc8dT48Zm9udCBjb2xvcj1cIicpID5cblx0XHRcdFx0XHRcdFx0LTFcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5kYXRhLmRhdGFWYWx1ZSA9IGV2ZW50LmRhdGEuZGF0YVZhbHVlLnJlcGxhY2UoXG5cdFx0XHRcdFx0XHRcdFx0Lzx1Pjxmb250IGNvbG9yPVwiIyguKj8pXCI+fDxcXC9mb250PjxcXC91Pi9nLFxuXHRcdFx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3QgaW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0XHRcdFx0ZXZlbnQuZGF0YS5kYXRhVmFsdWUgPSBldmVudC5kYXRhLmRhdGFWYWx1ZS5yZXBsYWNlKFxuXHRcdFx0XHRcdFx0UmVnRXhwKFJFR0VYX1VSTCwgJ2dpbScpLFxuXHRcdFx0XHRcdFx0dXJsID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKGluc3RhbmNlLl9pc1ZhbGlkVVJMKHVybCkpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoaW5zdGFuY2UuX2lzVmFsaWRFbWFpbCh1cmwpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnPGEgaHJlZj1cIm1haWx0bzonICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dXJsICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0J1wiPicgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR1cmwgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQnPC9hPidcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCc8YSBocmVmPVwiJyArIHVybCArICdcIj4nICsgdXJsICsgJzwvYT4nXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXRyaWV2ZXMgdGhlIGxhc3Qgd29yZCBpbnRyb2R1Y2VkIGJ5IHRoZSB1c2VyLiBSZWFkcyBmcm9tIHRoZSBjdXJyZW50XG5cdFx0ICogY2FyZXQgcG9zaXRpb24gYmFja3dhcmRzIHVudGlsIGl0IGZpbmRzIHRoZSBmaXJzdCB3aGl0ZSBzcGFjZS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBfZ2V0TGFzdFdvcmRcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgbGFzdCB3b3JkIGludHJvZHVjZWQgYnkgdXNlclxuXHRcdCAqL1xuXHRcdF9nZXRMYXN0V29yZChlZGl0b3IpIHtcblx0XHRcdGNvbnN0IHJhbmdlID0gZWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFJhbmdlcygpWzBdO1xuXG5cdFx0XHRpZiAoIXJhbmdlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG5cblx0XHRcdGxldCBwcmV2aW91c1RleHQgPSAnJztcblxuXHRcdFx0Ly8gVGhlIHVzZXIgcHJlc3NlZCBFbnRlciwgc28gd2UgaGF2ZSB0byBsb29rIG9uIHRoZSBwcmV2aW91cyBub2RlXG5cdFx0XHRpZiAodGhpcy5fY3VycmVudEtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuXHRcdFx0XHRsZXQgcHJldmlvdXNOb2RlID0gcmFuZ2Uuc3RhcnRDb250YWluZXIuZ2V0UHJldmlvdXMoKTtcblxuXHRcdFx0XHRsZXQgbGFzdENoaWxkO1xuXG5cdFx0XHRcdGlmIChwcmV2aW91c05vZGUpIHtcblx0XHRcdFx0XHQvLyBJZiBwcmV2aW91cyBub2RlIGlzIGEgU1BBQ0UsIChpdCBkb2VzIG5vdCBoYXZlICdnZXRMYXN0JyBtZXRob2QpLFxuXHRcdFx0XHRcdC8vIGlnbm9yZSBpdCBhbmQgZmluZCB0aGUgcHJldmlvdXMgdGV4dCBub2RlXG5cdFx0XHRcdFx0d2hpbGUgKCFwcmV2aW91c05vZGUuZ2V0TGFzdCkge1xuXHRcdFx0XHRcdFx0cHJldmlvdXNOb2RlID0gcHJldmlvdXNOb2RlLmdldFByZXZpb3VzKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGFzdENoaWxkID0gcHJldmlvdXNOb2RlLmdldExhc3QoKTtcblxuXHRcdFx0XHRcdC8vIERlcGVuZGluZyBvbiB0aGUgYnJvd3NlciwgdGhlIGxhc3QgY2hpbGQgbm9kZSBtYXkgYmUgYSA8QlI+XG5cdFx0XHRcdFx0Ly8gKHdoaWNoIGRvZXMgbm90IGhhdmUgJ2dldFRleHQnIG1ldGhvZCksXG5cdFx0XHRcdFx0Ly8gc28gaWdub3JlIGl0IGFuZCBmaW5kIHRoZSBwcmV2aW91cyB0ZXh0IG5vZGVcblx0XHRcdFx0XHR3aGlsZSAobGFzdENoaWxkICYmICFsYXN0Q2hpbGQuZ2V0VGV4dCgpKSB7XG5cdFx0XHRcdFx0XHRsYXN0Q2hpbGQgPSBsYXN0Q2hpbGQuZ2V0UHJldmlvdXMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDaGVjayBpZiB0aGUgbGFzdENoaWxkIGlzIGFscmVhZHkgYSBsaW5rXG5cdFx0XHRcdGlmICghKGxhc3RDaGlsZCAmJiBsYXN0Q2hpbGQuJC5ocmVmKSkge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0Q29udGFpbmVyID0gbGFzdENoaWxkO1xuXHRcdFx0XHRcdHByZXZpb3VzVGV4dCA9IGxhc3RDaGlsZCA/IGxhc3RDaGlsZC5nZXRUZXh0KCkgOiAnJztcblx0XHRcdFx0XHR0aGlzLl9vZmZzZXQgPSBwcmV2aW91c1RleHQubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9zdGFydENvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuXG5cdFx0XHRcdC8vIExhc3QgY2hhcmFjdGVyIGlzIHRoZSBkZWxpbWl0ZXIsIGlnbm9yZSBpdFxuXHRcdFx0XHRwcmV2aW91c1RleHQgPSB0aGlzLl9zdGFydENvbnRhaW5lclxuXHRcdFx0XHRcdC5nZXRUZXh0KClcblx0XHRcdFx0XHQuc3Vic3RyaW5nKDAsIG9mZnNldCAtIDEpO1xuXG5cdFx0XHRcdHRoaXMuX29mZnNldCA9IG9mZnNldCAtIDE7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBsYXN0V29yZCA9ICcnO1xuXG5cdFx0XHRjb25zdCBtYXRjaCA9IHByZXZpb3VzVGV4dC5tYXRjaChSRUdFWF9MQVNUX1dPUkQpO1xuXG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0bGFzdFdvcmQgPSBtYXRjaC5wb3AoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxhc3RXb3JkO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGxpbmsgaXMgYSB2YWxpZCBFbWFpbC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBpc1ZhbGlkRW1haWxcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbGluayBUaGUgZW1haWwgd2Ugd2FudCB0byBrbm93IGlmIGl0IGlzIGEgdmFsaWQgRW1haWxcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbWFpbCBpcyBhIHZhbGlkIEVtYWlsLCBmYWxzZSBvdGhlcndpc2Vcblx0XHQgKi9cblx0XHRfaXNWYWxpZEVtYWlsKGVtYWlsKSB7XG5cdFx0XHRyZXR1cm4gUkVHRVhfRU1BSUwudGVzdChlbWFpbCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gbGluayBpcyBhIHZhbGlkIFVSTC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBpc1ZhbGlkVVJMXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGxpbmsgVGhlIGxpbmsgd2Ugd2FudCB0byBrbm93IGlmIGl0IGlzIGEgdmFsaWQgVVJMXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgbGluayBpcyBhIHZhbGlkIFVSTCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdFx0ICovXG5cdFx0X2lzVmFsaWRVUkwobGluaykge1xuXHRcdFx0cmV0dXJuIFJlZ0V4cChSRUdFWF9VUkwsICdpJykudGVzdChsaW5rKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTGlzdGVucyB0byB0aGUgYGtleWRvd25gIGV2ZW50IGFuZCBpZiB0aGUga2V5Y29kZSBpcyBgQmFja3NwYWNlYCwgcmVtb3ZlcyB0aGUgcHJldmlvdXNseVxuXHRcdCAqIGNyZWF0ZWQgbGluay5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBfb25LZXlEb3duXG5cdFx0ICogQHBhcmFtIHtFdmVudEZhY2FkZX0gZXZlbnQgRXZlbnRGYWNhZGUgb2JqZWN0XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9vbktleURvd24oZXZlbnQpIHtcblx0XHRcdGNvbnN0IG5hdGl2ZUV2ZW50ID0gZXZlbnQuZGF0YS4kO1xuXG5cdFx0XHRjb25zdCBlZGl0b3IgPSBldmVudC5saXN0ZW5lckRhdGEuZWRpdG9yO1xuXG5cdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRlZGl0YWJsZS5yZW1vdmVMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93bik7XG5cblx0XHRcdGlmIChuYXRpdmVFdmVudC5rZXlDb2RlID09PSBLRVlfQkFDSykge1xuXHRcdFx0XHRldmVudC5jYW5jZWwoKTtcblx0XHRcdFx0ZXZlbnQuZGF0YS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUxpbmsoZWRpdG9yKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fY2tMaW5rID0gbnVsbDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTGlzdGVucyB0byB0aGUgYEVudGVyYCBhbmQgYFNwYWNlYCBrZXkgZXZlbnRzIGluIG9yZGVyIHRvIGNoZWNrIGlmIHRoZSBsYXN0IHdvcmRcblx0XHQgKiBpbnRyb2R1Y2VkIGJ5IHRoZSB1c2VyIHNob3VsZCBiZSByZXBsYWNlZCBieSBhIGxpbmsgZWxlbWVudC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBfb25LZXlVcFxuXHRcdCAqIEBwYXJhbSB7RXZlbnRGYWNhZGV9IGV2ZW50IEV2ZW50RmFjYWRlIG9iamVjdFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRfb25LZXlVcChldmVudCkge1xuXHRcdFx0Y29uc3QgbmF0aXZlRXZlbnQgPSBldmVudC5kYXRhLiQ7XG5cblx0XHRcdHRoaXMuX2N1cnJlbnRLZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuXHRcdFx0aWYgKERFTElNSVRFUlMuaW5kZXhPZih0aGlzLl9jdXJyZW50S2V5Q29kZSkgIT09IC0xKSB7XG5cdFx0XHRcdGNvbnN0IGVkaXRvciA9IGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3I7XG5cblx0XHRcdFx0Y29uc3QgbGFzdFdvcmQgPSB0aGlzLl9nZXRMYXN0V29yZChlZGl0b3IpO1xuXG5cdFx0XHRcdGlmICh0aGlzLl9pc1ZhbGlkVVJMKGxhc3RXb3JkKSkge1xuXHRcdFx0XHRcdHRoaXMuX3JlcGxhY2VDb250ZW50QnlMaW5rKGVkaXRvciwgbGFzdFdvcmQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlcGxhY2VzIGNvbnRlbnQgYnkgYSBsaW5rIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiBAZmlyZXMgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGluayNhdXRvbGlua0FkZFxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBfcmVwbGFjZUNvbnRlbnRCeUxpbmtcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudCBUaGUgdGV4dCB0aGF0IGhhcyB0byBiZSByZXBsYWNlZCBieSBhbiBsaW5rIGVsZW1lbnRcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X3JlcGxhY2VDb250ZW50QnlMaW5rKGVkaXRvciwgY29udGVudCkge1xuXHRcdFx0bGV0IHJhbmdlID0gZWRpdG9yLmNyZWF0ZVJhbmdlKCk7XG5cdFx0XHRjb25zdCBub2RlID0gQ0tFRElUT1IuZG9tLmVsZW1lbnQuZ2V0KHRoaXMuX3N0YXJ0Q29udGFpbmVyKTtcblx0XHRcdGNvbnN0IG9mZnNldCA9IHRoaXMuX29mZnNldDtcblxuXHRcdFx0Ly8gU2VsZWN0IHRoZSBjb250ZW50LCBzbyBDS0VESVRPUi5MaW5rIGNhbiBwcm9wZXJseSByZXBsYWNlIGl0XG5cdFx0XHRyYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQgLSBjb250ZW50Lmxlbmd0aCk7XG5cdFx0XHRyYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcblx0XHRcdHJhbmdlLnNlbGVjdCgpO1xuXG5cdFx0XHRjb25zdCBja0xpbmsgPSBuZXcgQ0tFRElUT1IuTGluayhlZGl0b3IpO1xuXHRcdFx0Y2tMaW5rLmNyZWF0ZShjb250ZW50KTtcblx0XHRcdHRoaXMuX2NrTGluayA9IGNrTGluaztcblxuXHRcdFx0Y29uc3QgbGlua05vZGUgPSBja0xpbmsuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXHRcdFx0ZWRpdG9yLmZpcmUoJ2F1dG9saW5rQWRkJywgbGlua05vZGUpO1xuXG5cdFx0XHR0aGlzLl9zdWJzY3JpYmVUb0tleUV2ZW50KGVkaXRvcik7XG5cblx0XHRcdC8vIE5vdyByYW5nZSBpcyBvbiB0aGUgbGluayBhbmQgaXQgaXMgc2VsZWN0ZWQuIFdlIGhhdmUgdG9cblx0XHRcdC8vIHJldHVybiBmb2N1cyB0byB0aGUgY2FyZXQgcG9zaXRpb24uXG5cdFx0XHRyYW5nZSA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZXMoKVswXTtcblxuXHRcdFx0Ly8gSWYgdXNlciBwcmVzc2VkIGBFbnRlcmAsIGdldCB0aGUgbmV4dCBlZGl0YWJsZSBub2RlIGF0IHBvc2l0aW9uIDAsXG5cdFx0XHQvLyBvdGhlcndpc2Ugc2V0IHRoZSBjdXJzb3IgYXQgdGhlIG5leHQgY2hhcmFjdGVyIG9mIHRoZSBsaW5rICh0aGUgd2hpdGUgc3BhY2UpXG5cdFx0XHRpZiAodGhpcy5fY3VycmVudEtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuXHRcdFx0XHRjb25zdCBuZXh0RWRpdGFibGVOb2RlID0gcmFuZ2UuZ2V0TmV4dEVkaXRhYmxlTm9kZSgpO1xuXG5cdFx0XHRcdHJhbmdlLnNldFN0YXJ0KG5leHRFZGl0YWJsZU5vZGUsIDApO1xuXHRcdFx0XHRyYW5nZS5zZXRFbmQobmV4dEVkaXRhYmxlTm9kZSwgMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBlbmNsb3NlZE5vZGUgPSByYW5nZS5nZXRFbmNsb3NlZE5vZGUoKTtcblxuXHRcdFx0XHRyYW5nZS5zZXRTdGFydChlbmNsb3NlZE5vZGUsIDApO1xuXHRcdFx0XHRyYW5nZS5zZXRFbmQoZW5jbG9zZWROb2RlLCAwKTtcblx0XHRcdH1cblxuXHRcdFx0cmFuZ2Uuc2VsZWN0KCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZpcmVkIHdoZW4gYSBVUkwgaXMgZGV0ZWN0ZWQgaW4gdGV4dCBhbmQgY29udmVydGVkIHRvIGEgbGluay5cblx0XHQgKlxuXHRcdCAqIEBldmVudCBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rI2F1dG9saW5rQWRkXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcblx0XHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBlbCBOb2RlIG9mIHRoZSBjcmVhdGVkIGxpbmsuXG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIHRoZSBjcmVhdGVkIGxpbmsgZWxlbWVudCwgYW5kIHJlcGxhY2VzIGl0IGJ5IGl0cyB0ZXh0LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcblx0XHQgKiBAbWV0aG9kIF9yZW1vdmVMaW5rXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9yZW1vdmVMaW5rKGVkaXRvcikge1xuXHRcdFx0Y29uc3QgcmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cdFx0XHRjb25zdCBjYXJldE9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuXG5cdFx0XHQvLyBTZWxlY3QgdGhlIGxpbmssIHNvIENLRURJVE9SLkxpbmsgY2FuIHByb3Blcmx5IHJlbW92ZSBpdFxuXHRcdFx0Y29uc3QgbGlua05vZGUgPVxuXHRcdFx0XHR0aGlzLl9zdGFydENvbnRhaW5lci5nZXROZXh0KCkgfHwgdGhpcy5fc3RhcnRDb250YWluZXI7XG5cblx0XHRcdGNvbnN0IG5ld1JhbmdlID0gZWRpdG9yLmNyZWF0ZVJhbmdlKCk7XG5cdFx0XHRuZXdSYW5nZS5zZXRTdGFydChsaW5rTm9kZSwgMCk7XG5cdFx0XHRuZXdSYW5nZS5zZXRFbmRBZnRlcihsaW5rTm9kZSk7XG5cdFx0XHRuZXdSYW5nZS5zZWxlY3QoKTtcblxuXHRcdFx0dGhpcy5fY2tMaW5rLnJlbW92ZSgpO1xuXG5cdFx0XHQvLyBSZXR1cm4gZm9jdXMgdG8gdGhlIGNhcmV0IHBvc2l0aW9uXG5cdFx0XHRyYW5nZS5zZXRFbmQocmFuZ2Uuc3RhcnRDb250YWluZXIsIGNhcmV0T2Zmc2V0KTtcblx0XHRcdHJhbmdlLnNldFN0YXJ0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBjYXJldE9mZnNldCk7XG5cblx0XHRcdHJhbmdlLnNlbGVjdCgpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTdWJzY3JpYmUgdG8gYSBrZXkgZXZlbnQgb2YgdGhlIGVkaXRhYmxlIGFyaWEuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlua1xuXHRcdCAqIEBtZXRob2QgX3N1YnNjcmliZVRvS2V5RXZlbnRcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X3N1YnNjcmliZVRvS2V5RXZlbnQoZWRpdG9yKSB7XG5cdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHQvLyBDaGFuZ2UgdGhlIHByaW9yaXR5IG9mIGtleWRvd24gbGlzdGVuZXIgLSAxIG1lYW5zIHRoZSBoaWdoZXN0IHByaW9yaXR5LlxuXHRcdFx0Ly8gSW4gQ2hyb21lIG9uIHByZXNzaW5nIGBFbnRlcmAgdGhlIGxpc3RlbmVyIGlzIG5vdCBiZWluZyBpbnZva2VkLlxuXHRcdFx0Ly8gU2VlIGh0dHA6Ly9kZXYuY2tlZGl0b3IuY29tL3RpY2tldC8xMTg2MSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHRcdGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKFxuXHRcdFx0XHRlZGl0YWJsZSxcblx0XHRcdFx0J2tleWRvd24nLFxuXHRcdFx0XHR0aGlzLl9vbktleURvd24sXG5cdFx0XHRcdHRoaXMsXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlZGl0b3IsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdDFcblx0XHRcdCk7XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2F1dG9saXN0JykpIHtcblx0Y29uc3QgS0VZX0JBQ0sgPSA4O1xuXG5cdGNvbnN0IEtFWV9TUEFDRSA9IDMyO1xuXG5cdGNvbnN0IERFRkFVTFRfQ09ORklHID0gW1xuXHRcdHtcblx0XHRcdHJlZ2V4OiAvXlxcKiQvLFxuXHRcdFx0dHlwZTogJ2J1bGxldGVkbGlzdCcsXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRyZWdleDogL14xXFwuJC8sXG5cdFx0XHR0eXBlOiAnbnVtYmVyZWRsaXN0Jyxcblx0XHR9LFxuXHRdO1xuXG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gd2hpY2ggYXV0b21hdGljYWxseSBnZW5lcmF0ZXMgb3JkZXJlZC91bm9yZGVyZWQgbGlzdCB3aGVuIHVzZXIgdHlwZXMgdGV4dCB3aGljaCBsb29rcyBsaWtlIGEgbGlzdC5cblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpc3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfYXV0b2xpc3QnLCB7XG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS2VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuXHRcdCAqIFRoZSBmdW5jdGlvbiByZWdpc3RlcnMgdGhlIGBrZXlkb3duYCBldmVudCBvbiB0aGUgY29udGVudCBlZGl0aW5nIGFyZWEuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlzdFxuXHRcdCAqIEBtZXRob2QgaW5pdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG5cdFx0ICovXG5cdFx0aW5pdChlZGl0b3IpIHtcblx0XHRcdGVkaXRvci5vbmNlKCdjb250ZW50RG9tJywgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRcdGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKFxuXHRcdFx0XHRcdGVkaXRhYmxlLFxuXHRcdFx0XHRcdCdrZXlkb3duJyxcblx0XHRcdFx0XHR0aGlzLl9vbktleURvd24sXG5cdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRlZGl0b3IsXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrcyBmb3IgcHJlc3NpbmcgdGhlIGBCYWNrc3BhY2VgIGtleSBpbiBvcmRlciB0byB1bmRvIHRoZSBsaXN0IGNyZWF0aW9uLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpc3Rcblx0XHQgKiBAbWV0aG9kIF9jaGVja0ZvckJhY2tzcGFjZUFuZFVuZG9cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudCBvYmplY3Rcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X2NoZWNrRm9yQmFja3NwYWNlQW5kVW5kbyhldmVudCkge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcjtcblxuXHRcdFx0Y29uc3QgbmF0aXZlRXZlbnQgPSBldmVudC5kYXRhLiQ7XG5cblx0XHRcdGNvbnN0IGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdGVkaXRhYmxlLnJlbW92ZUxpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fY2hlY2tGb3JCYWNrc3BhY2VBbmRVbmRvKTtcblxuXHRcdFx0aWYgKG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IEtFWV9CQUNLKSB7XG5cdFx0XHRcdGVkaXRvci5leGVjQ29tbWFuZCgndW5kbycpO1xuXHRcdFx0XHRlZGl0b3IuaW5zZXJ0SHRtbChldmVudC5saXN0ZW5lckRhdGEuYnVsbGV0ICsgJyZuYnNwOycpO1xuXHRcdFx0XHRldmVudC5kYXRhLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrcyBjdXJyZW50IGxpbmUgdG8gZmluZCBtYXRjaCB3aXRoIE1BVENIRVMgb2JqZWN0IHRvIGNyZWF0ZSBPTCBvciBVTC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saXN0XG5cdFx0ICogQG1ldGhvZCBfY2hlY2tMaW5lXG5cdFx0ICogQHBhcmFtIHtlZGl0b3J9IEVkaXRvciBvYmplY3Rcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fG51bGx9IFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBkZXRlY3RlZCBsaXN0IGNvbmZpZyBpZiBhbnlcblx0XHQgKi9cblx0XHRfZ2V0TGlzdENvbmZpZyhlZGl0b3IpIHtcblx0XHRcdGNvbnN0IGNvbmZpZ1JlZ2V4ID0gZWRpdG9yLmNvbmZpZy5hdXRvbGlzdCB8fCBERUZBVUxUX0NPTkZJRztcblxuXHRcdFx0Y29uc3QgcmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cblx0XHRcdGNvbnN0IHRleHRDb250YWluZXIgPSByYW5nZS5lbmRDb250YWluZXIuZ2V0VGV4dCgpO1xuXG5cdFx0XHRjb25zdCBidWxsZXQgPSB0ZXh0Q29udGFpbmVyLnN1YnN0cmluZygwLCByYW5nZS5zdGFydE9mZnNldCk7XG5cblx0XHRcdGNvbnN0IHRleHQgPSB0ZXh0Q29udGFpbmVyLnN1YnN0cmluZyhcblx0XHRcdFx0cmFuZ2Uuc3RhcnRPZmZzZXQsXG5cdFx0XHRcdHRleHRDb250YWluZXIubGVuZ3RoXG5cdFx0XHQpO1xuXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXG5cdFx0XHRjb25zdCByZWdleExlbiA9IGNvbmZpZ1JlZ2V4Lmxlbmd0aDtcblxuXHRcdFx0bGV0IGF1dG9saXN0Q2ZnID0gbnVsbDtcblxuXHRcdFx0d2hpbGUgKCFhdXRvbGlzdENmZyAmJiByZWdleExlbiA+IGluZGV4KSB7XG5cdFx0XHRcdGNvbnN0IHJlZ2V4SXRlbSA9IGNvbmZpZ1JlZ2V4W2luZGV4XTtcblxuXHRcdFx0XHRpZiAocmVnZXhJdGVtLnJlZ2V4LnRlc3QoYnVsbGV0KSkge1xuXHRcdFx0XHRcdGF1dG9saXN0Q2ZnID0ge1xuXHRcdFx0XHRcdFx0YnVsbGV0LFxuXHRcdFx0XHRcdFx0ZWRpdG9yLFxuXHRcdFx0XHRcdFx0dGV4dCxcblx0XHRcdFx0XHRcdHR5cGU6IHJlZ2V4SXRlbS50eXBlLFxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhdXRvbGlzdENmZztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGxpc3Qgd2l0aCBkaWZmZXJlbnQgdHlwZXM6IEJ1bGxldGVkIG9yIE51bWJlcmVkIGxpc3Rcblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saXN0XG5cdFx0ICogQG1ldGhvZCBfY3JlYXRlTGlzdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBsaXN0Q29uZmlnIE9iamVjdCB0aGF0IGNvbnRhaW5zIGJ1bGxldCwgdGV4dCBhbmQgdHlwZSBmb3IgY3JlYXRpbmcgdGhlIGxpc3Rcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X2NyZWF0ZUxpc3QobGlzdENvbmZpZykge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gbGlzdENvbmZpZy5lZGl0b3I7XG5cblx0XHRcdGNvbnN0IHJhbmdlID0gZWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFJhbmdlcygpWzBdO1xuXG5cdFx0XHRyYW5nZS5lbmRDb250YWluZXIuc2V0VGV4dChsaXN0Q29uZmlnLnRleHQpO1xuXHRcdFx0ZWRpdG9yLmV4ZWNDb21tYW5kKGxpc3RDb25maWcudHlwZSk7XG5cblx0XHRcdGNvbnN0IGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdC8vIFN1YnNjcmliZSB0byBrZXlkb3duIGluIG9yZGVyIHRvIGNoZWNrIGlmIHRoZSBuZXh0IGtleSBwcmVzcyBpcyBgQmFja3NwYWNlYC5cblx0XHRcdC8vIElmIHNvLCB0aGUgY3JlYXRpb24gb2YgdGhlIGxpc3Qgd2lsbCBiZSBkaXNjYXJkZWQuXG5cdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0ZWRpdGFibGUsXG5cdFx0XHRcdCdrZXlkb3duJyxcblx0XHRcdFx0dGhpcy5fY2hlY2tGb3JCYWNrc3BhY2VBbmRVbmRvLFxuXHRcdFx0XHR0aGlzLFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZWRpdG9yLFxuXHRcdFx0XHRcdGJ1bGxldDogbGlzdENvbmZpZy5idWxsZXQsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdDFcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIExpc3RlbnMgdG8gdGhlIGBTcGFjZWAga2V5IGV2ZW50cyB0byBjaGVjayBpZiB0aGUgbGFzdCB3b3JkXG5cdFx0ICogaW50cm9kdWNlZCBieSB0aGUgdXNlciBzaG91bGQgYmUgcmVwbGFjZWQgYnkgYSBsaXN0IChPTCBvciBVTClcblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saXN0XG5cdFx0ICogQG1ldGhvZCBfb25LZXlEb3duXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9vbktleURvd24oZXZlbnQpIHtcblx0XHRcdGNvbnN0IG5hdGl2ZUV2ZW50ID0gZXZlbnQuZGF0YS4kO1xuXG5cdFx0XHRpZiAobmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gS0VZX1NQQUNFKSB7XG5cdFx0XHRcdGNvbnN0IGxpc3RDb25maWcgPSB0aGlzLl9nZXRMaXN0Q29uZmlnKFxuXHRcdFx0XHRcdGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3Jcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAobGlzdENvbmZpZykge1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHR0aGlzLl9jcmVhdGVMaXN0KGxpc3RDb25maWcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbi8qKlxuICogQ0tFZGl0b3IgcGx1Z2luOiBEcmFnYWJsZSBpbWFnZSByZXNpemluZ1xuICogaHR0cHM6Ly9naXRodWIuY29tL3NzdHVyL2NrLWRyYWdyZXNpemVcbiAqIC0gU2hvd3Mgc2VtaS10cmFuc3BhcmVudCBvdmVybGF5IHdoaWxlIHJlc2l6aW5nXG4gKiAtIEVuZm9yY2VzIEFzcGVjdCBSYXRpbyAodW5sZXNzIGhvbGRpbmcgc2hpZnQpXG4gKiAtIFNuYXAgdG8gc2l6ZSBvZiBvdGhlciBpbWFnZXMgaW4gZWRpdG9yXG4gKiAtIEVzY2FwZSB3aGlsZSBkcmFnZ2luZyBjYW5jZWxzIHJlc2l6ZVxuICovXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9kcmFncmVzaXplJykpIHtcblx0Y29uc3QgSU1BR0VfSEFORExFUyA9IHtcblx0XHRib3RoOiBbJ3RsJywgJ3RtJywgJ3RyJywgJ2xtJywgJ3JtJywgJ2JsJywgJ2JtJywgJ2JyJ10sXG5cdFx0aGVpZ2h0OiBbJ3RsJywgJ3RtJywgJ3RyJywgJ2JsJywgJ2JtJywgJ2JyJ10sXG5cdFx0c2NhbGU6IFsndGwnLCAndHInLCAnYmwnLCAnYnInXSxcblx0XHR3aWR0aDogWyd0bCcsICd0cicsICdsbScsICdybScsICdibCcsICdiciddLFxuXHR9O1xuXG5cdGNvbnN0IFBPU0lUSU9OX0VMRU1FTlRfRk4gPSB7XG5cdFx0YmwoaGFuZGxlLCBsZWZ0LCB0b3AsIGJveCkge1xuXHRcdFx0cG9zaXRpb25FbGVtZW50KGhhbmRsZSwgLTMgKyBsZWZ0LCBib3guaGVpZ2h0IC0gNCArIHRvcCk7XG5cdFx0fSxcblx0XHRibShoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG5cdFx0XHRwb3NpdGlvbkVsZW1lbnQoXG5cdFx0XHRcdGhhbmRsZSxcblx0XHRcdFx0TWF0aC5yb3VuZChib3gud2lkdGggLyAyKSAtIDMgKyBsZWZ0LFxuXHRcdFx0XHRib3guaGVpZ2h0IC0gNCArIHRvcFxuXHRcdFx0KTtcblx0XHR9LFxuXHRcdGJyKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcblx0XHRcdHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIGJveC53aWR0aCAtIDQgKyBsZWZ0LCBib3guaGVpZ2h0IC0gNCArIHRvcCk7XG5cdFx0fSxcblx0XHRsbShoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG5cdFx0XHRwb3NpdGlvbkVsZW1lbnQoXG5cdFx0XHRcdGhhbmRsZSxcblx0XHRcdFx0LTMgKyBsZWZ0LFxuXHRcdFx0XHRNYXRoLnJvdW5kKGJveC5oZWlnaHQgLyAyKSAtIDMgKyB0b3Bcblx0XHRcdCk7XG5cdFx0fSxcblx0XHR0bChoYW5kbGUsIGxlZnQsIHRvcCwgX2JveCkge1xuXHRcdFx0cG9zaXRpb25FbGVtZW50KGhhbmRsZSwgbGVmdCAtIDMsIHRvcCAtIDMpO1xuXHRcdH0sXG5cdFx0dG0oaGFuZGxlLCBsZWZ0LCB0b3AsIGJveCkge1xuXHRcdFx0cG9zaXRpb25FbGVtZW50KFxuXHRcdFx0XHRoYW5kbGUsXG5cdFx0XHRcdE1hdGgucm91bmQoYm94LndpZHRoIC8gMikgLSAzICsgbGVmdCxcblx0XHRcdFx0LTMgKyB0b3Bcblx0XHRcdCk7XG5cdFx0fSxcblx0XHR0cihoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG5cdFx0XHRwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCBib3gud2lkdGggLSA0ICsgbGVmdCwgLTMgKyB0b3ApO1xuXHRcdH0sXG5cdFx0cm0oaGFuZGxlLCBsZWZ0LCB0b3AsIGJveCkge1xuXHRcdFx0cG9zaXRpb25FbGVtZW50KFxuXHRcdFx0XHRoYW5kbGUsXG5cdFx0XHRcdGJveC53aWR0aCAtIDQgKyBsZWZ0LFxuXHRcdFx0XHRNYXRoLnJvdW5kKGJveC5oZWlnaHQgLyAyKSAtIDMgKyB0b3Bcblx0XHRcdCk7XG5cdFx0fSxcblx0fTtcblxuXHRjb25zdCBJTUFHRV9TTkFQX1RPX1NJWkUgPSA3O1xuXG5cdGNvbnN0IGlzRmlyZWZveCA9ICdNb3pBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5cblx0Y29uc3QgaXNXZWJLaXQgPSAnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuXG5cdGNvbnN0IGVuYWJsZVBsdWdpbiA9IGlzV2ViS2l0IHx8IGlzRmlyZWZveDtcblxuXHRpZiAoZW5hYmxlUGx1Z2luKSB7XG5cdFx0Ly8gQ1NTIGlzIGFkZGVkIGluIGEgY29tcHJlc3NlZCBmb3JtXG5cdFx0Q0tFRElUT1IuYWRkQ3NzKFxuXHRcdFx0J2ltZzo6c2VsZWN0aW9ue2NvbG9yOnJnYmEoMCwwLDAsMCl9aW1nLmNraW1ncnN6e291dGxpbmU6MXB4IGRhc2hlZCAjMDAwfSNja2ltZ3Jzentwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDowO2hlaWdodDowO2N1cnNvcjpkZWZhdWx0O3otaW5kZXg6MTAwMDF9I2NraW1ncnN6IHNwYW57ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDt3aWR0aDowO2hlaWdodDowO2JhY2tncm91bmQtc2l6ZToxMDAlIDEwMCU7b3BhY2l0eTouNjU7b3V0bGluZToxcHggZGFzaGVkICMwMDB9I2NraW1ncnN6IGl7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jazt3aWR0aDo1cHg7aGVpZ2h0OjVweDtiYWNrZ3JvdW5kOiNmZmY7Ym9yZGVyOjFweCBzb2xpZCAjMDAwfSNja2ltZ3JzeiBpLmFjdGl2ZSwjY2tpbWdyc3ogaTpob3ZlcntiYWNrZ3JvdW5kOiMwMDB9I2NraW1ncnN6IGkuYnIsI2NraW1ncnN6IGkudGx7Y3Vyc29yOm53c2UtcmVzaXplfSNja2ltZ3JzeiBpLmJtLCNja2ltZ3JzeiBpLnRte2N1cnNvcjpucy1yZXNpemV9I2NraW1ncnN6IGkuYmwsI2NraW1ncnN6IGkudHJ7Y3Vyc29yOm5lc3ctcmVzaXplfSNja2ltZ3JzeiBpLmxtLCNja2ltZ3JzeiBpLnJte2N1cnNvcjpldy1yZXNpemV9Ym9keS5kcmFnZ2luZy1icixib2R5LmRyYWdnaW5nLWJyICosYm9keS5kcmFnZ2luZy10bCxib2R5LmRyYWdnaW5nLXRsICp7Y3Vyc29yOm53c2UtcmVzaXplIWltcG9ydGFudH1ib2R5LmRyYWdnaW5nLWJtLGJvZHkuZHJhZ2dpbmctYm0gKixib2R5LmRyYWdnaW5nLXRtLGJvZHkuZHJhZ2dpbmctdG0gKntjdXJzb3I6bnMtcmVzaXplIWltcG9ydGFudH1ib2R5LmRyYWdnaW5nLWJsLGJvZHkuZHJhZ2dpbmctYmwgKixib2R5LmRyYWdnaW5nLXRyLGJvZHkuZHJhZ2dpbmctdHIgKntjdXJzb3I6bmVzdy1yZXNpemUhaW1wb3J0YW50fWJvZHkuZHJhZ2dpbmctbG0sYm9keS5kcmFnZ2luZy1sbSAqLGJvZHkuZHJhZ2dpbmctcm0sYm9keS5kcmFnZ2luZy1ybSAqe2N1cnNvcjpldy1yZXNpemUhaW1wb3J0YW50fSdcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW5cblx0ICovXG5cdENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV9kcmFncmVzaXplJywge1xuXHRcdG9uTG9hZCgpIHtcblx0XHRcdGlmICghZW5hYmxlUGx1Z2luKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGluaXQoZWRpdG9yKSB7XG5cdFx0XHRpZiAoIWVuYWJsZVBsdWdpbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGVkaXRvci5vbmNlKCdjb250ZW50RG9tJywgX2V2dCA9PiB7XG5cdFx0XHRcdGluaXQoZWRpdG9yKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGluaXQoZWRpdG9yKSB7XG5cdFx0Y29uc3Qgd2luZG93ID0gZWRpdG9yLndpbmRvdy4kO1xuXG5cdFx0Y29uc3QgZG9jdW1lbnQgPSBlZGl0b3IuZG9jdW1lbnQuJDtcblxuXHRcdGlmIChpc0ZpcmVmb3gpIHtcblx0XHRcdC8vIERpc2FibGUgdGhlIG5hdGl2ZSBpbWFnZSByZXNpemluZ1xuXHRcdFx0ZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2VuYWJsZU9iamVjdFJlc2l6aW5nJywgZmFsc2UsIGZhbHNlKTtcblx0XHR9XG5cblx0XHRjb25zdCBzbmFwVG9TaXplID1cblx0XHRcdHR5cGVvZiBJTUFHRV9TTkFQX1RPX1NJWkUgPT09ICd1bmRlZmluZWQnXG5cdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHQ6IElNQUdFX1NOQVBfVE9fU0laRTtcblxuXHRcdGVkaXRvci5jb25maWcuaW1hZ2VTY2FsZVJlc2l6ZSA9XG5cdFx0XHRlZGl0b3IuY29uZmlnLmltYWdlU2NhbGVSZXNpemUgfHwgJ2JvdGgnO1xuXG5cdFx0Y29uc3QgcmVzaXplciA9IG5ldyBSZXNpemVyKGVkaXRvciwge1xuXHRcdFx0aW1hZ2VTY2FsZVJlc2l6ZTogZWRpdG9yLmNvbmZpZy5pbWFnZVNjYWxlUmVzaXplLFxuXHRcdFx0c25hcFRvU2l6ZSxcblx0XHR9KTtcblxuXHRcdGNvbnN0IG1vdXNlRG93bkxpc3RlbmVyID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKHJlc2l6ZXIuaXNIYW5kbGUoZS50YXJnZXQpKSB7XG5cdFx0XHRcdHJlc2l6ZXIuaW5pdERyYWcoZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlRG93bkxpc3RlbmVyLCBmYWxzZSk7XG5cblx0XHRmdW5jdGlvbiBzZWxlY3Rpb25DaGFuZ2UoKSB7XG5cdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRcdGlmICghc2VsZWN0aW9uKSByZXR1cm47XG5cdFx0XHQvLyBJZiBhbiBlbGVtZW50IGlzIHNlbGVjdGVkIGFuZCB0aGF0IGVsZW1lbnQgaXMgYW4gSU1HXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHNlbGVjdGlvbi5nZXRUeXBlKCkgIT09IENLRURJVE9SLlNFTEVDVElPTl9OT05FICYmXG5cdFx0XHRcdHNlbGVjdGlvbi5nZXRTdGFydEVsZW1lbnQoKS5pcygnaW1nJylcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBBbmQgd2UncmUgbm90IHJpZ2h0IG9yIG1pZGRsZSBjbGlja2luZyBvbiB0aGUgaW1hZ2Vcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCF3aW5kb3cuZXZlbnQgfHxcblx0XHRcdFx0XHQhd2luZG93LmV2ZW50LmJ1dHRvbiB8fFxuXHRcdFx0XHRcdHdpbmRvdy5ldmVudC5idXR0b24gPT09IDBcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmVzaXplci5zaG93KHNlbGVjdGlvbi5nZXRTdGFydEVsZW1lbnQoKS4kKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzaXplci5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZWRpdG9yLm9uKCdzZWxlY3Rpb25DaGFuZ2UnLCBzZWxlY3Rpb25DaGFuZ2UpO1xuXG5cdFx0ZWRpdG9yLm9uKCdnZXREYXRhJywgZSA9PiB7XG5cdFx0XHRsZXQgaHRtbCA9IGUuZGF0YS5kYXRhVmFsdWUgfHwgJyc7XG5cdFx0XHRodG1sID0gaHRtbC5yZXBsYWNlKC88ZGl2IGlkPVwiY2tpbWdyc3pcIihbXFxzXFxTXSo/KTxcXC9kaXY+L2ksICcnKTtcblx0XHRcdGh0bWwgPSBodG1sLnJlcGxhY2UoL1xcYihja2ltZ3JzeilcXGIvZywgJycpO1xuXHRcdFx0ZS5kYXRhLmRhdGFWYWx1ZSA9IGh0bWw7XG5cdFx0fSk7XG5cblx0XHRlZGl0b3Iub24oJ2JlZm9yZVVuZG9JbWFnZScsICgpID0+IHtcblx0XHRcdC8vIFJlbW92ZSB0aGUgaGFuZGxlcyBiZWZvcmUgdW5kbyBpbWFnZXMgYXJlIHNhdmVkXG5cdFx0XHRyZXNpemVyLmhpZGUoKTtcblx0XHR9KTtcblxuXHRcdGVkaXRvci5vbignYWZ0ZXJVbmRvSW1hZ2UnLCAoKSA9PiB7XG5cdFx0XHQvLyBSZXN0b3JlIHRoZSBoYW5kbGVzIGFmdGVyIHVuZG8gaW1hZ2VzIGFyZSBzYXZlZFxuXHRcdFx0c2VsZWN0aW9uQ2hhbmdlKCk7XG5cdFx0fSk7XG5cblx0XHRlZGl0b3Iub24oJ2JsdXInLCAoKSA9PiB7XG5cdFx0XHQvLyBSZW1vdmUgdGhlIGhhbmRsZXMgd2hlbiBlZGl0b3IgbG9zZXMgZm9jdXNcblx0XHRcdHJlc2l6ZXIuaGlkZSgpO1xuXHRcdH0pO1xuXG5cdFx0ZWRpdG9yLm9uKCdiZWZvcmVNb2RlVW5sb2FkJywgZnVuY3Rpb24gc2VsZigpIHtcblx0XHRcdGVkaXRvci5yZW1vdmVMaXN0ZW5lcignYmVmb3JlTW9kZVVubG9hZCcsIHNlbGYpO1xuXHRcdFx0cmVzaXplci5oaWRlKCk7XG5cdFx0fSk7XG5cblx0XHRlZGl0b3Iub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG5cdFx0XHRjb25zdCByZXNpemVFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NraW1ncnN6Jyk7XG5cblx0XHRcdGlmIChyZXNpemVFbGVtZW50KSB7XG5cdFx0XHRcdHJlc2l6ZUVsZW1lbnQucmVtb3ZlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc0ZpcmVmb3gpIHtcblx0XHRcdFx0ZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2VuYWJsZU9iamVjdFJlc2l6aW5nJywgZmFsc2UsIHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZURvd25MaXN0ZW5lcik7XG5cdFx0fSk7XG5cblx0XHQvLyBVcGRhdGUgdGhlIHNlbGVjdGlvbiB3aGVuIHRoZSBicm93c2VyIHdpbmRvdyBpcyByZXNpemVkXG5cdFx0bGV0IHJlc2l6ZVRpbWVvdXQ7XG5cdFx0ZWRpdG9yLndpbmRvdy5vbigncmVzaXplJywgKCkgPT4ge1xuXHRcdFx0Ly8gQ2FuY2VsIGFueSByZXNpemUgd2FpdGluZyB0byBoYXBwZW5cblx0XHRcdGNsZWFyVGltZW91dChyZXNpemVUaW1lb3V0KTtcblx0XHRcdC8vIERlbGF5IHJlc2l6ZSB0byBcImRlYm91bmNlXCJcblx0XHRcdHJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHNlbGVjdGlvbkNoYW5nZSwgNTApO1xuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gUmVzaXplcihlZGl0b3IsIGNmZykge1xuXHRcdHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuXHRcdHRoaXMud2luZG93ID0gZWRpdG9yLndpbmRvdy4kO1xuXHRcdHRoaXMuZG9jdW1lbnQgPSBlZGl0b3IuZG9jdW1lbnQuJDtcblx0XHR0aGlzLmNmZyA9IGNmZyB8fCB7fTtcblx0XHR0aGlzLmluaXQoKTtcblx0fVxuXG5cdFJlc2l6ZXIucHJvdG90eXBlID0ge1xuXHRcdGluaXQoKSB7XG5cdFx0XHRjb25zdCBpbnN0YW5jZSA9IHRoaXM7XG5cblx0XHRcdGNvbnN0IGNvbnRhaW5lciA9ICh0aGlzLmNvbnRhaW5lciA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcblx0XHRcdFx0J2Rpdidcblx0XHRcdCkpO1xuXG5cdFx0XHRjb250YWluZXIuaWQgPSAnY2tpbWdyc3onO1xuXHRcdFx0dGhpcy5wcmV2aWV3ID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5wcmV2aWV3KTtcblxuXHRcdFx0Y29uc3QgaGFuZGxlcyA9ICh0aGlzLmhhbmRsZXMgPSB7fSk7XG5cblx0XHRcdElNQUdFX0hBTkRMRVNbdGhpcy5jZmcuaW1hZ2VTY2FsZVJlc2l6ZV0uZm9yRWFjaChoYW5kbGVOYW1lID0+IHtcblx0XHRcdFx0aGFuZGxlc1toYW5kbGVOYW1lXSA9IGluc3RhbmNlLmhhbmRsZXNbXG5cdFx0XHRcdFx0aGFuZGxlTmFtZVxuXHRcdFx0XHRdID0gaW5zdGFuY2UuY3JlYXRlSGFuZGxlKGhhbmRsZU5hbWUpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGZvciAoY29uc3QgbiBpbiBoYW5kbGVzKSB7XG5cdFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGFuZGxlcywgbikpIHtcblx0XHRcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoaGFuZGxlc1tuXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGNyZWF0ZUhhbmRsZShuYW1lKSB7XG5cdFx0XHRjb25zdCBlbCA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpO1xuXHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChuYW1lKTtcblx0XHRcdHJldHVybiBlbDtcblx0XHR9LFxuXHRcdGlzSGFuZGxlKGVsKSB7XG5cdFx0XHRjb25zdCBoYW5kbGVzID0gdGhpcy5oYW5kbGVzO1xuXHRcdFx0Zm9yIChjb25zdCBuIGluIGhhbmRsZXMpIHtcblx0XHRcdFx0aWYgKGhhbmRsZXNbbl0gPT09IGVsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHNob3coZWwpIHtcblx0XHRcdGxldCB1aU5vZGUgPSB0aGlzLmVkaXRvci5jb25maWcudWlOb2RlO1xuXG5cdFx0XHRjb25zdCBzY3JvbGxUb3AgPSB1aU5vZGUgPyB1aU5vZGUuc2Nyb2xsVG9wIDogMDtcblxuXHRcdFx0dGhpcy5lbCA9IGVsO1xuXHRcdFx0aWYgKHRoaXMuY2ZnLnNuYXBUb1NpemUpIHtcblx0XHRcdFx0dGhpcy5vdGhlckltYWdlcyA9IHRvQXJyYXkoXG5cdFx0XHRcdFx0dGhpcy5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW1nJylcblx0XHRcdFx0KTtcblx0XHRcdFx0dGhpcy5vdGhlckltYWdlcy5zcGxpY2UodGhpcy5vdGhlckltYWdlcy5pbmRleE9mKGVsKSwgMSk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBib3ggPSAodGhpcy5ib3ggPSBnZXRCb3VuZGluZ0JveCh0aGlzLndpbmRvdywgZWwpKTtcblx0XHRcdHBvc2l0aW9uRWxlbWVudCh0aGlzLmNvbnRhaW5lciwgYm94LmxlZnQsIGJveC50b3AgKyBzY3JvbGxUb3ApO1xuXG5cdFx0XHR1aU5vZGUgPSB1aU5vZGUgfHwgZG9jdW1lbnQuYm9keTtcblxuXHRcdFx0dWlOb2RlLmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcblxuXHRcdFx0dGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdja2ltZ3JzeicpO1xuXHRcdFx0dGhpcy5zaG93SGFuZGxlcygpO1xuXHRcdH0sXG5cdFx0aGlkZSgpIHtcblx0XHRcdC8vIFJlbW92ZSBjbGFzcyBmcm9tIGFsbCBpbWcuY2tpbWdyc3pcblx0XHRcdGNvbnN0IGVsZW1lbnRzID0gdGhpcy5kb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdja2ltZ3JzeicpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRlbGVtZW50c1tpXS5jbGFzc0xpc3QucmVtb3ZlKCdja2ltZ3JzeicpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5oaWRlSGFuZGxlcygpO1xuXHRcdFx0aWYgKHRoaXMuY29udGFpbmVyLnBhcmVudE5vZGUpIHtcblx0XHRcdFx0dGhpcy5jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRpbml0RHJhZyhlKSB7XG5cdFx0XHRpZiAoZS5idXR0b24gIT09IDApIHtcblx0XHRcdFx0Ly8gcmlnaHQtY2xpY2sgb3IgbWlkZGxlLWNsaWNrXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHJlc2l6ZXIgPSB0aGlzO1xuXHRcdFx0Y29uc3QgZHJhZyA9IG5ldyBEcmFnRXZlbnQodGhpcy53aW5kb3csIHRoaXMuZG9jdW1lbnQpO1xuXHRcdFx0ZHJhZy5vblN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlc2l6ZXIuc2hvd1ByZXZpZXcoKTtcblx0XHRcdFx0cmVzaXplci5pc0RyYWdnaW5nID0gdHJ1ZTtcblx0XHRcdFx0cmVzaXplci5lZGl0b3IuZ2V0U2VsZWN0aW9uKCkubG9jaygpO1xuXHRcdFx0fTtcblx0XHRcdGRyYWcub25EcmFnID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlc2l6ZXIuY2FsY3VsYXRlU2l6ZSh0aGlzKTtcblx0XHRcdFx0cmVzaXplci51cGRhdGVQcmV2aWV3KCk7XG5cdFx0XHRcdGNvbnN0IGJveCA9IHJlc2l6ZXIucHJldmlld0JveDtcblx0XHRcdFx0cmVzaXplci51cGRhdGVIYW5kbGVzKGJveCwgYm94LmxlZnQsIGJveC50b3ApO1xuXHRcdFx0fTtcblx0XHRcdGRyYWcub25SZWxlYXNlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlc2l6ZXIuaXNEcmFnZ2luZyA9IGZhbHNlO1xuXHRcdFx0XHRyZXNpemVyLmhpZGVQcmV2aWV3KCk7XG5cdFx0XHRcdHJlc2l6ZXIuaGlkZSgpO1xuXHRcdFx0XHRyZXNpemVyLmVkaXRvci5nZXRTZWxlY3Rpb24oKS51bmxvY2soKTtcblx0XHRcdFx0Ly8gU2F2ZSBhbiB1bmRvIHNuYXBzaG90IGJlZm9yZSB0aGUgaW1hZ2UgaXMgcGVybWFuZW50bHkgY2hhbmdlZFxuXHRcdFx0XHRyZXNpemVyLmVkaXRvci5maXJlKCdzYXZlU25hcHNob3QnKTtcblx0XHRcdH07XG5cdFx0XHRkcmFnLm9uQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVzaXplci5yZXNpemVDb21wbGV0ZSgpO1xuXHRcdFx0XHQvLyBTYXZlIGFub3RoZXIgc25hcHNob3QgYWZ0ZXIgdGhlIGltYWdlIGlzIGNoYW5nZWRcblx0XHRcdFx0cmVzaXplci5lZGl0b3IuZmlyZSgnc2F2ZVNuYXBzaG90Jyk7XG5cdFx0XHR9O1xuXHRcdFx0ZHJhZy5zdGFydChlKTtcblx0XHR9LFxuXHRcdHVwZGF0ZUhhbmRsZXMoYm94LCBsZWZ0LCB0b3ApIHtcblx0XHRcdGxlZnQgPSBsZWZ0IHx8IDA7XG5cdFx0XHR0b3AgPSB0b3AgfHwgMDtcblx0XHRcdGNvbnN0IGhhbmRsZXMgPSB0aGlzLmhhbmRsZXM7XG5cblx0XHRcdGZvciAoY29uc3QgaGFuZGxlIGluIGhhbmRsZXMpIHtcblx0XHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoYW5kbGVzLCBoYW5kbGUpKSB7XG5cdFx0XHRcdFx0UE9TSVRJT05fRUxFTUVOVF9GTltoYW5kbGVdKFxuXHRcdFx0XHRcdFx0aGFuZGxlc1toYW5kbGVdLFxuXHRcdFx0XHRcdFx0bGVmdCxcblx0XHRcdFx0XHRcdHRvcCxcblx0XHRcdFx0XHRcdGJveFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHNob3dIYW5kbGVzKCkge1xuXHRcdFx0Y29uc3QgaGFuZGxlcyA9IHRoaXMuaGFuZGxlcztcblx0XHRcdHRoaXMudXBkYXRlSGFuZGxlcyh0aGlzLmJveCk7XG5cdFx0XHRmb3IgKGNvbnN0IG4gaW4gaGFuZGxlcykge1xuXHRcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhhbmRsZXMsIG4pKSB7XG5cdFx0XHRcdFx0aGFuZGxlc1tuXS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aGlkZUhhbmRsZXMoKSB7XG5cdFx0XHRjb25zdCBoYW5kbGVzID0gdGhpcy5oYW5kbGVzO1xuXHRcdFx0Zm9yIChjb25zdCBuIGluIGhhbmRsZXMpIHtcblx0XHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoYW5kbGVzLCBuKSkge1xuXHRcdFx0XHRcdGhhbmRsZXNbbl0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hvd1ByZXZpZXcoKSB7XG5cdFx0XHR0aGlzLnByZXZpZXcuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybChcIicgKyB0aGlzLmVsLnNyYyArICdcIiknO1xuXHRcdFx0dGhpcy5jYWxjdWxhdGVTaXplKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZVByZXZpZXcoKTtcblx0XHRcdHRoaXMucHJldmlldy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0XHR9LFxuXHRcdHVwZGF0ZVByZXZpZXcoKSB7XG5cdFx0XHRjb25zdCBib3ggPSB0aGlzLnByZXZpZXdCb3g7XG5cdFx0XHRwb3NpdGlvbkVsZW1lbnQodGhpcy5wcmV2aWV3LCBib3gubGVmdCwgYm94LnRvcCk7XG5cdFx0XHR0aGlzLnByZXZpZXcuc3R5bGUud2lkdGggPSB0aGlzLnByZXZpZXdCb3gud2lkdGggKyAncHgnO1xuXHRcdFx0dGhpcy5wcmV2aWV3LnN0eWxlLmhlaWdodCA9IHRoaXMucHJldmlld0JveC5oZWlnaHQgKyAncHgnO1xuXHRcdH0sXG5cdFx0aGlkZVByZXZpZXcoKSB7XG5cdFx0XHRjb25zdCBib3ggPSBnZXRCb3VuZGluZ0JveCh0aGlzLndpbmRvdywgdGhpcy5wcmV2aWV3KTtcblx0XHRcdHRoaXMucmVzdWx0ID0ge1xuXHRcdFx0XHR3aWR0aDogYm94LndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGJveC5oZWlnaHQsXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5wcmV2aWV3LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0fSxcblx0XHRjYWxjdWxhdGVTaXplKGRhdGEpIHtcblx0XHRcdGNvbnN0IGJveCA9ICh0aGlzLnByZXZpZXdCb3ggPSB7XG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0d2lkdGg6IHRoaXMuYm94LndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IHRoaXMuYm94LmhlaWdodCxcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoIWRhdGEpIHJldHVybjtcblxuXHRcdFx0Y29uc3QgYXR0ciA9IGRhdGEudGFyZ2V0LmNsYXNzTmFtZTtcblxuXHRcdFx0aWYgKH5hdHRyLmluZGV4T2YoJ3InKSkge1xuXHRcdFx0XHRib3gud2lkdGggPSBNYXRoLm1heCgzMiwgdGhpcy5ib3gud2lkdGggKyBkYXRhLmRlbHRhLngpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKH5hdHRyLmluZGV4T2YoJ2InKSkge1xuXHRcdFx0XHRib3guaGVpZ2h0ID0gTWF0aC5tYXgoMzIsIHRoaXMuYm94LmhlaWdodCArIGRhdGEuZGVsdGEueSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAofmF0dHIuaW5kZXhPZignbCcpKSB7XG5cdFx0XHRcdGJveC53aWR0aCA9IE1hdGgubWF4KDMyLCB0aGlzLmJveC53aWR0aCAtIGRhdGEuZGVsdGEueCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAofmF0dHIuaW5kZXhPZigndCcpKSB7XG5cdFx0XHRcdGJveC5oZWlnaHQgPSBNYXRoLm1heCgzMiwgdGhpcy5ib3guaGVpZ2h0IC0gZGF0YS5kZWx0YS55KTtcblx0XHRcdH1cblx0XHRcdC8vIGlmIGRyYWdnaW5nIGNvcm5lciwgZW5mb3JjZSBhc3BlY3QgcmF0aW8gKHVubGVzcyBzaGlmdCBrZXkgaXMgYmVpbmcgaGVsZClcblx0XHRcdGlmIChhdHRyLmluZGV4T2YoJ20nKSA8IDAgJiYgIWRhdGEua2V5cy5zaGlmdCkge1xuXHRcdFx0XHRjb25zdCByYXRpbyA9IHRoaXMuYm94LndpZHRoIC8gdGhpcy5ib3guaGVpZ2h0O1xuXHRcdFx0XHRpZiAoYm94LndpZHRoIC8gYm94LmhlaWdodCA+IHJhdGlvKSB7XG5cdFx0XHRcdFx0Ym94LmhlaWdodCA9IE1hdGgucm91bmQoYm94LndpZHRoIC8gcmF0aW8pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJveC53aWR0aCA9IE1hdGgucm91bmQoYm94LmhlaWdodCAqIHJhdGlvKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzbmFwVG9TaXplID0gdGhpcy5jZmcuc25hcFRvU2l6ZTtcblxuXHRcdFx0aWYgKHNuYXBUb1NpemUpIHtcblx0XHRcdFx0Y29uc3Qgb3RoZXJzID0gdGhpcy5vdGhlckltYWdlcztcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBvdGhlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBvdGhlciA9IGdldEJvdW5kaW5nQm94KHRoaXMud2luZG93LCBvdGhlcnNbaV0pO1xuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdE1hdGguYWJzKGJveC53aWR0aCAtIG90aGVyLndpZHRoKSA8PSBzbmFwVG9TaXplICYmXG5cdFx0XHRcdFx0XHRNYXRoLmFicyhib3guaGVpZ2h0IC0gb3RoZXIuaGVpZ2h0KSA8PSBzbmFwVG9TaXplXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRib3gud2lkdGggPSBvdGhlci53aWR0aDtcblx0XHRcdFx0XHRcdGJveC5oZWlnaHQgPSBvdGhlci5oZWlnaHQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVjYWxjdWxhdGUgbGVmdCBvciB0b3AgcG9zaXRpb25cblx0XHRcdGlmICh+YXR0ci5pbmRleE9mKCdsJykpIHtcblx0XHRcdFx0Ym94LmxlZnQgPSB0aGlzLmJveC53aWR0aCAtIGJveC53aWR0aDtcblx0XHRcdH1cblx0XHRcdGlmICh+YXR0ci5pbmRleE9mKCd0JykpIHtcblx0XHRcdFx0Ym94LnRvcCA9IHRoaXMuYm94LmhlaWdodCAtIGJveC5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZXNpemVDb21wbGV0ZSgpIHtcblx0XHRcdHJlc2l6ZUVsZW1lbnQuY2FsbChcblx0XHRcdFx0dGhpcyxcblx0XHRcdFx0dGhpcy5lbCxcblx0XHRcdFx0dGhpcy5yZXN1bHQud2lkdGgsXG5cdFx0XHRcdHRoaXMucmVzdWx0LmhlaWdodFxuXHRcdFx0KTtcblx0XHR9LFxuXHR9O1xuXG5cdGZ1bmN0aW9uIERyYWdFdmVudCh3aW5kb3csIGRvY3VtZW50KSB7XG5cdFx0dGhpcy53aW5kb3cgPSB3aW5kb3c7XG5cdFx0dGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuXHRcdHRoaXMuZXZlbnRzID0ge1xuXHRcdFx0bW91c2Vtb3ZlOiBiaW5kKHRoaXMubW91c2Vtb3ZlLCB0aGlzKSxcblx0XHRcdGtleWRvd246IGJpbmQodGhpcy5rZXlkb3duLCB0aGlzKSxcblx0XHRcdG1vdXNldXA6IGJpbmQodGhpcy5tb3VzZXVwLCB0aGlzKSxcblx0XHR9O1xuXHR9XG5cblx0RHJhZ0V2ZW50LnByb3RvdHlwZSA9IHtcblx0XHRzdGFydChlKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0dGhpcy50YXJnZXQgPSBlLnRhcmdldDtcblx0XHRcdHRoaXMuYXR0ciA9IGUudGFyZ2V0LmNsYXNzTmFtZTtcblx0XHRcdHRoaXMuc3RhcnRQb3MgPSB7XG5cdFx0XHRcdHg6IGUuY2xpZW50WCxcblx0XHRcdFx0eTogZS5jbGllbnRZLFxuXHRcdFx0fTtcblx0XHRcdHRoaXMudXBkYXRlKGUpO1xuXHRcdFx0Y29uc3QgZXZlbnRzID0gdGhpcy5ldmVudHM7XG5cdFx0XHR0aGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG5cdFx0XHRcdCdtb3VzZW1vdmUnLFxuXHRcdFx0XHRldmVudHMubW91c2Vtb3ZlLFxuXHRcdFx0XHRmYWxzZVxuXHRcdFx0KTtcblx0XHRcdHRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGV2ZW50cy5rZXlkb3duLCBmYWxzZSk7XG5cdFx0XHR0aGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBldmVudHMubW91c2V1cCwgZmFsc2UpO1xuXHRcdFx0dGhpcy5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ2RyYWdnaW5nLScgKyB0aGlzLmF0dHIpO1xuXHRcdFx0aWYgKHRoaXMub25TdGFydCkge1xuXHRcdFx0XHR0aGlzLm9uU3RhcnQoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHVwZGF0ZShlKSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRQb3MgPSB7XG5cdFx0XHRcdHg6IGUuY2xpZW50WCxcblx0XHRcdFx0eTogZS5jbGllbnRZLFxuXHRcdFx0fTtcblx0XHRcdHRoaXMuZGVsdGEgPSB7XG5cdFx0XHRcdHg6IGUuY2xpZW50WCAtIHRoaXMuc3RhcnRQb3MueCxcblx0XHRcdFx0eTogZS5jbGllbnRZIC0gdGhpcy5zdGFydFBvcy55LFxuXHRcdFx0fTtcblx0XHRcdHRoaXMua2V5cyA9IHtcblx0XHRcdFx0c2hpZnQ6IGUuc2hpZnRLZXksXG5cdFx0XHRcdGN0cmw6IGUuY3RybEtleSxcblx0XHRcdFx0YWx0OiBlLmFsdEtleSxcblx0XHRcdH07XG5cdFx0fSxcblx0XHRtb3VzZW1vdmUoZSkge1xuXHRcdFx0dGhpcy51cGRhdGUoZSk7XG5cdFx0XHRpZiAodGhpcy5vbkRyYWcpIHtcblx0XHRcdFx0dGhpcy5vbkRyYWcoKTtcblx0XHRcdH1cblx0XHRcdGlmIChlLndoaWNoID09PSAwKSB7XG5cdFx0XHRcdC8vIG1vdXNlIGJ1dHRvbiByZWxlYXNlZCBvdXRzaWRlIHdpbmRvdzsgbW91c2V1cCB3YXNuJ3QgZmlyZWQgKENocm9tZSlcblx0XHRcdFx0dGhpcy5tb3VzZXVwKGUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0a2V5ZG93bihlKSB7XG5cdFx0XHQvLyBlc2NhcGUga2V5IGNhbmNlbHMgZHJhZ2dpbmdcblx0XHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG5cdFx0XHRcdHRoaXMucmVsZWFzZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bW91c2V1cChlKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZShlKTtcblx0XHRcdHRoaXMucmVsZWFzZSgpO1xuXHRcdFx0aWYgKHRoaXMub25Db21wbGV0ZSkge1xuXHRcdFx0XHR0aGlzLm9uQ29tcGxldGUoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlbGVhc2UoKSB7XG5cdFx0XHR0aGlzLmRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZ2dpbmctJyArIHRoaXMuYXR0cik7XG5cdFx0XHRjb25zdCBldmVudHMgPSB0aGlzLmV2ZW50cztcblx0XHRcdHRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcblx0XHRcdFx0J21vdXNlbW92ZScsXG5cdFx0XHRcdGV2ZW50cy5tb3VzZW1vdmUsXG5cdFx0XHRcdGZhbHNlXG5cdFx0XHQpO1xuXHRcdFx0dGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXZlbnRzLmtleWRvd24sIGZhbHNlKTtcblx0XHRcdHRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGV2ZW50cy5tb3VzZXVwLCBmYWxzZSk7XG5cdFx0XHRpZiAodGhpcy5vblJlbGVhc2UpIHtcblx0XHRcdFx0dGhpcy5vblJlbGVhc2UoKTtcblx0XHRcdH1cblx0XHR9LFxuXHR9O1xuXG5cdC8vIGhlbHBlciBmdW5jdGlvbnNcblx0ZnVuY3Rpb24gdG9BcnJheShvYmopIHtcblx0XHRjb25zdCBsZW4gPSBvYmoubGVuZ3RoO1xuXG5cdFx0Y29uc3QgYXJyID0gbmV3IEFycmF5KGxlbik7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0YXJyW2ldID0gb2JqW2ldO1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyO1xuXHR9XG5cblx0ZnVuY3Rpb24gYmluZChmbiwgY3R4KSB7XG5cdFx0aWYgKGZuLmJpbmQpIHtcblx0XHRcdHJldHVybiBmbi5iaW5kKGN0eCk7XG5cdFx0fVxuXHRcdHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG5cdFx0XHRmbi5hcHBseShjdHgsIGFyZ3MpO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBwb3NpdGlvbkVsZW1lbnQoZWwsIGxlZnQsIHRvcCkge1xuXHRcdGVsLnN0eWxlLmxlZnQgPSBTdHJpbmcobGVmdCkgKyAncHgnO1xuXHRcdGVsLnN0eWxlLnRvcCA9IFN0cmluZyh0b3ApICsgJ3B4Jztcblx0fVxuXG5cdGZ1bmN0aW9uIHJlc2l6ZUVsZW1lbnQoZWwsIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRjb25zdCBpbWFnZVNjYWxlUmVzaXplID0gdGhpcy5lZGl0b3IuY29uZmlnLmltYWdlU2NhbGVSZXNpemU7XG5cdFx0aWYgKGltYWdlU2NhbGVSZXNpemUgPT09ICdib3RoJykge1xuXHRcdFx0ZWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIFN0cmluZyh3aWR0aCkpO1xuXHRcdFx0ZWwuc3R5bGUud2lkdGggPSBTdHJpbmcod2lkdGgpICsgJ3B4Jztcblx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgU3RyaW5nKGhlaWdodCkpO1xuXHRcdFx0ZWwuc3R5bGUuaGVpZ2h0ID0gU3RyaW5nKGhlaWdodCkgKyAncHgnO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRpbWFnZVNjYWxlUmVzaXplID09PSAnd2lkdGgnIHx8XG5cdFx0XHRpbWFnZVNjYWxlUmVzaXplID09PSAnc2NhbGUnXG5cdFx0KSB7XG5cdFx0XHRlbC5yZW1vdmVBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuXHRcdFx0ZWwuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuXHRcdFx0ZWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIFN0cmluZyh3aWR0aCkpO1xuXHRcdFx0ZWwuc3R5bGUud2lkdGggPSBTdHJpbmcod2lkdGgpICsgJ3B4Jztcblx0XHR9IGVsc2UgaWYgKGltYWdlU2NhbGVSZXNpemUgPT09ICdoZWlnaHQnKSB7XG5cdFx0XHRlbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIFN0cmluZyhoZWlnaHQpKTtcblx0XHRcdGVsLnN0eWxlLmhlaWdodCA9IFN0cmluZyhoZWlnaHQpICsgJ3B4Jztcblx0XHRcdGVsLnJlbW92ZUF0dHJpYnV0ZSgnd2lkdGgnKTtcblx0XHRcdGVsLnN0eWxlLndpZHRoID0gJ2F1dG8nO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KHdpbmRvdywgZWwpIHtcblx0XHRjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCxcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQsXG5cdFx0XHR3aWR0aDogcmVjdC53aWR0aCxcblx0XHRcdGhlaWdodDogcmVjdC5oZWlnaHQsXG5cdFx0fTtcblx0fVxufVxuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG4vKipcbiAqIENLRWRpdG9yIHBsdWdpbjogSW1hZ2UyXG4gKiAtIFNob3cgZ3JpcHBlciB0byByZXNpemUgaW1hZ2VzIG9uIElFXG4gKi9cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2RyYWdyZXNpemVfaWUnKSkge1xuXHRjb25zdCBhbGlnbm1lbnRzT2JqID0ge1xuXHRcdGNlbnRlcjogMSxcblx0XHRsZWZ0OiAwLFxuXHRcdHJpZ2h0OiAyLFxuXHR9O1xuXG5cdC8qXG5cdCAqIFNldCBjdXJzb3IgY3NzIGRlcGVuZCBvbiBpbWFnZVNjYWxlUmVzaXplIGNvbmZpZ1xuXHQgKiovXG5cblx0Y29uc3QgY3Vyc29yID0ge1xuXHRcdGJvdGg6ICdud3NlLXJlc2l6ZScsXG5cdFx0aGVpZ2h0OiAnbnMtcmVzaXplJyxcblx0XHRzY2FsZTogJ253c2UtcmVzaXplJyxcblx0XHR3aWR0aDogJ2V3LXJlc2l6ZScsXG5cdH07XG5cblx0Y29uc3QgcmVnZXhQZXJjZW50ID0gL15cXHMqKFxcZCslKVxccyokL2k7XG5cblx0Y29uc3QgdGVtcGxhdGUgPSAnPGltZyBhbHQ9XCJcIiBzcmM9XCJcIiAvPic7XG5cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX2RyYWdyZXNpemVfaWUnLCB7XG5cdFx0aGlkcGk6IHRydWUsXG5cblx0XHRpY29uczogJ2ltYWdlJyxcblxuXHRcdGluaXQoZWRpdG9yKSB7XG5cdFx0XHRjb25zdCBpbWFnZSA9IHdpZGdldERlZihlZGl0b3IpO1xuXG5cdFx0XHQvLyBSZWdpc3RlciB0aGUgd2lkZ2V0LlxuXHRcdFx0ZWRpdG9yLndpZGdldHMuYWRkKCdpbWFnZScsIGltYWdlKTtcblx0XHR9LFxuXG5cdFx0b25Mb2FkKCkge1xuXHRcdFx0Q0tFRElUT1IuYWRkQ3NzKFxuXHRcdFx0XHQnLmNrZV9pbWFnZV9yZXNpemVyX253c2UtcmVzaXpleycgK1xuXHRcdFx0XHRcdCdjdXJzb3I6IG53c2UtcmVzaXplOycgK1xuXHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0Jy5ja2VfaW1hZ2VfcmVzaXplcl9ucy1yZXNpemV7JyArXG5cdFx0XHRcdFx0J2N1cnNvcjogbnMtcmVzaXplOycgK1xuXHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0Jy5ja2VfaW1hZ2VfcmVzaXplcl9ud3NlLXJlc2l6ZXsnICtcblx0XHRcdFx0XHQnY3Vyc29yOiBud3NlLXJlc2l6ZTsnICtcblx0XHRcdFx0XHQnfScgK1xuXHRcdFx0XHRcdCcuY2tlX2ltYWdlX3Jlc2l6ZXJfZXctcmVzaXpleycgK1xuXHRcdFx0XHRcdCdjdXJzb3I6IGV3LXJlc2l6ZTsnICtcblx0XHRcdFx0XHQnfScgK1xuXHRcdFx0XHRcdCcuY2tlX2ltYWdlX25vY2FwdGlvbnsnICtcblx0XHRcdFx0XHQvLyBUaGlzIGlzIHRvIHJlbW92ZSB1bndhbnRlZCBzcGFjZSBzbyByZXNpemVcblx0XHRcdFx0XHQvLyB3cmFwcGVyIGlzIGRpc3BsYXllZCBwcm9wZXJ0eS5cblx0XHRcdFx0XHQnbGluZS1oZWlnaHQ6MCcgK1xuXHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0Jy5ja2VfaW1hZ2VfcmVzaXplcnsnICtcblx0XHRcdFx0XHQnZGlzcGxheTpub25lOycgK1xuXHRcdFx0XHRcdCdwb3NpdGlvbjphYnNvbHV0ZTsnICtcblx0XHRcdFx0XHQnd2lkdGg6MTBweDsnICtcblx0XHRcdFx0XHQnaGVpZ2h0OjEwcHg7JyArXG5cdFx0XHRcdFx0J2JvdHRvbTotNXB4OycgK1xuXHRcdFx0XHRcdCdyaWdodDotNXB4OycgK1xuXHRcdFx0XHRcdCdiYWNrZ3JvdW5kOiMwMDA7JyArXG5cdFx0XHRcdFx0J291dGxpbmU6MXB4IHNvbGlkICNmZmY7JyArXG5cdFx0XHRcdFx0Ly8gUHJldmVudCBkcmFnIGhhbmRsZXIgZnJvbSBiZWluZyBtaXNwbGFjZWQgKCMxMTIwNykuXG5cdFx0XHRcdFx0J2xpbmUtaGVpZ2h0OjA7JyArXG5cdFx0XHRcdFx0J2N1cnNvcjpud3NlLXJlc2l6ZTsnICtcblx0XHRcdFx0XHQnfScgK1xuXHRcdFx0XHRcdCcuY2tlX2ltYWdlX3Jlc2l6ZXJfd3JhcHBlcnsnICtcblx0XHRcdFx0XHQncG9zaXRpb246cmVsYXRpdmU7JyArXG5cdFx0XHRcdFx0J2Rpc3BsYXk6aW5saW5lLWJsb2NrOycgK1xuXHRcdFx0XHRcdCdsaW5lLWhlaWdodDowOycgK1xuXHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0Jy5ja2Vfd2lkZ2V0X3dyYXBwZXI6aG92ZXIgLmNrZV9pbWFnZV9yZXNpemVyLCcgK1xuXHRcdFx0XHRcdCcuY2tlX2ltYWdlX3Jlc2l6ZXIuY2tlX2ltYWdlX3Jlc2l6aW5neycgK1xuXHRcdFx0XHRcdCdkaXNwbGF5OmJsb2NrJyArXG5cdFx0XHRcdFx0J30nXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRyZXF1aXJlczogJ3dpZGdldCcsXG5cdH0pO1xuXG5cdC8vIFdpZGdldCBzdGF0ZXMgKGZvcm1zKSBkZXBlbmRpbmcgb24gYWxpZ25tZW50IGFuZCBjb25maWd1cmF0aW9uLlxuXHQvL1xuXHQvLyBOb24tY2FwdGlvbmVkIHdpZGdldCAoaW5saW5lIHN0eWxlcylcblx0Ly8gXHRcdOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuXHQvLyBcdFx04pSCQWxpZ24g4pSCSW50ZXJuYWwgZm9ybSAgICAgICAgICAgICAgICAgIOKUgkRhdGEgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgm5vbmUgIOKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICDilII8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCbGVmdCAg4pSCPHdyYXBwZXIgc3R5bGU94oCdZmxvYXQ6bGVmdOKAnT4gICDilII8aW1nIHN0eWxlPeKAnWZsb2F0OmxlZnTigJ0gLz4gICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgmNlbnRlcuKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICDilII8cCBzdHlsZT3igJ10ZXh0LWFsaWduOmNlbnRlcuKAnT7ilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8cCBzdHlsZT3igJ10ZXh0LWFsaWduOmNlbnRlcuKAnT4g4pSCICA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiAgIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICDilII8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCcmlnaHQg4pSCPHdyYXBwZXIgc3R5bGU94oCdZmxvYXQ6cmlnaHTigJ0+ICDilII8aW1nIHN0eWxlPeKAnWZsb2F0OnJpZ2h04oCdIC8+ICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJTilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcblx0Ly9cblx0Ly8gTm9uLWNhcHRpb25lZCB3aWRnZXQgKGNvbmZpZy5pbWFnZTJfYWxpZ25DbGFzc2VzIGRlZmluZWQpXG5cdC8vIFx0XHTilIzilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcblx0Ly8gXHRcdOKUgkFsaWduIOKUgkludGVybmFsIGZvcm0gICAgICAgICAgICAgICAgICDilIJEYXRhICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJub25lICDilII8d3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAg4pSCPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgmxlZnQgIOKUgjx3cmFwcGVyIGNsYXNzPeKAnWxlZnTigJ0+ICAgICAgICAg4pSCPGltZyBjbGFzcz3igJ1sZWZ04oCdIC8+ICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJjZW50ZXLilII8d3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAg4pSCPHAgY2xhc3M94oCdY2VudGVy4oCdPiAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPHAgY2xhc3M94oCdY2VudGVy4oCdPiAgICAgICAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgICA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAg4pSCPC9wPiAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgnJpZ2h0IOKUgjx3cmFwcGVyIGNsYXNzPeKAnXJpZ2h04oCdPiAgICAgICAg4pSCPGltZyBjbGFzcz3igJ1yaWdodOKAnSAvPiAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSU4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG5cdC8vXG5cdC8vIENhcHRpb25lZCB3aWRnZXQgKGlubGluZSBzdHlsZXMpXG5cdC8vIFx0XHTilIzilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcblx0Ly8gXHRcdOKUgkFsaWduIOKUgkludGVybmFsIGZvcm0gICAgICAgICAgICAgICAgICAgICAgICAgICDilIJEYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgm5vbmUgIOKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilII8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCbGVmdCAg4pSCPHdyYXBwZXIgc3R5bGU94oCdZmxvYXQ6bGVmdOKAnT4gICAgICAgICAgICDilII8ZmlndXJlIHN0eWxlPeKAnWZsb2F0OmxlZnTigJ0gLz4gICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgmNlbnRlcuKUgjx3cmFwcGVyIHN0eWxlPeKAnXRleHQtYWxpZ246Y2VudGVy4oCdPiAgICAg4pSCPGRpdiBzdHlsZT3igJ10ZXh0LWFsaWduOmNlbnRlcuKAnT4gICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIHN0eWxlPeKAnWRpc3BsYXk6aW5saW5lLWJsb2Nr4oCdIC8+4pSCIDxmaWd1cmUgc3R5bGU94oCdZGlzcGxheTppbmxpbmUtYmxvY2vigJ0gLz7ilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilII8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgnJpZ2h0IOKUgjx3cmFwcGVyIHN0eWxlPeKAnWZsb2F0OnJpZ2h04oCdPiAgICAgICAgICAg4pSCPGZpZ3VyZSBzdHlsZT3igJ1mbG9hdDpyaWdodOKAnSAvPiAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSU4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG5cdC8vXG5cdC8vIENhcHRpb25lZCB3aWRnZXQgKGNvbmZpZy5pbWFnZTJfYWxpZ25DbGFzc2VzIGRlZmluZWQpXG5cdC8vIFx0XHTilIzilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcblx0Ly8gXHRcdOKUgkFsaWduIOKUgkludGVybmFsIGZvcm0gICAgICAgICAgICAgICAgICAgICAgICAgICDilIJEYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgm5vbmUgIOKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilII8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCbGVmdCAg4pSCPHdyYXBwZXIgY2xhc3M94oCdbGVmdOKAnT4gICAgICAgICAgICAgICAgICDilII8ZmlndXJlIGNsYXNzPeKAnWxlZnTigJ0gLz4gICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgmNlbnRlcuKUgjx3cmFwcGVyIGNsYXNzPeKAnWNlbnRlcuKAnT4gICAgICAgICAgICAgICAg4pSCPGRpdiBjbGFzcz3igJ1jZW50ZXLigJ0+ICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCPC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJyaWdodCDilII8d3JhcHBlciBjbGFzcz3igJ1yaWdodOKAnT4gICAgICAgICAgICAgICAgIOKUgjxmaWd1cmUgY2xhc3M94oCdcmlnaHTigJ0gLz4gICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn1cblx0Ly8gQHJldHVybnMge09iamVjdH1cblx0ZnVuY3Rpb24gd2lkZ2V0RGVmKGVkaXRvcikge1xuXHRcdGVkaXRvci5jb25maWcuaW1hZ2VTY2FsZVJlc2l6ZSA9XG5cdFx0XHRlZGl0b3IuY29uZmlnLmltYWdlU2NhbGVSZXNpemUgfHwgJ2JvdGgnO1xuXG5cdFx0ZWRpdG9yLm9uKCdpbWFnZUFkZCcsIGltYWdlRGF0YSA9PiB7XG5cdFx0XHRlZGl0b3Iud2lkZ2V0cy5pbml0T24oaW1hZ2VEYXRhLmRhdGEuZWwsICdpbWFnZScpO1xuXHRcdH0pO1xuXG5cdFx0Y29uc3QgYWxpZ25DbGFzc2VzID0gZWRpdG9yLmNvbmZpZy5pbWFnZTJfYWxpZ25DbGFzc2VzO1xuXG5cdFx0Y29uc3QgY2FwdGlvbmVkQ2xhc3MgPSBlZGl0b3IuY29uZmlnLmltYWdlMl9jYXB0aW9uZWRDbGFzcztcblxuXHRcdHJldHVybiB7XG5cdFx0XHRpbml0KCkge1xuXHRcdFx0XHRjb25zdCBoZWxwZXJzID0gQ0tFRElUT1IucGx1Z2lucy5pbWFnZTI7XG5cblx0XHRcdFx0Y29uc3QgaW1hZ2UgPSB0aGlzLnBhcnRzLmltYWdlO1xuXG5cdFx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdFx0YWx0OiBpbWFnZS5nZXRBdHRyaWJ1dGUoJ2FsdCcpIHx8ICcnLFxuXHRcdFx0XHRcdGhhc0NhcHRpb246ICEhdGhpcy5wYXJ0cy5jYXB0aW9uLFxuXHRcdFx0XHRcdGhlaWdodDogaW1hZ2UuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCAnJyxcblx0XHRcdFx0XHQvLyBMb2NrIHJhdGlvIGlzIG9uIGJ5IGRlZmF1bHQgKCMxMDgzMykuXG5cdFx0XHRcdFx0bG9jazogdGhpcy5yZWFkeVxuXHRcdFx0XHRcdFx0PyBoZWxwZXJzLmNoZWNrSGFzTmF0dXJhbFJhdGlvKGltYWdlKVxuXHRcdFx0XHRcdFx0OiB0cnVlLFxuXHRcdFx0XHRcdHNyYzogaW1hZ2UuZ2V0QXR0cmlidXRlKCdzcmMnKSxcblx0XHRcdFx0XHR3aWR0aDogaW1hZ2UuZ2V0QXR0cmlidXRlKCd3aWR0aCcpIHx8ICcnLFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIElmIHdlIHVzZWQgJ2EnIGluIHdpZGdldCNwYXJ0cyBkZWZpbml0aW9uLCBpdCBjb3VsZCBoYXBwZW4gdGhhdFxuXHRcdFx0XHQvLyBzZWxlY3RlZCBlbGVtZW50IGlzIGEgY2hpbGQgb2Ygd2lkZ2V0LnBhcnRzI2NhcHRpb24uIFNpbmNlIHRoZXJlJ3Mgbm8gY2xldmVyXG5cdFx0XHRcdC8vIHdheSB0byBzb2x2ZSBpdCB3aXRoIENTUyBzZWxlY3RvcnMsIGl0J3MgZG9uZSBsaWtlIHRoYXQuICgjMTE3ODMpLlxuXHRcdFx0XHRjb25zdCBsaW5rID0gaW1hZ2UuZ2V0QXNjZW5kYW50KCdhJyk7XG5cblx0XHRcdFx0aWYgKGxpbmsgJiYgdGhpcy53cmFwcGVyLmNvbnRhaW5zKGxpbmspKSB7XG5cdFx0XHRcdFx0dGhpcy5wYXJ0cy5saW5rID0gbGluaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIERlcGVuZGluZyBvbiBjb25maWd1cmF0aW9uLCByZWFkIHN0eWxlL2NsYXNzIGZyb20gZWxlbWVudCBhbmRcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgaXQuIFJlbW92ZWQgc3R5bGUvY2xhc3Mgd2lsbCBiZSBzZXQgb24gd3JhcHBlciBpbiAjZGF0YSBsaXN0ZW5lci5cblx0XHRcdFx0Ly8gTm90ZTogQ2VudGVyIGFsaWdubWVudCBpcyBkZXRlY3RlZCBkdXJpbmcgdXBjYXN0LCBzbyBvbmx5IGxlZnQvcmlnaHQgY2FzZXNcblx0XHRcdFx0Ly8gYXJlIGNoZWNrZWQgYmVsb3cuXG5cdFx0XHRcdGlmICghZGF0YS5hbGlnbikge1xuXHRcdFx0XHRcdGNvbnN0IGFsaWduRWxlbWVudCA9IGRhdGEuaGFzQ2FwdGlvbiA/IHRoaXMuZWxlbWVudCA6IGltYWdlO1xuXG5cdFx0XHRcdFx0Ly8gUmVhZCB0aGUgaW5pdGlhbCBsZWZ0L3JpZ2h0IGFsaWdubWVudCBmcm9tIHRoZSBjbGFzcyBzZXQgb24gZWxlbWVudC5cblx0XHRcdFx0XHRpZiAoYWxpZ25DbGFzc2VzKSB7XG5cdFx0XHRcdFx0XHRpZiAoYWxpZ25FbGVtZW50Lmhhc0NsYXNzKGFsaWduQ2xhc3Nlc1swXSkpIHtcblx0XHRcdFx0XHRcdFx0ZGF0YS5hbGlnbiA9ICdsZWZ0Jztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYWxpZ25FbGVtZW50Lmhhc0NsYXNzKGFsaWduQ2xhc3Nlc1syXSkpIHtcblx0XHRcdFx0XHRcdFx0ZGF0YS5hbGlnbiA9ICdyaWdodCc7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChkYXRhLmFsaWduKSB7XG5cdFx0XHRcdFx0XHRcdGFsaWduRWxlbWVudC5yZW1vdmVDbGFzcyhcblx0XHRcdFx0XHRcdFx0XHRhbGlnbkNsYXNzZXNbYWxpZ25tZW50c09ialtkYXRhLmFsaWduXV1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGRhdGEuYWxpZ24gPSAnbm9uZSc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFJlYWQgaW5pdGlhbCBmbG9hdCBzdHlsZSBmcm9tIGZpZ3VyZS9pbWFnZSBhbmQgdGhlbiByZW1vdmUgaXQuXG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRkYXRhLmFsaWduID0gYWxpZ25FbGVtZW50LmdldFN0eWxlKCdmbG9hdCcpIHx8ICdub25lJztcblx0XHRcdFx0XHRcdGFsaWduRWxlbWVudC5yZW1vdmVTdHlsZSgnZmxvYXQnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgcmlkIG9mIGV4dHJhIHZlcnRpY2FsIHNwYWNlIHdoZW4gdGhlcmUncyBubyBjYXB0aW9uLlxuXHRcdFx0XHQvLyBJdCB3aWxsIGltcHJvdmUgdGhlIGxvb2sgb2YgdGhlIHJlc2l6ZXIuXG5cdFx0XHRcdHRoaXMud3JhcHBlclsoZGF0YS5oYXNDYXB0aW9uID8gJ3JlbW92ZScgOiAnYWRkJykgKyAnQ2xhc3MnXShcblx0XHRcdFx0XHQnY2tlX2ltYWdlX25vY2FwdGlvbidcblx0XHRcdFx0KTtcblxuXHRcdFx0XHR0aGlzLnNldERhdGEoZGF0YSk7XG5cblx0XHRcdFx0aWYgKGVkaXRvci5jb25maWcuaW1hZ2UyX2Rpc2FibGVSZXNpemVyICE9PSB0cnVlKSB7XG5cdFx0XHRcdFx0c2V0dXBSZXNpemVyKHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBPdmVycmlkZXMgZGVmYXVsdCBtZXRob2QgdG8gaGFuZGxlIGludGVybmFsIG11dGFiaWxpdHkgb2YgSW1hZ2UyLlxuXHRcdFx0Ly8gQHNlZSBDS0VESVRPUi5wbHVnaW5zLndpZGdldCNhZGRDbGFzc1xuXHRcdFx0YWRkQ2xhc3MoY2xhc3NOYW1lKSB7XG5cdFx0XHRcdGdldFN0eWxlYWJsZUVsZW1lbnQodGhpcykuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcblx0XHRcdH0sXG5cblx0XHRcdGFsbG93ZWRDb250ZW50OiBnZXRXaWRnZXRBbGxvd2VkQ29udGVudChlZGl0b3IpLFxuXG5cdFx0XHQvLyBUaGlzIHdpZGdldCBjb252ZXJ0cyBzdHlsZS1kcml2ZW4gZGltZW5zaW9ucyB0byBhdHRyaWJ1dGVzLlxuXHRcdFx0Y29udGVudFRyYW5zZm9ybWF0aW9uczogW1snaW1nW3dpZHRoXTogc2l6ZVRvQXR0cmlidXRlJ11dLFxuXG5cdFx0XHRkYXRhKCkge1xuXHRcdFx0XHRjb25zdCBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXM7XG5cblx0XHRcdFx0Ly8gSW1hZ2UgY2FuJ3QgYmUgY2FwdGlvbmVkIHdoZW4gZmlnY2FwdGlvbiBpcyBkaXNhbGxvd2VkICgjMTEwMDQpLlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dGhpcy5kYXRhLmhhc0NhcHRpb24gJiZcblx0XHRcdFx0XHQhZWRpdG9yLmZpbHRlci5jaGVja0ZlYXR1cmUoZmVhdHVyZXMuY2FwdGlvbilcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmhhc0NhcHRpb24gPSBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEltYWdlIGNhbid0IGJlIGFsaWduZWQgd2hlbiBmbG9hdGluZyBpcyBkaXNhbGxvd2VkICgjMTEwMDQpLlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dGhpcy5kYXRhLmFsaWduICE9ICdub25lJyAmJlxuXHRcdFx0XHRcdCFlZGl0b3IuZmlsdGVyLmNoZWNrRmVhdHVyZShmZWF0dXJlcy5hbGlnbilcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmFsaWduID0gJ25vbmUnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVXBkYXRlIHdpZGdldC5wYXJ0cy5saW5rIHNpbmNlIGl0IHdpbGwgbm90IGF1dG8tdXBkYXRlIHVubGVzcyB3aWRnZXRcblx0XHRcdFx0Ly8gaXMgZGVzdHJveWVkIGFuZCByZS1pbml0ZWQuXG5cdFx0XHRcdGlmICghdGhpcy5kYXRhLmxpbmspIHtcblx0XHRcdFx0XHRpZiAodGhpcy5wYXJ0cy5saW5rKSB7XG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpcy5wYXJ0cy5saW5rO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIXRoaXMucGFydHMubGluaykge1xuXHRcdFx0XHRcdFx0dGhpcy5wYXJ0cy5saW5rID0gdGhpcy5wYXJ0cy5pbWFnZS5nZXRQYXJlbnQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnBhcnRzLmltYWdlLnNldEF0dHJpYnV0ZXMoe1xuXHRcdFx0XHRcdGFsdDogdGhpcy5kYXRhLmFsdCxcblxuXHRcdFx0XHRcdGNvbnRlbnRlZGl0YWJsZTogdGhpcy5wYXJ0cy5pbWFnZS5nZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdFx0XHQnY29udGVudGVkaXRhYmxlJ1xuXHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdD8gdGhpcy5wYXJ0cy5pbWFnZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpXG5cdFx0XHRcdFx0XHQ6IHRydWUsXG5cblx0XHRcdFx0XHQvLyBUaGlzIGludGVybmFsIGlzIHJlcXVpcmVkIGJ5IHRoZSBlZGl0b3IuXG5cdFx0XHRcdFx0J2RhdGEtY2tlLXNhdmVkLXNyYyc6IHRoaXMuZGF0YS5zcmMsXG5cblx0XHRcdFx0XHRzcmM6IHRoaXMuZGF0YS5zcmMsXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIElmIHNoaWZ0aW5nIG5vbi1jYXB0aW9uZWQgLT4gY2FwdGlvbmVkLCByZW1vdmUgY2xhc3Nlc1xuXHRcdFx0XHQvLyByZWxhdGVkIHRvIHN0eWxlcyBmcm9tIDxpbWcvPi5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRoaXMub2xkRGF0YSAmJlxuXHRcdFx0XHRcdCF0aGlzLm9sZERhdGEuaGFzQ2FwdGlvbiAmJlxuXHRcdFx0XHRcdHRoaXMuZGF0YS5oYXNDYXB0aW9uXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGZvciAoY29uc3QgYyBpbiB0aGlzLmRhdGEuY2xhc3Nlcykge1xuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5kYXRhLmNsYXNzZXMsXG5cdFx0XHRcdFx0XHRcdFx0Y1xuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5wYXJ0cy5pbWFnZS5yZW1vdmVDbGFzcyhjKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgZGltZW5zaW9ucyBvZiB0aGUgaW1hZ2UgYWNjb3JkaW5nIHRvIGdhdGhlcmVkIGRhdGEuXG5cdFx0XHRcdC8vIERvIGl0IG9ubHkgd2hlbiB0aGUgYXR0cmlidXRlcyBhcmUgYWxsb3dlZCAoIzExMDA0KS5cblx0XHRcdFx0aWYgKGVkaXRvci5maWx0ZXIuY2hlY2tGZWF0dXJlKGZlYXR1cmVzLmRpbWVuc2lvbikpIHtcblx0XHRcdFx0XHRzZXREaW1lbnNpb25zKHRoaXMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FjaGUgY3VycmVudCBkYXRhLlxuXHRcdFx0XHR0aGlzLm9sZERhdGEgPSBDS0VESVRPUi50b29scy5leHRlbmQoe30sIHRoaXMuZGF0YSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRkb3duY2FzdDogZG93bmNhc3RXaWRnZXRFbGVtZW50KGVkaXRvciksXG5cblx0XHRcdGRyYWdnYWJsZTogZmFsc2UsXG5cblx0XHRcdC8vIFRoaXMgd2lkZ2V0IGhhcyBhbiBlZGl0YWJsZSBjYXB0aW9uLlxuXHRcdFx0ZWRpdGFibGVzOiB7XG5cdFx0XHRcdGNhcHRpb246IHtcblx0XHRcdFx0XHRzZWxlY3RvcjogJ2ZpZ2NhcHRpb24nLFxuXHRcdFx0XHRcdGFsbG93ZWRDb250ZW50OiAnYnIgZW0gc3Ryb25nIHN1YiBzdXAgdSBzOyBhWyFocmVmLHRhcmdldF0nLFxuXHRcdFx0XHR9LFxuXHRcdFx0fSxcblxuXHRcdFx0ZmVhdHVyZXM6IGdldFdpZGdldEZlYXR1cmVzKGVkaXRvciksXG5cblx0XHRcdC8vIE92ZXJyaWRlcyBkZWZhdWx0IG1ldGhvZCB0byBoYW5kbGUgaW50ZXJuYWwgbXV0YWJpbGl0eSBvZiBJbWFnZTIuXG5cdFx0XHQvLyBAc2VlIENLRURJVE9SLnBsdWdpbnMud2lkZ2V0I2dldENsYXNzZXNcblx0XHRcdGdldENsYXNzZXM6IChmdW5jdGlvbigpIHtcblx0XHRcdFx0Y29uc3QgY2xhc3NSZWdleCA9IG5ldyBSZWdFeHAoXG5cdFx0XHRcdFx0J14oJyArXG5cdFx0XHRcdFx0XHRbXS5jb25jYXQoY2FwdGlvbmVkQ2xhc3MsIGFsaWduQ2xhc3Nlcykuam9pbignfCcpICtcblx0XHRcdFx0XHRcdCcpJCdcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y29uc3QgY2xhc3NlcyA9IHRoaXMucmVwb3NpdG9yeS5wYXJzZUVsZW1lbnRDbGFzc2VzKFxuXHRcdFx0XHRcdFx0Z2V0U3R5bGVhYmxlRWxlbWVudCh0aGlzKS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJylcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Ly8gTmVpdGhlciBjb25maWcuaW1hZ2UyX2NhcHRpb25lZENsYXNzIG5vciBjb25maWcuaW1hZ2UyX2FsaWduQ2xhc3Nlc1xuXHRcdFx0XHRcdC8vIGRvIG5vdCBiZWxvbmcgdG8gc3R5bGUgY2xhc3Nlcy5cblx0XHRcdFx0XHRmb3IgKGNvbnN0IGMgaW4gY2xhc3Nlcykge1xuXHRcdFx0XHRcdFx0aWYgKGNsYXNzUmVnZXgudGVzdChjKSkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgY2xhc3Nlc1tjXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gY2xhc3Nlcztcblx0XHRcdFx0fTtcblx0XHRcdH0pKCksXG5cblx0XHRcdGdldExhYmVsKCkge1xuXHRcdFx0XHRjb25zdCBsYWJlbCA9ICh0aGlzLmRhdGEuYWx0IHx8ICcnKSArICcgJyArIHRoaXMucGF0aE5hbWU7XG5cblx0XHRcdFx0cmV0dXJuIGxhYmVsO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gT3ZlcnJpZGVzIGRlZmF1bHQgbWV0aG9kIHRvIGhhbmRsZSBpbnRlcm5hbCBtdXRhYmlsaXR5IG9mIEltYWdlMi5cblx0XHRcdC8vIEBzZWUgQ0tFRElUT1IucGx1Z2lucy53aWRnZXQjaGFzQ2xhc3Ncblx0XHRcdGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gZ2V0U3R5bGVhYmxlRWxlbWVudCh0aGlzKS5oYXNDbGFzcyhjbGFzc05hbWUpO1xuXHRcdFx0fSxcblxuXHRcdFx0cGFydHM6IHtcblx0XHRcdFx0Y2FwdGlvbjogJ2ZpZ2NhcHRpb24nLFxuXHRcdFx0XHRpbWFnZTogJ2ltZycsXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBPdmVycmlkZXMgZGVmYXVsdCBtZXRob2QgdG8gaGFuZGxlIGludGVybmFsIG11dGFiaWxpdHkgb2YgSW1hZ2UyLlxuXHRcdFx0Ly8gQHNlZSBDS0VESVRPUi5wbHVnaW5zLndpZGdldCNyZW1vdmVDbGFzc1xuXHRcdFx0cmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7XG5cdFx0XHRcdGdldFN0eWxlYWJsZUVsZW1lbnQodGhpcykucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcblx0XHRcdH0sXG5cblx0XHRcdHJlcXVpcmVkQ29udGVudDogJ2ltZ1tzcmMsYWx0XScsXG5cblx0XHRcdHN0eWxlYWJsZUVsZW1lbnRzOiAnaW1nIGZpZ3VyZScsXG5cblx0XHRcdC8vIFRlbXBsYXRlIG9mIHRoZSB3aWRnZXQ6IHBsYWluIGltYWdlLlxuXHRcdFx0dGVtcGxhdGUsXG5cblx0XHRcdHVwY2FzdDogdXBjYXN0V2lkZ2V0RWxlbWVudChlZGl0b3IpLFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQSBzZXQgb2YgRW5oYW5jZWQgSW1hZ2UgKGltYWdlMikgcGx1Z2luIGhlbHBlcnMuXG5cdCAqXG5cdCAqIEBjbGFzc1xuXHQgKiBAc2luZ2xldG9uXG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmltYWdlMiA9IHtcblx0XHQvKipcblx0XHQgKiBDaGVja3Mgd2hldGhlciB0aGUgY3VycmVudCBpbWFnZSByYXRpbyBtYXRjaGVzIHRoZSBuYXR1cmFsIG9uZVxuXHRcdCAqIGJ5IGNvbXBhcmluZyBkaW1lbnNpb25zLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gaW1hZ2Vcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGNoZWNrSGFzTmF0dXJhbFJhdGlvKGltYWdlKSB7XG5cdFx0XHRjb25zdCAkID0gaW1hZ2UuJDtcblxuXHRcdFx0Y29uc3QgbmF0dXJhbCA9IHRoaXMuZ2V0TmF0dXJhbChpbWFnZSk7XG5cblx0XHRcdC8vIFRoZSByZWFzb24gZm9yIHR3byBhbHRlcm5hdGl2ZSBjb21wYXJpc29ucyBpcyB0aGF0IHRoZSByb3VuZGluZyBjYW4gY29tZSBmcm9tXG5cdFx0XHQvLyBib3RoIGRpbWVuc2lvbnMsIGUuZy4gdGhlcmUgYXJlIHR3byBjYXNlczpcblx0XHRcdC8vIFx0MS4gaGVpZ2h0IGlzIGNvbXB1dGVkIGFzIGEgcm91bmRlZCByZWxhdGlvbiBvZiB0aGUgcmVhbCBoZWlnaHQgYW5kIHRoZSB2YWx1ZSBvZiB3aWR0aCxcblx0XHRcdC8vXHQyLiB3aWR0aCBpcyBjb21wdXRlZCBhcyBhIHJvdW5kZWQgcmVsYXRpb24gb2YgdGhlIHJlYWwgd2lkdGggYW5kIHRoZSB2YWx1ZSBvZiBoZWlnaC5cblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdE1hdGgucm91bmQoKCQuY2xpZW50V2lkdGggLyBuYXR1cmFsLndpZHRoKSAqIG5hdHVyYWwuaGVpZ2h0KSA9PVxuXHRcdFx0XHRcdCQuY2xpZW50SGVpZ2h0IHx8XG5cdFx0XHRcdE1hdGgucm91bmQoKCQuY2xpZW50SGVpZ2h0IC8gbmF0dXJhbC5oZWlnaHQpICogbmF0dXJhbC53aWR0aCkgPT1cblx0XHRcdFx0XHQkLmNsaWVudFdpZHRoXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIG5hdHVyYWwgZGltZW5zaW9ucyBvZiB0aGUgaW1hZ2UuIEZvciBtb2Rlcm4gYnJvd3NlcnNcblx0XHQgKiBpdCB1c2VzIG5hdHVyYWwoV2lkdGh8SGVpZ2h0KS4gRm9yIG9sZCBvbmVzIChJRTgpIGl0IGNyZWF0ZXNcblx0XHQgKiBhIG5ldyBpbWFnZSBhbmQgcmVhZHMgdGhlIGRpbWVuc2lvbnMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBpbWFnZVxuXHRcdCAqIEByZXR1cm4ge09iamVjdH1cblx0XHQgKi9cblx0XHRnZXROYXR1cmFsKGltYWdlKSB7XG5cdFx0XHRsZXQgZGltZW5zaW9ucztcblxuXHRcdFx0aWYgKGltYWdlLiQubmF0dXJhbFdpZHRoKSB7XG5cdFx0XHRcdGRpbWVuc2lvbnMgPSB7XG5cdFx0XHRcdFx0aGVpZ2h0OiBpbWFnZS4kLm5hdHVyYWxIZWlnaCxcblx0XHRcdFx0XHR3aWR0aDogaW1hZ2UuJC5uYXR1cmFsV2lkdGgsXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuXHRcdFx0XHRpbWcuc3JjID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCdzcmMnKTtcblxuXHRcdFx0XHRkaW1lbnNpb25zID0ge1xuXHRcdFx0XHRcdGhlaWdodDogaW1nLmhlaWdoLFxuXHRcdFx0XHRcdHdpZHRoOiBpbWcud2lkdGgsXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkaW1lbnNpb25zO1xuXHRcdH0sXG5cdH07XG5cblx0Ly8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB3aWRnZXRzIGZyb20gYWxsIDxpbWc+IGFuZFxuXHQvLyA8ZmlndXJlIGNsYXNzPVwie2NvbmZpZy5pbWFnZTJfY2FwdGlvbmVkQ2xhc3N9XCI+IGVsZW1lbnRzLlxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn0gZWRpdG9yXG5cdC8vIEByZXR1cm5zIHtGdW5jdGlvbn1cblx0ZnVuY3Rpb24gdXBjYXN0V2lkZ2V0RWxlbWVudChlZGl0b3IpIHtcblx0XHRjb25zdCBpc0NlbnRlcldyYXBwZXIgPSBjZW50ZXJXcmFwcGVyQ2hlY2tlcihlZGl0b3IpO1xuXG5cdFx0Y29uc3QgY2FwdGlvbmVkQ2xhc3MgPSBlZGl0b3IuY29uZmlnLmltYWdlMl9jYXB0aW9uZWRDbGFzcztcblxuXHRcdC8vIEBwYXJhbSB7Q0tFRElUT1IuaHRtbFBhcnNlci5lbGVtZW50fSBlbFxuXHRcdC8vIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGVsLCBkYXRhKSB7XG5cdFx0XHRjb25zdCBkaW1lbnNpb25zID0ge1xuXHRcdFx0XHRoZWlnaHQ6IDEsXG5cdFx0XHRcdHdpZHRoOiAxLFxuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgbmFtZSA9IGVsLm5hbWU7XG5cblx0XHRcdGxldCBpbWFnZTtcblxuXHRcdFx0Ly8gIzExMTEwIERvbid0IGluaXRpYWxpemUgb24gcGFzdGVkIGZha2Ugb2JqZWN0cy5cblx0XHRcdGlmIChlbC5hdHRyaWJ1dGVzWydkYXRhLWNrZS1yZWFsZWxlbWVudCddKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBjZW50ZXIgd3JhcHBlciBpcyBmb3VuZCwgdGhlcmUgYXJlIDMgcG9zc2libGUgY2FzZXM6XG5cdFx0XHQvL1xuXHRcdFx0Ly8gMS4gPGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGZpZ3VyZT4uLi48L2ZpZ3VyZT48L2Rpdj4uXG5cdFx0XHQvLyAgICBJbiB0aGlzIGNhc2UgY2VudGVyaW5nIGlzIGRvbmUgd2l0aCBhIGNsYXNzIHNldCBvbiB3aWRnZXQud3JhcHBlci5cblx0XHRcdC8vICAgIFNpbXBseSByZXBsYWNlIGNlbnRlcmluZyB3cmFwcGVyIHdpdGggZmlndXJlIChpdCdzIG5vIGxvbmdlciBuZWNlc3NhcnkpLlxuXHRcdFx0Ly9cblx0XHRcdC8vIDIuIDxwIHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48aW1nLz48L3A+LlxuXHRcdFx0Ly8gICAgTm90aGluZyB0byBkbyBoZXJlOiA8cD4gcmVtYWlucyBmb3Igc3R5bGluZyBwdXJwb3Nlcy5cblx0XHRcdC8vXG5cdFx0XHQvLyAzLiA8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48aW1nLz48L2Rpdj4uXG5cdFx0XHQvLyAgICBOb3RoaW5nIHRvIGRvIGhlcmUgKDIuKSBidXQgdGhhdCBjYXNlIGlzIG9ubHkgcG9zc2libGUgaW4gZW50ZXJNb2RlIGRpZmZlcmVudFxuXHRcdFx0Ly8gICAgdGhhbiBFTlRFUl9QLlxuXHRcdFx0aWYgKGlzQ2VudGVyV3JhcHBlcihlbCkpIHtcblx0XHRcdFx0aWYgKG5hbWUgPT0gJ2RpdicpIHtcblx0XHRcdFx0XHRjb25zdCBmaWd1cmUgPSBlbC5nZXRGaXJzdCgnZmlndXJlJyk7XG5cblx0XHRcdFx0XHQvLyBDYXNlICMxLlxuXHRcdFx0XHRcdGlmIChmaWd1cmUpIHtcblx0XHRcdFx0XHRcdGVsLnJlcGxhY2VXaXRoKGZpZ3VyZSk7XG5cdFx0XHRcdFx0XHRlbCA9IGZpZ3VyZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gQ2FzZXMgIzIgYW5kICMzIChoYW5kbGVkIHRyYW5zcGFyZW50bHkpXG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUncyBhIGNlbnRlcmluZyB3cmFwcGVyLCBzYXZlIGl0IGluIGRhdGEuXG5cdFx0XHRcdGRhdGEuYWxpZ24gPSAnY2VudGVyJztcblxuXHRcdFx0XHQvLyBJbWFnZSBjYW4gYmUgd3JhcHBlZCBpbiBsaW5rIDxhPjxpbWcvPjwvYT4uXG5cdFx0XHRcdGltYWdlID0gZWwuZ2V0Rmlyc3QoJ2ltZycpIHx8IGVsLmdldEZpcnN0KCdhJykuZ2V0Rmlyc3QoJ2ltZycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBObyBjZW50ZXIgd3JhcHBlciBoYXMgYmVlbiBmb3VuZC5cblx0XHRcdGVsc2UgaWYgKG5hbWUgPT0gJ2ZpZ3VyZScgJiYgZWwuaGFzQ2xhc3MoY2FwdGlvbmVkQ2xhc3MpKSB7XG5cdFx0XHRcdGltYWdlID0gZWwuZ2V0Rmlyc3QoJ2ltZycpIHx8IGVsLmdldEZpcnN0KCdhJykuZ2V0Rmlyc3QoJ2ltZycpO1xuXG5cdFx0XHRcdC8vIFVwY2FzdCBsaW5rZWQgaW1hZ2UgbGlrZSA8YT48aW1nLz48L2E+LlxuXHRcdFx0fSBlbHNlIGlmIChpc0xpbmtlZE9yU3RhbmRhbG9uZUltYWdlKGVsKSkge1xuXHRcdFx0XHRpbWFnZSA9IGVsLm5hbWUgPT0gJ2EnID8gZWwuY2hpbGRyZW5bMF0gOiBlbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFpbWFnZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgYW4gaW1hZ2UsIHRoZW4gY29vbCwgd2UgZ290IGEgd2lkZ2V0LlxuXHRcdFx0Ly8gTm93IGp1c3QgcmVtb3ZlIGRpbWVuc2lvbiBhdHRyaWJ1dGVzIGV4cHJlc3NlZCB3aXRoICUuXG5cdFx0XHRmb3IgKGNvbnN0IGQgaW4gZGltZW5zaW9ucykge1xuXHRcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRpbWVuc2lvbnMsIGQpKSB7XG5cdFx0XHRcdFx0Y29uc3QgZGltZW5zaW9uID0gaW1hZ2UuYXR0cmlidXRlc1tkXTtcblxuXHRcdFx0XHRcdGlmIChkaW1lbnNpb24gJiYgZGltZW5zaW9uLm1hdGNoKHJlZ2V4UGVyY2VudCkpIHtcblx0XHRcdFx0XHRcdGRlbGV0ZSBpbWFnZS5hdHRyaWJ1dGVzW2RdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fTtcblx0fVxuXG5cdC8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCB0cmFuc2Zvcm1zIHRoZSB3aWRnZXQgdG8gdGhlIGV4dGVybmFsIGZvcm1hdFxuXHQvLyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbi5cblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9XG5cdGZ1bmN0aW9uIGRvd25jYXN0V2lkZ2V0RWxlbWVudChlZGl0b3IpIHtcblx0XHRjb25zdCBhbGlnbkNsYXNzZXMgPSBlZGl0b3IuY29uZmlnLmltYWdlMl9hbGlnbkNsYXNzZXM7XG5cblx0XHQvLyBAcGFyYW0ge0NLRURJVE9SLmh0bWxQYXJzZXIuZWxlbWVudH0gZWxcblx0XHRyZXR1cm4gZnVuY3Rpb24oZWwpIHtcblx0XHRcdC8vIEluIGNhc2Ugb2YgPGE+PGltZy8+PC9hPiwgPGltZy8+IGlzIHRoZSBlbGVtZW50IHRvIGhvbGRcblx0XHRcdC8vIGlubGluZSBzdHlsZXMgb3IgY2xhc3NlcyAoaW1hZ2UyX2FsaWduQ2xhc3NlcykuXG5cdFx0XHRjb25zdCBhdHRyc0hvbGRlciA9IGVsLm5hbWUgPT0gJ2EnID8gZWwuZ2V0Rmlyc3QoKSA6IGVsO1xuXG5cdFx0XHRkZWxldGUgYXR0cnNIb2xkZXIuYXR0cmlidXRlcy5jb250ZW50ZWRpdGFibGU7XG5cblx0XHRcdGNvbnN0IGF0dHJzID0gYXR0cnNIb2xkZXIuYXR0cmlidXRlcztcblxuXHRcdFx0Y29uc3QgYWxpZ24gPSB0aGlzLmRhdGEuYWxpZ247XG5cblx0XHRcdC8vIERlLXdyYXAgdGhlIGltYWdlIGZyb20gcmVzaXplIGhhbmRsZSB3cmFwcGVyLlxuXHRcdFx0Ly8gT25seSBibG9jayB3aWRnZXRzIGhhdmUgb25lLlxuXHRcdFx0aWYgKCF0aGlzLmlubGluZSkge1xuXHRcdFx0XHRjb25zdCByZXNpemVXcmFwcGVyID0gZWwuZ2V0Rmlyc3QoJ3NwYW4nKTtcblxuXHRcdFx0XHRpZiAocmVzaXplV3JhcHBlcikge1xuXHRcdFx0XHRcdHJlc2l6ZVdyYXBwZXIucmVwbGFjZVdpdGgoXG5cdFx0XHRcdFx0XHRyZXNpemVXcmFwcGVyLmdldEZpcnN0KHtcblx0XHRcdFx0XHRcdFx0YTogMSxcblx0XHRcdFx0XHRcdFx0aW1nOiAxLFxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChhbGlnbiAmJiBhbGlnbiAhPSAnbm9uZScpIHtcblx0XHRcdFx0Y29uc3Qgc3R5bGVzID0gQ0tFRElUT1IudG9vbHMucGFyc2VDc3NUZXh0KGF0dHJzLnN0eWxlIHx8ICcnKTtcblxuXHRcdFx0XHQvLyBXaGVuIHRoZSB3aWRnZXQgaXMgY2FwdGlvbmVkICg8ZmlndXJlPikgYW5kIGludGVybmFsbHkgY2VudGVyaW5nIGlzIGRvbmVcblx0XHRcdFx0Ly8gd2l0aCB3aWRnZXQncyB3cmFwcGVyIHN0eWxlL2NsYXNzLCBpbiB0aGUgZXh0ZXJuYWwgZGF0YSByZXByZXNlbnRhdGlvbixcblx0XHRcdFx0Ly8gPGZpZ3VyZT4gbXVzdCBiZSB3cmFwcGVkIHdpdGggYW4gZWxlbWVudCBob2xkaW5nIGFuIHN0eWxlL2NsYXNzOlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBcdDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPlxuXHRcdFx0XHQvLyBcdFx0PGZpZ3VyZSBjbGFzcz1cImltYWdlXCIgc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9ja1wiPi4uLjwvZmlndXJlPlxuXHRcdFx0XHQvLyBcdDwvZGl2PlxuXHRcdFx0XHQvLyBvclxuXHRcdFx0XHQvLyBcdDxkaXYgY2xhc3M9XCJzb21lLWNlbnRlci1jbGFzc1wiPlxuXHRcdFx0XHQvLyBcdFx0PGZpZ3VyZSBjbGFzcz1cImltYWdlXCI+Li4uPC9maWd1cmU+XG5cdFx0XHRcdC8vIFx0PC9kaXY+XG5cdFx0XHRcdC8vXG5cdFx0XHRcdGlmIChhbGlnbiA9PSAnY2VudGVyJyAmJiBlbC5uYW1lID09ICdmaWd1cmUnKSB7XG5cdFx0XHRcdFx0ZWwgPSBlbC53cmFwV2l0aChcblx0XHRcdFx0XHRcdG5ldyBDS0VESVRPUi5odG1sUGFyc2VyLmVsZW1lbnQoXG5cdFx0XHRcdFx0XHRcdCdkaXYnLFxuXHRcdFx0XHRcdFx0XHRhbGlnbkNsYXNzZXNcblx0XHRcdFx0XHRcdFx0XHQ/IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3M6IGFsaWduQ2xhc3Nlc1sxXSxcblx0XHRcdFx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHRcdFx0XHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3R5bGU6ICd0ZXh0LWFsaWduOmNlbnRlcicsXG5cdFx0XHRcdFx0XHRcdFx0ICB9XG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIGxlZnQvcmlnaHQsIGFkZCBmbG9hdCBzdHlsZSB0byB0aGUgZG93bmNhc3RlZCBlbGVtZW50LlxuXHRcdFx0XHRlbHNlIGlmIChcblx0XHRcdFx0XHRhbGlnbiBpblxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGxlZnQ6IDEsXG5cdFx0XHRcdFx0XHRyaWdodDogMSxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGlmIChhbGlnbkNsYXNzZXMpIHtcblx0XHRcdFx0XHRcdGF0dHJzSG9sZGVyLmFkZENsYXNzKFxuXHRcdFx0XHRcdFx0XHRhbGlnbkNsYXNzZXNbYWxpZ25tZW50c09ialthbGlnbl1dXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdHlsZXNbJ2Zsb2F0J10gPSBhbGlnbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBVcGRhdGUgZWxlbWVudCBzdHlsZXMuXG5cdFx0XHRcdGlmICghYWxpZ25DbGFzc2VzICYmICFDS0VESVRPUi50b29scy5pc0VtcHR5KHN0eWxlcykpIHtcblx0XHRcdFx0XHRhdHRycy5zdHlsZSA9IENLRURJVE9SLnRvb2xzLndyaXRlQ3NzVGV4dChzdHlsZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbDtcblx0XHR9O1xuXHR9XG5cblx0Ly8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGFuIGVsZW1lbnQgaXMgYSBjZW50ZXJpbmcgd3JhcHBlci5cblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9IGVkaXRvclxuXHQvLyBAcmV0dXJucyB7RnVuY3Rpb259XG5cdGZ1bmN0aW9uIGNlbnRlcldyYXBwZXJDaGVja2VyKGVkaXRvcikge1xuXHRcdGNvbnN0IGNhcHRpb25lZENsYXNzID0gZWRpdG9yLmNvbmZpZy5pbWFnZTJfY2FwdGlvbmVkQ2xhc3M7XG5cblx0XHRjb25zdCBhbGlnbkNsYXNzZXMgPSBlZGl0b3IuY29uZmlnLmltYWdlMl9hbGlnbkNsYXNzZXM7XG5cblx0XHRjb25zdCB2YWxpZENoaWxkcmVuID0ge1xuXHRcdFx0YTogMSxcblx0XHRcdGZpZ3VyZTogMSxcblx0XHRcdGltZzogMSxcblx0XHR9O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHQvLyBXcmFwcGVyIG11c3QgYmUgZWl0aGVyIDxkaXY+IG9yIDxwPi5cblx0XHRcdGlmIChcblx0XHRcdFx0IShcblx0XHRcdFx0XHRlbC5uYW1lIGluXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZGl2OiAxLFxuXHRcdFx0XHRcdFx0cDogMSxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdClcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG5cblx0XHRcdC8vIENlbnRlcmluZyB3cmFwcGVyIGNhbiBoYXZlIG9ubHkgb25lIGNoaWxkLlxuXHRcdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCAhPT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XG5cblx0XHRcdC8vIE9ubHkgPGZpZ3VyZT4gb3IgPGltZyAvPiBjYW4gYmUgZmlyc3QgKG9ubHkpIGNoaWxkIG9mIGNlbnRlcmluZyB3cmFwcGVyLFxuXHRcdFx0Ly8gcmVnYXJkbGVzcyBvZiBpdHMgdHlwZS5cblx0XHRcdGlmICghKGNoaWxkLm5hbWUgaW4gdmFsaWRDaGlsZHJlbikpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBjZW50ZXJpbmcgd3JhcHBlciBpcyA8cD4sIG9ubHkgPGltZyAvPiBjYW4gYmUgdGhlIGNoaWxkLlxuXHRcdFx0Ly8gICA8cCBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGltZyAvPjwvcD5cblx0XHRcdGlmIChlbC5uYW1lID09ICdwJykge1xuXHRcdFx0XHRpZiAoIWlzTGlua2VkT3JTdGFuZGFsb25lSW1hZ2UoY2hpbGQpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBDZW50ZXJpbmcgPGRpdj4gY2FuIGhvbGQgPGltZy8+IG9yIDxmaWd1cmU+LCBkZXBlbmRpbmcgb24gZW50ZXJNb2RlLlxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIElmIGEgPGZpZ3VyZT4gaXMgdGhlIGZpcnN0IChvbmx5KSBjaGlsZCwgaXQgbXVzdCBoYXZlIGEgY2xhc3MuXG5cdFx0XHRcdC8vICAgPGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGZpZ3VyZT4uLi48L2ZpZ3VyZT48ZGl2PlxuXHRcdFx0XHRpZiAoY2hpbGQubmFtZSA9PSAnZmlndXJlJykge1xuXHRcdFx0XHRcdGlmICghY2hpbGQuaGFzQ2xhc3MoY2FwdGlvbmVkQ2xhc3MpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIENlbnRlcmluZyA8ZGl2PiBjYW4gaG9sZCA8aW1nLz4gb3IgPGE+PGltZy8+PC9hPiBvbmx5IHdoZW4gZW50ZXJNb2RlXG5cdFx0XHRcdFx0Ly8gaXMgRU5URVJfKEJSfERJVikuXG5cdFx0XHRcdFx0Ly8gICA8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48aW1nIC8+PC9kaXY+XG5cdFx0XHRcdFx0Ly8gICA8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48YT48aW1nIC8+PC9hPjwvZGl2PlxuXHRcdFx0XHRcdGlmIChlZGl0b3IuZW50ZXJNb2RlID09IENLRURJVE9SLkVOVEVSX1ApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBSZWdhcmRsZXNzIG9mIGVudGVyTW9kZSwgYSBjaGlsZCB3aGljaCBpcyBub3QgPGZpZ3VyZT4gbXVzdCBiZVxuXHRcdFx0XHRcdC8vIGVpdGhlciA8aW1nLz4gb3IgPGE+PGltZy8+PC9hPi5cblx0XHRcdFx0XHRpZiAoIWlzTGlua2VkT3JTdGFuZGFsb25lSW1hZ2UoY2hpbGQpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENlbnRlcmluZyB3cmFwcGVyIGdvdCB0byBiZS4uLiBjZW50ZXJpbmcuIElmIGltYWdlMl9hbGlnbkNsYXNzZXMgYXJlIGRlZmluZWQsXG5cdFx0XHQvLyBjaGVjayBmb3IgY2VudGVyaW5nIGNsYXNzLiBPdGhlcndpc2UsIGNoZWNrIHRoZSBzdHlsZS5cblx0XHRcdGlmIChcblx0XHRcdFx0YWxpZ25DbGFzc2VzXG5cdFx0XHRcdFx0PyBlbC5oYXNDbGFzcyhhbGlnbkNsYXNzZXNbMV0pXG5cdFx0XHRcdFx0OiBDS0VESVRPUi50b29scy5wYXJzZUNzc1RleHQoXG5cdFx0XHRcdFx0XHRcdGVsLmF0dHJpYnV0ZXMuc3R5bGUgfHwgJycsXG5cdFx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQgIClbJ3RleHQtYWxpZ24nXSA9PSAnY2VudGVyJ1xuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0fVxuXG5cdC8vIENoZWNrcyB3aGV0aGVyIGVsZW1lbnQgaXMgPGltZy8+IG9yIDxhPjxpbWcvPjwvYT4uXG5cdC8vXG5cdC8vIEBwYXJhbSB7Q0tFRElUT1IuaHRtbFBhcnNlci5lbGVtZW50fVxuXHRmdW5jdGlvbiBpc0xpbmtlZE9yU3RhbmRhbG9uZUltYWdlKGVsKSB7XG5cdFx0aWYgKGVsLm5hbWUgPT0gJ2ltZycpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoZWwubmFtZSA9PSAnYScpIHtcblx0XHRcdHJldHVybiBlbC5jaGlsZHJlbi5sZW5ndGggPT0gMSAmJiBlbC5nZXRGaXJzdCgnaW1nJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gU2V0cyB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB3aWRnZXQgaW1hZ2UgYWNjb3JkaW5nIHRvIGN1cnJlbnQgd2lkZ2V0IGRhdGEuXG5cdC8vXG5cdC8vIEBwYXJhbSB7Q0tFRElUT1IucGx1Z2lucy53aWRnZXR9IHdpZGdldFxuXHRmdW5jdGlvbiBzZXREaW1lbnNpb25zKHdpZGdldCkge1xuXHRcdGNvbnN0IGRhdGEgPSB3aWRnZXQuZGF0YTtcblxuXHRcdGNvbnN0IGRpbWVuc2lvbnMgPSB7XG5cdFx0XHRoZWlnaHQ6IGRhdGEuaGVpZ2h0LFxuXHRcdFx0d2lkdGg6IGRhdGEud2lkdGgsXG5cdFx0fTtcblxuXHRcdGNvbnN0IGltYWdlID0gd2lkZ2V0LnBhcnRzLmltYWdlO1xuXG5cdFx0Zm9yIChjb25zdCBkIGluIGRpbWVuc2lvbnMpIHtcblx0XHRcdGlmIChkaW1lbnNpb25zW2RdKSB7XG5cdFx0XHRcdGltYWdlLnNldEF0dHJpYnV0ZShkLCBkaW1lbnNpb25zW2RdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGltYWdlLnJlbW92ZUF0dHJpYnV0ZShkKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBEZWZpbmVzIGFsbCBmZWF0dXJlcyByZWxhdGVkIHRvIGRyYWctZHJpdmVuIGltYWdlIHJlc2l6aW5nLlxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLnBsdWdpbnMud2lkZ2V0fSB3aWRnZXRcblx0ZnVuY3Rpb24gc2V0dXBSZXNpemVyKHdpZGdldCkge1xuXHRcdGNvbnN0IGVkaXRvciA9IHdpZGdldC5lZGl0b3I7XG5cblx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0Y29uc3QgZG9jID0gZWRpdG9yLmRvY3VtZW50O1xuXG5cdFx0Ly8gU3RvcmUgdGhlIHJlc2l6ZXIgaW4gYSB3aWRnZXQgZm9yIHRlc3RpbmcgKCMxMTAwNCkuXG5cdFx0Y29uc3QgcmVzaXplciA9ICh3aWRnZXQucmVzaXplciA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJykpO1xuXG5cdFx0cmVzaXplci5hZGRDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXInKTtcblx0XHRyZXNpemVyLmFkZENsYXNzKFxuXHRcdFx0J2NrZV9pbWFnZV9yZXNpemVyXycgKyBjdXJzb3JbZWRpdG9yLmNvbmZpZy5pbWFnZVNjYWxlUmVzaXplXVxuXHRcdCk7XG5cdFx0cmVzaXplci5hcHBlbmQobmV3IENLRURJVE9SLmRvbS50ZXh0KCdcXHUyMDBiJywgZG9jKSk7XG5cblx0XHQvLyBJbmxpbmUgd2lkZ2V0cyBkb24ndCBuZWVkIGEgcmVzaXplciB3cmFwcGVyIGFzIGFuIGltYWdlIHNwYW5zIHRoZSBlbnRpcmUgd2lkZ2V0LlxuXHRcdGlmICghd2lkZ2V0LmlubGluZSkge1xuXHRcdFx0Y29uc3QgaW1hZ2VPckxpbmsgPSB3aWRnZXQucGFydHMubGluayB8fCB3aWRnZXQucGFydHMuaW1hZ2U7XG5cblx0XHRcdGNvbnN0IG9sZFJlc2l6ZVdyYXBwZXIgPSBpbWFnZU9yTGluay5nZXRQYXJlbnQoKTtcblxuXHRcdFx0Y29uc3QgcmVzaXplV3JhcHBlciA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cblx0XHRcdHJlc2l6ZVdyYXBwZXIuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyX3dyYXBwZXInKTtcblx0XHRcdHJlc2l6ZVdyYXBwZXIuYXBwZW5kKGltYWdlT3JMaW5rKTtcblx0XHRcdHJlc2l6ZVdyYXBwZXIuYXBwZW5kKHJlc2l6ZXIpO1xuXHRcdFx0d2lkZ2V0LmVsZW1lbnQuYXBwZW5kKHJlc2l6ZVdyYXBwZXIsIHRydWUpO1xuXG5cdFx0XHQvLyBSZW1vdmUgdGhlIG9sZCB3cmFwcGVyIHdoaWNoIGNvdWxkIGNhbWUgZnJvbSBlLmcuIHBhc3RlZCBIVE1MXG5cdFx0XHQvLyBhbmQgd2hpY2ggY291bGQgYmUgY29ycnVwdGVkIChlLmcuIHJlc2l6ZXIgc3BhbiBoYXMgYmVlbiBsb3N0KS5cblx0XHRcdGlmIChvbGRSZXNpemVXcmFwcGVyLmlzKCdzcGFuJykpIHtcblx0XHRcdFx0b2xkUmVzaXplV3JhcHBlci5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0d2lkZ2V0LndyYXBwZXIuYXBwZW5kKHJlc2l6ZXIpO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSB2YWx1ZXMgb2Ygc2l6ZSB2YXJpYWJsZXMgYW5kIG1vdXNlIG9mZnNldHMuXG5cdFx0cmVzaXplci5vbignbW91c2Vkb3duJywgZXZ0ID0+IHtcblx0XHRcdGNvbnN0IGltYWdlID0gd2lkZ2V0LnBhcnRzLmltYWdlO1xuXG5cdFx0XHQvLyBcImZhY3RvclwiIGNhbiBiZSBlaXRoZXIgMSBvciAtMS4gSS5lLjogRm9yIHJpZ2h0LWFsaWduZWQgaW1hZ2VzLCB3ZSBuZWVkIHRvXG5cdFx0XHQvLyBzdWJ0cmFjdCB0aGUgZGlmZmVyZW5jZSB0byBnZXQgcHJvcGVyIHdpZHRoLCBldGMuIFdpdGhvdXQgXCJmYWN0b3JcIixcblx0XHRcdC8vIHJlc2l6ZXIgc3RhcnRzIHdvcmtpbmcgdGhlIG9wcG9zaXRlIHdheS5cblx0XHRcdGNvbnN0IGZhY3RvciA9IHdpZGdldC5kYXRhLmFsaWduID09ICdyaWdodCcgPyAtMSA6IDE7XG5cblx0XHRcdC8vIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG1vdXNlIHJlbGF0aXZlIHRvIHRoZSBzY3JlZW5cblx0XHRcdC8vIHdoZW4gYnV0dG9uIGdldHMgcHJlc3NlZC5cblx0XHRcdGNvbnN0IHN0YXJ0WCA9IGV2dC5kYXRhLiQuc2NyZWVuWDtcblxuXHRcdFx0Y29uc3Qgc3RhcnRZID0gZXZ0LmRhdGEuJC5zY3JlZW5ZO1xuXG5cdFx0XHQvLyBUaGUgaW5pdGlhbCBkaW1lbnNpb25zIGFuZCBhc3BlY3QgcmF0aW8gb2YgdGhlIGltYWdlLlxuXHRcdFx0Y29uc3Qgc3RhcnRXaWR0aCA9IGltYWdlLiQuY2xpZW50V2lkdGg7XG5cblx0XHRcdGNvbnN0IHN0YXJ0SGVpZ2h0ID0gaW1hZ2UuJC5jbGllbnRIZWlnaHQ7XG5cblx0XHRcdGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuXG5cdFx0XHQvLyBBIGNsYXNzIGFwcGxpZWQgdG8gZWRpdGFibGUgZHVyaW5nIHJlc2l6aW5nLlxuXHRcdFx0Y29uc3QgY3Vyc29yQ2xhc3MgPSAnY2tlX2ltYWdlX3MnICsgKCF+ZmFjdG9yID8gJ3cnIDogJ2UnKTtcblxuXHRcdFx0bGV0IG5hdGl2ZUV2dDtcblx0XHRcdGxldCBuZXdXaWR0aDtcblx0XHRcdGxldCBuZXdIZWlnaHQ7XG5cdFx0XHRsZXQgdXBkYXRlRGF0YTtcblxuXHRcdFx0bGV0IG1vdmVEaWZmWDtcblx0XHRcdGxldCBtb3ZlRGlmZlk7XG5cblx0XHRcdC8vIFNhdmUgdGhlIHVuZG8gc25hcHNob3QgZmlyc3Q6IGJlZm9yZSByZXNpemluZy5cblx0XHRcdGVkaXRvci5maXJlKCdzYXZlU25hcHNob3QnKTtcblxuXHRcdFx0Ly8gTW91c2Vtb3ZlIGxpc3RlbmVycyBhcmUgcmVtb3ZlZCBvbiBtb3VzZXVwLlxuXHRcdFx0YXR0YWNoVG9Eb2N1bWVudHMoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBsaXN0ZW5lcnMpO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCB0aGUgbW91c2Vtb3ZlIGxpc3RlbmVyLiBVcGRhdGUgd2lkZ2V0IGRhdGEgaWYgdmFsaWQuXG5cdFx0XHRhdHRhY2hUb0RvY3VtZW50cygnbW91c2V1cCcsIG9uTW91c2VVcCwgbGlzdGVuZXJzKTtcblxuXHRcdFx0Ly8gVGhlIGVudGlyZSBlZGl0YWJsZSB3aWxsIGhhdmUgdGhlIHNwZWNpYWwgY3Vyc29yIHdoaWxlIHJlc2l6aW5nIGdvZXMgb24uXG5cdFx0XHRlZGl0YWJsZS5hZGRDbGFzcyhjdXJzb3JDbGFzcyk7XG5cblx0XHRcdC8vIFRoaXMgaXMgdG8gYWx3YXlzIGtlZXAgdGhlIHJlc2l6ZXIgZWxlbWVudCB2aXNpYmxlIHdoaWxlIHJlc2l6aW5nLlxuXHRcdFx0cmVzaXplci5hZGRDbGFzcygnY2tlX2ltYWdlX3Jlc2l6aW5nJyk7XG5cblx0XHRcdC8vIEF0dGFjaGVzIGFuIGV2ZW50IHRvIGEgZ2xvYmFsIGRvY3VtZW50IGlmIGlubGluZSBlZGl0b3IuXG5cdFx0XHQvLyBBZGRpdGlvbmFsbHksIGlmIGNsYXNzaWMgKGBpZnJhbWVgLWJhc2VkKSBlZGl0b3IsIGFsc28gYXR0YWNoZXMgdGhlIHNhbWUgZXZlbnQgdG8gYGlmcmFtZWAncyBkb2N1bWVudC5cblx0XHRcdGZ1bmN0aW9uIGF0dGFjaFRvRG9jdW1lbnRzKG5hbWUsIGNhbGxiYWNrLCBjb2xsZWN0aW9uKSB7XG5cdFx0XHRcdGNvbnN0IGdsb2JhbERvYyA9IENLRURJVE9SLmRvY3VtZW50O1xuXG5cdFx0XHRcdGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuXG5cdFx0XHRcdGlmICghZG9jLmVxdWFscyhnbG9iYWxEb2MpKSB7XG5cdFx0XHRcdFx0bGlzdGVuZXJzLnB1c2goZ2xvYmFsRG9jLm9uKG5hbWUsIGNhbGxiYWNrKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsaXN0ZW5lcnMucHVzaChkb2Mub24obmFtZSwgY2FsbGJhY2spKTtcblxuXHRcdFx0XHRpZiAoY29sbGVjdGlvbikge1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0XHRcdFx0Y29sbGVjdGlvbi5wdXNoKGxpc3RlbmVycy5wb3AoKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoaXMgaXMgaG93IHZhcmlhYmxlcyByZWZlciB0byB0aGUgZ2VvbWV0cnkuXG5cdFx0XHQvLyBOb3RlOiB4IGNvcnJlc3BvbmRzIHRvIG1vdmVPZmZzZXQsIHRoaXMgaXMgdGhlIHBvc2l0aW9uIG9mIG1vdXNlXG5cdFx0XHQvLyBOb3RlOiBvIGNvcnJlc3BvbmRzIHRvIFtzdGFydFgsIHN0YXJ0WV0uXG5cdFx0XHQvL1xuXHRcdFx0Ly8gXHQrLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rXG5cdFx0XHQvLyBcdHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcblx0XHRcdC8vIFx0fCAgICAgIEkgICAgICAgfCAgICAgIElJICAgICAgfFxuXHRcdFx0Ly8gXHR8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG5cdFx0XHQvLyBcdCstLS0tLS0tLS0tLS0tIG8gLS0tLS0tLS0tLS0tLSsgXyBfIF9cblx0XHRcdC8vIFx0fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgIF5cblxuXHRcdFx0Ly8gXHR8ICAgICAgVkkgICAgICB8ICAgICBJSUkgICAgICB8ICAgICAgfCBtb3ZlRGlmZllcblx0XHRcdC8vIFx0fCAgICAgICAgICAgICAgfCAgICAgICAgIHggXyBfIF8gXyBfIHZcblx0XHRcdC8vIFx0Ky0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLXwtLS0tK1xuXHRcdFx0Ly8gXHQgICAgICAgICAgICAgICB8ICAgICAgICAgfFxuXHRcdFx0Ly8gXHQgICAgICAgICAgICAgICAgPC0tLS0tLS0+XG5cdFx0XHQvLyBcdCAgICAgICAgICAgICAgICBtb3ZlRGlmZlhcblx0XHRcdGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2dCkge1xuXHRcdFx0XHRjb25zdCBpbWFnZVNjYWxlUmVzaXplID0gZWRpdG9yLmNvbmZpZy5pbWFnZVNjYWxlUmVzaXplO1xuXG5cdFx0XHRcdG5hdGl2ZUV2dCA9IGV2dC5kYXRhLiQ7XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyBob3cgZmFyIHRoZSBtb3VzZSBpcyBmcm9tIHRoZSBwb2ludCB0aGUgYnV0dG9uIHdhcyBwcmVzc2VkLlxuXHRcdFx0XHRtb3ZlRGlmZlggPSBuYXRpdmVFdnQuc2NyZWVuWCAtIHN0YXJ0WDtcblx0XHRcdFx0bW92ZURpZmZZID0gc3RhcnRZIC0gbmF0aXZlRXZ0LnNjcmVlblk7XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGltYWdlU2NhbGVSZXNpemUgPT09ICd3aWR0aCcgfHxcblx0XHRcdFx0XHRpbWFnZVNjYWxlUmVzaXplID09PSAnYm90aCcgfHxcblx0XHRcdFx0XHRpbWFnZVNjYWxlUmVzaXplID09PSAnc2NhbGUnXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdG5ld1dpZHRoID0gc3RhcnRXaWR0aCArIGZhY3RvciAqIG1vdmVEaWZmWDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRpbWFnZVNjYWxlUmVzaXplID09PSAnaGVpZ2h0JyB8fFxuXHRcdFx0XHRcdGltYWdlU2NhbGVSZXNpemUgPT09ICdib3RoJ1xuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRuZXdIZWlnaHQgPSBzdGFydEhlaWdodCAtIG1vdmVEaWZmWTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpbWFnZVNjYWxlUmVzaXplID09PSAnc2NhbGUnKSB7XG5cdFx0XHRcdFx0bmV3SGVpZ2h0ID0gJ2F1dG8nO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bmV3V2lkdGggPSBuZXdXaWR0aCB8fCBzdGFydFdpZHRoO1xuXHRcdFx0XHRuZXdIZWlnaHQgPSBuZXdIZWlnaHQgfHwgc3RhcnRIZWlnaHQ7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgdXBkYXRlIGF0dHJpYnV0ZXMgaWYgbGVzcyB0aGFuIDEwLlxuXHRcdFx0XHQvLyBUaGlzIGlzIHRvIHByZXZlbnQgaW1hZ2VzIHRvIHZpc3VhbGx5IGRpc2FwcGVhci5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG5ld1dpZHRoID49IDE1ICYmXG5cdFx0XHRcdFx0KG5ld0hlaWdodCA+PSAxNSB8fCBuZXdIZWlnaHQgPT09ICdhdXRvJylcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0aW1hZ2UuJC5zdHlsZS53aWR0aCA9IG5ld1dpZHRoICsgJ3B4Jztcblx0XHRcdFx0XHRpbWFnZS4kLnN0eWxlLmhlaWdodCA9IG5ld0hlaWdodCArICdweCc7XG5cblx0XHRcdFx0XHR1cGRhdGVEYXRhID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR1cGRhdGVEYXRhID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuXHRcdFx0XHRsZXQgbDtcblxuXHRcdFx0XHR3aGlsZSAoKGwgPSBsaXN0ZW5lcnMucG9wKCkpKSB7XG5cdFx0XHRcdFx0bC5yZW1vdmVMaXN0ZW5lcigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSBkZWZhdWx0IGN1cnNvciBieSByZW1vdmluZyBzcGVjaWFsIGNsYXNzLlxuXHRcdFx0XHRlZGl0YWJsZS5yZW1vdmVDbGFzcyhjdXJzb3JDbGFzcyk7XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyB0byBicmluZyBiYWNrIHRoZSByZWd1bGFyIGJlaGF2aW91ciBvZiB0aGUgcmVzaXplci5cblx0XHRcdFx0cmVzaXplci5yZW1vdmVDbGFzcygnY2tlX2ltYWdlX3Jlc2l6aW5nJyk7XG5cblx0XHRcdFx0aWYgKHVwZGF0ZURhdGEpIHtcblx0XHRcdFx0XHR3aWRnZXQuc2V0RGF0YSh7XG5cdFx0XHRcdFx0XHRoZWlnaHQ6IG5ld0hlaWdodCxcblx0XHRcdFx0XHRcdHdpZHRoOiBuZXdXaWR0aCxcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdC8vIFNhdmUgYW5vdGhlciB1bmRvIHNuYXBzaG90OiBhZnRlciByZXNpemluZy5cblx0XHRcdFx0XHRlZGl0b3IuZmlyZSgnc2F2ZVNuYXBzaG90Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEb24ndCB1cGRhdGUgZGF0YSB0d2ljZSBvciBtb3JlLlxuXHRcdFx0XHR1cGRhdGVEYXRhID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBDaGFuZ2UgdGhlIHBvc2l0aW9uIG9mIHRoZSB3aWRnZXQgcmVzaXplciB3aGVuIGRhdGEgY2hhbmdlcy5cblx0XHR3aWRnZXQub24oJ2RhdGEnLCAoKSA9PiB7XG5cdFx0XHRyZXNpemVyW3dpZGdldC5kYXRhLmFsaWduID09ICdyaWdodCcgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oXG5cdFx0XHRcdCdja2VfaW1hZ2VfcmVzaXplcl9sZWZ0J1xuXHRcdFx0KTtcblx0XHR9KTtcblxuXHRcdHdpZGdldC5wYXJ0cy5pbWFnZS5vbignY2xpY2snLCAoKSA9PiB7XG5cdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRcdGlmIChzZWxlY3Rpb24pIHtcblx0XHRcdFx0Y29uc3QgZWxlbWVudCA9IHNlbGVjdGlvbi5nZXRTdGFydEVsZW1lbnQoKTtcblxuXHRcdFx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0XHRcdGNvbnN0IHdpZGdldEVsZW1lbnQgPSBlbGVtZW50LmZpbmRPbmUoJ2ltZycpO1xuXG5cdFx0XHRcdFx0aWYgKHdpZGdldEVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHJlZ2lvbiA9IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdCgpO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBzY3JvbGxQb3NpdGlvbiA9IG5ldyBDS0VESVRPUi5kb20ud2luZG93KFxuXHRcdFx0XHRcdFx0XHR3aW5kb3dcblx0XHRcdFx0XHRcdCkuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcblx0XHRcdFx0XHRcdHJlZ2lvbi5sZWZ0IC09IHNjcm9sbFBvc2l0aW9uLng7XG5cdFx0XHRcdFx0XHRyZWdpb24udG9wICs9IHNjcm9sbFBvc2l0aW9uLnk7XG5cblx0XHRcdFx0XHRcdHJlZ2lvbi5kaXJlY3Rpb24gPSBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUDtcblxuXHRcdFx0XHRcdFx0ZWRpdG9yLmZpcmUoJ2VkaXRvckludGVyYWN0aW9uJywge1xuXHRcdFx0XHRcdFx0XHRuYXRpdmVFdmVudDogZXZlbnQsXG5cdFx0XHRcdFx0XHRcdHNlbGVjdGlvbkRhdGE6IHtcblx0XHRcdFx0XHRcdFx0XHRlbGVtZW50OiB3aWRnZXRFbGVtZW50LFxuXHRcdFx0XHRcdFx0XHRcdHJlZ2lvbixcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gUmV0dXJucyBhIHNldCBvZiB3aWRnZXQgYWxsb3dlZENvbnRlbnQgcnVsZXMsIGRlcGVuZGluZ1xuXHQvLyBvbiBjb25maWd1cmF0aW9ucyBsaWtlIGNvbmZpZyNpbWFnZTJfYWxpZ25DbGFzc2VzIG9yXG5cdC8vIGNvbmZpZyNpbWFnZTJfY2FwdGlvbmVkQ2xhc3MuXG5cdC8vXG5cdC8vIEBwYXJhbSB7Q0tFRElUT1IuZWRpdG9yfVxuXHQvLyBAcmV0dXJucyB7T2JqZWN0fVxuXHRmdW5jdGlvbiBnZXRXaWRnZXRBbGxvd2VkQ29udGVudChlZGl0b3IpIHtcblx0XHRjb25zdCBydWxlcyA9IHtcblx0XHRcdGZpZ2NhcHRpb246IHRydWUsXG5cdFx0XHRmaWd1cmU6IHtcblx0XHRcdFx0Y2xhc3NlczogJyEnICsgZWRpdG9yLmNvbmZpZy5pbWFnZTJfY2FwdGlvbmVkQ2xhc3MsXG5cdFx0XHR9LFxuXHRcdFx0aW1nOiB7XG5cdFx0XHRcdGF0dHJpYnV0ZXM6ICchc3JjLGFsdCx3aWR0aCxoZWlnaHQnLFxuXHRcdFx0fSxcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHJ1bGVzO1xuXHR9XG5cblx0Ly8gUmV0dXJucyBhIHNldCBvZiB3aWRnZXQgZmVhdHVyZSBydWxlcywgZGVwZW5kaW5nXG5cdC8vIG9uIGVkaXRvciBjb25maWd1cmF0aW9uLiBOb3RlIHRoYXQgdGhlIGZvbGxvd2luZyBtYXkgbm90IGNvdmVyXG5cdC8vIGFsbCB0aGUgcG9zc2libGUgY2FzZXMgc2luY2UgcmVxdWlyZWRDb250ZW50IHN1cHBvcnRzIGEgc2luZ2xlXG5cdC8vIHRhZyBvbmx5LlxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn1cblx0Ly8gQHJldHVybnMge09iamVjdH1cblx0ZnVuY3Rpb24gZ2V0V2lkZ2V0RmVhdHVyZXMoZWRpdG9yKSB7XG5cdFx0Y29uc3QgYWxpZ25DbGFzc2VzID0gZWRpdG9yLmNvbmZpZy5pbWFnZTJfYWxpZ25DbGFzc2VzO1xuXG5cdFx0Y29uc3QgZmVhdHVyZXMgPSB7XG5cdFx0XHRhbGlnbjoge1xuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6XG5cdFx0XHRcdFx0J2ltZycgK1xuXHRcdFx0XHRcdChhbGlnbkNsYXNzZXMgPyAnKCcgKyBhbGlnbkNsYXNzZXNbMF0gKyAnKScgOiAne2Zsb2F0fScpLFxuXHRcdFx0fSxcblx0XHRcdGNhcHRpb246IHtcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAnZmlnY2FwdGlvbicsXG5cdFx0XHR9LFxuXHRcdFx0ZGltZW5zaW9uOiB7XG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ2ltZ1t3aWR0aCxoZWlnaHRdJyxcblx0XHRcdH0sXG5cdFx0fTtcblxuXHRcdHJldHVybiBmZWF0dXJlcztcblx0fVxuXG5cdC8vIFJldHVybnMgZWxlbWVudCB3aGljaCBpcyBzdHlsZWQsIGNvbnNpZGVyaW5nIGN1cnJlbnRcblx0Ly8gc3RhdGUgb2YgdGhlIHdpZGdldC5cblx0Ly9cblx0Ly8gQHNlZSBDS0VESVRPUi5wbHVnaW5zLndpZGdldCNhcHBseVN0eWxlXG5cdC8vIEBwYXJhbSB7Q0tFRElUT1IucGx1Z2lucy53aWRnZXR9IHdpZGdldFxuXHQvLyBAcmV0dXJucyB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9XG5cdGZ1bmN0aW9uIGdldFN0eWxlYWJsZUVsZW1lbnQod2lkZ2V0KSB7XG5cdFx0cmV0dXJuIHdpZGdldC5kYXRhLmhhc0NhcHRpb24gPyB3aWRnZXQuZWxlbWVudCA6IHdpZGdldC5wYXJ0cy5pbWFnZTtcblx0fVxufVxuXG5DS0VESVRPUi5jb25maWcuaW1hZ2UyX2NhcHRpb25lZENsYXNzID0gJ2ltYWdlJztcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAxNywgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHA6Ly9ja2VkaXRvci5jb20vbGljZW5zZVxuICovXG5cbihmdW5jdGlvbigpIHtcblx0aWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9kcmFncmVzaXplX2llMTEnKSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IHRlbXBsYXRlID0gJzxpbWcgYWx0PVwiXCIgc3JjPVwiXCIgLz4nO1xuXG5cdGNvbnN0IHRlbXBsYXRlQmxvY2sgPSBuZXcgQ0tFRElUT1IudGVtcGxhdGUoXG5cdFx0JzxmaWd1cmUgY2xhc3M9XCJ7Y2FwdGlvbmVkQ2xhc3N9XCI+JyArXG5cdFx0XHR0ZW1wbGF0ZSArXG5cdFx0XHQnPGZpZ2NhcHRpb24+e2NhcHRpb25QbGFjZWhvbGRlcn08L2ZpZ2NhcHRpb24+JyArXG5cdFx0XHQnPC9maWd1cmU+J1xuXHQpO1xuXG5cdGNvbnN0IGFsaWdubWVudHNPYmogPSB7bGVmdDogMCwgY2VudGVyOiAxLCByaWdodDogMn07XG5cblx0Y29uc3QgcmVnZXhQZXJjZW50ID0gL15cXHMqKFxcZCslKVxccyokL2k7XG5cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX2RyYWdyZXNpemVfaWUxMScsIHtcblx0XHRyZXF1aXJlczogJ3dpZGdldCcsXG5cdFx0b25Mb2FkKCkge1xuXHRcdFx0Q0tFRElUT1IuYWRkQ3NzKFxuXHRcdFx0XHQnLmNrZV9pbWFnZV9ub2NhcHRpb257JyArXG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyB0byByZW1vdmUgdW53YW50ZWQgc3BhY2Ugc28gcmVzaXplXG5cdFx0XHRcdFx0Ly8gd3JhcHBlciBpcyBkaXNwbGF5ZWQgcHJvcGVydHkuXG5cdFx0XHRcdFx0J2xpbmUtaGVpZ2h0OjAnICtcblx0XHRcdFx0XHQnfScgK1xuXHRcdFx0XHRcdCcuY2tlX2VkaXRhYmxlLmNrZV9pbWFnZV9uZSwgLmNrZV9lZGl0YWJsZS5ja2VfaW1hZ2VfbmUgKntjdXJzb3I6bmUtcmVzaXplICFpbXBvcnRhbnR9JyArXG5cdFx0XHRcdFx0Jy5ja2VfZWRpdGFibGUuY2tlX2ltYWdlX253LCAuY2tlX2VkaXRhYmxlLmNrZV9pbWFnZV9udyAqe2N1cnNvcjpudy1yZXNpemUgIWltcG9ydGFudH0nICtcblx0XHRcdFx0XHQnLmNrZV9lZGl0YWJsZS5ja2VfaW1hZ2Vfc3csIC5ja2VfZWRpdGFibGUuY2tlX2ltYWdlX3N3ICp7Y3Vyc29yOnN3LXJlc2l6ZSAhaW1wb3J0YW50fScgK1xuXHRcdFx0XHRcdCcuY2tlX2VkaXRhYmxlLmNrZV9pbWFnZV9zZSwgLmNrZV9lZGl0YWJsZS5ja2VfaW1hZ2Vfc2UgKntjdXJzb3I6c2UtcmVzaXplICFpbXBvcnRhbnR9JyArXG5cdFx0XHRcdFx0Jy5ja2VfaW1hZ2VfcmVzaXplcnsnICtcblx0XHRcdFx0XHQnZGlzcGxheTpub25lOycgK1xuXHRcdFx0XHRcdCdwb3NpdGlvbjphYnNvbHV0ZTsnICtcblx0XHRcdFx0XHQnd2lkdGg6MTBweDsnICtcblx0XHRcdFx0XHQnaGVpZ2h0OjEwcHg7JyArXG5cdFx0XHRcdFx0J2JhY2tncm91bmQ6IzAwMDsnICtcblx0XHRcdFx0XHQnb3V0bGluZToxcHggc29saWQgI2ZmZjsnICtcblx0XHRcdFx0XHQvLyBQcmV2ZW50IGRyYWcgaGFuZGxlciBmcm9tIGJlaW5nIG1pc3BsYWNlZCAoIzExMjA3KS5cblx0XHRcdFx0XHQnbGluZS1oZWlnaHQ6MDsnICtcblx0XHRcdFx0XHQnY3Vyc29yOnNlLXJlc2l6ZTsnICtcblx0XHRcdFx0XHQnfScgK1xuXHRcdFx0XHRcdCcuY2tlX2ltYWdlX3Jlc2l6ZXJfd3JhcHBlcnsnICtcblx0XHRcdFx0XHQncG9zaXRpb246cmVsYXRpdmU7JyArXG5cdFx0XHRcdFx0J2Rpc3BsYXk6aW5saW5lLWJsb2NrOycgK1xuXHRcdFx0XHRcdCdsaW5lLWhlaWdodDowOycgK1xuXHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0Ly8gVG9wLXJpZ2h0IGNvcm5lciBzdHlsZSBvZiB0aGUgcmVzaXplci5cblx0XHRcdFx0XHQnLmNrZV9pbWFnZV9yZXNpemVyLmNrZV9pbWFnZV9yZXNpemVyX25leycgK1xuXHRcdFx0XHRcdCdjdXJzb3I6bmUtcmVzaXplOycgK1xuXHRcdFx0XHRcdCdsZWZ0OmF1dG87JyArXG5cdFx0XHRcdFx0J3JpZ2h0Oi01cHg7JyArXG5cdFx0XHRcdFx0J3RvcDotNXB4OycgK1xuXHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0Ly8gVG9wLWxlZnQgY29ybmVyIHN0eWxlIG9mIHRoZSByZXNpemVyLlxuXHRcdFx0XHRcdCcuY2tlX2ltYWdlX3Jlc2l6ZXIuY2tlX2ltYWdlX3Jlc2l6ZXJfbnd7JyArXG5cdFx0XHRcdFx0J2N1cnNvcjpudy1yZXNpemU7JyArXG5cdFx0XHRcdFx0J2xlZnQ6LTVweDsnICtcblx0XHRcdFx0XHQncmlnaHQ6YXV0bzsnICtcblx0XHRcdFx0XHQndG9wOi01cHg7JyArXG5cdFx0XHRcdFx0J30nICtcblx0XHRcdFx0XHQvLyBCb3R0b20tcmlnaHQgY29ybmVyIHN0eWxlIG9mIHRoZSByZXNpemVyLlxuXHRcdFx0XHRcdCcuY2tlX2ltYWdlX3Jlc2l6ZXIuY2tlX2ltYWdlX3Jlc2l6ZXJfc2V7JyArXG5cdFx0XHRcdFx0J2JvdHRvbTotNXB4OycgK1xuXHRcdFx0XHRcdCdjdXJzb3I6c2UtcmVzaXplOycgK1xuXHRcdFx0XHRcdCdsZWZ0OmF1dG87JyArXG5cdFx0XHRcdFx0J3JpZ2h0Oi01cHg7JyArXG5cdFx0XHRcdFx0J30nICtcblx0XHRcdFx0XHQvLyBCb3R0b20tbGVmdCBjb3JuZXIgc3R5bGUgb2YgdGhlIHJlc2l6ZXIuXG5cdFx0XHRcdFx0Jy5ja2VfaW1hZ2VfcmVzaXplci5ja2VfaW1hZ2VfcmVzaXplcl9zd3snICtcblx0XHRcdFx0XHQnYm90dG9tOi01cHg7JyArXG5cdFx0XHRcdFx0J2N1cnNvcjpzdy1yZXNpemU7JyArXG5cdFx0XHRcdFx0J2xlZnQ6LTVweDsnICtcblx0XHRcdFx0XHQncmlnaHQ6YXV0bzsnICtcblx0XHRcdFx0XHQnfScgK1xuXHRcdFx0XHRcdCcuY2tlX3dpZGdldF93cmFwcGVyOmhvdmVyIC5ja2VfaW1hZ2VfcmVzaXplciwnICtcblx0XHRcdFx0XHQnLmNrZV9pbWFnZV9yZXNpemluZz4uY2tlX2ltYWdlX3Jlc2l6ZXJ7JyArXG5cdFx0XHRcdFx0J2Rpc3BsYXk6YmxvY2snICtcblx0XHRcdFx0XHQnfScgK1xuXHRcdFx0XHRcdC8vIEV4cGFuZCB3aWRnZXQgd3JhcHBlciB3aGVuIGxpbmtlZCBpbmxpbmUgaW1hZ2UuXG5cdFx0XHRcdFx0Jy5ja2Vfd2lkZ2V0X3dyYXBwZXI+YXsnICtcblx0XHRcdFx0XHQnZGlzcGxheTppbmxpbmUtYmxvY2snICtcblx0XHRcdFx0XHQnfSdcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdGluaXQoZWRpdG9yKSB7XG5cdFx0XHQvLyBBZGFwdHMgY29uZmlndXJhdGlvbiBmcm9tIG9yaWdpbmFsIGltYWdlIHBsdWdpbi4gU2hvdWxkIGJlIHJlbW92ZWRcblx0XHRcdC8vIHdoZW4gd2UnbGwgcmVuYW1lIGFlX2RyYWdyZXNpemVfaWUxMSB0byBpbWFnZS5cblxuXHRcdFx0Y29uc3QgaW1hZ2UgPSB3aWRnZXREZWYoZWRpdG9yKTtcblxuXHRcdFx0Ly8gUmVnaXN0ZXIgdGhlIHdpZGdldC5cblx0XHRcdGVkaXRvci53aWRnZXRzLmFkZCgnaW1hZ2UnLCBpbWFnZSk7XG5cblx0XHRcdC8vIEFkZCBhIGxpc3RlbmVyIHRvIGhhbmRsZSBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50cyBhbmQgcHJvcGVybHkgZGV0ZWN0IGVkaXRvclxuXHRcdFx0Ly8gaW50ZXJhY3Rpb25zIG9uIHRoZSB3aWRnZXRzIHdpdGhvdXQgbWVzc2luZyB3aXRoIHdpZGdldCBuYXRpdmUgc2VsZWN0aW9uXG5cdFx0XHRlZGl0b3Iub24oJ3NlbGVjdGlvbkNoYW5nZScsIF9ldmVudCA9PiB7XG5cdFx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdFx0XHRpZiAoc2VsZWN0aW9uKSB7XG5cdFx0XHRcdFx0Y29uc3QgZWxlbWVudCA9IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuXHRcdFx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRjb25zdCB3aWRnZXRFbGVtZW50ID0gZWxlbWVudC5maW5kT25lKCdpbWcnKTtcblxuXHRcdFx0XHRcdFx0aWYgKHdpZGdldEVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcmVnaW9uID0gZWxlbWVudC5nZXRDbGllbnRSZWN0KCk7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3Qgc2Nyb2xsUG9zaXRpb24gPSBuZXcgQ0tFRElUT1IuZG9tLndpbmRvdyhcblx0XHRcdFx0XHRcdFx0XHR3aW5kb3dcblx0XHRcdFx0XHRcdFx0KS5nZXRTY3JvbGxQb3NpdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRyZWdpb24ubGVmdCAtPSBzY3JvbGxQb3NpdGlvbi54O1xuXHRcdFx0XHRcdFx0XHRyZWdpb24udG9wICs9IHNjcm9sbFBvc2l0aW9uLnk7XG5cblx0XHRcdFx0XHRcdFx0cmVnaW9uLmRpcmVjdGlvbiA9IENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QO1xuXG5cdFx0XHRcdFx0XHRcdGVkaXRvci5maXJlKCdlZGl0b3JJbnRlcmFjdGlvbicsIHtcblx0XHRcdFx0XHRcdFx0XHRuYXRpdmVFdmVudDoge30sXG5cdFx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uRGF0YToge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZWxlbWVudDogd2lkZ2V0RWxlbWVudCxcblx0XHRcdFx0XHRcdFx0XHRcdHJlZ2lvbixcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRhZnRlckluaXQoZWRpdG9yKSB7XG5cdFx0XHQvLyBJbnRlZ3JhdGUgd2l0aCBhbGlnbiBjb21tYW5kcyAoanVzdGlmeSBwbHVnaW4pLlxuXHRcdFx0Y29uc3QgYWxpZ24gPSB7bGVmdDogMSwgcmlnaHQ6IDEsIGNlbnRlcjogMSwgYmxvY2s6IDF9O1xuXG5cdFx0XHRjb25zdCBpbnRlZ3JhdGUgPSBhbGlnbkNvbW1hbmRJbnRlZ3JhdG9yKGVkaXRvcik7XG5cblx0XHRcdGZvciAoY29uc3QgdmFsdWUgaW4gYWxpZ24pIHtcblx0XHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhbGlnbiwgdmFsdWUpKSB7XG5cdFx0XHRcdFx0aW50ZWdyYXRlKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdH0pO1xuXG5cdC8vIFdpZGdldCBzdGF0ZXMgKGZvcm1zKSBkZXBlbmRpbmcgb24gYWxpZ25tZW50IGFuZCBjb25maWd1cmF0aW9uLlxuXHQvL1xuXHQvLyBOb24tY2FwdGlvbmVkIHdpZGdldCAoaW5saW5lIHN0eWxlcylcblx0Ly8gXHRcdOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuXHQvLyBcdFx04pSCQWxpZ24g4pSCSW50ZXJuYWwgZm9ybSAgICAgICAgICAgICAgICAgIOKUgkRhdGEgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgm5vbmUgIOKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICDilII8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCbGVmdCAg4pSCPHdyYXBwZXIgc3R5bGU94oCdZmxvYXQ6bGVmdOKAnT4gICDilII8aW1nIHN0eWxlPeKAnWZsb2F0OmxlZnTigJ0gLz4gICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgmNlbnRlcuKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICDilII8cCBzdHlsZT3igJ10ZXh0LWFsaWduOmNlbnRlcuKAnT7ilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8cCBzdHlsZT3igJ10ZXh0LWFsaWduOmNlbnRlcuKAnT4g4pSCICA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiAgIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICDilII8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCcmlnaHQg4pSCPHdyYXBwZXIgc3R5bGU94oCdZmxvYXQ6cmlnaHTigJ0+ICDilII8aW1nIHN0eWxlPeKAnWZsb2F0OnJpZ2h04oCdIC8+ICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJTilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcblx0Ly9cblx0Ly8gTm9uLWNhcHRpb25lZCB3aWRnZXQgKGNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfYWxpZ25DbGFzc2VzIGRlZmluZWQpXG5cdC8vIFx0XHTilIzilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcblx0Ly8gXHRcdOKUgkFsaWduIOKUgkludGVybmFsIGZvcm0gICAgICAgICAgICAgICAgICDilIJEYXRhICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJub25lICDilII8d3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAg4pSCPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgmxlZnQgIOKUgjx3cmFwcGVyIGNsYXNzPeKAnWxlZnTigJ0+ICAgICAgICAg4pSCPGltZyBjbGFzcz3igJ1sZWZ04oCdIC8+ICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJjZW50ZXLilII8d3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAg4pSCPHAgY2xhc3M94oCdY2VudGVy4oCdPiAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPHAgY2xhc3M94oCdY2VudGVy4oCdPiAgICAgICAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgICA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAg4pSCPC9wPiAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgnJpZ2h0IOKUgjx3cmFwcGVyIGNsYXNzPeKAnXJpZ2h04oCdPiAgICAgICAg4pSCPGltZyBjbGFzcz3igJ1yaWdodOKAnSAvPiAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSU4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG5cdC8vXG5cdC8vIENhcHRpb25lZCB3aWRnZXQgKGlubGluZSBzdHlsZXMpXG5cdC8vIFx0XHTilIzilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcblx0Ly8gXHRcdOKUgkFsaWduIOKUgkludGVybmFsIGZvcm0gICAgICAgICAgICAgICAgICAgICAgICAgICDilIJEYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgm5vbmUgIOKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilII8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCbGVmdCAg4pSCPHdyYXBwZXIgc3R5bGU94oCdZmxvYXQ6bGVmdOKAnT4gICAgICAgICAgICDilII8ZmlndXJlIHN0eWxlPeKAnWZsb2F0OmxlZnTigJ0gLz4gICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgmNlbnRlcuKUgjx3cmFwcGVyIHN0eWxlPeKAnXRleHQtYWxpZ246Y2VudGVy4oCdPiAgICAg4pSCPGRpdiBzdHlsZT3igJ10ZXh0LWFsaWduOmNlbnRlcuKAnT4gICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIHN0eWxlPeKAnWRpc3BsYXk6aW5saW5lLWJsb2Nr4oCdIC8+4pSCIDxmaWd1cmUgc3R5bGU94oCdZGlzcGxheTppbmxpbmUtYmxvY2vigJ0gLz7ilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilII8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgnJpZ2h0IOKUgjx3cmFwcGVyIHN0eWxlPeKAnWZsb2F0OnJpZ2h04oCdPiAgICAgICAgICAg4pSCPGZpZ3VyZSBzdHlsZT3igJ1mbG9hdDpyaWdodOKAnSAvPiAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSU4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG5cdC8vXG5cdC8vIENhcHRpb25lZCB3aWRnZXQgKGNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfYWxpZ25DbGFzc2VzIGRlZmluZWQpXG5cdC8vIFx0XHTilIzilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcblx0Ly8gXHRcdOKUgkFsaWduIOKUgkludGVybmFsIGZvcm0gICAgICAgICAgICAgICAgICAgICAgICAgICDilIJEYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgm5vbmUgIOKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilII8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCbGVmdCAg4pSCPHdyYXBwZXIgY2xhc3M94oCdbGVmdOKAnT4gICAgICAgICAgICAgICAgICDilII8ZmlndXJlIGNsYXNzPeKAnWxlZnTigJ0gLz4gICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgmNlbnRlcuKUgjx3cmFwcGVyIGNsYXNzPeKAnWNlbnRlcuKAnT4gICAgICAgICAgICAgICAg4pSCPGRpdiBjbGFzcz3igJ1jZW50ZXLigJ0+ICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCPC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJyaWdodCDilII8d3JhcHBlciBjbGFzcz3igJ1yaWdodOKAnT4gICAgICAgICAgICAgICAgIOKUgjxmaWd1cmUgY2xhc3M94oCdcmlnaHTigJ0gLz4gICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn1cblx0Ly8gQHJldHVybnMge09iamVjdH1cblx0ZnVuY3Rpb24gd2lkZ2V0RGVmKGVkaXRvcikge1xuXHRcdGNvbnN0IGFsaWduQ2xhc3NlcyA9IGVkaXRvci5jb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2FsaWduQ2xhc3NlcztcblxuXHRcdGNvbnN0IGNhcHRpb25lZENsYXNzID0gZWRpdG9yLmNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfY2FwdGlvbmVkQ2xhc3M7XG5cblx0XHRmdW5jdGlvbiBkZWZsYXRlKCkge1xuXHRcdFx0aWYgKHRoaXMuZGVmbGF0ZWQpIHJldHVybjtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgd2hldGhlciB3aWRnZXQgd2FzIGZvY3VzZWQgYmVmb3JlIGRlc3Ryb3llZC5cblx0XHRcdGlmIChlZGl0b3Iud2lkZ2V0cy5mb2N1c2VkID09IHRoaXMud2lkZ2V0KSB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuXG5cdFx0XHRlZGl0b3Iud2lkZ2V0cy5kZXN0cm95KHRoaXMud2lkZ2V0KTtcblxuXHRcdFx0Ly8gTWFyayB3aWRnZXQgd2FzIGRlc3Ryb3llZC5cblx0XHRcdHRoaXMuZGVmbGF0ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGluZmxhdGUoKSB7XG5cdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRjb25zdCBkb2MgPSBlZGl0b3IuZG9jdW1lbnQ7XG5cblx0XHRcdC8vIENyZWF0ZSBhIG5ldyB3aWRnZXQuIFRoaXMgd2lkZ2V0IHdpbGwgYmUgZWl0aGVyIGNhcHRpb25lZFxuXHRcdFx0Ly8gbm9uLWNhcHRpb25lZCwgYmxvY2sgb3IgaW5saW5lIGFjY29yZGluZyB0byB3aGF0IGlzIHRoZVxuXHRcdFx0Ly8gbmV3IHN0YXRlIG9mIHRoZSB3aWRnZXQuXG5cdFx0XHRpZiAodGhpcy5kZWZsYXRlZCkge1xuXHRcdFx0XHR0aGlzLndpZGdldCA9IGVkaXRvci53aWRnZXRzLmluaXRPbihcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQsXG5cdFx0XHRcdFx0J2ltYWdlJyxcblx0XHRcdFx0XHR0aGlzLndpZGdldC5kYXRhXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gT25jZSB3aWRnZXQgd2FzIHJlLWNyZWF0ZWQsIGl0IG1heSBiZWNvbWUgYW4gaW5saW5lIGVsZW1lbnQgd2l0aG91dFxuXHRcdFx0XHQvLyBibG9jayB3cmFwcGVyIChpLmUuIHdoZW4gdW5hbGlnbmVkLCBlbmQgbm90IGNhcHRpb25lZCkuIExldCdzIGRvIHNvbWVcblx0XHRcdFx0Ly8gc29ydCBvZiBhdXRvcGFyYWdyYXBoaW5nIGhlcmUgKCMxMDg1MykuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHR0aGlzLndpZGdldC5pbmxpbmUgJiZcblx0XHRcdFx0XHQhbmV3IENLRURJVE9SLmRvbS5lbGVtZW50UGF0aCh0aGlzLndpZGdldC53cmFwcGVyLCBlZGl0YWJsZSlcblx0XHRcdFx0XHRcdC5ibG9ja1xuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjb25zdCBibG9jayA9IGRvYy5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHRcdFx0ZWRpdG9yLmFjdGl2ZUVudGVyTW9kZSA9PSBDS0VESVRPUi5FTlRFUl9QID8gJ3AnIDogJ2Rpdidcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJsb2NrLnJlcGxhY2UodGhpcy53aWRnZXQud3JhcHBlcik7XG5cdFx0XHRcdFx0dGhpcy53aWRnZXQud3JhcHBlci5tb3ZlKGJsb2NrKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRoZSBmb2N1cyBtdXN0IGJlIHRyYW5zZmVycmVkIGZyb20gdGhlIG9sZCBvbmUgKGRlc3Ryb3llZClcblx0XHRcdFx0Ly8gdG8gdGhlIG5ldyBvbmUgKGp1c3QgY3JlYXRlZCkuXG5cdFx0XHRcdGlmICh0aGlzLmZvY3VzZWQpIHtcblx0XHRcdFx0XHR0aGlzLndpZGdldC5mb2N1cygpO1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLmZvY3VzZWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgdGhpcy5kZWZsYXRlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgbm93IHdpZGdldCB3YXMgZGVzdHJveWVkIGp1c3QgdXBkYXRlIHdyYXBwZXIncyBhbGlnbm1lbnQuXG5cdFx0XHQvLyBBY2NvcmRpbmcgdG8gdGhlIG5ldyBzdGF0ZS5cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzZXRXcmFwcGVyQWxpZ24odGhpcy53aWRnZXQsIGFsaWduQ2xhc3Nlcyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsbG93ZWRDb250ZW50OiBnZXRXaWRnZXRBbGxvd2VkQ29udGVudChlZGl0b3IpLFxuXG5cdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICdpbWdbc3JjLGFsdF0nLFxuXG5cdFx0XHRmZWF0dXJlczogZ2V0V2lkZ2V0RmVhdHVyZXMoZWRpdG9yKSxcblxuXHRcdFx0c3R5bGVhYmxlRWxlbWVudHM6ICdpbWcgZmlndXJlJyxcblxuXHRcdFx0Ly8gVGhpcyB3aWRnZXQgY29udmVydHMgc3R5bGUtZHJpdmVuIGRpbWVuc2lvbnMgdG8gYXR0cmlidXRlcy5cblx0XHRcdGNvbnRlbnRUcmFuc2Zvcm1hdGlvbnM6IFtbJ2ltZ1t3aWR0aF06IHNpemVUb0F0dHJpYnV0ZSddXSxcblxuXHRcdFx0Ly8gVGhpcyB3aWRnZXQgaGFzIGFuIGVkaXRhYmxlIGNhcHRpb24uXG5cdFx0XHRlZGl0YWJsZXM6IHtcblx0XHRcdFx0Y2FwdGlvbjoge1xuXHRcdFx0XHRcdHNlbGVjdG9yOiAnZmlnY2FwdGlvbicsXG5cdFx0XHRcdFx0YWxsb3dlZENvbnRlbnQ6ICdiciBlbSBzdHJvbmcgc3ViIHN1cCB1IHM7IGFbIWhyZWYsdGFyZ2V0XScsXG5cdFx0XHRcdH0sXG5cdFx0XHR9LFxuXG5cdFx0XHRwYXJ0czoge1xuXHRcdFx0XHRpbWFnZTogJ2ltZycsXG5cdFx0XHRcdGNhcHRpb246ICdmaWdjYXB0aW9uJyxcblx0XHRcdFx0Ly8gcGFydHMjbGluayBkZWZpbmVkIGluIHdpZGdldCNpbml0XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUZW1wbGF0ZSBvZiB0aGUgd2lkZ2V0OiBwbGFpbiBpbWFnZS5cblx0XHRcdHRlbXBsYXRlLFxuXG5cdFx0XHRkYXRhKCkge1xuXHRcdFx0XHRjb25zdCBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXM7XG5cblx0XHRcdFx0Ly8gSW1hZ2UgY2FuJ3QgYmUgY2FwdGlvbmVkIHdoZW4gZmlnY2FwdGlvbiBpcyBkaXNhbGxvd2VkICgjMTEwMDQpLlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dGhpcy5kYXRhLmhhc0NhcHRpb24gJiZcblx0XHRcdFx0XHQhZWRpdG9yLmZpbHRlci5jaGVja0ZlYXR1cmUoZmVhdHVyZXMuY2FwdGlvbilcblx0XHRcdFx0KVxuXHRcdFx0XHRcdHRoaXMuZGF0YS5oYXNDYXB0aW9uID0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gSW1hZ2UgY2FuJ3QgYmUgYWxpZ25lZCB3aGVuIGZsb2F0aW5nIGlzIGRpc2FsbG93ZWQgKCMxMTAwNCkuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHR0aGlzLmRhdGEuYWxpZ24gIT0gJ25vbmUnICYmXG5cdFx0XHRcdFx0IWVkaXRvci5maWx0ZXIuY2hlY2tGZWF0dXJlKGZlYXR1cmVzLmFsaWduKVxuXHRcdFx0XHQpXG5cdFx0XHRcdFx0dGhpcy5kYXRhLmFsaWduID0gJ25vbmUnO1xuXG5cdFx0XHRcdC8vIENvbnZlcnQgdGhlIGludGVybmFsIGZvcm0gb2YgdGhlIHdpZGdldCBmcm9tIHRoZSBvbGQgc3RhdGUgdG8gdGhlIG5ldyBvbmUuXG5cdFx0XHRcdHRoaXMuc2hpZnRTdGF0ZSh7XG5cdFx0XHRcdFx0d2lkZ2V0OiB0aGlzLFxuXHRcdFx0XHRcdGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcblx0XHRcdFx0XHRvbGREYXRhOiB0aGlzLm9sZERhdGEsXG5cdFx0XHRcdFx0bmV3RGF0YTogdGhpcy5kYXRhLFxuXHRcdFx0XHRcdGRlZmxhdGUsXG5cdFx0XHRcdFx0aW5mbGF0ZSxcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gVXBkYXRlIHdpZGdldC5wYXJ0cy5saW5rIHNpbmNlIGl0IHdpbGwgbm90IGF1dG8tdXBkYXRlIHVubGVzcyB3aWRnZXRcblx0XHRcdFx0Ly8gaXMgZGVzdHJveWVkIGFuZCByZS1pbml0ZWQuXG5cdFx0XHRcdGlmICghdGhpcy5kYXRhLmxpbmspIHtcblx0XHRcdFx0XHRpZiAodGhpcy5wYXJ0cy5saW5rKSBkZWxldGUgdGhpcy5wYXJ0cy5saW5rO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICghdGhpcy5wYXJ0cy5saW5rKVxuXHRcdFx0XHRcdFx0dGhpcy5wYXJ0cy5saW5rID0gdGhpcy5wYXJ0cy5pbWFnZS5nZXRQYXJlbnQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMucGFydHMuaW1hZ2Uuc2V0QXR0cmlidXRlcyh7XG5cdFx0XHRcdFx0c3JjOiB0aGlzLmRhdGEuc3JjLFxuXG5cdFx0XHRcdFx0Ly8gVGhpcyBpbnRlcm5hbCBpcyByZXF1aXJlZCBieSB0aGUgZWRpdG9yLlxuXHRcdFx0XHRcdCdkYXRhLWNrZS1zYXZlZC1zcmMnOiB0aGlzLmRhdGEuc3JjLFxuXG5cdFx0XHRcdFx0YWx0OiB0aGlzLmRhdGEuYWx0LFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBJZiBzaGlmdGluZyBub24tY2FwdGlvbmVkIC0+IGNhcHRpb25lZCwgcmVtb3ZlIGNsYXNzZXNcblx0XHRcdFx0Ly8gcmVsYXRlZCB0byBzdHlsZXMgZnJvbSA8aW1nLz4uXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHR0aGlzLm9sZERhdGEgJiZcblx0XHRcdFx0XHQhdGhpcy5vbGREYXRhLmhhc0NhcHRpb24gJiZcblx0XHRcdFx0XHR0aGlzLmRhdGEuaGFzQ2FwdGlvblxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGMgaW4gdGhpcy5kYXRhLmNsYXNzZXMpIHtcblx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZGF0YS5jbGFzc2VzLFxuXHRcdFx0XHRcdFx0XHRcdGNcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGFydHMuaW1hZ2UucmVtb3ZlQ2xhc3MoYyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGRpbWVuc2lvbnMgb2YgdGhlIGltYWdlIGFjY29yZGluZyB0byBnYXRoZXJlZCBkYXRhLlxuXHRcdFx0XHQvLyBEbyBpdCBvbmx5IHdoZW4gdGhlIGF0dHJpYnV0ZXMgYXJlIGFsbG93ZWQgKCMxMTAwNCkuXG5cdFx0XHRcdGlmIChlZGl0b3IuZmlsdGVyLmNoZWNrRmVhdHVyZShmZWF0dXJlcy5kaW1lbnNpb24pKVxuXHRcdFx0XHRcdHNldERpbWVuc2lvbnModGhpcyk7XG5cblx0XHRcdFx0Ly8gQ2FjaGUgY3VycmVudCBkYXRhLlxuXHRcdFx0XHR0aGlzLm9sZERhdGEgPSBDS0VESVRPUi50b29scy5leHRlbmQoe30sIHRoaXMuZGF0YSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRpbml0KCkge1xuXHRcdFx0XHRjb25zdCBoZWxwZXJzID0gQ0tFRElUT1IucGx1Z2lucy5hZV9kcmFncmVzaXplX2llMTE7XG5cblx0XHRcdFx0Y29uc3QgaW1hZ2UgPSB0aGlzLnBhcnRzLmltYWdlO1xuXG5cdFx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdFx0aGFzQ2FwdGlvbjogISF0aGlzLnBhcnRzLmNhcHRpb24sXG5cdFx0XHRcdFx0c3JjOiBpbWFnZS5nZXRBdHRyaWJ1dGUoJ3NyYycpLFxuXHRcdFx0XHRcdGFsdDogaW1hZ2UuZ2V0QXR0cmlidXRlKCdhbHQnKSB8fCAnJyxcblx0XHRcdFx0XHR3aWR0aDogaW1hZ2UuZ2V0QXR0cmlidXRlKCd3aWR0aCcpIHx8ICcnLFxuXHRcdFx0XHRcdGhlaWdodDogaW1hZ2UuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCAnJyxcblxuXHRcdFx0XHRcdC8vIExvY2sgcmF0aW8gaXMgb24gYnkgZGVmYXVsdCAoIzEwODMzKS5cblx0XHRcdFx0XHRsb2NrOiB0aGlzLnJlYWR5XG5cdFx0XHRcdFx0XHQ/IGhlbHBlcnMuY2hlY2tIYXNOYXR1cmFsUmF0aW8oaW1hZ2UpXG5cdFx0XHRcdFx0XHQ6IHRydWUsXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gSWYgd2UgdXNlZCAnYScgaW4gd2lkZ2V0I3BhcnRzIGRlZmluaXRpb24sIGl0IGNvdWxkIGhhcHBlbiB0aGF0XG5cdFx0XHRcdC8vIHNlbGVjdGVkIGVsZW1lbnQgaXMgYSBjaGlsZCBvZiB3aWRnZXQucGFydHMjY2FwdGlvbi4gU2luY2UgdGhlcmUncyBubyBjbGV2ZXJcblx0XHRcdFx0Ly8gd2F5IHRvIHNvbHZlIGl0IHdpdGggQ1NTIHNlbGVjdG9ycywgaXQncyBkb25lIGxpa2UgdGhhdC4gKCMxMTc4MykuXG5cdFx0XHRcdGNvbnN0IGxpbmsgPSBpbWFnZS5nZXRBc2NlbmRhbnQoJ2EnKTtcblxuXHRcdFx0XHRpZiAobGluayAmJiB0aGlzLndyYXBwZXIuY29udGFpbnMobGluaykpIHRoaXMucGFydHMubGluayA9IGxpbms7XG5cblx0XHRcdFx0Ly8gRGVwZW5kaW5nIG9uIGNvbmZpZ3VyYXRpb24sIHJlYWQgc3R5bGUvY2xhc3MgZnJvbSBlbGVtZW50IGFuZFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSBpdC4gUmVtb3ZlZCBzdHlsZS9jbGFzcyB3aWxsIGJlIHNldCBvbiB3cmFwcGVyIGluICNkYXRhIGxpc3RlbmVyLlxuXHRcdFx0XHQvLyBOb3RlOiBDZW50ZXIgYWxpZ25tZW50IGlzIGRldGVjdGVkIGR1cmluZyB1cGNhc3QsIHNvIG9ubHkgbGVmdC9yaWdodCBjYXNlc1xuXHRcdFx0XHQvLyBhcmUgY2hlY2tlZCBiZWxvdy5cblx0XHRcdFx0aWYgKCFkYXRhLmFsaWduKSB7XG5cdFx0XHRcdFx0Y29uc3QgYWxpZ25FbGVtZW50ID0gZGF0YS5oYXNDYXB0aW9uID8gdGhpcy5lbGVtZW50IDogaW1hZ2U7XG5cblx0XHRcdFx0XHQvLyBSZWFkIHRoZSBpbml0aWFsIGxlZnQvcmlnaHQgYWxpZ25tZW50IGZyb20gdGhlIGNsYXNzIHNldCBvbiBlbGVtZW50LlxuXHRcdFx0XHRcdGlmIChhbGlnbkNsYXNzZXMpIHtcblx0XHRcdFx0XHRcdGlmIChhbGlnbkVsZW1lbnQuaGFzQ2xhc3MoYWxpZ25DbGFzc2VzWzBdKSkge1xuXHRcdFx0XHRcdFx0XHRkYXRhLmFsaWduID0gJ2xlZnQnO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChhbGlnbkVsZW1lbnQuaGFzQ2xhc3MoYWxpZ25DbGFzc2VzWzJdKSkge1xuXHRcdFx0XHRcdFx0XHRkYXRhLmFsaWduID0gJ3JpZ2h0Jztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGRhdGEuYWxpZ24pIHtcblx0XHRcdFx0XHRcdFx0YWxpZ25FbGVtZW50LnJlbW92ZUNsYXNzKFxuXHRcdFx0XHRcdFx0XHRcdGFsaWduQ2xhc3Nlc1thbGlnbm1lbnRzT2JqW2RhdGEuYWxpZ25dXVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZGF0YS5hbGlnbiA9ICdub25lJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gUmVhZCBpbml0aWFsIGZsb2F0IHN0eWxlIGZyb20gZmlndXJlL2ltYWdlIGFuZCB0aGVuIHJlbW92ZSBpdC5cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGRhdGEuYWxpZ24gPSBhbGlnbkVsZW1lbnQuZ2V0U3R5bGUoJ2Zsb2F0JykgfHwgJ25vbmUnO1xuXHRcdFx0XHRcdFx0YWxpZ25FbGVtZW50LnJlbW92ZVN0eWxlKCdmbG9hdCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFVwZGF0ZSBkYXRhLmxpbmsgb2JqZWN0IHdpdGggYXR0cmlidXRlcyBpZiB0aGUgbGluayBoYXMgYmVlbiBkaXNjb3ZlcmVkLlxuXHRcdFx0XHRpZiAoZWRpdG9yLnBsdWdpbnMubGluayAmJiB0aGlzLnBhcnRzLmxpbmspIHtcblx0XHRcdFx0XHRkYXRhLmxpbmsgPSBoZWxwZXJzLmdldExpbmtBdHRyaWJ1dGVzUGFyc2VyKCkoXG5cdFx0XHRcdFx0XHRlZGl0b3IsXG5cdFx0XHRcdFx0XHR0aGlzLnBhcnRzLmxpbmtcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHJpZCBvZiBja2Vfd2lkZ2V0XyogY2xhc3NlcyBpbiBkYXRhLiBPdGhlcndpc2Vcblx0XHRcdFx0XHQvLyB0aGV5IG1pZ2h0IGFwcGVhciBpbiBsaW5rIGRpYWxvZy5cblx0XHRcdFx0XHRjb25zdCBhZHZhbmNlZCA9IGRhdGEubGluay5hZHZhbmNlZDtcblx0XHRcdFx0XHRpZiAoYWR2YW5jZWQgJiYgYWR2YW5jZWQuYWR2Q1NTQ2xhc3Nlcykge1xuXHRcdFx0XHRcdFx0YWR2YW5jZWQuYWR2Q1NTQ2xhc3NlcyA9IENLRURJVE9SLnRvb2xzLnRyaW0oXG5cdFx0XHRcdFx0XHRcdGFkdmFuY2VkLmFkdkNTU0NsYXNzZXMucmVwbGFjZSgvY2tlX1xcUysvLCAnJylcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IHJpZCBvZiBleHRyYSB2ZXJ0aWNhbCBzcGFjZSB3aGVuIHRoZXJlJ3Mgbm8gY2FwdGlvbi5cblx0XHRcdFx0Ly8gSXQgd2lsbCBpbXByb3ZlIHRoZSBsb29rIG9mIHRoZSByZXNpemVyLlxuXHRcdFx0XHR0aGlzLndyYXBwZXJbKGRhdGEuaGFzQ2FwdGlvbiA/ICdyZW1vdmUnIDogJ2FkZCcpICsgJ0NsYXNzJ10oXG5cdFx0XHRcdFx0J2NrZV9pbWFnZV9ub2NhcHRpb24nXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0dGhpcy5zZXREYXRhKGRhdGEpO1xuXG5cdFx0XHRcdC8vIFNldHVwIGR5bmFtaWMgaW1hZ2UgcmVzaXppbmcgd2l0aCBtb3VzZS5cblx0XHRcdFx0Ly8gRG9uJ3QgaW5pdGlhbGl6ZSByZXNpemVyIHdoZW4gZGltZW5zaW9ucyBhcmUgZGlzYWxsb3dlZCAoIzExMDA0KS5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGVkaXRvci5maWx0ZXIuY2hlY2tGZWF0dXJlKHRoaXMuZmVhdHVyZXMuZGltZW5zaW9uKSAmJlxuXHRcdFx0XHRcdGVkaXRvci5jb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2Rpc2FibGVSZXNpemVyICE9PSB0cnVlXG5cdFx0XHRcdClcblx0XHRcdFx0XHRzZXR1cFJlc2l6ZXIodGhpcyk7XG5cblx0XHRcdFx0Y29uc3QgZHJhZ0hhbmRsZXJTdHlsZSA9IHRoaXMuZHJhZ0hhbmRsZXJDb250YWluZXIuJC5zdHlsZTtcblx0XHRcdFx0ZHJhZ0hhbmRsZXJTdHlsZS5zZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHRcdFx0J3JnYmEoMjU1LCAyNTUsIDI1NSwgMSdcblx0XHRcdFx0KTtcblx0XHRcdFx0ZHJhZ0hhbmRsZXJTdHlsZS5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCAnMScpO1xuXG5cdFx0XHRcdHRoaXMuc2hpZnRTdGF0ZSA9IGhlbHBlcnMuc3RhdGVTaGlmdGVyKHRoaXMuZWRpdG9yKTtcblxuXHRcdFx0XHQvLyBBZGQgd2lkZ2V0IGVkaXRpbmcgb3B0aW9uIHRvIGl0cyBjb250ZXh0IG1lbnUuXG5cdFx0XHRcdHRoaXMub24oJ2NvbnRleHRNZW51JywgZnVuY3Rpb24oZXZ0KSB7XG5cdFx0XHRcdFx0ZXZ0LmRhdGEuaW1hZ2UgPSBDS0VESVRPUi5UUklTVEFURV9PRkY7XG5cblx0XHRcdFx0XHQvLyBJbnRlZ3JhdGUgY29udGV4dCBtZW51IGl0ZW1zIGZvciBsaW5rLlxuXHRcdFx0XHRcdC8vIE5vdGUgdGhhdCB3aWRnZXQgbWF5IGJlIHdyYXBwZWQgaW4gYSBsaW5rLCB3aGljaFxuXHRcdFx0XHRcdC8vIGRvZXMgbm90IGJlbG9uZyB0byB0aGF0IHdpZGdldCAoIzExODE0KS5cblx0XHRcdFx0XHRpZiAodGhpcy5wYXJ0cy5saW5rIHx8IHRoaXMud3JhcHBlci5nZXRBc2NlbmRhbnQoJ2EnKSlcblx0XHRcdFx0XHRcdGV2dC5kYXRhLmxpbmsgPSBldnQuZGF0YS51bmxpbmsgPSBDS0VESVRPUi5UUklTVEFURV9PRkY7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gT3ZlcnJpZGVzIGRlZmF1bHQgbWV0aG9kIHRvIGhhbmRsZSBpbnRlcm5hbCBtdXRhYmlsaXR5IG9mIGFlX2RyYWdyZXNpemVfaWUxMS5cblx0XHRcdC8vIEBzZWUgQ0tFRElUT1IucGx1Z2lucy53aWRnZXQjYWRkQ2xhc3Ncblx0XHRcdGFkZENsYXNzKGNsYXNzTmFtZSkge1xuXHRcdFx0XHRnZXRTdHlsZWFibGVFbGVtZW50KHRoaXMpLmFkZENsYXNzKGNsYXNzTmFtZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBPdmVycmlkZXMgZGVmYXVsdCBtZXRob2QgdG8gaGFuZGxlIGludGVybmFsIG11dGFiaWxpdHkgb2YgYWVfZHJhZ3Jlc2l6ZV9pZTExLlxuXHRcdFx0Ly8gQHNlZSBDS0VESVRPUi5wbHVnaW5zLndpZGdldCNoYXNDbGFzc1xuXHRcdFx0aGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG5cdFx0XHRcdHJldHVybiBnZXRTdHlsZWFibGVFbGVtZW50KHRoaXMpLmhhc0NsYXNzKGNsYXNzTmFtZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBPdmVycmlkZXMgZGVmYXVsdCBtZXRob2QgdG8gaGFuZGxlIGludGVybmFsIG11dGFiaWxpdHkgb2YgYWVfZHJhZ3Jlc2l6ZV9pZTExLlxuXHRcdFx0Ly8gQHNlZSBDS0VESVRPUi5wbHVnaW5zLndpZGdldCNyZW1vdmVDbGFzc1xuXHRcdFx0cmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7XG5cdFx0XHRcdGdldFN0eWxlYWJsZUVsZW1lbnQodGhpcykucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIE92ZXJyaWRlcyBkZWZhdWx0IG1ldGhvZCB0byBoYW5kbGUgaW50ZXJuYWwgbXV0YWJpbGl0eSBvZiBhZV9kcmFncmVzaXplX2llMTEuXG5cdFx0XHQvLyBAc2VlIENLRURJVE9SLnBsdWdpbnMud2lkZ2V0I2dldENsYXNzZXNcblx0XHRcdGdldENsYXNzZXM6IChmdW5jdGlvbigpIHtcblx0XHRcdFx0Y29uc3QgY2xhc3NSZWdleCA9IG5ldyBSZWdFeHAoXG5cdFx0XHRcdFx0J14oJyArXG5cdFx0XHRcdFx0XHRbXS5jb25jYXQoY2FwdGlvbmVkQ2xhc3MsIGFsaWduQ2xhc3Nlcykuam9pbignfCcpICtcblx0XHRcdFx0XHRcdCcpJCdcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y29uc3QgY2xhc3NlcyA9IHRoaXMucmVwb3NpdG9yeS5wYXJzZUVsZW1lbnRDbGFzc2VzKFxuXHRcdFx0XHRcdFx0Z2V0U3R5bGVhYmxlRWxlbWVudCh0aGlzKS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJylcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Ly8gTmVpdGhlciBjb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2NhcHRpb25lZENsYXNzIG5vciBjb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2FsaWduQ2xhc3Nlc1xuXHRcdFx0XHRcdC8vIGRvIG5vdCBiZWxvbmcgdG8gc3R5bGUgY2xhc3Nlcy5cblx0XHRcdFx0XHRmb3IgKGNvbnN0IGMgaW4gY2xhc3Nlcykge1xuXHRcdFx0XHRcdFx0aWYgKGNsYXNzUmVnZXgudGVzdChjKSkgZGVsZXRlIGNsYXNzZXNbY107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGNsYXNzZXM7XG5cdFx0XHRcdH07XG5cdFx0XHR9KSgpLFxuXG5cdFx0XHR1cGNhc3Q6IHVwY2FzdFdpZGdldEVsZW1lbnQoZWRpdG9yKSxcblx0XHRcdGRvd25jYXN0OiBkb3duY2FzdFdpZGdldEVsZW1lbnQoZWRpdG9yKSxcblxuXHRcdFx0Z2V0TGFiZWwoKSB7XG5cdFx0XHRcdGNvbnN0IGxhYmVsID0gKHRoaXMuZGF0YS5hbHQgfHwgJycpICsgJyAnICsgdGhpcy5wYXRoTmFtZTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5lZGl0b3IubGFuZy53aWRnZXQubGFiZWwucmVwbGFjZSgvJTEvLCBsYWJlbCk7XG5cdFx0XHR9LFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQSBzZXQgb2YgRW5oYW5jZWQgSW1hZ2UgKGFlX2RyYWdyZXNpemVfaWUxMSkgcGx1Z2luIGhlbHBlcnMuXG5cdCAqXG5cdCAqIEBjbGFzc1xuXHQgKiBAc2luZ2xldG9uXG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmFlX2RyYWdyZXNpemVfaWUxMSA9IHtcblx0XHRzdGF0ZVNoaWZ0ZXIoZWRpdG9yKSB7XG5cdFx0XHQvLyBUYWcgbmFtZSB1c2VkIGZvciBjZW50ZXJpbmcgbm9uLWNhcHRpb25lZCB3aWRnZXRzLlxuXHRcdFx0Y29uc3QgZG9jID0gZWRpdG9yLmRvY3VtZW50O1xuXG5cdFx0XHRjb25zdCBhbGlnbkNsYXNzZXMgPSBlZGl0b3IuY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXM7XG5cblx0XHRcdGNvbnN0IGNhcHRpb25lZENsYXNzID1cblx0XHRcdFx0ZWRpdG9yLmNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfY2FwdGlvbmVkQ2xhc3M7XG5cblx0XHRcdGNvbnN0IGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdC8vIFRoZSBvcmRlciB0aGF0IHN0YXRlQWN0aW9ucyBnZXQgZXhlY3V0ZWQuIEl0IG1hdHRlcnMhXG5cblx0XHRcdGNvbnN0IHNoaWZ0YWJsZXMgPSBbJ2hhc0NhcHRpb24nLCAnYWxpZ24nLCAnbGluayddO1xuXG5cdFx0XHQvLyBBdG9taWMgcHJvY2VkdXJlcywgb25lIHBlciBzdGF0ZSB2YXJpYWJsZS5cblx0XHRcdGNvbnN0IHN0YXRlQWN0aW9ucyA9IHtcblx0XHRcdFx0YWxpZ24oc2hpZnQsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuXHRcdFx0XHRcdGNvbnN0IGVsID0gc2hpZnQuZWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEFsaWdubWVudCBjaGFuZ2VkLlxuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdHNoaWZ0LmNoYW5nZWQuYWxpZ24gfHxcblx0XHRcdFx0XHRcdChlbC4kLnN0eWxlLm1hcmdpbkxlZnQgPT09ICdhdXRvJyAmJlxuXHRcdFx0XHRcdFx0XHRlbC4kLnN0eWxlLm1hcmdpblJpZ2h0ID09PSAnYXV0bycpXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHQvLyBObyBjYXB0aW9uIGluIHRoZSBuZXcgc3RhdGUuXG5cdFx0XHRcdFx0XHRpZiAoIXNoaWZ0Lm5ld0RhdGEuaGFzQ2FwdGlvbikge1xuXHRcdFx0XHRcdFx0XHQvLyBDaGFuZ2VkIHRvIFwiY2VudGVyXCIgKG5vbi1jYXB0aW9uZWQpLlxuXHRcdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdFx0bmV3VmFsdWUgPT0gJ2NlbnRlcicgfHxcblx0XHRcdFx0XHRcdFx0XHQoZWwuJC5zdHlsZS5tYXJnaW5MZWZ0ID09PSAnYXV0bycgJiZcblx0XHRcdFx0XHRcdFx0XHRcdGVsLiQuc3R5bGUubWFyZ2luUmlnaHQgPT09ICdhdXRvJylcblx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0c2hpZnQuZGVmbGF0ZSgpO1xuXHRcdFx0XHRcdFx0XHRcdHNoaWZ0LmVsZW1lbnQgPSB3cmFwSW5DZW50ZXJpbmcoZWRpdG9yLCBlbCk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBDaGFuZ2VkIHRvIFwibm9uLWNlbnRlclwiIGZyb20gXCJjZW50ZXJcIiB3aGlsZSBjYXB0aW9uIHJlbW92ZWQuXG5cdFx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0XHQhc2hpZnQuY2hhbmdlZC5oYXNDYXB0aW9uICYmXG5cdFx0XHRcdFx0XHRcdFx0b2xkVmFsdWUgPT0gJ2NlbnRlcicgJiZcblx0XHRcdFx0XHRcdFx0XHRuZXdWYWx1ZSAhPSAnY2VudGVyJ1xuXHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHRzaGlmdC5kZWZsYXRlKCk7XG5cdFx0XHRcdFx0XHRcdFx0c2hpZnQuZWxlbWVudCA9IHVud3JhcEZyb21DZW50ZXJpbmcoZWwpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQWxpZ25tZW50IHJlbWFpbnMgYW5kIFwiY2VudGVyXCIgcmVtb3ZlZCBjYXB0aW9uLlxuXHRcdFx0XHRcdGVsc2UgaWYgKFxuXHRcdFx0XHRcdFx0bmV3VmFsdWUgPT0gJ2NlbnRlcicgJiZcblx0XHRcdFx0XHRcdHNoaWZ0LmNoYW5nZWQuaGFzQ2FwdGlvbiAmJlxuXHRcdFx0XHRcdFx0IXNoaWZ0Lm5ld0RhdGEuaGFzQ2FwdGlvblxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0c2hpZnQuZGVmbGF0ZSgpO1xuXHRcdFx0XHRcdFx0c2hpZnQuZWxlbWVudCA9IHdyYXBJbkNlbnRlcmluZyhlZGl0b3IsIGVsKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGaW5hbGx5IHNldCBkaXNwbGF5IGZvciBmaWd1cmUuXG5cdFx0XHRcdFx0aWYgKCFhbGlnbkNsYXNzZXMgJiYgZWwuaXMoJ2ZpZ3VyZScpKSB7XG5cdFx0XHRcdFx0XHRpZiAobmV3VmFsdWUgPT0gJ2NlbnRlcicpXG5cdFx0XHRcdFx0XHRcdGVsLnNldFN0eWxlKCdkaXNwbGF5JywgJ2lubGluZS1ibG9jaycpO1xuXHRcdFx0XHRcdFx0ZWxzZSBlbC5yZW1vdmVTdHlsZSgnZGlzcGxheScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRoYXNDYXB0aW9uKHNoaWZ0LCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcblx0XHRcdFx0XHQvLyBUaGlzIGFjdGlvbiBpcyBmb3IgcmVhbCBzdGF0ZSBjaGFuZ2Ugb25seS5cblx0XHRcdFx0XHRpZiAoIXNoaWZ0LmNoYW5nZWQuaGFzQ2FwdGlvbikgcmV0dXJuO1xuXG5cdFx0XHRcdFx0Ly8gR2V0IDxpbWcvPiBvciA8YT48aW1nLz48L2E+IGZyb20gd2lkZ2V0LiBOb3RlIHRoYXQgd2lkZ2V0IGVsZW1lbnQgbWlnaHQgaXRzZWxmXG5cdFx0XHRcdFx0Ly8gYmUgd2hhdCB3ZSdyZSBsb29raW5nIGZvci4gQWxzbyBlbGVtZW50IGNhbiBiZSA8cCBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGE+Li4uPC9hPjwvcD4uXG5cdFx0XHRcdFx0bGV0IGltYWdlT3JMaW5rO1xuXHRcdFx0XHRcdGlmIChzaGlmdC5lbGVtZW50LmlzKHtpbWc6IDEsIGE6IDF9KSlcblx0XHRcdFx0XHRcdGltYWdlT3JMaW5rID0gc2hpZnQuZWxlbWVudDtcblx0XHRcdFx0XHRlbHNlIGltYWdlT3JMaW5rID0gc2hpZnQuZWxlbWVudC5maW5kT25lKCdhLGltZycpO1xuXG5cdFx0XHRcdFx0Ly8gU3dpdGNoaW5nIGhhc0NhcHRpb24gYWx3YXlzIGRlc3Ryb3lzIHRoZSB3aWRnZXQuXG5cdFx0XHRcdFx0c2hpZnQuZGVmbGF0ZSgpO1xuXG5cdFx0XHRcdFx0Ly8gVGhlcmUgd2FzIG5vIGNhcHRpb24sIGJ1dCB0aGUgY2FwdGlvbiBpcyB0byBiZSBhZGRlZC5cblx0XHRcdFx0XHRpZiAobmV3VmFsdWUpIHtcblx0XHRcdFx0XHRcdC8vIENyZWF0ZSBuZXcgPGZpZ3VyZT4gZnJvbSB3aWRnZXQgdGVtcGxhdGUuXG5cdFx0XHRcdFx0XHRjb25zdCBmaWd1cmUgPSBDS0VESVRPUi5kb20uZWxlbWVudC5jcmVhdGVGcm9tSHRtbChcblx0XHRcdFx0XHRcdFx0dGVtcGxhdGVCbG9jay5vdXRwdXQoe1xuXHRcdFx0XHRcdFx0XHRcdGNhcHRpb25lZENsYXNzLFxuXHRcdFx0XHRcdFx0XHRcdGNhcHRpb25QbGFjZWhvbGRlcjpcblx0XHRcdFx0XHRcdFx0XHRcdGVkaXRvci5sYW5nLmFlX2RyYWdyZXNpemVfaWUxMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuY2FwdGlvblBsYWNlaG9sZGVyLFxuXHRcdFx0XHRcdFx0XHR9KSxcblx0XHRcdFx0XHRcdFx0ZG9jXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBSZXBsYWNlIGVsZW1lbnQgd2l0aCA8ZmlndXJlPi5cblx0XHRcdFx0XHRcdHJlcGxhY2VTYWZlbHkoZmlndXJlLCBzaGlmdC5lbGVtZW50KTtcblxuXHRcdFx0XHRcdFx0Ly8gVXNlIG9sZCA8aW1nLz4gb3IgPGE+PGltZy8+PC9hPiBpbnN0ZWFkIG9mIHRoZSBvbmUgZnJvbSB0aGUgdGVtcGxhdGUsXG5cdFx0XHRcdFx0XHQvLyBzbyB3ZSB3b24ndCBsb3NlIGFkZGl0aW9uYWwgYXR0cmlidXRlcy5cblx0XHRcdFx0XHRcdGltYWdlT3JMaW5rLnJlcGxhY2UoZmlndXJlLmZpbmRPbmUoJ2ltZycpKTtcblxuXHRcdFx0XHRcdFx0Ly8gVXBkYXRlIHdpZGdldCdzIGVsZW1lbnQuXG5cdFx0XHRcdFx0XHRzaGlmdC5lbGVtZW50ID0gZmlndXJlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFRoZSBjYXB0aW9uIHdhcyBwcmVzZW50LCBidXQgbm93IGl0J3MgdG8gYmUgcmVtb3ZlZC5cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFVud3JhcCA8aW1nLz4gb3IgPGE+PGltZy8+PC9hPiBmcm9tIGZpZ3VyZS5cblx0XHRcdFx0XHRcdGltYWdlT3JMaW5rLnJlcGxhY2Uoc2hpZnQuZWxlbWVudCk7XG5cblx0XHRcdFx0XHRcdC8vIFVwZGF0ZSB3aWRnZXQncyBlbGVtZW50LlxuXHRcdFx0XHRcdFx0c2hpZnQuZWxlbWVudCA9IGltYWdlT3JMaW5rO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRsaW5rKHNoaWZ0LCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoc2hpZnQuY2hhbmdlZC5saW5rKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBpbWcgPSBzaGlmdC5lbGVtZW50LmlzKCdpbWcnKVxuXHRcdFx0XHRcdFx0XHQ/IHNoaWZ0LmVsZW1lbnRcblx0XHRcdFx0XHRcdFx0OiBzaGlmdC5lbGVtZW50LmZpbmRPbmUoJ2ltZycpO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBsaW5rID0gc2hpZnQuZWxlbWVudC5pcygnYScpXG5cdFx0XHRcdFx0XHRcdD8gc2hpZnQuZWxlbWVudFxuXHRcdFx0XHRcdFx0XHQ6IHNoaWZ0LmVsZW1lbnQuZmluZE9uZSgnYScpO1xuXG5cdFx0XHRcdFx0XHQvLyBXaHkgZGVmbGF0ZTpcblx0XHRcdFx0XHRcdC8vIElmIGVsZW1lbnQgaXMgPGltZy8+LCBpdCB3aWxsIGJlIHdyYXBwZWQgaW50byA8YT4sXG5cdFx0XHRcdFx0XHQvLyB3aGljaCBiZWNvbWVzIGEgbmV3IHdpZGdldC5lbGVtZW50LlxuXHRcdFx0XHRcdFx0Ly8gSWYgZWxlbWVudCBpcyA8YT48aW1nLz48L2E+LCBpdCB3aWxsIGJlIHVubGlua2VkXG5cdFx0XHRcdFx0XHQvLyBzbyA8aW1nLz4gYmVjb21lcyBhIG5ldyB3aWRnZXQuZWxlbWVudC5cblxuXHRcdFx0XHRcdFx0Y29uc3QgbmVlZHNEZWZsYXRlID1cblx0XHRcdFx0XHRcdFx0KHNoaWZ0LmVsZW1lbnQuaXMoJ2EnKSAmJiAhbmV3VmFsdWUpIHx8XG5cdFx0XHRcdFx0XHRcdChzaGlmdC5lbGVtZW50LmlzKCdpbWcnKSAmJiBuZXdWYWx1ZSk7XG5cblx0XHRcdFx0XHRcdGxldCBuZXdFbDtcblxuXHRcdFx0XHRcdFx0aWYgKG5lZWRzRGVmbGF0ZSkgc2hpZnQuZGVmbGF0ZSgpO1xuXG5cdFx0XHRcdFx0XHQvLyBJZiB1bmxpbmtlZCB0aGUgaW1hZ2UsIHJldHVybmVkIGVsZW1lbnQgaXMgPGltZz4uXG5cdFx0XHRcdFx0XHRpZiAoIW5ld1ZhbHVlKSBuZXdFbCA9IHVud3JhcEZyb21MaW5rKGxpbmspO1xuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIElmIGxpbmtlZCB0aGUgaW1hZ2UsIHJldHVybmVkIGVsZW1lbnQgaXMgPGE+LlxuXHRcdFx0XHRcdFx0XHRpZiAoIW9sZFZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdG5ld0VsID0gd3JhcEluTGluayhpbWcsIHNoaWZ0Lm5ld0RhdGEubGluayk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2V0IGFuZCByZW1vdmUgYWxsIGF0dHJpYnV0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc3RhdGUuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBDS0VESVRPUi5wbHVnaW5zLmFlX2RyYWdyZXNpemVfaWUxMS5nZXRMaW5rQXR0cmlidXRlc0dldHRlcigpKFxuXHRcdFx0XHRcdFx0XHRcdGVkaXRvcixcblx0XHRcdFx0XHRcdFx0XHRuZXdWYWx1ZVxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghQ0tFRElUT1IudG9vbHMuaXNFbXB0eShhdHRyaWJ1dGVzLnNldCkpXG5cdFx0XHRcdFx0XHRcdFx0KG5ld0VsIHx8IGxpbmspLnNldEF0dHJpYnV0ZXMoYXR0cmlidXRlcy5zZXQpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChhdHRyaWJ1dGVzLnJlbW92ZWQubGVuZ3RoKVxuXHRcdFx0XHRcdFx0XHRcdChuZXdFbCB8fCBsaW5rKS5yZW1vdmVBdHRyaWJ1dGVzKFxuXHRcdFx0XHRcdFx0XHRcdFx0YXR0cmlidXRlcy5yZW1vdmVkXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG5lZWRzRGVmbGF0ZSkgc2hpZnQuZWxlbWVudCA9IG5ld0VsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdH07XG5cblx0XHRcdGZ1bmN0aW9uIHdyYXBJbkNlbnRlcmluZyhlZGl0b3IsIGVsZW1lbnQpIHtcblx0XHRcdFx0Y29uc3QgYXR0cmlic0FuZFN0eWxlcyA9IHt9O1xuXG5cdFx0XHRcdGlmIChhbGlnbkNsYXNzZXMpXG5cdFx0XHRcdFx0YXR0cmlic0FuZFN0eWxlcy5hdHRyaWJ1dGVzID0ge2NsYXNzOiBhbGlnbkNsYXNzZXNbMV19O1xuXHRcdFx0XHRlbHNlIGF0dHJpYnNBbmRTdHlsZXMuc3R5bGVzID0geyd0ZXh0LWFsaWduJzogJ2NlbnRlcid9O1xuXG5cdFx0XHRcdC8vIFRoZXJlJ3Mgbm8gZ2VudGxlIHdheSB0byBjZW50ZXIgaW5saW5lIGVsZW1lbnQgd2l0aCBDU1MsIHNvIGNyZWF0ZSBwL2RpdlxuXHRcdFx0XHQvLyB0aGF0IHdyYXBzIHdpZGdldCBjb250ZW50cyBhbmQgZG9lcyB0aGUgdHJpY2sgZWl0aGVyIHdpdGggc3R5bGUgb3IgY2xhc3MuXG5cdFx0XHRcdGNvbnN0IGNlbnRlciA9IGRvYy5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHRcdGVkaXRvci5hY3RpdmVFbnRlck1vZGUgPT0gQ0tFRElUT1IuRU5URVJfUCA/ICdwJyA6ICdkaXYnLFxuXHRcdFx0XHRcdGF0dHJpYnNBbmRTdHlsZXNcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBSZXBsYWNlIGVsZW1lbnQgd2l0aCBjZW50ZXJpbmcgd3JhcHBlci5cblx0XHRcdFx0cmVwbGFjZVNhZmVseShjZW50ZXIsIGVsZW1lbnQpO1xuXHRcdFx0XHRlbGVtZW50Lm1vdmUoY2VudGVyKTtcblxuXHRcdFx0XHRyZXR1cm4gY2VudGVyO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiB1bndyYXBGcm9tQ2VudGVyaW5nKGVsZW1lbnQpIHtcblx0XHRcdFx0Y29uc3QgaW1hZ2VPckxpbmsgPSBlbGVtZW50LmZpbmRPbmUoJ2EsaW1nJyk7XG5cblx0XHRcdFx0aW1hZ2VPckxpbmsucmVwbGFjZShlbGVtZW50KTtcblxuXHRcdFx0XHRyZXR1cm4gaW1hZ2VPckxpbms7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdyYXBzIDxpbWcvPiAtPiA8YT48aW1nLz48L2E+LlxuXHRcdFx0Ly8gUmV0dXJucyByZWZlcmVuY2UgdG8gPGE+LlxuXHRcdFx0Ly9cblx0XHRcdC8vIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGltZ1xuXHRcdFx0Ly8gQHBhcmFtIHtPYmplY3R9IGxpbmtEYXRhXG5cdFx0XHQvLyBAcmV0dXJucyB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9XG5cdFx0XHRmdW5jdGlvbiB3cmFwSW5MaW5rKGltZywgbGlua0RhdGEpIHtcblx0XHRcdFx0Y29uc3QgbGluayA9IGRvYy5jcmVhdGVFbGVtZW50KCdhJywge1xuXHRcdFx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0XHRcdGhyZWY6IGxpbmtEYXRhLnVybCxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRsaW5rLnJlcGxhY2UoaW1nKTtcblx0XHRcdFx0aW1nLm1vdmUobGluayk7XG5cblx0XHRcdFx0cmV0dXJuIGxpbms7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlLXdyYXBzIDxhPjxpbWcvPjwvYT4gLT4gPGltZy8+LlxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgcmVmZXJlbmNlIHRvIDxpbWcvPlxuXHRcdFx0Ly9cblx0XHRcdC8vIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGxpbmtcblx0XHRcdC8vIEByZXR1cm5zIHtDS0VESVRPUi5kb20uZWxlbWVudH1cblx0XHRcdGZ1bmN0aW9uIHVud3JhcEZyb21MaW5rKGxpbmspIHtcblx0XHRcdFx0Y29uc3QgaW1nID0gbGluay5maW5kT25lKCdpbWcnKTtcblxuXHRcdFx0XHRpbWcucmVwbGFjZShsaW5rKTtcblxuXHRcdFx0XHRyZXR1cm4gaW1nO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiByZXBsYWNlU2FmZWx5KHJlcGxhY2luZywgcmVwbGFjZWQpIHtcblx0XHRcdFx0aWYgKHJlcGxhY2VkLmdldFBhcmVudCgpKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmFuZ2UgPSBlZGl0b3IuY3JlYXRlUmFuZ2UoKTtcblxuXHRcdFx0XHRcdHJhbmdlLm1vdmVUb1Bvc2l0aW9uKFxuXHRcdFx0XHRcdFx0cmVwbGFjZWQsXG5cdFx0XHRcdFx0XHRDS0VESVRPUi5QT1NJVElPTl9CRUZPUkVfU1RBUlRcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Ly8gUmVtb3ZlIG9sZCBlbGVtZW50LiBEbyBpdCBiZWZvcmUgaW5zZXJ0aW9uIHRvIGF2b2lkIGEgY2FzZSB3aGVuXG5cdFx0XHRcdFx0Ly8gZWxlbWVudCBpcyBtb3ZlZCBmcm9tICdyZXBsYWNlZCcgZWxlbWVudCBiZWZvcmUgaXQsIHdoYXQgY3JlYXRlc1xuXHRcdFx0XHRcdC8vIGEgdHJpY2t5IGNhc2Ugd2hpY2ggaW5zZXJ0RWxlbWVudEludG9yUmFuZ2UgZG9lcyBub3QgaGFuZGxlLlxuXHRcdFx0XHRcdHJlcGxhY2VkLnJlbW92ZSgpO1xuXG5cdFx0XHRcdFx0ZWRpdGFibGUuaW5zZXJ0RWxlbWVudEludG9SYW5nZShyZXBsYWNpbmcsIHJhbmdlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXBsYWNpbmcucmVwbGFjZShyZXBsYWNlZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHNoaWZ0KSB7XG5cdFx0XHRcdGxldCBuYW1lO1xuXHRcdFx0XHRsZXQgaTtcblxuXHRcdFx0XHRzaGlmdC5jaGFuZ2VkID0ge307XG5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHNoaWZ0YWJsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRuYW1lID0gc2hpZnRhYmxlc1tpXTtcblxuXHRcdFx0XHRcdHNoaWZ0LmNoYW5nZWRbbmFtZV0gPSBzaGlmdC5vbGREYXRhXG5cdFx0XHRcdFx0XHQ/IHNoaWZ0Lm9sZERhdGFbbmFtZV0gIT09IHNoaWZ0Lm5ld0RhdGFbbmFtZV1cblx0XHRcdFx0XHRcdDogZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJdGVyYXRlIG92ZXIgcG9zc2libGUgc3RhdGUgdmFyaWFibGVzLlxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2hpZnRhYmxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG5hbWUgPSBzaGlmdGFibGVzW2ldO1xuXG5cdFx0XHRcdFx0c3RhdGVBY3Rpb25zW25hbWVdKFxuXHRcdFx0XHRcdFx0c2hpZnQsXG5cdFx0XHRcdFx0XHRzaGlmdC5vbGREYXRhID8gc2hpZnQub2xkRGF0YVtuYW1lXSA6IG51bGwsXG5cdFx0XHRcdFx0XHRzaGlmdC5uZXdEYXRhW25hbWVdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNoaWZ0LmluZmxhdGUoKTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrcyB3aGV0aGVyIHRoZSBjdXJyZW50IGltYWdlIHJhdGlvIG1hdGNoZXMgdGhlIG5hdHVyYWwgb25lXG5cdFx0ICogYnkgY29tcGFyaW5nIGRpbWVuc2lvbnMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBpbWFnZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0Y2hlY2tIYXNOYXR1cmFsUmF0aW8oaW1hZ2UpIHtcblx0XHRcdGNvbnN0ICQgPSBpbWFnZS4kO1xuXG5cdFx0XHRjb25zdCBuYXR1cmFsID0gdGhpcy5nZXROYXR1cmFsKGltYWdlKTtcblxuXHRcdFx0Ly8gVGhlIHJlYXNvbiBmb3IgdHdvIGFsdGVybmF0aXZlIGNvbXBhcmlzb25zIGlzIHRoYXQgdGhlIHJvdW5kaW5nIGNhbiBjb21lIGZyb21cblx0XHRcdC8vIGJvdGggZGltZW5zaW9ucywgZS5nLiB0aGVyZSBhcmUgdHdvIGNhc2VzOlxuXHRcdFx0Ly8gXHQxLiBoZWlnaHQgaXMgY29tcHV0ZWQgYXMgYSByb3VuZGVkIHJlbGF0aW9uIG9mIHRoZSByZWFsIGhlaWdodCBhbmQgdGhlIHZhbHVlIG9mIHdpZHRoLFxuXHRcdFx0Ly9cdDIuIHdpZHRoIGlzIGNvbXB1dGVkIGFzIGEgcm91bmRlZCByZWxhdGlvbiBvZiB0aGUgcmVhbCB3aWR0aCBhbmQgdGhlIHZhbHVlIG9mIGhlaWdoLlxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0TWF0aC5yb3VuZCgoJC5jbGllbnRXaWR0aCAvIG5hdHVyYWwud2lkdGgpICogbmF0dXJhbC5oZWlnaHQpID09XG5cdFx0XHRcdFx0JC5jbGllbnRIZWlnaHQgfHxcblx0XHRcdFx0TWF0aC5yb3VuZCgoJC5jbGllbnRIZWlnaHQgLyBuYXR1cmFsLmhlaWdodCkgKiBuYXR1cmFsLndpZHRoKSA9PVxuXHRcdFx0XHRcdCQuY2xpZW50V2lkdGhcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgbmF0dXJhbCBkaW1lbnNpb25zIG9mIHRoZSBpbWFnZS4gRm9yIG1vZGVybiBicm93c2Vyc1xuXHRcdCAqIGl0IHVzZXMgbmF0dXJhbChXaWR0aHxIZWlnaHQpLiBGb3Igb2xkIG9uZXMgKElFOCkgaXQgY3JlYXRlc1xuXHRcdCAqIGEgbmV3IGltYWdlIGFuZCByZWFkcyB0aGUgZGltZW5zaW9ucy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGltYWdlXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGdldE5hdHVyYWwoaW1hZ2UpIHtcblx0XHRcdGxldCBkaW1lbnNpb25zO1xuXG5cdFx0XHRpZiAoaW1hZ2UuJC5uYXR1cmFsV2lkdGgpIHtcblx0XHRcdFx0ZGltZW5zaW9ucyA9IHtcblx0XHRcdFx0XHR3aWR0aDogaW1hZ2UuJC5uYXR1cmFsV2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBpbWFnZS4kLm5hdHVyYWxIZWlnaHQsXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcblx0XHRcdFx0aW1nLnNyYyA9IGltYWdlLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG5cblx0XHRcdFx0ZGltZW5zaW9ucyA9IHtcblx0XHRcdFx0XHR3aWR0aDogaW1nLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogaW1nLmhlaWdodCxcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRpbWVuc2lvbnM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYW4gYXR0cmlidXRlIGdldHRlciBmdW5jdGlvbi4gRGVmYXVsdCBnZXR0ZXIgY29tZXMgZnJvbSB0aGUgTGluayBwbHVnaW5cblx0XHQgKiBhbmQgaXMgZG9jdW1lbnRlZCBieSB7QGxpbmsgQ0tFRElUT1IucGx1Z2lucy5saW5rI2dldExpbmtBdHRyaWJ1dGVzfS5cblx0XHQgKlxuXHRcdCAqICoqTm90ZToqKiBJdCBpcyBwb3NzaWJsZSB0byBvdmVycmlkZSB0aGlzIG1ldGhvZCBhbmQgdXNlIGEgY3VzdG9tIGdldHRlciBlLmcuXG5cdFx0ICogaW4gdGhlIGFic2VuY2Ugb2YgdGhlIExpbmsgcGx1Z2luLlxuXHRcdCAqXG5cdFx0ICogKipOb3RlOioqIElmIGEgY3VzdG9tIGdldHRlciBpcyB1c2VkLCBhIGRhdGEgbW9kZWwgZm9ybWF0IGl0IHByb2R1Y2VzXG5cdFx0ICogbXVzdCBiZSBjb21wYXRpYmxlIHdpdGgge0BsaW5rIENLRURJVE9SLnBsdWdpbnMubGluayNnZXRMaW5rQXR0cmlidXRlc30uXG5cdFx0ICpcblx0XHQgKiAqKk5vdGU6KiogQSBjdXN0b20gZ2V0dGVyIG11c3QgdW5kZXJzdGFuZCB0aGUgZGF0YSBtb2RlbCBmb3JtYXQgcHJvZHVjZWQgYnlcblx0XHQgKiB7QGxpbmsgI2dldExpbmtBdHRyaWJ1dGVzUGFyc2VyfSB0byB3b3JrIGNvcnJlY3RseS5cblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyAoY29tcG9zZXMpIGxpbmsgYXR0cmlidXRlcy5cblx0XHQgKiBAc2luY2UgNC41LjVcblx0XHQgKi9cblx0XHRnZXRMaW5rQXR0cmlidXRlc0dldHRlcigpIHtcblx0XHRcdC8vICMxMzg4NVxuXHRcdFx0cmV0dXJuIENLRURJVE9SLnBsdWdpbnMubGluay5nZXRMaW5rQXR0cmlidXRlcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhbiBhdHRyaWJ1dGUgcGFyc2VyIGZ1bmN0aW9uLiBEZWZhdWx0IHBhcnNlciBjb21lcyBmcm9tIHRoZSBMaW5rIHBsdWdpblxuXHRcdCAqIGFuZCBpcyBkb2N1bWVudGVkIGJ5IHtAbGluayBDS0VESVRPUi5wbHVnaW5zLmxpbmsjcGFyc2VMaW5rQXR0cmlidXRlc30uXG5cdFx0ICpcblx0XHQgKiAqKk5vdGU6KiogSXQgaXMgcG9zc2libGUgdG8gb3ZlcnJpZGUgdGhpcyBtZXRob2QgYW5kIHVzZSBhIGN1c3RvbSBwYXJzZXIgZS5nLlxuXHRcdCAqIGluIHRoZSBhYnNlbmNlIG9mIHRoZSBMaW5rIHBsdWdpbi5cblx0XHQgKlxuXHRcdCAqICoqTm90ZToqKiBJZiBhIGN1c3RvbSBwYXJzZXIgaXMgdXNlZCwgYSBkYXRhIG1vZGVsIGZvcm1hdCBwcm9kdWNlZCBieSB0aGUgcGFyc2VyXG5cdFx0ICogbXVzdCBiZSBjb21wYXRpYmxlIHdpdGgge0BsaW5rICNnZXRMaW5rQXR0cmlidXRlc0dldHRlcn0uXG5cdFx0ICpcblx0XHQgKiAqKk5vdGU6KiogSWYgYSBjdXN0b20gcGFyc2VyIGlzIHVzZWQsIGl0IHNob3VsZCBiZSBjb21wYXRpYmxlIHdpdGggdGhlXG5cdFx0ICoge0BsaW5rIENLRURJVE9SLnBsdWdpbnMubGluayNwYXJzZUxpbmtBdHRyaWJ1dGVzfSBkYXRhIG1vZGVsIGZvcm1hdC4gT3RoZXJ3aXNlIHRoZVxuXHRcdCAqIExpbmsgcGx1Z2luIGRpYWxvZyBtYXkgbm90IGJlIHBvcHVsYXRlZCBjb3JyZWN0bHkgd2l0aCBwYXJzZWQgZGF0YS4gSG93ZXZlclxuXHRcdCAqIGFzIGxvbmcgYXMgRW5oYW5jZWQgSW1hZ2UgaXMgKipub3QqKiB1c2VkIHdpdGggdGhlIExpbmsgcGx1Z2luIGRpYWxvZywgYW55IGN1c3RvbSBkYXRhIG1vZGVsXG5cdFx0ICogd2lsbCB3b3JrLCBiZWluZyBzdG9yZWQgYXMgYW4gaW50ZXJuYWwgcHJvcGVydHkgb2YgRW5oYW5jZWQgSW1hZ2Ugd2lkZ2V0J3MgZGF0YSBvbmx5LlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCBwYXJzZXMgYXR0cmlidXRlcy5cblx0XHQgKiBAc2luY2UgNC41LjVcblx0XHQgKi9cblx0XHRnZXRMaW5rQXR0cmlidXRlc1BhcnNlcigpIHtcblx0XHRcdC8vICMxMzg4NVxuXHRcdFx0cmV0dXJuIENLRURJVE9SLnBsdWdpbnMubGluay5wYXJzZUxpbmtBdHRyaWJ1dGVzO1xuXHRcdH0sXG5cdH07XG5cblx0ZnVuY3Rpb24gc2V0V3JhcHBlckFsaWduKHdpZGdldCwgYWxpZ25DbGFzc2VzKSB7XG5cdFx0Y29uc3Qgd3JhcHBlciA9IHdpZGdldC53cmFwcGVyO1xuXG5cdFx0Y29uc3QgYWxpZ24gPSB3aWRnZXQuZGF0YS5hbGlnbjtcblxuXHRcdGNvbnN0IGhhc0NhcHRpb24gPSB3aWRnZXQuZGF0YS5oYXNDYXB0aW9uO1xuXG5cdFx0aWYgKGFsaWduQ2xhc3Nlcykge1xuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBhbGlnbiBjbGFzc2VzIGZpcnN0LlxuXHRcdFx0Zm9yIChsZXQgaSA9IDM7IGktLTsgKSB3cmFwcGVyLnJlbW92ZUNsYXNzKGFsaWduQ2xhc3Nlc1tpXSk7XG5cblx0XHRcdGlmIChhbGlnbiA9PSAnY2VudGVyJykge1xuXHRcdFx0XHQvLyBBdm9pZCB0b3VjaGluZyBub24tY2FwdGlvbmVkLCBjZW50ZXJlZCB3aWRnZXRzIGJlY2F1c2Vcblx0XHRcdFx0Ly8gdGhleSBoYXZlIHRoZSBjbGFzcyBzZXQgb24gdGhlIGVsZW1lbnQgaW5zdGVhZCBvZiB3cmFwcGVyOlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBcdDxkaXYgY2xhc3M9XCJja2Vfd2lkZ2V0X3dyYXBwZXJcIj5cblx0XHRcdFx0Ly8gXHRcdDxwIGNsYXNzPVwiY2VudGVyLWNsYXNzXCI+XG5cdFx0XHRcdC8vIFx0XHRcdDxpbWcgLz5cblx0XHRcdFx0Ly8gXHRcdDwvcD5cblx0XHRcdFx0Ly8gXHQ8L2Rpdj5cblx0XHRcdFx0aWYgKGhhc0NhcHRpb24pIHtcblx0XHRcdFx0XHR3cmFwcGVyLmFkZENsYXNzKGFsaWduQ2xhc3Nlc1sxXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYWxpZ24gIT0gJ25vbmUnKSB7XG5cdFx0XHRcdHdyYXBwZXIuYWRkQ2xhc3MoYWxpZ25DbGFzc2VzW2FsaWdubWVudHNPYmpbYWxpZ25dXSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChhbGlnbiA9PSAnY2VudGVyJykge1xuXHRcdFx0XHRpZiAoaGFzQ2FwdGlvbikgd3JhcHBlci5zZXRTdHlsZSgndGV4dC1hbGlnbicsICdjZW50ZXInKTtcblx0XHRcdFx0ZWxzZSB3cmFwcGVyLnJlbW92ZVN0eWxlKCd0ZXh0LWFsaWduJyk7XG5cblx0XHRcdFx0d3JhcHBlci5yZW1vdmVTdHlsZSgnZmxvYXQnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChhbGlnbiA9PSAnbm9uZScpIHdyYXBwZXIucmVtb3ZlU3R5bGUoJ2Zsb2F0Jyk7XG5cdFx0XHRcdGVsc2Ugd3JhcHBlci5zZXRTdHlsZSgnZmxvYXQnLCBhbGlnbik7XG5cblx0XHRcdFx0d3JhcHBlci5yZW1vdmVTdHlsZSgndGV4dC1hbGlnbicpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBpbWFnZSA9IHdyYXBwZXIuJC5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcblxuXHRcdFx0Y29uc3QgaW1hZ2VTdHlsZXMgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cblx0XHRcdGlmIChpbWFnZVN0eWxlcykge1xuXHRcdFx0XHRsZXQgc3R5bGVzID0gJyc7XG5cblx0XHRcdFx0Y29uc3QgaGVpZ2h0U3R5bGVzID0gLyhoZWlnaHQ6Lis/OykvLmV4ZWMoaW1hZ2VTdHlsZXMpO1xuXHRcdFx0XHRpZiAoaGVpZ2h0U3R5bGVzKSB7XG5cdFx0XHRcdFx0c3R5bGVzICs9IGhlaWdodFN0eWxlc1swXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHdpZHRoU3R5bGVzID0gLyh3aWR0aDouKz87KS8uZXhlYyhpbWFnZVN0eWxlcyk7XG5cdFx0XHRcdGlmICh3aWR0aFN0eWxlcykge1xuXHRcdFx0XHRcdHN0eWxlcyArPSB3aWR0aFN0eWxlc1swXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGltYWdlLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHlsZXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgd2lkZ2V0cyBmcm9tIGFsbCA8aW1nPiBhbmRcblx0Ly8gPGZpZ3VyZSBjbGFzcz1cIntjb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2NhcHRpb25lZENsYXNzfVwiPiBlbGVtZW50cy5cblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9IGVkaXRvclxuXHQvLyBAcmV0dXJucyB7RnVuY3Rpb259XG5cdGZ1bmN0aW9uIHVwY2FzdFdpZGdldEVsZW1lbnQoZWRpdG9yKSB7XG5cdFx0Y29uc3QgaXNDZW50ZXJXcmFwcGVyID0gY2VudGVyV3JhcHBlckNoZWNrZXIoZWRpdG9yKTtcblxuXHRcdGNvbnN0IGNhcHRpb25lZENsYXNzID0gZWRpdG9yLmNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfY2FwdGlvbmVkQ2xhc3M7XG5cblx0XHQvLyBAcGFyYW0ge0NLRURJVE9SLmh0bWxQYXJzZXIuZWxlbWVudH0gZWxcblx0XHQvLyBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHRcdHJldHVybiBmdW5jdGlvbihlbCwgZGF0YSkge1xuXHRcdFx0Y29uc3QgZGltZW5zaW9ucyA9IHt3aWR0aDogMSwgaGVpZ2h0OiAxfTtcblxuXHRcdFx0Y29uc3QgbmFtZSA9IGVsLm5hbWU7XG5cblx0XHRcdGxldCBpbWFnZTtcblxuXHRcdFx0Ly8gIzExMTEwIERvbid0IGluaXRpYWxpemUgb24gcGFzdGVkIGZha2Ugb2JqZWN0cy5cblx0XHRcdGlmIChlbC5hdHRyaWJ1dGVzWydkYXRhLWNrZS1yZWFsZWxlbWVudCddKSByZXR1cm47XG5cblx0XHRcdC8vIElmIGEgY2VudGVyIHdyYXBwZXIgaXMgZm91bmQsIHRoZXJlIGFyZSAzIHBvc3NpYmxlIGNhc2VzOlxuXHRcdFx0Ly9cblx0XHRcdC8vIDEuIDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxmaWd1cmU+Li4uPC9maWd1cmU+PC9kaXY+LlxuXHRcdFx0Ly8gICAgSW4gdGhpcyBjYXNlIGNlbnRlcmluZyBpcyBkb25lIHdpdGggYSBjbGFzcyBzZXQgb24gd2lkZ2V0LndyYXBwZXIuXG5cdFx0XHQvLyAgICBTaW1wbHkgcmVwbGFjZSBjZW50ZXJpbmcgd3JhcHBlciB3aXRoIGZpZ3VyZSAoaXQncyBubyBsb25nZXIgbmVjZXNzYXJ5KS5cblx0XHRcdC8vXG5cdFx0XHQvLyAyLiA8cCBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGltZy8+PC9wPi5cblx0XHRcdC8vICAgIE5vdGhpbmcgdG8gZG8gaGVyZTogPHA+IHJlbWFpbnMgZm9yIHN0eWxpbmcgcHVycG9zZXMuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gMy4gPGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGltZy8+PC9kaXY+LlxuXHRcdFx0Ly8gICAgTm90aGluZyB0byBkbyBoZXJlICgyLikgYnV0IHRoYXQgY2FzZSBpcyBvbmx5IHBvc3NpYmxlIGluIGVudGVyTW9kZSBkaWZmZXJlbnRcblx0XHRcdC8vICAgIHRoYW4gRU5URVJfUC5cblx0XHRcdGlmIChpc0NlbnRlcldyYXBwZXIoZWwpKSB7XG5cdFx0XHRcdGlmIChuYW1lID09ICdkaXYnKSB7XG5cdFx0XHRcdFx0Y29uc3QgZmlndXJlID0gZWwuZ2V0Rmlyc3QoJ2ZpZ3VyZScpO1xuXG5cdFx0XHRcdFx0Ly8gQ2FzZSAjMS5cblx0XHRcdFx0XHRpZiAoZmlndXJlKSB7XG5cdFx0XHRcdFx0XHRlbC5yZXBsYWNlV2l0aChmaWd1cmUpO1xuXHRcdFx0XHRcdFx0ZWwgPSBmaWd1cmU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIENhc2VzICMyIGFuZCAjMyAoaGFuZGxlZCB0cmFuc3BhcmVudGx5KVxuXG5cdFx0XHRcdC8vIElmIHRoZXJlJ3MgYSBjZW50ZXJpbmcgd3JhcHBlciwgc2F2ZSBpdCBpbiBkYXRhLlxuXHRcdFx0XHRkYXRhLmFsaWduID0gJ2NlbnRlcic7XG5cblx0XHRcdFx0Ly8gSW1hZ2UgY2FuIGJlIHdyYXBwZWQgaW4gbGluayA8YT48aW1nLz48L2E+LlxuXHRcdFx0XHRpbWFnZSA9IGVsLmdldEZpcnN0KCdpbWcnKSB8fCBlbC5nZXRGaXJzdCgnYScpLmdldEZpcnN0KCdpbWcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gY2VudGVyIHdyYXBwZXIgaGFzIGJlZW4gZm91bmQuXG5cdFx0XHRlbHNlIGlmIChuYW1lID09ICdmaWd1cmUnICYmIGVsLmhhc0NsYXNzKGNhcHRpb25lZENsYXNzKSkge1xuXHRcdFx0XHRpbWFnZSA9IGVsLmdldEZpcnN0KCdpbWcnKSB8fCBlbC5nZXRGaXJzdCgnYScpLmdldEZpcnN0KCdpbWcnKTtcblxuXHRcdFx0XHQvLyBVcGNhc3QgbGlua2VkIGltYWdlIGxpa2UgPGE+PGltZy8+PC9hPi5cblx0XHRcdH0gZWxzZSBpZiAoaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZShlbCkpIHtcblx0XHRcdFx0aW1hZ2UgPSBlbC5uYW1lID09ICdhJyA/IGVsLmNoaWxkcmVuWzBdIDogZWw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaW1hZ2UpIHJldHVybjtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBhbiBpbWFnZSwgdGhlbiBjb29sLCB3ZSBnb3QgYSB3aWRnZXQuXG5cdFx0XHQvLyBOb3cganVzdCByZW1vdmUgZGltZW5zaW9uIGF0dHJpYnV0ZXMgZXhwcmVzc2VkIHdpdGggJS5cblx0XHRcdGZvciAoY29uc3QgZCBpbiBkaW1lbnNpb25zKSB7XG5cdFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGltZW5zaW9ucywgZCkpIHtcblx0XHRcdFx0XHRjb25zdCBkaW1lbnNpb24gPSBpbWFnZS5hdHRyaWJ1dGVzW2RdO1xuXHRcdFx0XHRcdGlmIChkaW1lbnNpb24gJiYgZGltZW5zaW9uLm1hdGNoKHJlZ2V4UGVyY2VudCkpXG5cdFx0XHRcdFx0XHRkZWxldGUgaW1hZ2UuYXR0cmlidXRlc1tkXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fTtcblx0fVxuXG5cdC8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCB0cmFuc2Zvcm1zIHRoZSB3aWRnZXQgdG8gdGhlIGV4dGVybmFsIGZvcm1hdFxuXHQvLyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbi5cblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9XG5cdGZ1bmN0aW9uIGRvd25jYXN0V2lkZ2V0RWxlbWVudChlZGl0b3IpIHtcblx0XHRjb25zdCBhbGlnbkNsYXNzZXMgPSBlZGl0b3IuY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXM7XG5cblx0XHQvLyBAcGFyYW0ge0NLRURJVE9SLmh0bWxQYXJzZXIuZWxlbWVudH0gZWxcblx0XHRyZXR1cm4gZnVuY3Rpb24oZWwpIHtcblx0XHRcdC8vIEluIGNhc2Ugb2YgPGE+PGltZy8+PC9hPiwgPGltZy8+IGlzIHRoZSBlbGVtZW50IHRvIGhvbGRcblx0XHRcdC8vIGlubGluZSBzdHlsZXMgb3IgY2xhc3NlcyAoYWVfZHJhZ3Jlc2l6ZV9pZTExX2FsaWduQ2xhc3NlcykuXG5cdFx0XHRjb25zdCBhdHRyc0hvbGRlciA9IGVsLm5hbWUgPT0gJ2EnID8gZWwuZ2V0Rmlyc3QoKSA6IGVsO1xuXG5cdFx0XHRjb25zdCBhdHRycyA9IGF0dHJzSG9sZGVyLmF0dHJpYnV0ZXM7XG5cblx0XHRcdGNvbnN0IGFsaWduID0gdGhpcy5kYXRhLmFsaWduO1xuXG5cdFx0XHQvLyBEZS13cmFwIHRoZSBpbWFnZSBmcm9tIHJlc2l6ZSBoYW5kbGUgd3JhcHBlci5cblx0XHRcdC8vIE9ubHkgYmxvY2sgd2lkZ2V0cyBoYXZlIG9uZS5cblx0XHRcdGlmICghdGhpcy5pbmxpbmUpIHtcblx0XHRcdFx0Y29uc3QgcmVzaXplV3JhcHBlciA9IGVsLmdldEZpcnN0KCdzcGFuJyk7XG5cblx0XHRcdFx0aWYgKHJlc2l6ZVdyYXBwZXIpXG5cdFx0XHRcdFx0cmVzaXplV3JhcHBlci5yZXBsYWNlV2l0aChcblx0XHRcdFx0XHRcdHJlc2l6ZVdyYXBwZXIuZ2V0Rmlyc3Qoe2ltZzogMSwgYTogMX0pXG5cdFx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGFsaWduICYmIGFsaWduICE9ICdub25lJykge1xuXHRcdFx0XHRjb25zdCBzdHlsZXMgPSBDS0VESVRPUi50b29scy5wYXJzZUNzc1RleHQoYXR0cnMuc3R5bGUgfHwgJycpO1xuXG5cdFx0XHRcdC8vIFdoZW4gdGhlIHdpZGdldCBpcyBjYXB0aW9uZWQgKDxmaWd1cmU+KSBhbmQgaW50ZXJuYWxseSBjZW50ZXJpbmcgaXMgZG9uZVxuXHRcdFx0XHQvLyB3aXRoIHdpZGdldCdzIHdyYXBwZXIgc3R5bGUvY2xhc3MsIGluIHRoZSBleHRlcm5hbCBkYXRhIHJlcHJlc2VudGF0aW9uLFxuXHRcdFx0XHQvLyA8ZmlndXJlPiBtdXN0IGJlIHdyYXBwZWQgd2l0aCBhbiBlbGVtZW50IGhvbGRpbmcgYW4gc3R5bGUvY2xhc3M6XG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIFx0PGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+XG5cdFx0XHRcdC8vIFx0XHQ8ZmlndXJlIGNsYXNzPVwiaW1hZ2VcIiBzdHlsZT1cImRpc3BsYXk6aW5saW5lLWJsb2NrXCI+Li4uPC9maWd1cmU+XG5cdFx0XHRcdC8vIFx0PC9kaXY+XG5cdFx0XHRcdC8vIG9yXG5cdFx0XHRcdC8vIFx0PGRpdiBjbGFzcz1cInNvbWUtY2VudGVyLWNsYXNzXCI+XG5cdFx0XHRcdC8vIFx0XHQ8ZmlndXJlIGNsYXNzPVwiaW1hZ2VcIj4uLi48L2ZpZ3VyZT5cblx0XHRcdFx0Ly8gXHQ8L2Rpdj5cblx0XHRcdFx0Ly9cblx0XHRcdFx0aWYgKGFsaWduID09ICdjZW50ZXInICYmIGVsLm5hbWUgPT0gJ2ZpZ3VyZScpIHtcblx0XHRcdFx0XHRlbCA9IGVsLndyYXBXaXRoKFxuXHRcdFx0XHRcdFx0bmV3IENLRURJVE9SLmh0bWxQYXJzZXIuZWxlbWVudChcblx0XHRcdFx0XHRcdFx0J2RpdicsXG5cdFx0XHRcdFx0XHRcdGFsaWduQ2xhc3Nlc1xuXHRcdFx0XHRcdFx0XHRcdD8ge2NsYXNzOiBhbGlnbkNsYXNzZXNbMV19XG5cdFx0XHRcdFx0XHRcdFx0OiB7c3R5bGU6ICd0ZXh0LWFsaWduOmNlbnRlcid9XG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIGxlZnQvcmlnaHQsIGFkZCBmbG9hdCBzdHlsZSB0byB0aGUgZG93bmNhc3RlZCBlbGVtZW50LlxuXHRcdFx0XHRlbHNlIGlmIChhbGlnbiBpbiB7bGVmdDogMSwgcmlnaHQ6IDF9KSB7XG5cdFx0XHRcdFx0aWYgKGFsaWduQ2xhc3Nlcylcblx0XHRcdFx0XHRcdGF0dHJzSG9sZGVyLmFkZENsYXNzKFxuXHRcdFx0XHRcdFx0XHRhbGlnbkNsYXNzZXNbYWxpZ25tZW50c09ialthbGlnbl1dXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGVsc2Ugc3R5bGVzWydmbG9hdCddID0gYWxpZ247XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBVcGRhdGUgZWxlbWVudCBzdHlsZXMuXG5cdFx0XHRcdGlmICghYWxpZ25DbGFzc2VzICYmICFDS0VESVRPUi50b29scy5pc0VtcHR5KHN0eWxlcykpXG5cdFx0XHRcdFx0YXR0cnMuc3R5bGUgPSBDS0VESVRPUi50b29scy53cml0ZUNzc1RleHQoc3R5bGVzKSArICc7Jztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsO1xuXHRcdH07XG5cdH1cblxuXHQvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYW4gZWxlbWVudCBpcyBhIGNlbnRlcmluZyB3cmFwcGVyLlxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn0gZWRpdG9yXG5cdC8vIEByZXR1cm5zIHtGdW5jdGlvbn1cblx0ZnVuY3Rpb24gY2VudGVyV3JhcHBlckNoZWNrZXIoZWRpdG9yKSB7XG5cdFx0Y29uc3QgY2FwdGlvbmVkQ2xhc3MgPSBlZGl0b3IuY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9jYXB0aW9uZWRDbGFzcztcblxuXHRcdGNvbnN0IGFsaWduQ2xhc3NlcyA9IGVkaXRvci5jb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2FsaWduQ2xhc3NlcztcblxuXHRcdGNvbnN0IHZhbGlkQ2hpbGRyZW4gPSB7ZmlndXJlOiAxLCBhOiAxLCBpbWc6IDF9O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHQvLyBXcmFwcGVyIG11c3QgYmUgZWl0aGVyIDxkaXY+IG9yIDxwPi5cblx0XHRcdGlmICghKGVsLm5hbWUgaW4ge2RpdjogMSwgcDogMX0pKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG5cblx0XHRcdC8vIENlbnRlcmluZyB3cmFwcGVyIGNhbiBoYXZlIG9ubHkgb25lIGNoaWxkLlxuXHRcdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG5cdFx0XHQvLyBPbmx5IDxmaWd1cmU+IG9yIDxpbWcgLz4gY2FuIGJlIGZpcnN0IChvbmx5KSBjaGlsZCBvZiBjZW50ZXJpbmcgd3JhcHBlcixcblx0XHRcdC8vIHJlZ2FyZGxlc3Mgb2YgaXRzIHR5cGUuXG5cdFx0XHRpZiAoIShjaGlsZC5uYW1lIGluIHZhbGlkQ2hpbGRyZW4pKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdC8vIElmIGNlbnRlcmluZyB3cmFwcGVyIGlzIDxwPiwgb25seSA8aW1nIC8+IGNhbiBiZSB0aGUgY2hpbGQuXG5cdFx0XHQvLyAgIDxwIHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48aW1nIC8+PC9wPlxuXHRcdFx0aWYgKGVsLm5hbWUgPT0gJ3AnKSB7XG5cdFx0XHRcdGlmICghaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZShjaGlsZCkpIHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIENlbnRlcmluZyA8ZGl2PiBjYW4gaG9sZCA8aW1nLz4gb3IgPGZpZ3VyZT4sIGRlcGVuZGluZyBvbiBlbnRlck1vZGUuXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gSWYgYSA8ZmlndXJlPiBpcyB0aGUgZmlyc3QgKG9ubHkpIGNoaWxkLCBpdCBtdXN0IGhhdmUgYSBjbGFzcy5cblx0XHRcdFx0Ly8gICA8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48ZmlndXJlPi4uLjwvZmlndXJlPjxkaXY+XG5cdFx0XHRcdGlmIChjaGlsZC5uYW1lID09ICdmaWd1cmUnKSB7XG5cdFx0XHRcdFx0aWYgKCFjaGlsZC5oYXNDbGFzcyhjYXB0aW9uZWRDbGFzcykpIHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBDZW50ZXJpbmcgPGRpdj4gY2FuIGhvbGQgPGltZy8+IG9yIDxhPjxpbWcvPjwvYT4gb25seSB3aGVuIGVudGVyTW9kZVxuXHRcdFx0XHRcdC8vIGlzIEVOVEVSXyhCUnxESVYpLlxuXHRcdFx0XHRcdC8vICAgPGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGltZyAvPjwvZGl2PlxuXHRcdFx0XHRcdC8vICAgPGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGE+PGltZyAvPjwvYT48L2Rpdj5cblx0XHRcdFx0XHRpZiAoZWRpdG9yLmVudGVyTW9kZSA9PSBDS0VESVRPUi5FTlRFUl9QKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0XHQvLyBSZWdhcmRsZXNzIG9mIGVudGVyTW9kZSwgYSBjaGlsZCB3aGljaCBpcyBub3QgPGZpZ3VyZT4gbXVzdCBiZVxuXHRcdFx0XHRcdC8vIGVpdGhlciA8aW1nLz4gb3IgPGE+PGltZy8+PC9hPi5cblx0XHRcdFx0XHRpZiAoIWlzTGlua2VkT3JTdGFuZGFsb25lSW1hZ2UoY2hpbGQpKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2VudGVyaW5nIHdyYXBwZXIgZ290IHRvIGJlLi4uIGNlbnRlcmluZy4gSWYgYWVfZHJhZ3Jlc2l6ZV9pZTExX2FsaWduQ2xhc3NlcyBhcmUgZGVmaW5lZCxcblx0XHRcdC8vIGNoZWNrIGZvciBjZW50ZXJpbmcgY2xhc3MuIE90aGVyd2lzZSwgY2hlY2sgdGhlIHN0eWxlLlxuXHRcdFx0aWYgKFxuXHRcdFx0XHRhbGlnbkNsYXNzZXNcblx0XHRcdFx0XHQ/IGVsLmhhc0NsYXNzKGFsaWduQ2xhc3Nlc1sxXSlcblx0XHRcdFx0XHQ6IENLRURJVE9SLnRvb2xzLnBhcnNlQ3NzVGV4dChcblx0XHRcdFx0XHRcdFx0ZWwuYXR0cmlidXRlcy5zdHlsZSB8fCAnJyxcblx0XHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCAgKVsndGV4dC1hbGlnbiddID09ICdjZW50ZXInXG5cdFx0XHQpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0fVxuXG5cdC8vIENoZWNrcyB3aGV0aGVyIGVsZW1lbnQgaXMgPGltZy8+IG9yIDxhPjxpbWcvPjwvYT4uXG5cdC8vXG5cdC8vIEBwYXJhbSB7Q0tFRElUT1IuaHRtbFBhcnNlci5lbGVtZW50fVxuXHRmdW5jdGlvbiBpc0xpbmtlZE9yU3RhbmRhbG9uZUltYWdlKGVsKSB7XG5cdFx0aWYgKGVsLm5hbWUgPT0gJ2ltZycpIHJldHVybiB0cnVlO1xuXHRcdGVsc2UgaWYgKGVsLm5hbWUgPT0gJ2EnKVxuXHRcdFx0cmV0dXJuIGVsLmNoaWxkcmVuLmxlbmd0aCA9PSAxICYmIGVsLmdldEZpcnN0KCdpbWcnKTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIFNldHMgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgd2lkZ2V0IGltYWdlIGFjY29yZGluZyB0byBjdXJyZW50IHdpZGdldCBkYXRhLlxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLnBsdWdpbnMud2lkZ2V0fSB3aWRnZXRcblx0ZnVuY3Rpb24gc2V0RGltZW5zaW9ucyh3aWRnZXQpIHtcblx0XHRjb25zdCBkYXRhID0gd2lkZ2V0LmRhdGE7XG5cblx0XHRjb25zdCBkaW1lbnNpb25zID0ge3dpZHRoOiBkYXRhLndpZHRoLCBoZWlnaHQ6IGRhdGEuaGVpZ2h0fTtcblxuXHRcdGNvbnN0IGltYWdlID0gd2lkZ2V0LnBhcnRzLmltYWdlO1xuXG5cdFx0Zm9yIChjb25zdCBkIGluIGRpbWVuc2lvbnMpIHtcblx0XHRcdGlmIChkaW1lbnNpb25zW2RdKSBpbWFnZS5zZXRBdHRyaWJ1dGUoZCwgZGltZW5zaW9uc1tkXSk7XG5cdFx0XHRlbHNlIGltYWdlLnJlbW92ZUF0dHJpYnV0ZShkKTtcblx0XHR9XG5cdH1cblxuXHQvLyBEZWZpbmVzIGFsbCBmZWF0dXJlcyByZWxhdGVkIHRvIGRyYWctZHJpdmVuIGltYWdlIHJlc2l6aW5nLlxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLnBsdWdpbnMud2lkZ2V0fSB3aWRnZXRcblx0ZnVuY3Rpb24gc2V0dXBSZXNpemVyKHdpZGdldCkge1xuXHRcdGNvbnN0IGVkaXRvciA9IHdpZGdldC5lZGl0b3I7XG5cblx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0Y29uc3QgZG9jID0gZWRpdG9yLmRvY3VtZW50O1xuXG5cdFx0Ly8gU3RvcmUgdGhlIHJlc2l6ZXIgaW4gYSB3aWRnZXQgZm9yIHRlc3RpbmcgKCMxMTAwNCkuXG5cblx0XHRjb25zdCByZXNpemVyID0gKHdpZGdldC5yZXNpemVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSk7XG5cblx0XHQvLyBDcmVhdGUgcmVzaXplciBmb3IgZWFjaCBjb3JuZXIgKE5FLCBOVywgU0UsIFNXKVxuXG5cdFx0Y29uc3QgcmVzaXplck5FID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblxuXHRcdGNvbnN0IHJlc2l6ZXJOVyA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cblx0XHRjb25zdCByZXNpemVyU0UgPSBkb2MuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXG5cdFx0Y29uc3QgcmVzaXplclNXID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblxuXHRcdHJlc2l6ZXJORS5hZGRDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXInKTtcblx0XHRyZXNpemVyTkUuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyX25lJyk7XG5cblx0XHRyZXNpemVyTlcuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyJyk7XG5cdFx0cmVzaXplck5XLmFkZENsYXNzKCdja2VfaW1hZ2VfcmVzaXplcl9udycpO1xuXG5cdFx0cmVzaXplclNFLmFkZENsYXNzKCdja2VfaW1hZ2VfcmVzaXplcicpO1xuXHRcdHJlc2l6ZXJTRS5hZGRDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXJfc2UnKTtcblxuXHRcdHJlc2l6ZXJTVy5hZGRDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXInKTtcblx0XHRyZXNpemVyU1cuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyX3N3Jyk7XG5cblx0XHQvLyBBZGQgZWFjaCBkaXJlY3Rpb25hbCByZXNpemVyIGFzIGEgY2hpbGQgb2YgcmVzaXplclxuXHRcdHJlc2l6ZXIuYXBwZW5kKHJlc2l6ZXJORSk7XG5cdFx0cmVzaXplci5hcHBlbmQocmVzaXplck5XKTtcblx0XHRyZXNpemVyLmFwcGVuZChyZXNpemVyU0UpO1xuXHRcdHJlc2l6ZXIuYXBwZW5kKHJlc2l6ZXJTVyk7XG5cblx0XHQvLyByZXNpemVyLnNldEF0dHJpYnV0ZSggJ3RpdGxlJywgZWRpdG9yLmxhbmcuYWVfZHJhZ3Jlc2l6ZV9pZTExLnJlc2l6ZXIgKTtcblx0XHRyZXNpemVyLmFwcGVuZChuZXcgQ0tFRElUT1IuZG9tLnRleHQoJ1xcdTIwMGInLCBkb2MpKTtcblxuXHRcdC8vIElubGluZSB3aWRnZXRzIGRvbid0IG5lZWQgYSByZXNpemVyIHdyYXBwZXIgYXMgYW4gaW1hZ2Ugc3BhbnMgdGhlIGVudGlyZSB3aWRnZXQuXG5cdFx0aWYgKCF3aWRnZXQuaW5saW5lKSB7XG5cdFx0XHRjb25zdCBpbWFnZU9yTGluayA9IHdpZGdldC5wYXJ0cy5saW5rIHx8IHdpZGdldC5wYXJ0cy5pbWFnZTtcblxuXHRcdFx0Y29uc3Qgb2xkUmVzaXplV3JhcHBlciA9IGltYWdlT3JMaW5rLmdldFBhcmVudCgpO1xuXG5cdFx0XHRjb25zdCByZXNpemVXcmFwcGVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblxuXHRcdFx0cmVzaXplV3JhcHBlci5hZGRDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXJfd3JhcHBlcicpO1xuXHRcdFx0cmVzaXplV3JhcHBlci5hcHBlbmQoaW1hZ2VPckxpbmspO1xuXHRcdFx0cmVzaXplV3JhcHBlci5hcHBlbmQocmVzaXplcik7XG5cdFx0XHR3aWRnZXQuZWxlbWVudC5hcHBlbmQocmVzaXplV3JhcHBlciwgdHJ1ZSk7XG5cblx0XHRcdC8vIFJlbW92ZSB0aGUgb2xkIHdyYXBwZXIgd2hpY2ggY291bGQgY2FtZSBmcm9tIGUuZy4gcGFzdGVkIEhUTUxcblx0XHRcdC8vIGFuZCB3aGljaCBjb3VsZCBiZSBjb3JydXB0ZWQgKGUuZy4gcmVzaXplciBzcGFuIGhhcyBiZWVuIGxvc3QpLlxuXHRcdFx0aWYgKG9sZFJlc2l6ZVdyYXBwZXIuaXMoJ3NwYW4nKSkgb2xkUmVzaXplV3JhcHBlci5yZW1vdmUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2lkZ2V0LndyYXBwZXIuYXBwZW5kKHJlc2l6ZXIpO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSB2YWx1ZXMgb2Ygc2l6ZSB2YXJpYWJsZXMgYW5kIG1vdXNlIG9mZnNldHMuXG5cdFx0cmVzaXplci5vbignbW91c2Vkb3duJywgZXZ0ID0+IHtcblx0XHRcdGNvbnN0IGltYWdlID0gd2lkZ2V0LnBhcnRzLmltYWdlO1xuXG5cdFx0XHQvLyBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBtb3VzZSByZWxhdGl2ZSB0byB0aGUgc2NyZWVuXG5cdFx0XHQvLyB3aGVuIGJ1dHRvbiBnZXRzIHByZXNzZWQuXG5cblx0XHRcdGNvbnN0IHN0YXJ0WCA9IGV2dC5kYXRhLiQuc2NyZWVuWDtcblxuXHRcdFx0Y29uc3Qgc3RhcnRZID0gZXZ0LmRhdGEuJC5zY3JlZW5ZO1xuXG5cdFx0XHQvLyBUaGUgaW5pdGlhbCBkaW1lbnNpb25zIGFuZCBhc3BlY3QgcmF0aW8gb2YgdGhlIGltYWdlLlxuXG5cdFx0XHRjb25zdCBzdGFydFdpZHRoID0gaW1hZ2UuJC5jbGllbnRXaWR0aDtcblxuXHRcdFx0Y29uc3Qgc3RhcnRIZWlnaHQgPSBpbWFnZS4kLmNsaWVudEhlaWdodDtcblxuXHRcdFx0Y29uc3QgcmF0aW8gPSBzdGFydFdpZHRoIC8gc3RhcnRIZWlnaHQ7XG5cblx0XHRcdGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuXG5cdFx0XHRjb25zdCB0YXJnZXQgPSBldnQuZGF0YS5nZXRUYXJnZXQoKTtcblxuXHRcdFx0bGV0IGZhY3Rvclg7XG5cblx0XHRcdGxldCBmYWN0b3JZO1xuXG5cdFx0XHRsZXQgbW92ZURpZmZYO1xuXG5cdFx0XHRsZXQgbW92ZURpZmZZO1xuXG5cdFx0XHRsZXQgbmF0aXZlRXZ0O1xuXG5cdFx0XHRsZXQgbmV3SGVpZ2h0O1xuXG5cdFx0XHRsZXQgbmV3V2lkdGg7XG5cblx0XHRcdGxldCB1cGRhdGVEYXRhO1xuXG5cdFx0XHQvLyBcImZhY3RvclhcIiBhbmQgXCJmYWN0b3JZXCIgY2FuIGJlIGVpdGhlciAxIG9yIC0xLiBJLmUuOiBXZSBuZWVkIHRvXG5cdFx0XHQvLyBhZGQvc3VidHJhY3QgdGhlIGRpZmZlcmVuY2UgdG8gZ2V0IHByb3BlciB3aWR0aCwgZXRjLiBXaXRob3V0IFwiZmFjdG9yWFwiXG5cdFx0XHQvLyBhbmQgXCJmYWN0b3JZXCIsIHJlc2l6ZXIgc3RhcnRzIHdvcmtpbmcgdGhlIG9wcG9zaXRlIHdheS5cblx0XHRcdGlmICh0YXJnZXQuaGFzQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyX25lJykpIHtcblx0XHRcdFx0ZmFjdG9yWCA9IDE7XG5cdFx0XHRcdGZhY3RvclkgPSAxO1xuXHRcdFx0fSBlbHNlIGlmICh0YXJnZXQuaGFzQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyX253JykpIHtcblx0XHRcdFx0ZmFjdG9yWCA9IC0xO1xuXHRcdFx0XHRmYWN0b3JZID0gMTtcblx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0Lmhhc0NsYXNzKCdja2VfaW1hZ2VfcmVzaXplcl9zZScpKSB7XG5cdFx0XHRcdGZhY3RvclggPSAxO1xuXHRcdFx0XHRmYWN0b3JZID0gLTE7XG5cdFx0XHR9IGVsc2UgaWYgKHRhcmdldC5oYXNDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXJfc3cnKSkge1xuXHRcdFx0XHRmYWN0b3JYID0gLTE7XG5cdFx0XHRcdGZhY3RvclkgPSAtMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQSBjbGFzcyBhcHBsaWVkIHRvIGVkaXRhYmxlIGR1cmluZyByZXNpemluZy5cblx0XHRcdGNvbnN0IGN1cnNvckNsYXNzID1cblx0XHRcdFx0J2NrZV9pbWFnZV8nICtcblx0XHRcdFx0KCF+ZmFjdG9yWSA/ICdzJyA6ICduJykgK1xuXHRcdFx0XHQoIX5mYWN0b3JYID8gJ3cnIDogJ2UnKTtcblxuXHRcdFx0Ly8gU2F2ZSB0aGUgdW5kbyBzbmFwc2hvdCBmaXJzdDogYmVmb3JlIHJlc2l6aW5nLlxuXHRcdFx0ZWRpdG9yLmZpcmUoJ3NhdmVTbmFwc2hvdCcpO1xuXG5cdFx0XHQvLyBNb3VzZW1vdmUgbGlzdGVuZXJzIGFyZSByZW1vdmVkIG9uIG1vdXNldXAuXG5cdFx0XHRhdHRhY2hUb0RvY3VtZW50cygnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGxpc3RlbmVycyk7XG5cblx0XHRcdC8vIENsZWFuIHVwIHRoZSBtb3VzZW1vdmUgbGlzdGVuZXIuIFVwZGF0ZSB3aWRnZXQgZGF0YSBpZiB2YWxpZC5cblx0XHRcdGF0dGFjaFRvRG9jdW1lbnRzKCdtb3VzZXVwJywgb25Nb3VzZVVwLCBsaXN0ZW5lcnMpO1xuXG5cdFx0XHQvLyBUaGUgZW50aXJlIGVkaXRhYmxlIHdpbGwgaGF2ZSB0aGUgc3BlY2lhbCBjdXJzb3Igd2hpbGUgcmVzaXppbmcgZ29lcyBvbi5cblx0XHRcdGVkaXRhYmxlLmFkZENsYXNzKGN1cnNvckNsYXNzKTtcblxuXHRcdFx0Ly8gVGhpcyBpcyB0byBhbHdheXMga2VlcCB0aGUgcmVzaXplciBlbGVtZW50IHZpc2libGUgd2hpbGUgcmVzaXppbmcuXG5cdFx0XHRyZXNpemVyLmFkZENsYXNzKCdja2VfaW1hZ2VfcmVzaXppbmcnKTtcblxuXHRcdFx0Ly8gQXR0YWNoZXMgYW4gZXZlbnQgdG8gYSBnbG9iYWwgZG9jdW1lbnQgaWYgaW5saW5lIGVkaXRvci5cblx0XHRcdC8vIEFkZGl0aW9uYWxseSwgaWYgY2xhc3NpYyAoYGlmcmFtZWAtYmFzZWQpIGVkaXRvciwgYWxzbyBhdHRhY2hlcyB0aGUgc2FtZSBldmVudCB0byBgaWZyYW1lYCdzIGRvY3VtZW50LlxuXHRcdFx0ZnVuY3Rpb24gYXR0YWNoVG9Eb2N1bWVudHMobmFtZSwgY2FsbGJhY2ssIGNvbGxlY3Rpb24pIHtcblx0XHRcdFx0Y29uc3QgZ2xvYmFsRG9jID0gQ0tFRElUT1IuZG9jdW1lbnQ7XG5cblx0XHRcdFx0Y29uc3QgbGlzdGVuZXJzID0gW107XG5cblx0XHRcdFx0aWYgKCFkb2MuZXF1YWxzKGdsb2JhbERvYykpXG5cdFx0XHRcdFx0bGlzdGVuZXJzLnB1c2goZ2xvYmFsRG9jLm9uKG5hbWUsIGNhbGxiYWNrKSk7XG5cblx0XHRcdFx0bGlzdGVuZXJzLnB1c2goZG9jLm9uKG5hbWUsIGNhbGxiYWNrKSk7XG5cblx0XHRcdFx0aWYgKGNvbGxlY3Rpb24pIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gbGlzdGVuZXJzLmxlbmd0aDsgaS0tOyApXG5cdFx0XHRcdFx0XHRjb2xsZWN0aW9uLnB1c2gobGlzdGVuZXJzLnBvcCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxjdWxhdGUgd2lkdGggZmlyc3QsIGFuZCB0aGVuIGFkanVzdCBoZWlnaHQsIHByZXNlcnZpbmcgcmF0aW8uXG5cdFx0XHRmdW5jdGlvbiBhZGp1c3RUb1goKSB7XG5cdFx0XHRcdG5ld1dpZHRoID0gc3RhcnRXaWR0aCArIGZhY3RvclggKiBtb3ZlRGlmZlg7XG5cdFx0XHRcdG5ld0hlaWdodCA9IE1hdGgucm91bmQobmV3V2lkdGggLyByYXRpbyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBoZWlnaHQgZmlyc3QsIGFuZCB0aGVuIGFkanVzdCB3aWR0aCwgcHJlc2VydmluZyByYXRpby5cblx0XHRcdGZ1bmN0aW9uIGFkanVzdFRvWSgpIHtcblx0XHRcdFx0bmV3SGVpZ2h0ID0gc3RhcnRIZWlnaHQgKyBmYWN0b3JZICogbW92ZURpZmZZO1xuXHRcdFx0XHRuZXdXaWR0aCA9IE1hdGgucm91bmQobmV3SGVpZ2h0ICogcmF0aW8pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGlzIGlzIGhvdyB2YXJpYWJsZXMgcmVmZXIgdG8gdGhlIGdlb21ldHJ5LlxuXHRcdFx0Ly8gTm90ZTogeCBjb3JyZXNwb25kcyB0byBtb3ZlT2Zmc2V0LCB0aGlzIGlzIHRoZSBwb3NpdGlvbiBvZiBtb3VzZVxuXHRcdFx0Ly8gTm90ZTogbyBjb3JyZXNwb25kcyB0byBbc3RhcnRYLCBzdGFydFldLlxuXHRcdFx0Ly9cblx0XHRcdC8vIFx0Ky0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tK1xuXHRcdFx0Ly8gXHR8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG5cdFx0XHQvLyBcdHwgICAgICBJICAgICAgIHwgICAgICBJSSAgICAgIHxcblx0XHRcdC8vIFx0fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuXHRcdFx0Ly8gXHQrLS0tLS0tLS0tLS0tLSBvIC0tLS0tLS0tLS0tLS0rIF8gXyBfXG5cdFx0XHQvLyBcdHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICBeXG5cdFx0XHQvLyBcdHwgICAgICBWSSAgICAgIHwgICAgIElJSSAgICAgIHwgICAgICB8IG1vdmVEaWZmWVxuXHRcdFx0Ly8gXHR8ICAgICAgICAgICAgICB8ICAgICAgICAgeCBfIF8gXyBfIF8gdlxuXHRcdFx0Ly8gXHQrLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tfC0tLS0rXG5cdFx0XHQvLyBcdCAgICAgICAgICAgICAgIHwgICAgICAgICB8XG5cdFx0XHQvLyBcdCAgICAgICAgICAgICAgICA8LS0tLS0tLT5cblx0XHRcdC8vIFx0ICAgICAgICAgICAgICAgIG1vdmVEaWZmWFxuXHRcdFx0ZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZ0KSB7XG5cdFx0XHRcdG5hdGl2ZUV2dCA9IGV2dC5kYXRhLiQ7XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyBob3cgZmFyIHRoZSBtb3VzZSBpcyBmcm9tIHRoZSBwb2ludCB0aGUgYnV0dG9uIHdhcyBwcmVzc2VkLlxuXHRcdFx0XHRtb3ZlRGlmZlggPSBuYXRpdmVFdnQuc2NyZWVuWCAtIHN0YXJ0WDtcblx0XHRcdFx0bW92ZURpZmZZID0gc3RhcnRZIC0gbmF0aXZlRXZ0LnNjcmVlblk7XG5cblx0XHRcdFx0Ly8gUmVzaXplIHdpdGggTkUsIFNFIGRyYWcgaGFuZGxlc1xuXHRcdFx0XHRpZiAoZmFjdG9yWCA9PSAxKSB7XG5cdFx0XHRcdFx0aWYgKG1vdmVEaWZmWCA8PSAwKSB7XG5cdFx0XHRcdFx0XHRhZGp1c3RUb1koKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YWRqdXN0VG9YKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFJlc2l6ZSB3aXRoIE5XLCBTVyBkcmFnIGhhbmRsZXNcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKG1vdmVEaWZmWCA8PSAwKSB7XG5cdFx0XHRcdFx0XHRhZGp1c3RUb1goKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YWRqdXN0VG9ZKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRG9uJ3QgdXBkYXRlIGF0dHJpYnV0ZXMgaWYgbGVzcyB0aGFuIDEwLlxuXHRcdFx0XHQvLyBUaGlzIGlzIHRvIHByZXZlbnQgaW1hZ2VzIHRvIHZpc3VhbGx5IGRpc2FwcGVhci5cblx0XHRcdFx0aWYgKG5ld1dpZHRoID49IDE1ICYmIG5ld0hlaWdodCA+PSAxNSkge1xuXHRcdFx0XHRcdGltYWdlLiQuc3R5bGUud2lkdGggPSBuZXdXaWR0aCArICdweCc7XG5cdFx0XHRcdFx0aW1hZ2UuJC5zdHlsZS5oZWlnaHQgPSBuZXdIZWlnaHQgKyAncHgnO1xuXG5cdFx0XHRcdFx0dXBkYXRlRGF0YSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dXBkYXRlRGF0YSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcblx0XHRcdFx0bGV0IGw7XG5cblx0XHRcdFx0d2hpbGUgKChsID0gbGlzdGVuZXJzLnBvcCgpKSkgbC5yZW1vdmVMaXN0ZW5lcigpO1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgZGVmYXVsdCBjdXJzb3IgYnkgcmVtb3Zpbmcgc3BlY2lhbCBjbGFzcy5cblx0XHRcdFx0ZWRpdGFibGUucmVtb3ZlQ2xhc3MoY3Vyc29yQ2xhc3MpO1xuXG5cdFx0XHRcdC8vIFRoaXMgaXMgdG8gYnJpbmcgYmFjayB0aGUgcmVndWxhciBiZWhhdmlvdXIgb2YgdGhlIHJlc2l6ZXIuXG5cdFx0XHRcdHJlc2l6ZXIucmVtb3ZlQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemluZycpO1xuXG5cdFx0XHRcdGlmICh1cGRhdGVEYXRhKSB7XG5cdFx0XHRcdFx0d2lkZ2V0LnNldERhdGEoe1xuXHRcdFx0XHRcdFx0aGVpZ2h0OiBuZXdIZWlnaHQsXG5cdFx0XHRcdFx0XHR3aWR0aDogbmV3V2lkdGgsXG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvLyBTYXZlIGFub3RoZXIgdW5kbyBzbmFwc2hvdDogYWZ0ZXIgcmVzaXppbmcuXG5cdFx0XHRcdFx0ZWRpdG9yLmZpcmUoJ3NhdmVTbmFwc2hvdCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRG9uJ3QgdXBkYXRlIGRhdGEgdHdpY2Ugb3IgbW9yZS5cblx0XHRcdFx0dXBkYXRlRGF0YSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGFsaWdubWVudCB2YWx1ZSBvZiBhbiBpbWFnZVxuXHQgKlxuXHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBpbWFnZSBUaGUgaW1hZ2UgZWxlbWVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW1hZ2VBbGlnbm1lbnQgVGhlIGltYWdlIGFsaWdubWVudCB2YWx1ZSB0byBiZSByZW1vdmVkXG5cdCAqL1xuXHRjb25zdCByZW1vdmVXaWRnZXRBbGlnbm1lbnQgPSBmdW5jdGlvbih3aWRnZXQsIGltYWdlQWxpZ25tZW50KSB7XG5cdFx0aWYgKGltYWdlQWxpZ25tZW50ID09PSAnbGVmdCcgfHwgaW1hZ2VBbGlnbm1lbnQgPT09ICdyaWdodCcpIHtcblx0XHRcdHdpZGdldC53cmFwcGVyLnJlbW92ZVN0eWxlKCdmbG9hdCcpO1xuXHRcdH0gZWxzZSBpZiAoaW1hZ2VBbGlnbm1lbnQgPT09ICdjZW50ZXInKSB7XG5cdFx0XHR3aWRnZXQuZWRpdG9yLmV4ZWNDb21tYW5kKCdqdXN0aWZ5bGVmdCcpO1xuXHRcdFx0d2lkZ2V0LmVkaXRvci5leGVjQ29tbWFuZCgnanVzdGlmeWxlZnQnKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gSW50ZWdyYXRlcyB3aWRnZXQgYWxpZ25tZW50IHNldHRpbmcgd2l0aCBqdXN0aWZ5XG5cdC8vIHBsdWdpbidzIGNvbW1hbmRzIChleGVjdXRpb24gYW5kIHJlZnJlc2htZW50KS5cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9IGVkaXRvclxuXHQvLyBAcGFyYW0ge1N0cmluZ30gdmFsdWUgJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJyBvciAnYmxvY2snXG5cdGZ1bmN0aW9uIGFsaWduQ29tbWFuZEludGVncmF0b3IoZWRpdG9yKSB7XG5cdFx0Y29uc3QgZXhlY0NhbGxiYWNrcyA9IFtdO1xuXG5cdFx0bGV0IGVuYWJsZWQ7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGNvbnN0IGNvbW1hbmQgPSBlZGl0b3IuZ2V0Q29tbWFuZCgnanVzdGlmeScgKyB2YWx1ZSk7XG5cblx0XHRcdC8vIE1vc3QgbGlrZWx5LCB0aGUganVzdGlmeSBwbHVnaW4gaXNuJ3QgbG9hZGVkLlxuXHRcdFx0aWYgKCFjb21tYW5kKSByZXR1cm47XG5cblx0XHRcdC8vIFRoaXMgY29tbWFuZCB3aWxsIGJlIG1hbnVhbGx5IHJlZnJlc2hlZCBhbG9uZyB3aXRoXG5cdFx0XHQvLyBvdGhlciBjb21tYW5kcyBhZnRlciBleGVjLlxuXHRcdFx0ZXhlY0NhbGxiYWNrcy5wdXNoKCgpID0+IHtcblx0XHRcdFx0Y29tbWFuZC5yZWZyZXNoKGVkaXRvciwgZWRpdG9yLmVsZW1lbnRQYXRoKCkpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmICh2YWx1ZSBpbiB7cmlnaHQ6IDEsIGxlZnQ6IDEsIGNlbnRlcjogMX0pIHtcblx0XHRcdFx0Y29tbWFuZC5vbignZXhlYycsIGV2dCA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qgd2lkZ2V0ID0gZ2V0Rm9jdXNlZFdpZGdldChlZGl0b3IpO1xuXG5cdFx0XHRcdFx0aWYgKHdpZGdldCkge1xuXHRcdFx0XHRcdFx0aWYgKHdpZGdldC5kYXRhLmFsaWduID09PSB2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVXaWRnZXRBbGlnbm1lbnQod2lkZ2V0LCB2YWx1ZSk7XG5cblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHdpZGdldC5kYXRhLmFsaWduO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0d2lkZ2V0LnNldERhdGEoJ2FsaWduJywgdmFsdWUpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBPbmNlIHRoZSB3aWRnZXQgY2hhbmdlZCBpdHMgYWxpZ24sIGFsbCB0aGUgYWxpZ24gY29tbWFuZHNcblx0XHRcdFx0XHRcdC8vIG11c3QgYmUgcmVmcmVzaGVkOiB0aGUgZXZlbnQgaXMgdG8gYmUgY2FuY2VsbGVkLlxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGV4ZWNDYWxsYmFja3MubGVuZ3RoOyBpLS07IClcblx0XHRcdFx0XHRcdFx0ZXhlY0NhbGxiYWNrc1tpXSgpO1xuXG5cdFx0XHRcdFx0XHRldnQuY2FuY2VsKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Y29tbWFuZC5vbigncmVmcmVzaCcsIGZ1bmN0aW9uKGV2dCkge1xuXHRcdFx0XHRjb25zdCB3aWRnZXQgPSBnZXRGb2N1c2VkV2lkZ2V0KGVkaXRvcik7XG5cblx0XHRcdFx0Y29uc3QgYWxsb3dlZCA9IHtyaWdodDogMSwgbGVmdDogMSwgY2VudGVyOiAxfTtcblxuXHRcdFx0XHRpZiAoIXdpZGdldCkgcmV0dXJuO1xuXG5cdFx0XHRcdC8vIENhY2hlIFwiZW5hYmxlZFwiIG9uIGZpcnN0IHVzZS4gVGhpcyBpcyBiZWNhdXNlIGZpbHRlciNjaGVja0ZlYXR1cmUgbWF5XG5cdFx0XHRcdC8vIG5vdCBiZSBhdmFpbGFibGUgZHVyaW5nIHBsdWdpbidzIGFmdGVySW5pdCBpbiB0aGUgZnV0dXJlIOKAlCBhIG1vbWVudCB3aGVuXG5cdFx0XHRcdC8vIGFsaWduQ29tbWFuZEludGVncmF0b3IgaXMgY2FsbGVkLlxuXHRcdFx0XHRpZiAoZW5hYmxlZCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGVuYWJsZWQgPSBlZGl0b3IuZmlsdGVyLmNoZWNrRmVhdHVyZShcblx0XHRcdFx0XHRcdGVkaXRvci53aWRnZXRzLnJlZ2lzdGVyZWQuaW1hZ2UuZmVhdHVyZXMuYWxpZ25cblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIERvbid0IGFsbG93IGp1c3RpZnkgY29tbWFuZHMgd2hlbiB3aWRnZXQgYWxpZ25tZW50IGlzIGRpc2FibGVkICgjMTEwMDQpLlxuXHRcdFx0XHRpZiAoIWVuYWJsZWQpIHRoaXMuc2V0U3RhdGUoQ0tFRElUT1IuVFJJU1RBVEVfRElTQUJMRUQpO1xuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnNldFN0YXRlKFxuXHRcdFx0XHRcdFx0d2lkZ2V0LmRhdGEuYWxpZ24gPT0gdmFsdWVcblx0XHRcdFx0XHRcdFx0PyBDS0VESVRPUi5UUklTVEFURV9PTlxuXHRcdFx0XHRcdFx0XHQ6IHZhbHVlIGluIGFsbG93ZWRcblx0XHRcdFx0XHRcdFx0PyBDS0VESVRPUi5UUklTVEFURV9PRkZcblx0XHRcdFx0XHRcdFx0OiBDS0VESVRPUi5UUklTVEFURV9ESVNBQkxFRFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRldnQuY2FuY2VsKCk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gUmV0dXJucyB0aGUgZm9jdXNlZCB3aWRnZXQsIGlmIG9mIHRoZSB0eXBlIHNwZWNpZmljIGZvciB0aGlzIHBsdWdpbi5cblx0Ly8gSWYgbm8gd2lkZ2V0IGlzIGZvY3VzZWQsIGBudWxsYCBpcyByZXR1cm5lZC5cblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9XG5cdC8vIEByZXR1cm5zIHtDS0VESVRPUi5wbHVnaW5zLndpZGdldH1cblx0ZnVuY3Rpb24gZ2V0Rm9jdXNlZFdpZGdldChlZGl0b3IpIHtcblx0XHRjb25zdCB3aWRnZXQgPSBlZGl0b3Iud2lkZ2V0cy5mb2N1c2VkO1xuXG5cdFx0aWYgKHdpZGdldCAmJiB3aWRnZXQubmFtZSA9PSAnaW1hZ2UnKSByZXR1cm4gd2lkZ2V0O1xuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBSZXR1cm5zIGEgc2V0IG9mIHdpZGdldCBhbGxvd2VkQ29udGVudCBydWxlcywgZGVwZW5kaW5nXG5cdC8vIG9uIGNvbmZpZ3VyYXRpb25zIGxpa2UgY29uZmlnI2FlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXMgb3Jcblx0Ly8gY29uZmlnI2FlX2RyYWdyZXNpemVfaWUxMV9jYXB0aW9uZWRDbGFzcy5cblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9XG5cdC8vIEByZXR1cm5zIHtPYmplY3R9XG5cdGZ1bmN0aW9uIGdldFdpZGdldEFsbG93ZWRDb250ZW50KGVkaXRvcikge1xuXHRcdGNvbnN0IGFsaWduQ2xhc3NlcyA9IGVkaXRvci5jb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2FsaWduQ2xhc3NlcztcblxuXHRcdGNvbnN0IHJ1bGVzID0ge1xuXHRcdFx0Ly8gV2lkZ2V0IG1heSBuZWVkIDxkaXY+IG9yIDxwPiBjZW50ZXJpbmcgd3JhcHBlci5cblx0XHRcdGRpdjoge1xuXHRcdFx0XHRtYXRjaDogY2VudGVyV3JhcHBlckNoZWNrZXIoZWRpdG9yKSxcblx0XHRcdH0sXG5cdFx0XHRwOiB7XG5cdFx0XHRcdG1hdGNoOiBjZW50ZXJXcmFwcGVyQ2hlY2tlcihlZGl0b3IpLFxuXHRcdFx0fSxcblx0XHRcdGltZzoge1xuXHRcdFx0XHRhdHRyaWJ1dGVzOiAnIXNyYyxhbHQsd2lkdGgsaGVpZ2h0Jyxcblx0XHRcdH0sXG5cdFx0XHRmaWd1cmU6IHtcblx0XHRcdFx0Y2xhc3NlczogJyEnICsgZWRpdG9yLmNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfY2FwdGlvbmVkQ2xhc3MsXG5cdFx0XHR9LFxuXHRcdFx0ZmlnY2FwdGlvbjogdHJ1ZSxcblx0XHR9O1xuXG5cdFx0aWYgKGFsaWduQ2xhc3Nlcykge1xuXHRcdFx0Ly8gQ2VudGVyaW5nIGNsYXNzIGZyb20gdGhlIGNvbmZpZy5cblx0XHRcdHJ1bGVzLmRpdi5jbGFzc2VzID0gYWxpZ25DbGFzc2VzWzFdO1xuXHRcdFx0cnVsZXMucC5jbGFzc2VzID0gcnVsZXMuZGl2LmNsYXNzZXM7XG5cblx0XHRcdC8vIExlZnQvcmlnaHQgY2xhc3NlcyBmcm9tIHRoZSBjb25maWcuXG5cdFx0XHRydWxlcy5pbWcuY2xhc3NlcyA9IGFsaWduQ2xhc3Nlc1swXSArICcsJyArIGFsaWduQ2xhc3Nlc1syXTtcblx0XHRcdHJ1bGVzLmZpZ3VyZS5jbGFzc2VzICs9ICcsJyArIHJ1bGVzLmltZy5jbGFzc2VzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBDZW50ZXJpbmcgd2l0aCB0ZXh0LWFsaWduLlxuXHRcdFx0cnVsZXMuZGl2LnN0eWxlcyA9ICd0ZXh0LWFsaWduJztcblx0XHRcdHJ1bGVzLnAuc3R5bGVzID0gJ3RleHQtYWxpZ24nO1xuXG5cdFx0XHRydWxlcy5pbWcuc3R5bGVzID0gJ2Zsb2F0Jztcblx0XHRcdHJ1bGVzLmZpZ3VyZS5zdHlsZXMgPSAnZmxvYXQsZGlzcGxheSc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJ1bGVzO1xuXHR9XG5cblx0Ly8gUmV0dXJucyBhIHNldCBvZiB3aWRnZXQgZmVhdHVyZSBydWxlcywgZGVwZW5kaW5nXG5cdC8vIG9uIGVkaXRvciBjb25maWd1cmF0aW9uLiBOb3RlIHRoYXQgdGhlIGZvbGxvd2luZyBtYXkgbm90IGNvdmVyXG5cdC8vIGFsbCB0aGUgcG9zc2libGUgY2FzZXMgc2luY2UgcmVxdWlyZWRDb250ZW50IHN1cHBvcnRzIGEgc2luZ2xlXG5cdC8vIHRhZyBvbmx5LlxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn1cblx0Ly8gQHJldHVybnMge09iamVjdH1cblx0ZnVuY3Rpb24gZ2V0V2lkZ2V0RmVhdHVyZXMoZWRpdG9yKSB7XG5cdFx0Y29uc3QgYWxpZ25DbGFzc2VzID0gZWRpdG9yLmNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfYWxpZ25DbGFzc2VzO1xuXG5cdFx0Y29uc3QgZmVhdHVyZXMgPSB7XG5cdFx0XHRkaW1lbnNpb246IHtcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAnaW1nW3dpZHRoLGhlaWdodF0nLFxuXHRcdFx0fSxcblx0XHRcdGFsaWduOiB7XG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDpcblx0XHRcdFx0XHQnaW1nJyArXG5cdFx0XHRcdFx0KGFsaWduQ2xhc3NlcyA/ICcoJyArIGFsaWduQ2xhc3Nlc1swXSArICcpJyA6ICd7ZmxvYXR9JyksXG5cdFx0XHR9LFxuXHRcdFx0Y2FwdGlvbjoge1xuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICdmaWdjYXB0aW9uJyxcblx0XHRcdH0sXG5cdFx0fTtcblxuXHRcdHJldHVybiBmZWF0dXJlcztcblx0fVxuXG5cdC8vIFJldHVybnMgZWxlbWVudCB3aGljaCBpcyBzdHlsZWQsIGNvbnNpZGVyaW5nIGN1cnJlbnRcblx0Ly8gc3RhdGUgb2YgdGhlIHdpZGdldC5cblx0Ly9cblx0Ly8gQHNlZSBDS0VESVRPUi5wbHVnaW5zLndpZGdldCNhcHBseVN0eWxlXG5cdC8vIEBwYXJhbSB7Q0tFRElUT1IucGx1Z2lucy53aWRnZXR9IHdpZGdldFxuXHQvLyBAcmV0dXJucyB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9XG5cdGZ1bmN0aW9uIGdldFN0eWxlYWJsZUVsZW1lbnQod2lkZ2V0KSB7XG5cdFx0cmV0dXJuIHdpZGdldC5kYXRhLmhhc0NhcHRpb24gPyB3aWRnZXQuZWxlbWVudCA6IHdpZGdldC5wYXJ0cy5pbWFnZTtcblx0fVxufSkoKTtcblxuLyoqXG4gKiBBIENTUyBjbGFzcyBhcHBsaWVkIHRvIHRoZSBgPGZpZ3VyZT5gIGVsZW1lbnQgb2YgYSBjYXB0aW9uZWQgaW1hZ2UuXG4gKlxuICogUmVhZCBtb3JlIGluIHRoZSBbZG9jdW1lbnRhdGlvbl0oIyEvZ3VpZGUvZGV2X2NhcHRpb25lZGltYWdlKSBhbmQgc2VlIHRoZVxuICogW1NESyBzYW1wbGVdKGh0dHA6Ly9zZGsuY2tlZGl0b3IuY29tL3NhbXBsZXMvY2FwdGlvbmVkaW1hZ2UuaHRtbCkuXG4gKlxuICpcdFx0Ly8gQ2hhbmdlcyB0aGUgY2xhc3MgdG8gXCJjYXB0aW9uZWRJbWFnZVwiLlxuICpcdFx0Y29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9jYXB0aW9uZWRDbGFzcyA9ICdjYXB0aW9uZWRJbWFnZSc7XG4gKlxuICogQGNmZyB7U3RyaW5nfSBbYWVfZHJhZ3Jlc2l6ZV9pZTExX2NhcHRpb25lZENsYXNzPSdpbWFnZSddXG4gKiBAbWVtYmVyIENLRURJVE9SLmNvbmZpZ1xuICovXG5DS0VESVRPUi5jb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2NhcHRpb25lZENsYXNzID0gJ2ltYWdlJztcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IHtISUdIX1BSSU9SSVRZfSBmcm9tICcuL3ByaW9yaXRpZXMnO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2VtYmVkJykpIHtcblx0Y29uc3QgUkVHRVhfSFRUUCA9IC9eaHR0cHM/LztcblxuXHRjb25zdCBSRUdFWF9ERUZBVUxUX0xJTksgPSAvPGEgaHJlZj0vO1xuXG5cdENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfVVJMX1RQTCA9XG5cdFx0J2h0dHA6Ly9hbGxveS5pZnJhbWUubHkvYXBpL29lbWJlZD91cmw9e3VybH0mY2FsbGJhY2s9e2NhbGxiYWNrfSc7XG5cdENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfV0lER0VUX1RQTCA9XG5cdFx0JzxkaXYgZGF0YS1hZS1lbWJlZC11cmw9XCJ7dXJsfVwiPjwvZGl2Pic7XG5cdENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfREVGQVVMVF9MSU5LX1RQTCA9ICc8YSBocmVmPVwie3VybH1cIj57dXJsfTwvYT4nO1xuXHQvKipcblx0ICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIGFkZHMgdGhlIGluZnJhc3RydWN0dXJlIHRvIGVtYmVkIHVybHMgYXMgbWVkaWEgb2JqZWN0cyB1c2luZyBhbiBvZW1iZWRcblx0ICogc2VydmljZS4gQnkgZGVmYXVsdCwgYW5kIGZvciBkZW1vaW5nIHB1cnBvc2VzIG9ubHksIHRoZSBvZW1iZWQgc2VydmljZSBpcyBob3N0ZWQgaW4gaWZyYW1lLmx5XG5cdCAqIGF0IC8vYWxsb3kuaWZyYW1lLmx5L2FwaS9vZW1iZWQ/dXJsPXt1cmx9JmNhbGxiYWNrPXtjYWxsYmFja30uIE5vdGUgdGhpcyBzaG91bGQgYmUgY2hhbmdlZCB0b1xuXHQgKiBhIHNlbGYtaG9zdGVkIG9yIHBhaWQgc2VydmljZSBpbiBwcm9kdWN0aW9uIGVudmlyb25tZW50cy4gQWNjZXNzIHRvIHRoZSBhbGxveS5pZnJhbWUubHkgZW5kcG9pbnRcblx0ICogbWF5IGJlIHJlc3RyaWN0ZWQgcGVyIGRvbWFpbiBkdWUgdG8gc2lnbmlmaWNhbnQgdHJhZmZpYy5cblx0ICpcblx0ICogVGhpcyBwbHVnaW4gYWRkcyBhbiBgZW1iZWRVcmxgIGNvbW1hbmQgdGhhdCBjYW4gYmUgdXNlZCB0byBlYXNpbHkgZW1iZWQgYSBVUkwgYW5kIHRyYW5zZm9ybSBpdFxuXHQgKiB0byBhbiBlbWJlZGRlZCBjb250ZW50LlxuXHQgKlxuXHQgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9lbWJlZFxuXHQgKi9cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX2VtYmVkJywge1xuXHRcdHJlcXVpcmVzOiAnd2lkZ2V0Jyxcblx0XHRpbml0KGVkaXRvcikge1xuXHRcdFx0Y29uc3QgQUVfRU1CRURfVVJMX1RQTCA9IG5ldyBDS0VESVRPUi50ZW1wbGF0ZShcblx0XHRcdFx0ZWRpdG9yLmNvbmZpZy5lbWJlZFVybFRlbXBsYXRlIHx8XG5cdFx0XHRcdFx0Q0tFRElUT1IuREVGQVVMVF9BRV9FTUJFRF9VUkxfVFBMXG5cdFx0XHQpO1xuXHRcdFx0Y29uc3QgQUVfRU1CRURfV0lER0VUX1RQTCA9IG5ldyBDS0VESVRPUi50ZW1wbGF0ZShcblx0XHRcdFx0ZWRpdG9yLmNvbmZpZy5lbWJlZFdpZGdldFRwbCB8fFxuXHRcdFx0XHRcdENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfV0lER0VUX1RQTFxuXHRcdFx0KTtcblx0XHRcdGNvbnN0IEFFX0VNQkVEX0RFRkFVTFRfTElOS19UUEwgPSBuZXcgQ0tFRElUT1IudGVtcGxhdGUoXG5cdFx0XHRcdGVkaXRvci5jb25maWcuZW1iZWRMaW5rRGVmYXVsdFRwbCB8fFxuXHRcdFx0XHRcdENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfREVGQVVMVF9MSU5LX1RQTFxuXHRcdFx0KTtcblxuXHRcdFx0Ly8gRGVmYXVsdCBmdW5jdGlvbiB0byB1cGNhc3QgRE9NIGVsZW1lbnRzIHRvIGVtYmVkIHdpZGdldHMuXG5cdFx0XHQvLyBJdCBtYXRjaGVzIENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfV0lER0VUX1RQTFxuXHRcdFx0Y29uc3QgZGVmYXVsdEVtYmVkV2lkZ2V0VXBjYXN0Rm4gPSBmdW5jdGlvbihlbGVtZW50LCBkYXRhKSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRlbGVtZW50Lm5hbWUgPT09ICdkaXYnICYmXG5cdFx0XHRcdFx0ZWxlbWVudC5hdHRyaWJ1dGVzWydkYXRhLWFlLWVtYmVkLXVybCddXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGRhdGEudXJsID0gZWxlbWVudC5hdHRyaWJ1dGVzWydkYXRhLWFlLWVtYmVkLXVybCddO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIENyZWF0ZSBhIGVtYmVkVXJsIGNvbW1hbmQgdGhhdCBjYW4gYmUgaW52b2tlZCB0byBlYXNpbHkgZW1iZWQgbWVkaWEgVVJMc1xuXHRcdFx0ZWRpdG9yLmFkZENvbW1hbmQoJ2VtYmVkVXJsJywge1xuXHRcdFx0XHRleGVjKGVkaXRvciwgZGF0YSkge1xuXHRcdFx0XHRcdGVkaXRvci5pbnNlcnRIdG1sKFxuXHRcdFx0XHRcdFx0QUVfRU1CRURfV0lER0VUX1RQTC5vdXRwdXQoe1xuXHRcdFx0XHRcdFx0XHR1cmw6IGRhdGEudXJsLFxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIENyZWF0ZSBhIHdpZGdldCB0byBwcm9wZXJseSBoYW5kbGUgZW1iZWQgb3BlcmF0aW9uc1xuXHRcdFx0ZWRpdG9yLndpZGdldHMuYWRkKCdhZV9lbWJlZCcsIHtcblx0XHRcdFx0bWFzazogdHJ1ZSxcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAnZGl2W2RhdGEtYWUtZW1iZWQtdXJsXScsXG5cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIExpc3RlbmVyIHRvIGJlIGV4ZWN1dGVkIGV2ZXJ5IHRpbWUgdGhlIHdpZGdldCdzIGRhdGEgY2hhbmdlcy4gSXQgdGFrZXMgY2FyZSBvZlxuXHRcdFx0XHQgKiByZXF1ZXN0aW5nIHRoZSBlbWJlZCBvYmplY3QgdG8gdGhlIGNvbmZpZ3VyZWQgb2VtYmVkIHNlcnZpY2UgYW5kIHJlbmRlciBpdCBpblxuXHRcdFx0XHQgKiB0aGUgZWRpdG9yXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIEBtZXRob2QgZGF0YVxuXHRcdFx0XHQgKiBAcGFyYW0ge2V2ZW50fSBldmVudCBEYXRhIGNoYW5nZSBldmVudFxuXHRcdFx0XHQgKi9cblx0XHRcdFx0ZGF0YShldmVudCkge1xuXHRcdFx0XHRcdGNvbnN0IHdpZGdldCA9IHRoaXM7XG5cblx0XHRcdFx0XHRjb25zdCB1cmwgPSBldmVudC5kYXRhLnVybDtcblxuXHRcdFx0XHRcdGlmICh1cmwpIHtcblx0XHRcdFx0XHRcdENLRURJVE9SLnRvb2xzLmpzb25wKFxuXHRcdFx0XHRcdFx0XHRBRV9FTUJFRF9VUkxfVFBMLFxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0dXJsOiBlbmNvZGVVUklDb21wb25lbnQodXJsKSxcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChyZXNwb25zZS5odG1sKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFJFR0VYX0RFRkFVTFRfTElOSy50ZXN0KHJlc3BvbnNlLmh0bWwpXG5cdFx0XHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0d2lkZ2V0LmNyZWF0ZUFUYWcodXJsKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHdpZGdldC5lbGVtZW50LnNldEh0bWwocmVzcG9uc2UuaHRtbCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHdpZGdldC5jcmVhdGVBVGFnKHVybCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRfbXNnID0+IHtcblx0XHRcdFx0XHRcdFx0XHR3aWRnZXQuY3JlYXRlQVRhZyh1cmwpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRjcmVhdGVBVGFnKHVybCkge1xuXHRcdFx0XHRcdHRoaXMuZWRpdG9yLmV4ZWNDb21tYW5kKCd1bmRvJyk7XG5cblx0XHRcdFx0XHRjb25zdCBhVGFnSHRtbCA9IEFFX0VNQkVEX0RFRkFVTFRfTElOS19UUEwub3V0cHV0KHtcblx0XHRcdFx0XHRcdHVybCxcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdHRoaXMuZWRpdG9yLmluc2VydEh0bWwoYVRhZ0h0bWwpO1xuXHRcdFx0XHRcdHRoaXMuZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBGdW5jdGlvbiB1c2VkIHRvIHVwY2FzdCBhbiBlbGVtZW50IHRvIGFlX2VtYmVkIHdpZGdldHMuXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIEBtZXRob2QgdXBjYXN0XG5cdFx0XHRcdCAqIEBwYXJhbSB7Q0tFRElUT1IuaHRtbFBhcnNlci5lbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGJlIGNoZWNrZWRcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB3aWRnZXRcblx0XHRcdFx0ICovXG5cdFx0XHRcdHVwY2FzdChlbGVtZW50LCBkYXRhKSB7XG5cdFx0XHRcdFx0Y29uc3QgZW1iZWRXaWRnZXRVcGNhc3RGbiA9XG5cdFx0XHRcdFx0XHRlZGl0b3IuY29uZmlnLmVtYmVkV2lkZ2V0VXBjYXN0Rm4gfHxcblx0XHRcdFx0XHRcdGRlZmF1bHRFbWJlZFdpZGdldFVwY2FzdEZuO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGVtYmVkV2lkZ2V0VXBjYXN0Rm4oZWxlbWVudCwgZGF0YSk7XG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQWRkIGEgbGlzdGVuZXIgdG8gaGFuZGxlIHBhc3RlIGV2ZW50cyBhbmQgdHVybiBsaW5rcyBpbnRvIGVtYmVkIG9iamVjdHNcblx0XHRcdGVkaXRvci5vbmNlKCdjb250ZW50RG9tJywgKCkgPT4ge1xuXHRcdFx0XHRlZGl0b3Iub24oXG5cdFx0XHRcdFx0J3Bhc3RlJyxcblx0XHRcdFx0XHRldmVudCA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5rID0gZXZlbnQuZGF0YS5kYXRhVmFsdWU7XG5cblx0XHRcdFx0XHRcdGlmIChSRUdFWF9IVFRQLnRlc3QobGluaykpIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcCgpO1xuXG5cdFx0XHRcdFx0XHRcdGVkaXRvci5leGVjQ29tbWFuZCgnZW1iZWRVcmwnLCB7XG5cdFx0XHRcdFx0XHRcdFx0dXJsOiBldmVudC5kYXRhLmRhdGFWYWx1ZSxcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHJ1biBiZWZvcmUgYXV0b2xpbmsncyBwYXN0ZSBoYW5kbGVyLFxuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB0aGUgbGluayB3aWxsIGJlIHR1cm5lZCBpbnRvIGFuIGFuY2hvciBhbmQgb3VyXG5cdFx0XHRcdFx0Ly8gUkVHRVhfSFRUUCB0ZXN0IHdpbGwgZmFpbC5cblx0XHRcdFx0XHRISUdIX1BSSU9SSVRZXG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQWRkIGEgbGlzdGVuZXIgdG8gaGFuZGxlIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnRzIGFuZCBwcm9wZXJseSBkZXRlY3QgZWRpdG9yXG5cdFx0XHQvLyBpbnRlcmFjdGlvbnMgb24gdGhlIHdpZGdldHMgd2l0aG91dCBtZXNzaW5nIHdpdGggd2lkZ2V0IG5hdGl2ZSBzZWxlY3Rpb25cblx0XHRcdGVkaXRvci5vbignc2VsZWN0aW9uQ2hhbmdlJywgX2V2ZW50ID0+IHtcblx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0XHRcdGlmIChzZWxlY3Rpb24pIHtcblx0XHRcdFx0XHRjb25zdCBlbGVtZW50ID0gc2VsZWN0aW9uLmdldFNlbGVjdGVkRWxlbWVudCgpO1xuXG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHdpZGdldEVsZW1lbnQgPSBlbGVtZW50LmZpbmRPbmUoXG5cdFx0XHRcdFx0XHRcdCdbZGF0YS13aWRnZXQ9XCJhZV9lbWJlZFwiXSdcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGlmICh3aWRnZXRFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHJlZ2lvbiA9IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdCgpO1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHNjcm9sbFBvc2l0aW9uID0gbmV3IENLRURJVE9SLmRvbS53aW5kb3coXG5cdFx0XHRcdFx0XHRcdFx0d2luZG93XG5cdFx0XHRcdFx0XHRcdCkuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcblx0XHRcdFx0XHRcdFx0cmVnaW9uLmxlZnQgLT0gc2Nyb2xsUG9zaXRpb24ueDtcblx0XHRcdFx0XHRcdFx0cmVnaW9uLnRvcCArPSBzY3JvbGxQb3NpdGlvbi55O1xuXG5cdFx0XHRcdFx0XHRcdHJlZ2lvbi5kaXJlY3Rpb24gPSBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUDtcblxuXHRcdFx0XHRcdFx0XHRlZGl0b3IuZmlyZSgnZWRpdG9ySW50ZXJhY3Rpb24nLCB7XG5cdFx0XHRcdFx0XHRcdFx0bmF0aXZlRXZlbnQ6IHt9LFxuXHRcdFx0XHRcdFx0XHRcdHNlbGVjdGlvbkRhdGE6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQ6IHdpZGdldEVsZW1lbnQsXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWdpb24sXG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQWRkIGEgZmlsdGVyIHRvIHNraXAgZmlsdGVyaW5nIHdpZGdldCBlbGVtZW50c1xuXHRcdFx0ZWRpdG9yLmZpbHRlci5hZGRFbGVtZW50Q2FsbGJhY2soZWxlbWVudCA9PiB7XG5cdFx0XHRcdGlmICgnZGF0YS1hZS1lbWJlZC11cmwnIGluIGVsZW1lbnQuYXR0cmlidXRlcykge1xuXHRcdFx0XHRcdHJldHVybiBDS0VESVRPUi5GSUxURVJfU0tJUF9UUkVFO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXHR9KTtcbn1cbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlc2l6ZXIgZnJvbSAnLi9SZXNpemVyLmVzJztcblxuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnZW1iZWR1cmwnKSkge1xuXHRjb25zdCBSRUdFWF9IVFRQID0gL15odHRwcz8vO1xuXG5cdENLRURJVE9SLkRFRkFVTFRfTEZSX0VNQkVEX1dJREdFVF9UUEwgPVxuXHRcdCc8ZGl2IGRhdGEtZW1iZWQtdXJsPVwie3VybH1cIiBjbGFzcz1cImVtYmVkLXJlc3BvbnNpdmUgZW1iZWQtcmVzcG9uc2l2ZS0xNmJ5OVwiPntjb250ZW50fTxkaXYgY2xhc3M9XCJlbWJlZC1oZWxwLW1lc3NhZ2VcIj57aGVscE1lc3NhZ2VJY29ufTxzcGFuPiB7aGVscE1lc3NhZ2V9PC9zcGFuPjwvZGl2PjwvZGl2Pjxicj4nO1xuXG5cdC8qKlxuXHQgKiBFbnVtIGZvciBzdXBwb3J0ZWQgZW1iZWQgYWxpZ25tZW50c1xuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKi9cblxuXHRjb25zdCBFTUJFRF9BTElHTk1FTlQgPSB7XG5cdFx0Q0VOVEVSOiAnY2VudGVyJyxcblx0XHRMRUZUOiAnbGVmdCcsXG5cdFx0UklHSFQ6ICdyaWdodCcsXG5cdH07XG5cblx0LyoqXG5cdCAqIEVudW0gdmFsdWVzIGZvciBzdXBwb3J0ZWQgZW1iZWQgYWxpZ25tZW50c1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqL1xuXG5cdGNvbnN0IEFMSUdOX1ZBTFVFUyA9IFtcblx0XHRFTUJFRF9BTElHTk1FTlQuQ0VOVEVSLFxuXHRcdEVNQkVEX0FMSUdOTUVOVC5MRUZULFxuXHRcdEVNQkVEX0FMSUdOTUVOVC5SSUdIVCxcblx0XTtcblxuXHQvKipcblx0ICogTmVjZXNzYXJ5IHN0eWxlcyBmb3IgdGhlIGNlbnRlciBhbGlnbm1lbnRcblx0ICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuXHQgKi9cblxuXHRjb25zdCBDRU5URVJFRF9FTUJFRF9TVFlMRSA9IFtcblx0XHR7XG5cdFx0XHRuYW1lOiAnZGlzcGxheScsXG5cdFx0XHR2YWx1ZTogJ2Jsb2NrJyxcblx0XHR9LFxuXHRcdHtcblx0XHRcdG5hbWU6ICdtYXJnaW4tbGVmdCcsXG5cdFx0XHR2YWx1ZTogJ2F1dG8nLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bmFtZTogJ21hcmdpbi1yaWdodCcsXG5cdFx0XHR2YWx1ZTogJ2F1dG8nLFxuXHRcdH0sXG5cdF07XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgYWxpZ25tZW50IHZhbHVlIG9mIGFuIGVtYmVkIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGVtYmVkIFRoZSBlbWJlZCBlbGVtZW50XG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGFsaWdubWVudCB2YWx1ZVxuXHQgKi9cblxuXHRjb25zdCBnZXRFbWJlZEFsaWdubWVudCA9IGZ1bmN0aW9uKGVtYmVkKSB7XG5cdFx0bGV0IGVtYmVkQWxpZ25tZW50ID0gZW1iZWQuZ2V0U3R5bGUoJ2Zsb2F0Jyk7XG5cblx0XHRpZiAoXG5cdFx0XHQhZW1iZWRBbGlnbm1lbnQgfHxcblx0XHRcdGVtYmVkQWxpZ25tZW50ID09PSAnaW5oZXJpdCcgfHxcblx0XHRcdGVtYmVkQWxpZ25tZW50ID09PSAnbm9uZSdcblx0XHQpIHtcblx0XHRcdGVtYmVkQWxpZ25tZW50ID0gZW1iZWQuZ2V0QXR0cmlidXRlKCdhbGlnbicpO1xuXHRcdH1cblxuXHRcdGlmICghZW1iZWRBbGlnbm1lbnQpIHtcblx0XHRcdGNvbnN0IGNlbnRlcmVkRW1iZWQgPSBDRU5URVJFRF9FTUJFRF9TVFlMRS5ldmVyeShzdHlsZSA9PiB7XG5cdFx0XHRcdGxldCBzdHlsZUNoZWNrID0gZW1iZWQuZ2V0U3R5bGUoc3R5bGUubmFtZSkgPT09IHN0eWxlLnZhbHVlO1xuXG5cdFx0XHRcdGlmICghc3R5bGVDaGVjayAmJiBzdHlsZS52ZW5kb3JQcmVmaXhlcykge1xuXHRcdFx0XHRcdHN0eWxlQ2hlY2sgPSBzdHlsZS52ZW5kb3JQcmVmaXhlcy5zb21lKFxuXHRcdFx0XHRcdFx0dmVuZG9yUHJlZml4ID0+XG5cdFx0XHRcdFx0XHRcdGVtYmVkLmdldFN0eWxlKHZlbmRvclByZWZpeCArIHN0eWxlLm5hbWUpID09PVxuXHRcdFx0XHRcdFx0XHRzdHlsZS52YWx1ZVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gc3R5bGVDaGVjaztcblx0XHRcdH0pO1xuXG5cdFx0XHRlbWJlZEFsaWdubWVudCA9IGNlbnRlcmVkRW1iZWQgPyBFTUJFRF9BTElHTk1FTlQuQ0VOVEVSIDogbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZW1iZWRBbGlnbm1lbnQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGFsaWdubWVudCB2YWx1ZSBvZiBhbiBlbWJlZFxuXHQgKlxuXHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBlbWJlZCBUaGUgZW1iZWQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZW1iZWRBbGlnbm1lbnQgVGhlIGVtYmVkIGFsaWdubWVudCB2YWx1ZSB0byBiZSByZW1vdmVkXG5cdCAqL1xuXG5cdGNvbnN0IHJlbW92ZUVtYmVkQWxpZ25tZW50ID0gZnVuY3Rpb24oZW1iZWQsIGVtYmVkQWxpZ25tZW50KSB7XG5cdFx0aWYgKFxuXHRcdFx0ZW1iZWRBbGlnbm1lbnQgPT09IEVNQkVEX0FMSUdOTUVOVC5MRUZUIHx8XG5cdFx0XHRlbWJlZEFsaWdubWVudCA9PT0gRU1CRURfQUxJR05NRU5ULlJJR0hUXG5cdFx0KSB7XG5cdFx0XHRlbWJlZC5yZW1vdmVTdHlsZSgnZmxvYXQnKTtcblxuXHRcdFx0aWYgKGVtYmVkQWxpZ25tZW50ID09PSBnZXRFbWJlZEFsaWdubWVudChlbWJlZCkpIHtcblx0XHRcdFx0ZW1iZWQucmVtb3ZlQXR0cmlidXRlKCdhbGlnbicpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZW1iZWRBbGlnbm1lbnQgPT09IEVNQkVEX0FMSUdOTUVOVC5DRU5URVIpIHtcblx0XHRcdENFTlRFUkVEX0VNQkVEX1NUWUxFLmZvckVhY2goc3R5bGUgPT4ge1xuXHRcdFx0XHRlbWJlZC5yZW1vdmVTdHlsZShzdHlsZS5uYW1lKTtcblxuXHRcdFx0XHRpZiAoc3R5bGUudmVuZG9yUHJlZml4ZXMpIHtcblx0XHRcdFx0XHRzdHlsZS52ZW5kb3JQcmVmaXhlcy5mb3JFYWNoKHZlbmRvclByZWZpeCA9PlxuXHRcdFx0XHRcdFx0ZW1iZWQucmVtb3ZlU3R5bGUodmVuZG9yUHJlZml4ICsgc3R5bGUubmFtZSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGFsaWdubWVudCB2YWx1ZSBvZiBhbiBlbWJlZFxuXHQgKlxuXHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBlbWJlZCBUaGUgZW1iZWQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZW1iZWRBbGlnbm1lbnQgVGhlIGVtYmVkIGFsaWdubWVudCB2YWx1ZSB0byBiZSBzZXRcblx0ICovXG5cblx0Y29uc3Qgc2V0RW1iZWRBbGlnbm1lbnQgPSBmdW5jdGlvbihlbWJlZCwgZW1iZWRBbGlnbm1lbnQpIHtcblx0XHRyZW1vdmVFbWJlZEFsaWdubWVudChlbWJlZCwgZ2V0RW1iZWRBbGlnbm1lbnQoZW1iZWQpKTtcblxuXHRcdGlmIChcblx0XHRcdGVtYmVkQWxpZ25tZW50ID09PSBFTUJFRF9BTElHTk1FTlQuTEVGVCB8fFxuXHRcdFx0ZW1iZWRBbGlnbm1lbnQgPT09IEVNQkVEX0FMSUdOTUVOVC5SSUdIVFxuXHRcdCkge1xuXHRcdFx0ZW1iZWQuc2V0U3R5bGUoJ2Zsb2F0JywgZW1iZWRBbGlnbm1lbnQpO1xuXHRcdH0gZWxzZSBpZiAoZW1iZWRBbGlnbm1lbnQgPT09IEVNQkVEX0FMSUdOTUVOVC5DRU5URVIpIHtcblx0XHRcdENFTlRFUkVEX0VNQkVEX1NUWUxFLmZvckVhY2goc3R5bGUgPT4ge1xuXHRcdFx0XHRlbWJlZC5zZXRTdHlsZShzdHlsZS5uYW1lLCBzdHlsZS52YWx1ZSk7XG5cblx0XHRcdFx0aWYgKHN0eWxlLnZlbmRvclByZWZpeGVzKSB7XG5cdFx0XHRcdFx0c3R5bGUudmVuZG9yUHJlZml4ZXMuZm9yRWFjaCh2ZW5kb3JQcmVmaXggPT5cblx0XHRcdFx0XHRcdGVtYmVkLnNldFN0eWxlKHZlbmRvclByZWZpeCArIHN0eWxlLm5hbWUsIHN0eWxlLnZhbHVlKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRjb25zdCBnZXRTZWxlY3RlZEVsZW1lbnQgPSBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHRjb25zdCByZXN1bHQgPSB7XG5cdFx0XHRhbGlnbm1lbnQ6IG51bGwsXG5cdFx0XHRlbGVtZW50OiBudWxsLFxuXHRcdH07XG5cblx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRpZiAoc2VsZWN0aW9uKSB7XG5cdFx0XHRjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRFbGVtZW50KCk7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0c2VsZWN0ZWRFbGVtZW50ICYmXG5cdFx0XHRcdHNlbGVjdGVkRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2tlLXdpZGdldC13cmFwcGVyJylcblx0XHRcdCkge1xuXHRcdFx0XHRyZXN1bHQuYWxpZ25tZW50ID0gZ2V0RW1iZWRBbGlnbm1lbnQoc2VsZWN0ZWRFbGVtZW50KTtcblx0XHRcdFx0cmVzdWx0LmVsZW1lbnQgPSBzZWxlY3RlZEVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRjb25zdCByZXNpemVFbGVtZW50ID0gZnVuY3Rpb24oZWwsIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRjb25zdCB3cmFwcGVyRWxlbWVudCA9IGVsLnBhcmVudEVsZW1lbnQ7XG5cblx0XHRpZiAod3JhcHBlckVsZW1lbnQgJiYgd2lkdGggPiAwICYmIGhlaWdodCA+IDApIHtcblx0XHRcdGNvbnN0IHJlY3QgPSB3cmFwcGVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdFx0Y29uc3QgcHdpZHRoID1cblx0XHRcdFx0d2lkdGggPj0gcmVjdC53aWR0aFxuXHRcdFx0XHRcdD8gMTAwXG5cdFx0XHRcdFx0OiBNYXRoLmZsb29yKCh3aWR0aCAvIHJlY3Qud2lkdGgpICogMTAwKTtcblx0XHRcdGNvbnN0IHN0eWxlID0gYHdpZHRoOiR7cHdpZHRofSU7YDtcblxuXHRcdFx0d3JhcHBlckVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHlsZScsIHN0eWxlKTtcblxuXHRcdFx0Y29uc3Qgd2lkZ2V0RWxlbWVudCA9IHdyYXBwZXJFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXG5cdFx0XHRcdCdbZGF0YS13aWRnZXQ9XCJlbWJlZHVybFwiXSdcblx0XHRcdCk7XG5cblx0XHRcdGlmICh3aWRnZXRFbGVtZW50KSB7XG5cdFx0XHRcdGNvbnN0IHN0eWxlcyA9XG5cdFx0XHRcdFx0SlNPTi5wYXJzZSh3aWRnZXRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1zdHlsZXMnKSkgfHwge307XG5cblx0XHRcdFx0c3R5bGVzLndpZHRoID0gYCR7d2lkdGh9cHhgO1xuXHRcdFx0XHRzdHlsZXMuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDtcblxuXHRcdFx0XHR3aWRnZXRFbGVtZW50LnNldEF0dHJpYnV0ZShcblx0XHRcdFx0XHQnZGF0YS1zdHlsZXMnLFxuXHRcdFx0XHRcdEpTT04uc3RyaW5naWZ5KHN0eWxlcylcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRjb25zdCBpZnJhbWVFbGVtZW50ID0gd2lkZ2V0RWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpZnJhbWUnKTtcblxuXHRcdFx0XHRpZiAoaWZyYW1lRWxlbWVudCkge1xuXHRcdFx0XHRcdGlmcmFtZUVsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoKTtcblx0XHRcdFx0XHRpZnJhbWVFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRjb25zdCBzZWxlY3RXaWRnZXQgPSBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdFx0aWYgKHNlbGVjdGlvbikge1xuXHRcdFx0XHRjb25zdCB3cmFwcGVyRWxlbWVudCA9IHNlbGVjdGlvbi5yb290LmZpbmQoXG5cdFx0XHRcdFx0J1tkYXRhLWNrZS13aWRnZXQtd3JhcHBlcl0nXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKHdyYXBwZXJFbGVtZW50KSB7XG5cdFx0XHRcdFx0Y29uc3QgZWxlbWVudExpc3QgPSB3cmFwcGVyRWxlbWVudC4kO1xuXHRcdFx0XHRcdGlmIChlbGVtZW50TGlzdC5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBsYXN0RWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChcblx0XHRcdFx0XHRcdFx0ZWxlbWVudExpc3RbZWxlbWVudExpc3QubGVuZ3RoIC0gMV1cblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGltYWdlRWxlbWVudCA9IGxhc3RFbGVtZW50LmZpbmRPbmUoJ2ltZycpO1xuXHRcdFx0XHRcdFx0Y29uc3Qgd2lkZ2V0RWxlbWVudCA9IGxhc3RFbGVtZW50LmZpbmRPbmUoXG5cdFx0XHRcdFx0XHRcdCdbZGF0YS13aWRnZXQ9XCJlbWJlZHVybFwiXSdcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGlmIChpbWFnZUVsZW1lbnQgJiYgd2lkZ2V0RWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCByYW5nZSA9IGVkaXRvci5jcmVhdGVSYW5nZSgpO1xuXG5cdFx0XHRcdFx0XHRcdHJhbmdlLnNldFN0YXJ0KHdpZGdldEVsZW1lbnQsIDApO1xuXHRcdFx0XHRcdFx0XHRyYW5nZS5zZXRFbmQoaW1hZ2VFbGVtZW50LCAxKTtcblxuXHRcdFx0XHRcdFx0XHRzZWxlY3Rpb24uc2VsZWN0UmFuZ2VzKFtyYW5nZV0pO1xuXHRcdFx0XHRcdFx0XHRzZWxlY3Rpb24uc2VsZWN0RWxlbWVudChsYXN0RWxlbWVudCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSwgMCk7XG5cdH07XG5cblx0bGV0IGN1cnJlbnRBbGlnbm1lbnQgPSBudWxsO1xuXHRsZXQgY3VycmVudEVsZW1lbnQgPSBudWxsO1xuXHRsZXQgcmVzaXplciA9IG51bGw7XG5cblx0LyoqXG5cdCAqIENLRWRpdG9yIHBsdWdpbiB3aGljaCBhZGRzIHRoZSBpbmZyYXN0cnVjdHVyZSB0byBlbWJlZCB1cmxzIGFzIG1lZGlhIG9iamVjdHNcblx0ICpcblx0ICogVGhpcyBwbHVnaW4gYWRkcyBhbiBgZW1iZWRVcmxgIGNvbW1hbmQgdGhhdCBjYW4gYmUgdXNlZCB0byBlYXNpbHkgZW1iZWQgYSBVUkwgYW5kIHRyYW5zZm9ybSBpdFxuXHQgKiB0byBhbiBlbWJlZGRlZCBjb250ZW50LlxuXHQgKlxuXHQgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5lbWJlZHVybFxuXHQgKi9cblxuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnZW1iZWR1cmwnLCB7XG5cdFx0cmVxdWlyZXM6ICd3aWRnZXQnLFxuXG5cdFx0aW5pdDogZWRpdG9yID0+IHtcblx0XHRcdGNvbnN0IExGUl9FTUJFRF9XSURHRVRfVFBMID0gbmV3IENLRURJVE9SLnRlbXBsYXRlKFxuXHRcdFx0XHRlZGl0b3IuY29uZmlnLmVtYmVkV2lkZ2V0VHBsIHx8XG5cdFx0XHRcdFx0Q0tFRElUT1IuREVGQVVMVF9MRlJfRU1CRURfV0lER0VUX1RQTFxuXHRcdFx0KTtcblxuXHRcdFx0bGV0IHByb3ZpZGVycyA9IGVkaXRvci5jb25maWcuZW1iZWRQcm92aWRlcnMgfHwgW107XG5cblx0XHRcdHByb3ZpZGVycyA9IHByb3ZpZGVycy5tYXAocHJvdmlkZXIgPT4ge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGlkOiBwcm92aWRlci5pZCxcblx0XHRcdFx0XHR0cGw6IG5ldyBDS0VESVRPUi50ZW1wbGF0ZShcblx0XHRcdFx0XHRcdGA8ZGl2IGRhdGEtZW1iZWQtaWQ9XCJ7ZW1iZWRJZH1cIj4ke3Byb3ZpZGVyLnRwbH08L2Rpdj5gXG5cdFx0XHRcdFx0KSxcblx0XHRcdFx0XHR0eXBlOiBwcm92aWRlci50eXBlLFxuXHRcdFx0XHRcdHVybFNjaGVtZXM6IHByb3ZpZGVyLnVybFNjaGVtZXMubWFwKFxuXHRcdFx0XHRcdFx0c2NoZW1lID0+IG5ldyBSZWdFeHAoc2NoZW1lKVxuXHRcdFx0XHRcdCksXG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblxuXHRcdFx0Y29uc3QgZ2VuZXJhdGVFbWJlZENvbnRlbnQgPSAodXJsLCBjb250ZW50KSA9PiB7XG5cdFx0XHRcdHJldHVybiBMRlJfRU1CRURfV0lER0VUX1RQTC5vdXRwdXQoe1xuXHRcdFx0XHRcdGNvbnRlbnQsXG5cdFx0XHRcdFx0aGVscE1lc3NhZ2U6IEFsbG95RWRpdG9yLlN0cmluZ3MudmlkZW9QbGF5YmFja0Rpc2FibGVkLFxuXHRcdFx0XHRcdGhlbHBNZXNzYWdlSWNvbjogTGlmZXJheS5VdGlsLmdldExleGljb25JY29uVHBsKFxuXHRcdFx0XHRcdFx0J2luZm8tY2lyY2xlJ1xuXHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0dXJsLFxuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IGRlZmF1bHRFbWJlZFdpZGdldFVwY2FzdEZuID0gKGVsZW1lbnQsIGRhdGEpID0+IHtcblx0XHRcdFx0bGV0IHVwY2FzdFdpZGdldCA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRlbGVtZW50Lm5hbWUgPT09ICdkaXYnICYmXG5cdFx0XHRcdFx0ZWxlbWVudC5hdHRyaWJ1dGVzWydkYXRhLWVtYmVkLXVybCddXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGRhdGEudXJsID0gZWxlbWVudC5hdHRyaWJ1dGVzWydkYXRhLWVtYmVkLXVybCddO1xuXG5cdFx0XHRcdFx0dXBjYXN0V2lkZ2V0ID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0XHRlbGVtZW50Lm5hbWUgPT09ICdkaXYnICYmXG5cdFx0XHRcdFx0ZWxlbWVudC5hdHRyaWJ1dGVzWydkYXRhLWVtYmVkLWlkJ11cblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Y29uc3QgaWZyYW1lID0gZWxlbWVudC5jaGlsZHJlblswXTtcblxuXHRcdFx0XHRcdGRhdGEudXJsID0gaWZyYW1lLmF0dHJpYnV0ZXMuc3JjO1xuXG5cdFx0XHRcdFx0ZGVsZXRlIGVsZW1lbnQuYXR0cmlidXRlcy5zdHlsZTtcblxuXHRcdFx0XHRcdGNvbnN0IGVtYmVkQ29udGVudCA9IGdlbmVyYXRlRW1iZWRDb250ZW50KFxuXHRcdFx0XHRcdFx0ZGF0YS51cmwsXG5cdFx0XHRcdFx0XHRlbGVtZW50LmdldE91dGVySHRtbCgpXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGNvbnN0IHdpZGdldEZyYWdtZW50ID0gbmV3IENLRURJVE9SLmh0bWxQYXJzZXIuZnJhZ21lbnQuZnJvbUh0bWwoXG5cdFx0XHRcdFx0XHRlbWJlZENvbnRlbnRcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0dXBjYXN0V2lkZ2V0ID0gd2lkZ2V0RnJhZ21lbnQuY2hpbGRyZW5bMF07XG5cblx0XHRcdFx0XHR1cGNhc3RXaWRnZXQuYXR0cmlidXRlc1snZGF0YS1zdHlsZXMnXSA9XG5cdFx0XHRcdFx0XHRlbGVtZW50LmF0dHJpYnV0ZXNbJ2RhdGEtc3R5bGVzJ107XG5cdFx0XHRcdFx0dXBjYXN0V2lkZ2V0LnJlbW92ZUNsYXNzKCdlbWJlZC1yZXNwb25zaXZlJyk7XG5cdFx0XHRcdFx0dXBjYXN0V2lkZ2V0LnJlbW92ZUNsYXNzKCdlbWJlZC1yZXNwb25zaXZlLTE2Ynk5Jyk7XG5cblx0XHRcdFx0XHRlbGVtZW50LnJlcGxhY2VXaXRoKHVwY2FzdFdpZGdldCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdXBjYXN0V2lkZ2V0O1xuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3Qgc2hvd0Vycm9yID0gZXJyb3JNc2cgPT4ge1xuXHRcdFx0XHRlZGl0b3IuZmlyZSgnZXJyb3InLCBlcnJvck1zZyk7XG5cblx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0ZWRpdG9yLmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuXG5cdFx0XHRcdFx0ZWRpdG9yLmZvY3VzKCk7XG5cblx0XHRcdFx0XHRyZXNpemVyLmhpZGUoKTtcblx0XHRcdFx0fSwgMCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRlZGl0b3IuYWRkQ29tbWFuZCgnZW1iZWRVcmwnLCB7XG5cdFx0XHRcdGV4ZWM6IChlZGl0b3IsIGRhdGEpID0+IHtcblx0XHRcdFx0XHRjb25zdCB0eXBlID0gZGF0YS50eXBlO1xuXHRcdFx0XHRcdGNvbnN0IHVybCA9IGRhdGEudXJsO1xuXHRcdFx0XHRcdGxldCBjb250ZW50O1xuXG5cdFx0XHRcdFx0aWYgKFJFR0VYX0hUVFAudGVzdCh1cmwpKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB2YWxpZFByb3ZpZGVyID0gcHJvdmlkZXJzXG5cdFx0XHRcdFx0XHRcdC5maWx0ZXIocHJvdmlkZXIgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0eXBlID8gcHJvdmlkZXIudHlwZSA9PT0gdHlwZSA6IHRydWU7XG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdC5zb21lKHByb3ZpZGVyID0+IHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBzY2hlbWUgPSBwcm92aWRlci51cmxTY2hlbWVzLmZpbmQoXG5cdFx0XHRcdFx0XHRcdFx0XHRzY2hlbWUgPT4gc2NoZW1lLnRlc3QodXJsKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoc2NoZW1lKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBlbWJlZElkID0gc2NoZW1lLmV4ZWModXJsKVsxXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y29udGVudCA9IHByb3ZpZGVyLnRwbC5vdXRwdXQoe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbWJlZElkLFxuXHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHNjaGVtZTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdGlmICh2YWxpZFByb3ZpZGVyKSB7XG5cdFx0XHRcdFx0XHRcdGVkaXRvci5fc2VsZWN0RW1iZWRXaWRnZXQgPSB1cmw7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgZW1iZWRDb250ZW50ID0gZ2VuZXJhdGVFbWJlZENvbnRlbnQoXG5cdFx0XHRcdFx0XHRcdFx0dXJsLFxuXHRcdFx0XHRcdFx0XHRcdGNvbnRlbnRcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRlZGl0b3IuaW5zZXJ0SHRtbChlbWJlZENvbnRlbnQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c2hvd0Vycm9yKEFsbG95RWRpdG9yLlN0cmluZ3MucGxhdGZvcm1Ob3RTdXBwb3J0ZWQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzaG93RXJyb3IoQWxsb3lFZGl0b3IuU3RyaW5ncy5lbnRlclZhbGlkVXJsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblxuXHRcdFx0ZWRpdG9yLndpZGdldHMuYWRkKCdlbWJlZHVybCcsIHtcblx0XHRcdFx0ZHJhZ2dhYmxlOiBmYWxzZSxcblx0XHRcdFx0bWFzazogdHJ1ZSxcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAnZGl2W2RhdGEtZW1iZWQtdXJsXScsXG5cblx0XHRcdFx0ZGF0YShldmVudCkge1xuXHRcdFx0XHRcdGNvbnN0IGluc3RhbmNlID0gdGhpcztcblxuXHRcdFx0XHRcdC8vIFN5bmMgZGltZW5zaW9ucyBhbmQgYWxpZ25tZW50IHdpdGggZWRpdG9yIHdyYXBwZXJcblxuXHRcdFx0XHRcdGxldCBzdHlsZXMgPSBudWxsO1xuXG5cdFx0XHRcdFx0Y29uc3Qgc3R5bGVzSlNPTiA9IGluc3RhbmNlLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFxuXHRcdFx0XHRcdFx0J2RhdGEtc3R5bGVzJ1xuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAoc3R5bGVzSlNPTikge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0c3R5bGVzID0gSlNPTi5wYXJzZShzdHlsZXNKU09OKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKF9lcnJvcikge1xuXHRcdFx0XHRcdFx0XHRzdHlsZXMgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICghc3R5bGVzKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBpZnJhbWUgPSBpbnN0YW5jZS53cmFwcGVyLmZpbmRPbmUoJ2lmcmFtZScpO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBib3VuZHMgPSBpbnN0YW5jZS53cmFwcGVyLiQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRcdFx0XHRjb25zdCB3aWR0aCA9IGlmcmFtZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHB3aWR0aCA9XG5cdFx0XHRcdFx0XHRcdHdpZHRoID49IGJvdW5kcy53aWR0aFxuXHRcdFx0XHRcdFx0XHRcdD8gMTAwXG5cdFx0XHRcdFx0XHRcdFx0OiBNYXRoLnJvdW5kKCh3aWR0aCAvIGJvdW5kcy53aWR0aCkgKiAxMDApO1xuXG5cdFx0XHRcdFx0XHRzdHlsZXMgPSB7XG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBgJHtwd2lkdGh9JWAsXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGluc3RhbmNlLndyYXBwZXIuc2V0QXR0cmlidXRlKFxuXHRcdFx0XHRcdFx0J3N0eWxlJyxcblx0XHRcdFx0XHRcdENLRURJVE9SLnRvb2xzLndyaXRlQ3NzVGV4dChzdHlsZXMpXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGlmIChlZGl0b3IuX3NlbGVjdEVtYmVkV2lkZ2V0ID09PSBldmVudC5kYXRhLnVybCkge1xuXHRcdFx0XHRcdFx0c2VsZWN0V2lkZ2V0KGVkaXRvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGRvd25jYXN0KHdpZGdldCkge1xuXHRcdFx0XHRcdGNvbnN0IGVtYmVkQ29udGVudCA9IHdpZGdldC5jaGlsZHJlblswXTtcblxuXHRcdFx0XHRcdGVtYmVkQ29udGVudC5hdHRyaWJ1dGVzLmNsYXNzID1cblx0XHRcdFx0XHRcdCdlbWJlZC1yZXNwb25zaXZlIGVtYmVkLXJlc3BvbnNpdmUtMTZieTknO1xuXG5cdFx0XHRcdFx0ZW1iZWRDb250ZW50LmF0dHJpYnV0ZXNbJ2RhdGEtc3R5bGVzJ10gPSBKU09OLnN0cmluZ2lmeShcblx0XHRcdFx0XHRcdENLRURJVE9SLnRvb2xzLnBhcnNlQ3NzVGV4dChcblx0XHRcdFx0XHRcdFx0d2lkZ2V0LnBhcmVudC5hdHRyaWJ1dGVzLnN0eWxlXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGVtYmVkQ29udGVudC5hdHRyaWJ1dGVzLnN0eWxlID1cblx0XHRcdFx0XHRcdHdpZGdldC5wYXJlbnQuYXR0cmlidXRlcy5zdHlsZTtcblxuXHRcdFx0XHRcdHJldHVybiBlbWJlZENvbnRlbnQ7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0dXBjYXN0KGVsZW1lbnQsIGRhdGEpIHtcblx0XHRcdFx0XHRjb25zdCBlbWJlZFdpZGdldFVwY2FzdEZuID1cblx0XHRcdFx0XHRcdGVkaXRvci5jb25maWcuZW1iZWRXaWRnZXRVcGNhc3RGbiB8fFxuXHRcdFx0XHRcdFx0ZGVmYXVsdEVtYmVkV2lkZ2V0VXBjYXN0Rm47XG5cblx0XHRcdFx0XHRyZXR1cm4gZW1iZWRXaWRnZXRVcGNhc3RGbihlbGVtZW50LCBkYXRhKTtcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcblx0XHRcdFx0J3Jlc2l6ZScsXG5cdFx0XHRcdCgpID0+IHtcblx0XHRcdFx0XHRyZXNpemVyLmhpZGUoKTtcblx0XHRcdFx0XHRzZWxlY3RXaWRnZXQoZWRpdG9yKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZmFsc2Vcblx0XHRcdCk7XG5cblx0XHRcdGVkaXRvci5vbignc2VsZWN0aW9uQ2hhbmdlJywgX2V2ZW50ID0+IHtcblx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0XHRcdGlmIChzZWxlY3Rpb24pIHtcblx0XHRcdFx0XHRjb25zdCBlbGVtZW50ID0gc2VsZWN0aW9uLmdldFNlbGVjdGVkRWxlbWVudCgpO1xuXG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHdpZGdldEVsZW1lbnQgPSBlbGVtZW50LmZpbmRPbmUoXG5cdFx0XHRcdFx0XHRcdCdbZGF0YS13aWRnZXQ9XCJlbWJlZHVybFwiXSdcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGlmICh3aWRnZXRFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHNjcm9sbFBvc2l0aW9uID0gbmV3IENLRURJVE9SLmRvbS53aW5kb3coXG5cdFx0XHRcdFx0XHRcdFx0d2luZG93XG5cdFx0XHRcdFx0XHRcdCkuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCByZWdpb24gPSBlbGVtZW50LmdldENsaWVudFJlY3QoKTtcblxuXHRcdFx0XHRcdFx0XHRyZWdpb24uZGlyZWN0aW9uID0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1A7XG5cdFx0XHRcdFx0XHRcdHJlZ2lvbi5sZWZ0IC09IHNjcm9sbFBvc2l0aW9uLng7XG5cdFx0XHRcdFx0XHRcdHJlZ2lvbi50b3AgKz0gc2Nyb2xsUG9zaXRpb24ueTtcblxuXHRcdFx0XHRcdFx0XHRlZGl0b3IuZmlyZSgnZWRpdG9ySW50ZXJhY3Rpb24nLCB7XG5cdFx0XHRcdFx0XHRcdFx0bmF0aXZlRXZlbnQ6IHt9LFxuXHRcdFx0XHRcdFx0XHRcdHNlbGVjdGlvbkRhdGE6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQ6IHdpZGdldEVsZW1lbnQsXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWdpb24sXG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnN0IGltYWdlRWxlbWVudCA9IGVsZW1lbnQuZmluZE9uZShcblx0XHRcdFx0XHRcdFx0J2ltZy5ja2Vfd2lkZ2V0X21hc2snXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoaW1hZ2VFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdHJlc2l6ZXIuc2hvdyhpbWFnZUVsZW1lbnQuJCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc2l6ZXIuaGlkZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGVkaXRvci5vbignZGVzdHJveScsICgpID0+IHtcblx0XHRcdFx0Y29uc3QgcmVzaXplRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdja2ltZ3JzeicpO1xuXG5cdFx0XHRcdGlmIChyZXNpemVFbGVtZW50KSB7XG5cdFx0XHRcdFx0cmVzaXplRWxlbWVudC5yZW1vdmUoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlRG93bkxpc3RlbmVyKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRlZGl0b3Iub24oJ2JsdXInLCAoKSA9PiB7XG5cdFx0XHRcdHJlc2l6ZXIuaGlkZSgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGVkaXRvci5maWx0ZXIuYWRkRWxlbWVudENhbGxiYWNrKGVsZW1lbnQgPT4ge1xuXHRcdFx0XHRpZiAoJ2RhdGEtZW1iZWQtdXJsJyBpbiBlbGVtZW50LmF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gQ0tFRElUT1IuRklMVEVSX1NLSVBfVFJFRTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGNvbnN0IG1vdXNlRG93bkxpc3RlbmVyID0gZXZlbnQgPT4ge1xuXHRcdFx0XHRjb25zdCByZXN1bHQgPSBnZXRTZWxlY3RlZEVsZW1lbnQoZWRpdG9yKTtcblxuXHRcdFx0XHRjdXJyZW50QWxpZ25tZW50ID0gcmVzdWx0LmFsaWdubWVudDtcblx0XHRcdFx0Y3VycmVudEVsZW1lbnQgPSByZXN1bHQuZWxlbWVudDtcblxuXHRcdFx0XHRpZiAocmVzaXplci5pc0hhbmRsZShldmVudC50YXJnZXQpKSB7XG5cdFx0XHRcdFx0cmVzaXplci5pbml0RHJhZyhldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdHJlc2l6ZXIgPSBuZXcgUmVzaXplcihlZGl0b3IsIHtcblx0XHRcdFx0b25Db21wbGV0ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0XHRcdFx0cmVzaXplRWxlbWVudChlbGVtZW50LCB3aWR0aCwgaGVpZ2h0KTtcblxuXHRcdFx0XHRcdGlmIChjdXJyZW50QWxpZ25tZW50ICYmIGN1cnJlbnRFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRzZXRFbWJlZEFsaWdubWVudChjdXJyZW50RWxlbWVudCwgY3VycmVudEFsaWdubWVudCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbGVjdFdpZGdldChlZGl0b3IpO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlRG93bkxpc3RlbmVyLCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdGFmdGVySW5pdDogZWRpdG9yID0+IHtcblx0XHRcdEFMSUdOX1ZBTFVFUy5mb3JFYWNoKGFsaWduVmFsdWUgPT4ge1xuXHRcdFx0XHRjb25zdCBjb21tYW5kID0gZWRpdG9yLmdldENvbW1hbmQoJ2p1c3RpZnknICsgYWxpZ25WYWx1ZSk7XG5cblx0XHRcdFx0aWYgKGNvbW1hbmQpIHtcblx0XHRcdFx0XHRjb21tYW5kLm9uKCdleGVjJywgZXZlbnQgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWRFbGVtZW50ID0gZWRpdG9yXG5cdFx0XHRcdFx0XHRcdC5nZXRTZWxlY3Rpb24oKVxuXHRcdFx0XHRcdFx0XHQuZ2V0U2VsZWN0ZWRFbGVtZW50KCk7XG5cblx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0c2VsZWN0ZWRFbGVtZW50ICYmXG5cdFx0XHRcdFx0XHRcdHNlbGVjdGVkRWxlbWVudC5nZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdFx0XHRcdFx0J2RhdGEtY2tlLXdpZGdldC13cmFwcGVyJ1xuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWRFbWJlZCA9IHNlbGVjdGVkRWxlbWVudC5maW5kT25lKFxuXHRcdFx0XHRcdFx0XHRcdCdbZGF0YS13aWRnZXQ9XCJlbWJlZHVybFwiXSBbZGF0YS1lbWJlZC1pZF0nXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKHNlbGVjdGVkRW1iZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBlbWJlZEFsaWdubWVudCA9IGdldEVtYmVkQWxpZ25tZW50KFxuXHRcdFx0XHRcdFx0XHRcdFx0c2VsZWN0ZWRFbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChlbWJlZEFsaWdubWVudCA9PT0gYWxpZ25WYWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVtb3ZlRW1iZWRBbGlnbm1lbnQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNlbGVjdGVkRWxlbWVudCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWxpZ25WYWx1ZVxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0c2V0RW1iZWRBbGlnbm1lbnQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNlbGVjdGVkRWxlbWVudCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWxpZ25WYWx1ZVxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50RWxlbWVudCA9IHNlbGVjdGVkRWxlbWVudDtcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50QWxpZ25tZW50ID0gZ2V0RW1iZWRBbGlnbm1lbnQoXG5cdFx0XHRcdFx0XHRcdFx0XHRzZWxlY3RlZEVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgaW1hZ2VFbGVtZW50ID0gc2VsZWN0ZWRFbGVtZW50LmZpbmRPbmUoXG5cdFx0XHRcdFx0XHRcdFx0XHQnaW1nJ1xuXHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoaW1hZ2VFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXNpemVyLnNob3coaW1hZ2VFbGVtZW50LiQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGV2ZW50LmNhbmNlbCgpO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgZWxlbWVudFBhdGggPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnRQYXRoKFxuXHRcdFx0XHRcdFx0XHRcdFx0c2VsZWN0ZWRFbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdEFMSUdOX1ZBTFVFUy5mb3JFYWNoKGFsaWduVmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgY29tbWFuZCA9IGVkaXRvci5nZXRDb21tYW5kKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnanVzdGlmeScgKyBhbGlnblZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoY29tbWFuZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb21tYW5kLnJlZnJlc2goZWRpdG9yLCBlbGVtZW50UGF0aCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGNvbW1hbmQub24oJ3JlZnJlc2gnLCBldmVudCA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBsYXN0RWxlbWVudCA9IGV2ZW50LmRhdGEucGF0aC5sYXN0RWxlbWVudDtcblxuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRsYXN0RWxlbWVudCAmJlxuXHRcdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5nZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdFx0XHRcdFx0J2RhdGEtY2tlLXdpZGdldC13cmFwcGVyJ1xuXHRcdFx0XHRcdFx0XHQpICYmXG5cdFx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmZpbmRPbmUoJ1tkYXRhLXdpZGdldF0gW2RhdGEtZW1iZWQtaWRdJylcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBlbWJlZEFsaWdubWVudCA9IGdldEVtYmVkQWxpZ25tZW50KFxuXHRcdFx0XHRcdFx0XHRcdGxhc3RFbGVtZW50XG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0ZXZlbnQuc2VuZGVyLnNldFN0YXRlKFxuXHRcdFx0XHRcdFx0XHRcdGVtYmVkQWxpZ25tZW50ID09PSBhbGlnblZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IENLRURJVE9SLlRSSVNUQVRFX09OXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IENLRURJVE9SLlRSSVNUQVRFX09GRlxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdGV2ZW50LmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXHR9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2VtYmVkdXJsJyk7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBTZWxlY3Rpb25UZXN0IGZyb20gJy4uL3NlbGVjdGlvbnMvc2VsZWN0aW9uLXRlc3QnO1xuXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9pbWFnZWFsaWdubWVudCcpKSB7XG5cdC8qKlxuXHQgKiBFbnVtIGZvciBzdXBwb3J0ZWQgaW1hZ2UgYWxpZ25tZW50c1xuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKi9cblx0Y29uc3QgSU1BR0VfQUxJR05NRU5UID0ge1xuXHRcdENFTlRFUjogJ2NlbnRlcicsXG5cdFx0TEVGVDogJ2xlZnQnLFxuXHRcdFJJR0hUOiAncmlnaHQnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbnVtIHZhbHVlcyBmb3Igc3VwcG9ydGVkIGltYWdlIGFsaWdubWVudHNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKi9cblx0Y29uc3QgQUxJR05fVkFMVUVTID0gW1xuXHRcdElNQUdFX0FMSUdOTUVOVC5MRUZULFxuXHRcdElNQUdFX0FMSUdOTUVOVC5SSUdIVCxcblx0XHRJTUFHRV9BTElHTk1FTlQuQ0VOVEVSLFxuXHRdO1xuXG5cdC8qKlxuXHQgKiBOZWNlc3Nhcnkgc3R5bGVzIGZvciB0aGUgbGVmdHxjZW50ZXJ8cmlnaHQgYWxpZ25tZW50XG5cdCAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cblx0ICovXG5cdGNvbnN0IElNQUdFX1NUWUxFX0FMSUdOTUVOVCA9IHtcblx0XHRbSU1BR0VfQUxJR05NRU5ULkxFRlRdOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6ICdkaXNwbGF5Jyxcblx0XHRcdFx0dmFsdWU6ICdpbmxpbmUtYmxvY2snLFxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogJ2Zsb2F0Jyxcblx0XHRcdFx0dmFsdWU6ICdsZWZ0Jyxcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6ICdtYXJnaW4tcmlnaHQnLFxuXHRcdFx0XHR2YWx1ZTogJzEuMnJlbScsXG5cdFx0XHR9LFxuXHRcdF0sXG5cdFx0W0lNQUdFX0FMSUdOTUVOVC5DRU5URVJdOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6ICdkaXNwbGF5Jyxcblx0XHRcdFx0dmFsdWU6ICdibG9jaycsXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiAnbWFyZ2luLWxlZnQnLFxuXHRcdFx0XHR2YWx1ZTogJ2F1dG8nLFxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogJ21hcmdpbi1yaWdodCcsXG5cdFx0XHRcdHZhbHVlOiAnYXV0bycsXG5cdFx0XHR9LFxuXHRcdF0sXG5cdFx0W0lNQUdFX0FMSUdOTUVOVC5SSUdIVF06IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogJ2Rpc3BsYXknLFxuXHRcdFx0XHR2YWx1ZTogJ2lubGluZS1ibG9jaycsXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiAnZmxvYXQnLFxuXHRcdFx0XHR2YWx1ZTogJ3JpZ2h0Jyxcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6ICdtYXJnaW4tbGVmdCcsXG5cdFx0XHRcdHZhbHVlOiAnMS4ycmVtJyxcblx0XHRcdH0sXG5cdFx0XSxcblx0fTtcblxuXHQvKipcblx0ICogUmV0cmlldmVzIHRoZSBhbGlnbm1lbnQgdmFsdWUgb2YgYW4gaW1hZ2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGltYWdlIFRoZSBpbWFnZSBlbGVtZW50XG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGFsaWdubWVudCB2YWx1ZVxuXHQgKi9cblx0Y29uc3QgZ2V0SW1hZ2VBbGlnbm1lbnQgPSBmdW5jdGlvbihpbWFnZSkge1xuXHRcdGxldCBpbWFnZUFsaWdubWVudCA9IGltYWdlLmdldFN0eWxlKCdmbG9hdCcpO1xuXG5cdFx0aWYgKFxuXHRcdFx0IWltYWdlQWxpZ25tZW50IHx8XG5cdFx0XHRpbWFnZUFsaWdubWVudCA9PT0gJ2luaGVyaXQnIHx8XG5cdFx0XHRpbWFnZUFsaWdubWVudCA9PT0gJ25vbmUnXG5cdFx0KSB7XG5cdFx0XHRpbWFnZUFsaWdubWVudCA9IGltYWdlLmdldEF0dHJpYnV0ZSgnYWxpZ24nKTtcblx0XHR9XG5cblx0XHRpZiAoIWltYWdlQWxpZ25tZW50KSB7XG5cdFx0XHRsZXQgY2VudGVyZWRJbWFnZSA9IElNQUdFX1NUWUxFX0FMSUdOTUVOVFtcblx0XHRcdFx0SU1BR0VfQUxJR05NRU5ULkNFTlRFUlxuXHRcdFx0XS5ldmVyeShzdHlsZSA9PiB7XG5cdFx0XHRcdGxldCBzdHlsZUNoZWNrID0gaW1hZ2UuZ2V0U3R5bGUoc3R5bGUubmFtZSkgPT09IHN0eWxlLnZhbHVlO1xuXG5cdFx0XHRcdGlmICghc3R5bGVDaGVjayAmJiBzdHlsZS52ZW5kb3JQcmVmaXhlcykge1xuXHRcdFx0XHRcdHN0eWxlQ2hlY2sgPSBzdHlsZS52ZW5kb3JQcmVmaXhlcy5zb21lKHZlbmRvclByZWZpeCA9PiB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHRpbWFnZS5nZXRTdHlsZSh2ZW5kb3JQcmVmaXggKyBzdHlsZS5uYW1lKSA9PT1cblx0XHRcdFx0XHRcdFx0c3R5bGUudmFsdWVcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gc3R5bGVDaGVjaztcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoIWltYWdlQWxpZ25tZW50KSB7XG5cdFx0XHRcdGNvbnN0IGltYWdlQ29udGFpbmVyID0gaW1hZ2UuJC5wYXJlbnROb2RlO1xuXG5cdFx0XHRcdGlmIChpbWFnZUNvbnRhaW5lci5zdHlsZS50ZXh0QWxpZ24gPT0gSU1BR0VfQUxJR05NRU5ULkNFTlRFUikge1xuXHRcdFx0XHRcdElNQUdFX1NUWUxFX0FMSUdOTUVOVFtJTUFHRV9BTElHTk1FTlQuQ0VOVEVSXS5mb3JFYWNoKFxuXHRcdFx0XHRcdFx0c3R5bGUgPT4ge1xuXHRcdFx0XHRcdFx0XHRpbWFnZS5zZXRTdHlsZShzdHlsZS5uYW1lLCBzdHlsZS52YWx1ZSk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKHN0eWxlLnZlbmRvclByZWZpeGVzKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3R5bGUudmVuZG9yUHJlZml4ZXMuZm9yRWFjaCh2ZW5kb3JQcmVmaXggPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0aW1hZ2Uuc2V0U3R5bGUoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZlbmRvclByZWZpeCArIHN0eWxlLm5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0eWxlLnZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRjZW50ZXJlZEltYWdlID0gdHJ1ZTtcblx0XHRcdFx0XHRpbWFnZUNvbnRhaW5lci5zdHlsZS50ZXh0QWxpZ24gPSAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpbWFnZUFsaWdubWVudCA9IGNlbnRlcmVkSW1hZ2UgPyBJTUFHRV9BTElHTk1FTlQuQ0VOVEVSIDogbnVsbDtcblx0XHR9XG5cblx0XHRpZiAoIUNLRURJVE9SLmVudi5lZGdlICYmIENLRURJVE9SLmVudi5pZSkge1xuXHRcdFx0Y29uc3QgcCA9IGltYWdlLmZpbmRPbmUoJ3AnKTtcblx0XHRcdGlmIChwKSB7XG5cdFx0XHRcdGltYWdlQWxpZ25tZW50ID0gcC5nZXRTdHlsZSgndGV4dC1hbGlnbicpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBpbWFnZUFsaWdubWVudDtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgYWxpZ25tZW50IHZhbHVlIG9mIGFuIGltYWdlXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGltYWdlIFRoZSBpbWFnZSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbWFnZUFsaWdubWVudCBUaGUgaW1hZ2UgYWxpZ25tZW50IHZhbHVlIHRvIGJlIHJlbW92ZWRcblx0ICovXG5cdGNvbnN0IHJlbW92ZUltYWdlQWxpZ25tZW50ID0gZnVuY3Rpb24oaW1hZ2UsIGltYWdlQWxpZ25tZW50KSB7XG5cdFx0aWYgKFxuXHRcdFx0aW1hZ2VBbGlnbm1lbnQgPT09IElNQUdFX0FMSUdOTUVOVC5MRUZUIHx8XG5cdFx0XHRpbWFnZUFsaWdubWVudCA9PT0gSU1BR0VfQUxJR05NRU5ULlJJR0hUXG5cdFx0KSB7XG5cdFx0XHRpZiAoaW1hZ2VBbGlnbm1lbnQgPT09IGdldEltYWdlQWxpZ25tZW50KGltYWdlKSkge1xuXHRcdFx0XHRpbWFnZS5yZW1vdmVBdHRyaWJ1dGUoJ2FsaWduJyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChpbWFnZUFsaWdubWVudCA9PT0gSU1BR0VfQUxJR05NRU5ULkNFTlRFUikge1xuXHRcdFx0Y29uc3QgaW1hZ2VDb250YWluZXIgPSBpbWFnZS4kLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmIChpbWFnZUNvbnRhaW5lci5zdHlsZS50ZXh0QWxpZ24gPT0gSU1BR0VfQUxJR05NRU5ULkNFTlRFUikge1xuXHRcdFx0XHRpbWFnZUNvbnRhaW5lci5zdHlsZS50ZXh0QWxpZ24gPSAnJztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCBzdHlsZXMgPSBJTUFHRV9TVFlMRV9BTElHTk1FTlRbaW1hZ2VBbGlnbm1lbnRdO1xuXG5cdFx0aWYgKHN0eWxlcykge1xuXHRcdFx0c3R5bGVzLmZvckVhY2goc3R5bGUgPT4ge1xuXHRcdFx0XHRpbWFnZS5yZW1vdmVTdHlsZShzdHlsZS5uYW1lKTtcblxuXHRcdFx0XHRpZiAoc3R5bGUudmVuZG9yUHJlZml4ZXMpIHtcblx0XHRcdFx0XHRzdHlsZS52ZW5kb3JQcmVmaXhlcy5mb3JFYWNoKHZlbmRvclByZWZpeCA9PiB7XG5cdFx0XHRcdFx0XHRpbWFnZS5yZW1vdmVTdHlsZSh2ZW5kb3JQcmVmaXggKyBzdHlsZS5uYW1lKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBhbGlnbm1lbnQgdmFsdWUgb2YgYW4gaW1hZ2Vcblx0ICpcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gaW1hZ2UgVGhlIGltYWdlIGVsZW1lbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IGltYWdlQWxpZ25tZW50IFRoZSBpbWFnZSBhbGlnbm1lbnQgdmFsdWUgdG8gYmUgc2V0XG5cdCAqL1xuXHRjb25zdCBzZXRJbWFnZUFsaWdubWVudCA9IGZ1bmN0aW9uKGltYWdlLCBpbWFnZUFsaWdubWVudCkge1xuXHRcdHJlbW92ZUltYWdlQWxpZ25tZW50KGltYWdlLCBnZXRJbWFnZUFsaWdubWVudChpbWFnZSkpO1xuXG5cdFx0Y29uc3Qgc3R5bGVzID0gSU1BR0VfU1RZTEVfQUxJR05NRU5UW2ltYWdlQWxpZ25tZW50XTtcblxuXHRcdGlmIChzdHlsZXMpIHtcblx0XHRcdHN0eWxlcy5mb3JFYWNoKHN0eWxlID0+IHtcblx0XHRcdFx0aW1hZ2Uuc2V0U3R5bGUoc3R5bGUubmFtZSwgc3R5bGUudmFsdWUpO1xuXG5cdFx0XHRcdGlmIChzdHlsZS52ZW5kb3JQcmVmaXhlcykge1xuXHRcdFx0XHRcdHN0eWxlLnZlbmRvclByZWZpeGVzLmZvckVhY2godmVuZG9yUHJlZml4ID0+IHtcblx0XHRcdFx0XHRcdGltYWdlLnNldFN0eWxlKHZlbmRvclByZWZpeCArIHN0eWxlLm5hbWUsIHN0eWxlLnZhbHVlKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gd2hpY2ggbW9kaWZpZXMgdGhlIGp1c3RpZnkgY29tbWFuZHMgdG8gcHJvcGVybHkgYWxpZ24gaW1hZ2VzLiBUaGlzXG5cdCAqIHBsdWdpbiBpcyBhbiBleGNlcnB0IG9mIENLRWRpdG9yJ3Mgb3JpZ2luYWwgaW1hZ2Ugb25lIHRoYXQgY2FuIGJlIGZvdW5kIGF0XG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ja2VkaXRvci9ja2VkaXRvci1kZXYvYmxvYi9tYXN0ZXIvcGx1Z2lucy9pbWFnZS9wbHVnaW4uanNcblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfaW1hZ2VhbGlnbm1lbnRcblx0ICovXG5cdENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV9pbWFnZWFsaWdubWVudCcsIHtcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXphdGlvbiBvZiB0aGUgcGx1Z2luLCBwYXJ0IG9mIENLRWRpdG9yIHBsdWdpbiBsaWZlY3ljbGUuXG5cdFx0ICogVGhlIGZ1bmN0aW9uIHJlZ2lzdGVycyBhICdwYXN0ZScgZXZlbnQgb24gdGhlIGVkaXRpbmcgYXJlYS5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgYWZ0ZXJJbml0XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2Vcblx0XHQgKi9cblx0XHRhZnRlckluaXQoZWRpdG9yKSB7XG5cdFx0XHRjb25zdCBzZWxmID0gdGhpcztcblxuXHRcdFx0QUxJR05fVkFMVUVTLmZvckVhY2godmFsdWUgPT4ge1xuXHRcdFx0XHRjb25zdCBjb21tYW5kID0gZWRpdG9yLmdldENvbW1hbmQoJ2p1c3RpZnknICsgdmFsdWUpO1xuXG5cdFx0XHRcdGlmIChjb21tYW5kKSB7XG5cdFx0XHRcdFx0Y29tbWFuZC5vbignZXhlYycsIGV2ZW50ID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uRGF0YSgpO1xuXG5cdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdHNlbGVjdGlvbkRhdGEgJiZcblx0XHRcdFx0XHRcdFx0U2VsZWN0aW9uVGVzdC5pbWFnZSh7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YToge3NlbGVjdGlvbkRhdGF9LFxuXHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGltYWdlID0gc2VsZWN0aW9uRGF0YS5lbGVtZW50O1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGltYWdlQWxpZ25tZW50ID0gZ2V0SW1hZ2VBbGlnbm1lbnQoaW1hZ2UpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChpbWFnZUFsaWdubWVudCA9PT0gdmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRyZW1vdmVJbWFnZUFsaWdubWVudChpbWFnZSwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHNldEltYWdlQWxpZ25tZW50KGltYWdlLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRldmVudC5jYW5jZWwoKTtcblxuXHRcdFx0XHRcdFx0XHRzZWxmLnJlZnJlc2hDb21tYW5kcyhcblx0XHRcdFx0XHRcdFx0XHRlZGl0b3IsXG5cdFx0XHRcdFx0XHRcdFx0bmV3IENLRURJVE9SLmRvbS5lbGVtZW50UGF0aChpbWFnZSlcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGNvbW1hbmQub24oJ3JlZnJlc2gnLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uRGF0YSA9IHtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudDogZXZlbnQuZGF0YS5wYXRoLmxhc3RFbGVtZW50LFxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRTZWxlY3Rpb25UZXN0LmltYWdlKHtcblx0XHRcdFx0XHRcdFx0XHRkYXRhOiB7c2VsZWN0aW9uRGF0YX0sXG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgaW1hZ2VBbGlnbm1lbnQgPSBnZXRJbWFnZUFsaWdubWVudChcblx0XHRcdFx0XHRcdFx0XHRzZWxlY3Rpb25EYXRhLmVsZW1lbnRcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFN0YXRlKFxuXHRcdFx0XHRcdFx0XHRcdGltYWdlQWxpZ25tZW50ID09PSB2YWx1ZVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBDS0VESVRPUi5UUklTVEFURV9PTlxuXHRcdFx0XHRcdFx0XHRcdFx0OiBDS0VESVRPUi5UUklTVEFURV9PRkZcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRldmVudC5jYW5jZWwoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZvcmNlcyBhIHJlZnJlc2ggb2YgdGhlIG1vZGlmaWVkIGp1c3RpZnkgY29tbWFuZHMuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGFwcGxpZWQgY2hhbmdlc1xuXHRcdCAqIGRvIG5vdCBtb2RpZnkgdGhlIHNlbGVjdGlvbiwgc28gdGhlIHJlZnJlc2ggaXMgbmV2ZXIgdHJpZ2dlcmVkIGFuZCB0aGUgVUkgZG9lcyBub3QgdXBkYXRlXG5cdFx0ICogcHJvcGVybHkgdW50aWwgdGhlIG5leHQgc2VsZWN0aW9uQ2hhbmdlIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9IGVkaXRvciBUaGUgZWRpdG9yIGluc3RhbmNlXG5cdFx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudFBhdGh9IGVsZW1lbnRQYXRoIFRoZSBwYXRoIG9mIHRoZSBzZWxlY3RlZCBpbWFnZVxuXHRcdCAqL1xuXHRcdHJlZnJlc2hDb21tYW5kcyhlZGl0b3IsIGVsZW1lbnRQYXRoKSB7XG5cdFx0XHRBTElHTl9WQUxVRVMuZm9yRWFjaCh2YWx1ZSA9PiB7XG5cdFx0XHRcdGNvbnN0IGNvbW1hbmQgPSBlZGl0b3IuZ2V0Q29tbWFuZCgnanVzdGlmeScgKyB2YWx1ZSk7XG5cblx0XHRcdFx0aWYgKGNvbW1hbmQpIHtcblx0XHRcdFx0XHRjb21tYW5kLnJlZnJlc2goZWRpdG9yLCBlbGVtZW50UGF0aCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cdH0pO1xufVxuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgJy4vYWRkaW1hZ2VzJztcblxuaW1wb3J0ICcuL2F1dG9saW5rJztcblxuaW1wb3J0ICcuL2F1dG9saXN0JztcblxuaW1wb3J0ICcuL2RyYWdyZXNpemUnO1xuXG5pbXBvcnQgJy4vZHJhZ3Jlc2l6ZV9pZSc7XG5cbmltcG9ydCAnLi9kcmFncmVzaXplX2llMTEnO1xuXG5pbXBvcnQgJy4vZW1iZWQnO1xuaW1wb3J0IGVtYmVkdXJsIGZyb20gJy4vZW1iZWR1cmwnO1xuXG5pbXBvcnQgJy4vaW1hZ2VhbGlnbm1lbnQnO1xuXG5pbXBvcnQgJy4vcGFzdGVpbWFnZXMnO1xuXG5pbXBvcnQgJy4vcGxhY2Vob2xkZXInO1xuXG5pbXBvcnQgJy4vc2VsZWN0aW9ua2V5c3Ryb2tlcyc7XG5cbmltcG9ydCAnLi90YWJsZXJlc2l6ZSc7XG5cbmltcG9ydCAnLi90YWJsZXRvb2xzJztcblxuZXhwb3J0IHtlbWJlZHVybH07XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3Bhc3RlaW1hZ2VzJykpIHtcblx0LyoqXG5cdCAqIENLRWRpdG9yIHBsdWdpbiB3aGljaCBhbGxvd3MgcGFzdGluZyBpbWFnZXMgZGlyZWN0bHkgaW50byB0aGUgZWRpdGFibGUgYXJlYS4gVGhlIGltYWdlIHdpbGwgYmUgZW5jb2RlZFxuXHQgKiBhcyBEYXRhIFVSSS4gQW4gZXZlbnQgYGJlZm9yZUltYWdlQWRkYCB3aWxsIGJlIGZpcmVkIHdpdGggdGhlIGxpc3Qgb2YgcGFzdGVkIGltYWdlcy4gSWYgYW55IG9mIHRoZSBsaXN0ZW5lcnNcblx0ICogcmV0dXJucyBgZmFsc2VgIG9yIGNhbmNlbHMgdGhlIGV2ZW50LCB0aGUgaW1hZ2VzIHdvbid0IGJlIGFkZGVkIHRvIHRoZSBjb250ZW50LiBPdGhlcndpc2UsXG5cdCAqIGFuIGV2ZW50IGBpbWFnZUFkZGAgd2lsbCBiZSBmaXJlZCB3aXRoIHRoZSBpbnNlcnRlZCBlbGVtZW50IGludG8gdGhlIGVkaXRhYmxlIGFyZWEuXG5cdCAqXG5cdCAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX3Bhc3RlaW1hZ2VzXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBGaXJlZCBiZWZvcmUgYWRkaW5nIGltYWdlcyB0byB0aGUgZWRpdG9yLlxuXHQgKiBAZXZlbnQgYmVmb3JlSW1hZ2VBZGRcblx0ICogQHBhcmFtIHtBcnJheX0gaW1hZ2VGaWxlcyBBcnJheSBvZiBpbWFnZSBmaWxlc1xuXHQgKi9cblxuXHQvKipcblx0ICogRmlyZWQgd2hlbiBhbiBpbWFnZSBpcyBiZWluZyBhZGRlZCB0byB0aGUgZWRpdG9yIHN1Y2Nlc3NmdWxseS5cblx0ICpcblx0ICogQGV2ZW50IGltYWdlQWRkXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGVsIFRoZSBjcmVhdGVkIGltYWdlIHdpdGggc3JjIGFzIERhdGEgVVJJXG5cdCAqIEBwYXJhbSB7RmlsZX0gZmlsZSBUaGUgaW1hZ2UgZmlsZVxuXHQgKi9cblxuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfcGFzdGVpbWFnZXMnLCB7XG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS0VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuXHRcdCAqIFRoZSBmdW5jdGlvbiByZWdpc3RlcnMgYSAncGFzdGUnIGV2ZW50IG9uIHRoZSBlZGl0aW5nIGFyZWEuXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIGluaXRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuXHRcdCAqL1xuXHRcdGluaXQoZWRpdG9yKSB7XG5cdFx0XHRlZGl0b3Iub25jZSgnY29udGVudERvbScsICgpID0+IHtcblx0XHRcdFx0Y29uc3QgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuXHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0XHRlZGl0YWJsZSxcblx0XHRcdFx0XHQncGFzdGUnLFxuXHRcdFx0XHRcdHRoaXMuX29uUGFzdGUsXG5cdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRlZGl0b3IsXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBmdW5jdGlvbiBjcmVhdGVzIGFuIGltZyBlbGVtZW50IHdpdGggc3JjIHRoZSBpbWFnZSBkYXRhIGFzIERhdGEgVVJJLlxuXHRcdCAqIFRoZW4sIGl0IGZpcmVzIGFuICdpbWFnZUFkZCcgZXZlbnQgdmlhIENLRWRpdG9yJ3MgZXZlbnQgc3lzdGVtLiBUaGUgcGFzc2VkXG5cdFx0ICogcGFyYW1zIHdpbGwgYmU6XG5cdFx0ICogLSBgZWxgIC0gdGhlIGNyZWF0ZWQgaW1nIGVsZW1lbnRcblx0XHQgKiAtIGBmaWxlYCAtIHRoZSBvcmlnaW5hbCBwYXN0ZWQgZGF0YVxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBfb25QYXN0ZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5ldmVudH0gZXZlbnQgQSBgcGFzdGVgIGV2ZW50LCBhcyByZWNlaXZlZCBuYXRpdmVseSBmcm9tIENLRWRpdG9yXG5cdFx0ICovXG5cdFx0X29uUGFzdGUoZXZlbnQpIHtcblx0XHRcdGlmIChldmVudC5kYXRhLiQuY2xpcGJvYXJkRGF0YSkge1xuXHRcdFx0XHRjb25zdCBwYXN0ZWREYXRhID0gZXZlbnQuZGF0YS4kLmNsaXBib2FyZERhdGEuaXRlbXNbMF07XG5cdFx0XHRcdGNvbnN0IGVkaXRvciA9IGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3I7XG5cblx0XHRcdFx0aWYgKHBhc3RlZERhdGEudHlwZS5pbmRleE9mKCdpbWFnZScpID09PSAwKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRcdFx0XHRjb25zdCBpbWFnZUZpbGUgPSBwYXN0ZWREYXRhLmdldEFzRmlsZSgpO1xuXG5cdFx0XHRcdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdFx0XHRjb25zdCByZXN1bHQgPSBlZGl0b3IuZmlyZSgnYmVmb3JlSW1hZ2VBZGQnLCB7XG5cdFx0XHRcdFx0XHRcdGltYWdlRmlsZXM6IGltYWdlRmlsZSxcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGVsID0gQ0tFRElUT1IuZG9tLmVsZW1lbnQuY3JlYXRlRnJvbUh0bWwoXG5cdFx0XHRcdFx0XHRcdFx0JzxpbWcgc3JjPVwiJyArIGV2ZW50LnRhcmdldC5yZXN1bHQgKyAnXCI+J1xuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdGVkaXRvci5pbnNlcnRFbGVtZW50KGVsKTtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBpbWFnZURhdGEgPSB7XG5cdFx0XHRcdFx0XHRcdFx0ZWwsXG5cdFx0XHRcdFx0XHRcdFx0ZmlsZTogaW1hZ2VGaWxlLFxuXHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdGVkaXRvci5maXJlKCdpbWFnZUFkZCcsIGltYWdlRGF0YSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdHJlYWRlci5yZWFkQXNEYXRhVVJMKGltYWdlRmlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHR9KTtcbn1cbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfcGxhY2Vob2xkZXInKSkge1xuXHQvKipcblx0ICogQ0tFRElUT1IgZW50ZXJNb2RlIGNvbmZpZyBzZXQgdGhlIGJlaGF2aW9yIG9mIHBhcmFncmFwaHNcblx0ICogV2hlbiB0aGUgY29udGVudCBpcyBlbXB0eSBDS0VESVRPUiBrZWVwcyB0aGUgZW50ZXJNb2RlIHN0cmluZ1xuXHQgKiBpbnRvIHRoZSBjb250ZW50XG5cdCAqIEBwcm9wZXJ0eVxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0Y29uc3QgYnJGaWxsZXIgPSBDS0VESVRPUi5lbnYubmVlZHNCckZpbGxlciA/ICc8YnI+JyA6ICcnO1xuXG5cdGNvbnN0IGVudGVyTW9kZUVtcHR5VmFsdWUgPSB7XG5cdFx0MTogWyc8cD4nICsgYnJGaWxsZXIgKyAnPC9wPiddLFxuXHRcdDI6IFsnJywgJyAnLCBickZpbGxlcl0sXG5cdFx0MzogWyc8ZGl2PicgKyBickZpbGxlciArICc8L2Rpdj4nXSxcblx0fTtcblxuXHQvKipcblx0ICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIGFsbG93cyBhZGRpbmcgYSBwbGFjZWhvbGRlciB0byB0aGUgZWRpdG9yLiBJbiB0aGlzIGNhc2UsIGlmIHRoZXJlXG5cdCAqIGlzIG5vIGNvbnRlbnQgdG8gdGhlIGVkaXRvciwgdGhlcmUgd2lsbCBiZSBoaW50IHRvIHRoZSB1c2VyLlxuXHQgKlxuXHQgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9wbGFjZWhvbGRlclxuXHQgKi9cblxuXHQvKipcblx0ICogU3BlY2lmaWVzIHRoZSBwbGFjZWhvbGRlciBjbGFzcyB3aGljaCBoYXZlIHRvIGJlIGFkZWQgdG8gZWRpdG9yIHdoZW4gZWRpdG9yIGlzIG5vdCBmb2N1c2VkLlxuXHQgKlxuXHQgKiBAYXR0cmlidXRlIHBsYWNlaG9sZGVyQ2xhc3Ncblx0ICogQGRlZmF1bHQgYWVfcGxhY2Vob2xkZXJcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqL1xuXG5cdENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV9wbGFjZWhvbGRlcicsIHtcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXphdGlvbiBvZiB0aGUgcGx1Z2luLCBwYXJ0IG9mIENLRWRpdG9yIHBsdWdpbiBsaWZlY3ljbGUuXG5cdFx0ICogVGhlIGZ1bmN0aW9uIHJlZ2lzdGVycyBhICdibHVyJyBhbmQgJ2NvbnRlbnREb20nIGV2ZW50IGxpc3RlbmVycy5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgaW5pdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG5cdFx0ICovXG5cdFx0aW5pdChlZGl0b3IpIHtcblx0XHRcdGVkaXRvci5vbignYmx1cicsIHRoaXMuX2NoZWNrRW1wdHlEYXRhLCB0aGlzKTtcblx0XHRcdGVkaXRvci5vbignY2hhbmdlJywgdGhpcy5fY2hlY2tFbXB0eURhdGEsIHRoaXMpO1xuXHRcdFx0ZWRpdG9yLm9uKCdmb2N1cycsIHRoaXMuX3JlbW92ZVBsYWNlaG9sZGVyQ2xhc3MsIHRoaXMpO1xuXHRcdFx0ZWRpdG9yLm9uY2UoJ2NvbnRlbnREb20nLCB0aGlzLl9jaGVja0VtcHR5RGF0YSwgdGhpcyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgYW55IGRhdGEgZnJvbSB0aGUgY29udGVudCBhbmQgYWRkcyBhIGNsYXNzLFxuXHRcdCAqIHNwZWNpZmllZCBieSB0aGUgXCJwbGFjZWhvbGRlckNsYXNzXCIgY29uZmlnIGF0dHJpYnV0ZS5cblx0XHQgKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAbWV0aG9kIF9jaGVja0VtcHR5RGF0YVxuXHRcdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmV2ZW50fSBlZGl0b3IgZXZlbnQsIGZpcmVkIGZyb20gQ0tFZGl0b3Jcblx0XHQgKi9cblx0XHRfY2hlY2tFbXB0eURhdGEoZXZlbnQpIHtcblx0XHRcdGNvbnN0IGVkaXRvciA9IGV2ZW50LmVkaXRvcjtcblxuXHRcdFx0Y29uc3QgZWRpdGFibGVOb2RlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdGNvbnN0IGlubmVySHRtbCA9IGVkaXRhYmxlTm9kZS4kLmlubmVySFRNTC50cmltKCk7XG5cblx0XHRcdGNvbnN0IGlzRW1wdHkgPSBlbnRlck1vZGVFbXB0eVZhbHVlW2VkaXRvci5jb25maWcuZW50ZXJNb2RlXS5zb21lKFxuXHRcdFx0XHRlbGVtZW50ID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gaW5uZXJIdG1sID09PSBlbGVtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXG5cdFx0XHRpZiAoaXNFbXB0eSkge1xuXHRcdFx0XHRlZGl0YWJsZU5vZGUuYWRkQ2xhc3MoZWRpdG9yLmNvbmZpZy5wbGFjZWhvbGRlckNsYXNzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVkaXRhYmxlTm9kZS5yZW1vdmVDbGFzcyhlZGl0b3IuY29uZmlnLnBsYWNlaG9sZGVyQ2xhc3MpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcbiAgICAgICAgICAgICAqIFJlbW92ZSBwbGFjZWhvbGRlciBjbGFzcyB3aGVuIGlucHV0IGlzIGZvY3VzZWRcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9yZW1vdmVQbGFjZWhvbGRlckNsYXNzXG4gICAgICAgICAgICAgKyBAcGFyYW0ge0NLRURJVE9SLmRvbS5ldmVudH0gZWRpdG9yIGV2ZW50LCBmaXJlZCBmcm9tIENLRWRpdG9yXG4gICAgICAgICAgICAgKi9cblx0XHRfcmVtb3ZlUGxhY2Vob2xkZXJDbGFzcyhldmVudCkge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gZXZlbnQuZWRpdG9yO1xuXG5cdFx0XHRjb25zdCBlZGl0b3JOb2RlID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGVkaXRvci5lbGVtZW50LiQpO1xuXG5cdFx0XHRlZGl0b3JOb2RlLnJlbW92ZUNsYXNzKGVkaXRvci5jb25maWcucGxhY2Vob2xkZXJDbGFzcyk7XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbi8qKlxuICogUHJpb3JpdGllcyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIG9yZGVyIGluIHdoaWNoIGV2ZW50IGhhbmRsZXJzIHJ1bi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vY2tlZGl0b3IuY29tL2RvY3MvY2tlZGl0b3I0L2xhdGVzdC9hcGkvQ0tFRElUT1JfZXZlbnQuaHRtbCNtZXRob2Qtb25cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUFJJT1JJVFkgPSAxMDtcbmV4cG9ydCBjb25zdCBISUdIX1BSSU9SSVRZID0gNTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfc2VsZWN0aW9ua2V5c3Ryb2tlcycpKSB7XG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gdGhhdCBzaW11bGF0ZXMgZWRpdG9yIGludGVyYWN0aW9uIGV2ZW50cyBiYXNlZCBvbiBtYW51YWwga2V5c3Ryb2tlcy4gVGhpc1xuXHQgKiBjYW4gYmUgdXNlZCB0byB0cmlnZ2VyIGRpZmZlcmVudCByZWFjdGlvbnMgaW4gdGhlIGVkaXRvci5cblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfc2VsZWN0aW9ua2V5c3Ryb2tlc1xuXHQgKi9cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX3NlbGVjdGlvbmtleXN0cm9rZXMnLCB7XG5cdFx0cmVxdWlyZXM6ICdhZV9zZWxlY3Rpb25yZWdpb24nLFxuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS0VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuXHRcdCAqIFRoZSBmdW5jdGlvbiBhZGRzIGEgY29tbWFuZCB0byB0aGUgZWRpdG9yIGZvciBldmVyeSBkZWZpbmVkIHNlbGVjdGlvbktleXN0cm9rZVxuXHRcdCAqIGluIHRoZSBjb25maWd1cmF0aW9uIGFuZCBtYXBzIGl0IHRvIHRoZSBzcGVjaWZpZWQga2V5c3Ryb2tlLlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBpbml0XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2Vcblx0XHQgKi9cblx0XHRpbml0KGVkaXRvcikge1xuXHRcdFx0aWYgKGVkaXRvci5jb25maWcuc2VsZWN0aW9uS2V5c3Ryb2tlcykge1xuXHRcdFx0XHRlZGl0b3IuY29uZmlnLnNlbGVjdGlvbktleXN0cm9rZXMuZm9yRWFjaChcblx0XHRcdFx0XHRzZWxlY3Rpb25LZXlzdHJva2UgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgY29tbWFuZCA9IG5ldyBDS0VESVRPUi5jb21tYW5kKGVkaXRvciwge1xuXHRcdFx0XHRcdFx0XHRleGVjKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0XHRcdGVkaXRvci5maXJlKCdlZGl0b3JJbnRlcmFjdGlvbicsIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1hbnVhbFNlbGVjdGlvbjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uS2V5c3Ryb2tlLnNlbGVjdGlvbixcblx0XHRcdFx0XHRcdFx0XHRcdG5hdGl2ZUV2ZW50OiB7fSxcblx0XHRcdFx0XHRcdFx0XHRcdHNlbGVjdGlvbkRhdGE6IGVkaXRvci5nZXRTZWxlY3Rpb25EYXRhKCksXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgY29tbWFuZE5hbWUgPVxuXHRcdFx0XHRcdFx0XHQnc2VsZWN0aW9uS2V5c3Ryb2tlJyArIHNlbGVjdGlvbktleXN0cm9rZS5zZWxlY3Rpb247XG5cblx0XHRcdFx0XHRcdGVkaXRvci5hZGRDb21tYW5kKGNvbW1hbmROYW1lLCBjb21tYW5kKTtcblx0XHRcdFx0XHRcdGVkaXRvci5zZXRLZXlzdHJva2UoXG5cdFx0XHRcdFx0XHRcdHNlbGVjdGlvbktleXN0cm9rZS5rZXlzLFxuXHRcdFx0XHRcdFx0XHRjb21tYW5kTmFtZVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMTUsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwOi8vY2tlZGl0b3IuY29tL2xpY2Vuc2VcbiAqL1xuXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV90YWJsZXJlc2l6ZScpKSB7XG5cdGNvbnN0IHB4VW5pdCA9IENLRURJVE9SLnRvb2xzLmNzc0xlbmd0aDtcblxuXHRmdW5jdGlvbiBnZXRXaWR0aChlbCkge1xuXHRcdHJldHVybiBDS0VESVRPUi5lbnYuaWVcblx0XHRcdD8gZWwuJC5jbGllbnRXaWR0aFxuXHRcdFx0OiBwYXJzZUludChlbC5nZXRDb21wdXRlZFN0eWxlKCd3aWR0aCcpLCAxMCk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRCb3JkZXJXaWR0aChlbGVtZW50LCBzaWRlKSB7XG5cdFx0bGV0IGNvbXB1dGVkID0gZWxlbWVudC5nZXRDb21wdXRlZFN0eWxlKCdib3JkZXItJyArIHNpZGUgKyAnLXdpZHRoJyk7XG5cblx0XHRjb25zdCBib3JkZXJNYXAgPSB7XG5cdFx0XHR0aGluOiAnMHB4Jyxcblx0XHRcdG1lZGl1bTogJzFweCcsXG5cdFx0XHR0aGljazogJzJweCcsXG5cdFx0fTtcblxuXHRcdGlmIChjb21wdXRlZC5pbmRleE9mKCdweCcpIDwgMCkge1xuXHRcdFx0Ly8gbG9vayB1cCBrZXl3b3Jkc1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRjb21wdXRlZCBpbiBib3JkZXJNYXAgJiZcblx0XHRcdFx0ZWxlbWVudC5nZXRDb21wdXRlZFN0eWxlKCdib3JkZXItc3R5bGUnKSAhPSAnbm9uZSdcblx0XHRcdCkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGJvcmRlck1hcFtjb21wdXRlZF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb21wdXRlZCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhcnNlSW50KGNvbXB1dGVkLCAxMCk7XG5cdH1cblxuXHQvLyBHZXRzIHRoZSB0YWJsZSByb3cgdGhhdCBjb250YWlucyB0aGUgbW9zdCBjb2x1bW5zLlxuXHRmdW5jdGlvbiBnZXRNYXN0ZXJQaWxsYXJSb3codGFibGUpIHtcblx0XHRjb25zdCAkcm93cyA9IHRhYmxlLiQucm93cztcblxuXHRcdGxldCBtYXhDZWxscyA9IDA7XG5cblx0XHRsZXQgY2VsbHNDb3VudDtcblxuXHRcdGxldCAkZWxlY3RlZDtcblxuXHRcdGxldCAkdHI7XG5cblx0XHRmb3IgKGxldCBpID0gMCwgbGVuID0gJHJvd3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdCR0ciA9ICRyb3dzW2ldO1xuXHRcdFx0Y2VsbHNDb3VudCA9ICR0ci5jZWxscy5sZW5ndGg7XG5cblx0XHRcdGlmIChjZWxsc0NvdW50ID4gbWF4Q2VsbHMpIHtcblx0XHRcdFx0bWF4Q2VsbHMgPSBjZWxsc0NvdW50O1xuXHRcdFx0XHQkZWxlY3RlZCA9ICR0cjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gJGVsZWN0ZWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBidWlsZFRhYmxlQ29sdW1uUGlsbGFycyh0YWJsZSkge1xuXHRcdGNvbnN0IHBpbGxhcnMgPSBbXTtcblxuXHRcdGxldCBwaWxsYXJJbmRleCA9IC0xO1xuXG5cdFx0Y29uc3QgcnRsID0gdGFibGUuZ2V0Q29tcHV0ZWRTdHlsZSgnZGlyZWN0aW9uJykgPT09ICdydGwnO1xuXG5cdFx0Ly8gR2V0IHRoZSByYXcgcm93IGVsZW1lbnQgdGhhdCBjb2ludGFpbnMgdGhlIG1vc3QgY29sdW1ucy5cblx0XHRjb25zdCAkdHIgPSBnZXRNYXN0ZXJQaWxsYXJSb3codGFibGUpO1xuXG5cdFx0Ly8gR2V0IHRoZSB0Ym9keSBlbGVtZW50IGFuZCBwb3NpdGlvbiwgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHNldCB0aGVcblx0XHQvLyB0b3AgYW5kIGJvdHRvbSBib3VuZGFyaWVzLlxuXHRcdGNvbnN0IHRib2R5ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHRhYmxlLiQudEJvZGllc1swXSk7XG5cblx0XHRjb25zdCB0Ym9keVBvc2l0aW9uID0gdGJvZHkuZ2V0RG9jdW1lbnRQb3NpdGlvbigpO1xuXG5cdFx0Ly8gTG9vcCB0aG9ydWdoIGFsbCBjZWxscywgYnVpbGRpbmcgcGlsbGFycyBhZnRlciBlYWNoIG9uZSBvZiB0aGVtLlxuXHRcdGZvciAobGV0IGkgPSAwLCBsZW4gPSAkdHIuY2VsbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdC8vIEJvdGggdGhlIGN1cnJlbnQgY2VsbCBhbmQgdGhlIHN1Y2Nlc3NpdmUgb25lIHdpbGwgYmUgdXNlZCBpbiB0aGVcblx0XHRcdC8vIHBpbGxhciBzaXplIGNhbGN1bGF0aW9uLlxuXHRcdFx0Y29uc3QgdGQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoJHRyLmNlbGxzW2ldKTtcblxuXHRcdFx0Y29uc3QgbmV4dFRkID1cblx0XHRcdFx0JHRyLmNlbGxzW2kgKyAxXSAmJiBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoJHRyLmNlbGxzW2kgKyAxXSk7XG5cblx0XHRcdHBpbGxhckluZGV4ICs9IHRkLiQuY29sU3BhbiB8fCAxO1xuXG5cdFx0XHQvLyBDYWxjdWxhdGUgdGhlIHBpbGxhciBib3VuZGFyeSBwb3NpdGlvbnMuXG5cdFx0XHRsZXQgcGlsbGFyTGVmdDtcblx0XHRcdGxldCBwaWxsYXJSaWdodDtcblxuXHRcdFx0bGV0IHggPSB0ZC5nZXREb2N1bWVudFBvc2l0aW9uKCkueDtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9ucyBiYXNlZCBvbiB0aGUgY3VycmVudCBjZWxsLlxuXHRcdFx0aWYgKHJ0bCkge1xuXHRcdFx0XHRwaWxsYXJSaWdodCA9IHggKyBnZXRCb3JkZXJXaWR0aCh0ZCwgJ2xlZnQnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBpbGxhckxlZnQgPSB4ICsgdGQuJC5vZmZzZXRXaWR0aCAtIGdldEJvcmRlcldpZHRoKHRkLCAncmlnaHQnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9ucyBiYXNlZCBvbiB0aGUgbmV4dCBjZWxsLCBpZiBhdmFpbGFibGUuXG5cdFx0XHRpZiAobmV4dFRkKSB7XG5cdFx0XHRcdHggPSBuZXh0VGQuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLng7XG5cblx0XHRcdFx0aWYgKHJ0bCkge1xuXHRcdFx0XHRcdHBpbGxhckxlZnQgPVxuXHRcdFx0XHRcdFx0eCArXG5cdFx0XHRcdFx0XHRuZXh0VGQuJC5vZmZzZXRXaWR0aCAtXG5cdFx0XHRcdFx0XHRnZXRCb3JkZXJXaWR0aChuZXh0VGQsICdyaWdodCcpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBpbGxhclJpZ2h0ID0geCArIGdldEJvcmRlcldpZHRoKG5leHRUZCwgJ2xlZnQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGNhbGN1bGF0ZSBwb3NpdGlvbnMgYmFzZWQgb24gdGhlIHRhYmxlIChmb3IgbGFzdCBjZWxsKS5cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR4ID0gdGFibGUuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLng7XG5cblx0XHRcdFx0aWYgKHJ0bCkge1xuXHRcdFx0XHRcdHBpbGxhckxlZnQgPSB4O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBpbGxhclJpZ2h0ID0geCArIHRhYmxlLiQub2Zmc2V0V2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcGlsbGFyV2lkdGggPSBNYXRoLm1heChwaWxsYXJSaWdodCAtIHBpbGxhckxlZnQsIDQpO1xuXG5cdFx0XHQvLyBUaGUgcGlsbGFyIHNob3VsZCByZWZsZWN0cyBleGFjdGx5IHRoZSBzaGFwZSBvZiB0aGUgaG92ZXJlZFxuXHRcdFx0Ly8gY29sdW1uIGJvcmRlciBsaW5lLlxuXHRcdFx0cGlsbGFycy5wdXNoKHtcblx0XHRcdFx0dGFibGUsXG5cdFx0XHRcdGluZGV4OiBwaWxsYXJJbmRleCxcblx0XHRcdFx0eDogcGlsbGFyTGVmdCxcblx0XHRcdFx0eTogdGJvZHlQb3NpdGlvbi55LFxuXHRcdFx0XHR3aWR0aDogcGlsbGFyV2lkdGgsXG5cdFx0XHRcdGhlaWdodDogdGJvZHkuJC5vZmZzZXRIZWlnaHQsXG5cdFx0XHRcdHJ0bCxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBwaWxsYXJzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UGlsbGFyQXRQb3NpdGlvbihwaWxsYXJzLCBwb3NpdGlvblgpIHtcblx0XHRmb3IgKGxldCBpID0gMCwgbGVuID0gcGlsbGFycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y29uc3QgcGlsbGFyID0gcGlsbGFyc1tpXTtcblxuXHRcdFx0aWYgKHBvc2l0aW9uWCA+PSBwaWxsYXIueCAmJiBwb3NpdGlvblggPD0gcGlsbGFyLnggKyBwaWxsYXIud2lkdGgpIHtcblx0XHRcdFx0cmV0dXJuIHBpbGxhcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNhbmNlbChldnQpIHtcblx0XHQoZXZ0LmRhdGEgfHwgZXZ0KS5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gQ29sdW1uUmVzaXplcihlZGl0b3IsIHBpbGxhcikge1xuXHRcdGxldCBjdXJyZW50U2hpZnQ7XG5cdFx0bGV0IGxlZnRTaGlmdEJvdW5kYXJ5O1xuXHRcdGxldCBsZWZ0U2lkZUNlbGxzO1xuXHRcdGxldCByZXNpemluZztcblx0XHRsZXQgcmlnaHRTaGlmdEJvdW5kYXJ5O1xuXHRcdGxldCByaWdodFNpZGVDZWxscztcblx0XHRsZXQgc3RhcnRPZmZzZXQ7XG5cblx0XHRjb25zdCBkb2N1bWVudCA9IGVkaXRvci5kb2N1bWVudDtcblxuXHRcdGNvbnN0IHJlc2l6ZXIgPSBDS0VESVRPUi5kb20uZWxlbWVudC5jcmVhdGVGcm9tSHRtbChcblx0XHRcdCc8ZGl2IGRhdGEtY2tlLXRlbXA9MSBjb250ZW50ZWRpdGFibGU9ZmFsc2UgdW5zZWxlY3RhYmxlPW9uICcgK1xuXHRcdFx0XHQnc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTtjdXJzb3I6Y29sLXJlc2l6ZTtmaWx0ZXI6YWxwaGEob3BhY2l0eT0wKTtvcGFjaXR5OjA7JyArXG5cdFx0XHRcdCdwYWRkaW5nOjA7YmFja2dyb3VuZC1jb2xvcjojMDA0O2JhY2tncm91bmQtaW1hZ2U6bm9uZTtib3JkZXI6MHB4IG5vbmU7ei1pbmRleDoxMFwiPjwvZGl2PicsXG5cdFx0XHRkb2N1bWVudFxuXHRcdCk7XG5cblx0XHRjb25zdCBpc1Jlc2l6aW5nID0gKHRoaXMuaXNSZXNpemluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHJlc2l6aW5nO1xuXHRcdH0pO1xuXG5cdFx0Y29uc3QgbW92ZSA9ICh0aGlzLm1vdmUgPSBmdW5jdGlvbihwb3NYKSB7XG5cdFx0XHRsZXQgcmVzaXplck5ld1Bvc2l0aW9uID1cblx0XHRcdFx0cG9zWCAtIE1hdGgucm91bmQocmVzaXplci4kLm9mZnNldFdpZHRoIC8gMik7XG5cblx0XHRcdGlmIChpc1Jlc2l6aW5nKSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZXNpemVyTmV3UG9zaXRpb24gPT09IGxlZnRTaGlmdEJvdW5kYXJ5IHx8XG5cdFx0XHRcdFx0cmVzaXplck5ld1Bvc2l0aW9uID09PSByaWdodFNoaWZ0Qm91bmRhcnlcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzaXplck5ld1Bvc2l0aW9uID0gTWF0aC5tYXgoXG5cdFx0XHRcdFx0cmVzaXplck5ld1Bvc2l0aW9uLFxuXHRcdFx0XHRcdGxlZnRTaGlmdEJvdW5kYXJ5XG5cdFx0XHRcdCk7XG5cdFx0XHRcdHJlc2l6ZXJOZXdQb3NpdGlvbiA9IE1hdGgubWluKFxuXHRcdFx0XHRcdHJlc2l6ZXJOZXdQb3NpdGlvbixcblx0XHRcdFx0XHRyaWdodFNoaWZ0Qm91bmRhcnlcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRjdXJyZW50U2hpZnQgPSByZXNpemVyTmV3UG9zaXRpb24gLSBzdGFydE9mZnNldDtcblx0XHRcdH1cblxuXHRcdFx0cmVzaXplci5zZXRTdHlsZSgnbGVmdCcsIHB4VW5pdChyZXNpemVyTmV3UG9zaXRpb24pKTtcblx0XHR9KTtcblxuXHRcdGZ1bmN0aW9uIGRldGFjaCgpIHtcblx0XHRcdHJlc2l6ZXIucmVtb3ZlTGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuXHRcdFx0cmVzaXplci5yZW1vdmVMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuXHRcdFx0cmVzaXplci5yZW1vdmVMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc2l6ZVN0YXJ0KCkge1xuXHRcdFx0Ly8gQmVmb3JlIHN0YXJ0aW5nIHRvIHJlc2l6ZSwgZmlndXJlIG91dCB3aGljaCBjZWxscyB0byBjaGFuZ2Vcblx0XHRcdC8vIGFuZCB0aGUgYm91bmRhcmllcyBvZiB0aGlzIHJlc2l6aW5nIHNoaWZ0LlxuXG5cdFx0XHRjb25zdCBjb2x1bW5JbmRleCA9IHBpbGxhci5pbmRleDtcblxuXHRcdFx0Y29uc3QgbWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcChwaWxsYXIudGFibGUpO1xuXG5cdFx0XHRjb25zdCBsZWZ0Q29sdW1uQ2VsbHMgPSBbXTtcblxuXHRcdFx0Y29uc3QgcmlnaHRDb2x1bW5DZWxscyA9IFtdO1xuXG5cdFx0XHRsZXQgbGVmdE1pblNpemUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG5cdFx0XHRsZXQgcmlnaHRNaW5TaXplID0gbGVmdE1pblNpemU7XG5cblx0XHRcdGNvbnN0IHJ0bCA9IHBpbGxhci5ydGw7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsZW4gPSBtYXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0Y29uc3Qgcm93ID0gbWFwW2ldO1xuXG5cdFx0XHRcdGxldCBsZWZ0Q2VsbCA9IHJvd1tjb2x1bW5JbmRleCArIChydGwgPyAxIDogMCldO1xuXG5cdFx0XHRcdGxldCByaWdodENlbGwgPSByb3dbY29sdW1uSW5kZXggKyAocnRsID8gMCA6IDEpXTtcblxuXHRcdFx0XHRsZWZ0Q2VsbCA9IGxlZnRDZWxsICYmIG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChsZWZ0Q2VsbCk7XG5cdFx0XHRcdHJpZ2h0Q2VsbCA9IHJpZ2h0Q2VsbCAmJiBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQocmlnaHRDZWxsKTtcblxuXHRcdFx0XHRpZiAoIWxlZnRDZWxsIHx8ICFyaWdodENlbGwgfHwgIWxlZnRDZWxsLmVxdWFscyhyaWdodENlbGwpKSB7XG5cdFx0XHRcdFx0aWYgKGxlZnRDZWxsKSB7XG5cdFx0XHRcdFx0XHRsZWZ0TWluU2l6ZSA9IE1hdGgubWluKGxlZnRNaW5TaXplLCBnZXRXaWR0aChsZWZ0Q2VsbCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocmlnaHRDZWxsKSB7XG5cdFx0XHRcdFx0XHRyaWdodE1pblNpemUgPSBNYXRoLm1pbihcblx0XHRcdFx0XHRcdFx0cmlnaHRNaW5TaXplLFxuXHRcdFx0XHRcdFx0XHRnZXRXaWR0aChyaWdodENlbGwpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxlZnRDb2x1bW5DZWxscy5wdXNoKGxlZnRDZWxsKTtcblx0XHRcdFx0XHRyaWdodENvbHVtbkNlbGxzLnB1c2gocmlnaHRDZWxsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWNoZSB0aGUgbGlzdCBvZiBjZWxscyB0byBiZSByZXNpemVkLlxuXHRcdFx0bGVmdFNpZGVDZWxscyA9IGxlZnRDb2x1bW5DZWxscztcblx0XHRcdHJpZ2h0U2lkZUNlbGxzID0gcmlnaHRDb2x1bW5DZWxscztcblxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHJlc2l6ZSBsaW1pdCBib3VuZGFyaWVzLlxuXHRcdFx0bGVmdFNoaWZ0Qm91bmRhcnkgPSBwaWxsYXIueCAtIGxlZnRNaW5TaXplO1xuXHRcdFx0cmlnaHRTaGlmdEJvdW5kYXJ5ID0gcGlsbGFyLnggKyByaWdodE1pblNpemU7XG5cblx0XHRcdHJlc2l6ZXIuc2V0T3BhY2l0eSgwLjUpO1xuXHRcdFx0c3RhcnRPZmZzZXQgPSBwYXJzZUludChyZXNpemVyLmdldFN0eWxlKCdsZWZ0JyksIDEwKTtcblx0XHRcdGN1cnJlbnRTaGlmdCA9IDA7XG5cdFx0XHRyZXNpemluZyA9IDE7XG5cblx0XHRcdHJlc2l6ZXIub24oJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcblxuXHRcdFx0Ly8gUHJldmVudCB0aGUgbmF0aXZlIGRyYWcgYmVoYXZpb3Igb3RoZXJ3aXNlICdtb3VzZW1vdmUnIHdvbid0IGZpcmUuXG5cdFx0XHRkb2N1bWVudC5vbignZHJhZ3N0YXJ0JywgY2FuY2VsKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXNpemVFbmQoKSB7XG5cdFx0XHRyZXNpemluZyA9IDA7XG5cblx0XHRcdHJlc2l6ZXIuc2V0T3BhY2l0eSgwKTtcblxuXHRcdFx0aWYgKGN1cnJlbnRTaGlmdCkge1xuXHRcdFx0XHRyZXNpemVDb2x1bW4oKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdGFibGUgPSBwaWxsYXIudGFibGU7XG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0dGFibGUucmVtb3ZlQ3VzdG9tRGF0YSgnX2NrZV90YWJsZV9waWxsYXJzJyk7XG5cdFx0XHR9LCAwKTtcblxuXHRcdFx0ZG9jdW1lbnQucmVtb3ZlTGlzdGVuZXIoJ2RyYWdzdGFydCcsIGNhbmNlbCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzaXplQ29sdW1uKCkge1xuXHRcdFx0Y29uc3QgcnRsID0gcGlsbGFyLnJ0bDtcblxuXHRcdFx0Y29uc3QgY2VsbHNDb3VudCA9IHJ0bFxuXHRcdFx0XHQ/IHJpZ2h0U2lkZUNlbGxzLmxlbmd0aFxuXHRcdFx0XHQ6IGxlZnRTaWRlQ2VsbHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBQZXJmb3JtIHRoZSBhY3R1YWwgcmVzaXplIHRvIHRhYmxlIGNlbGxzLCBvbmx5IGZvciB0aG9zZSBieSBzaWRlIG9mIHRoZSBwaWxsYXIuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxzQ291bnQ7IGkrKykge1xuXHRcdFx0XHRjb25zdCBsZWZ0Q2VsbCA9IGxlZnRTaWRlQ2VsbHNbaV07XG5cblx0XHRcdFx0Y29uc3QgcmlnaHRDZWxsID0gcmlnaHRTaWRlQ2VsbHNbaV07XG5cblx0XHRcdFx0Y29uc3QgdGFibGUgPSBwaWxsYXIudGFibGU7XG5cblx0XHRcdFx0Ly8gRGVmZXIgdGhlIHJlc2l6aW5nIHRvIGF2b2lkIGFueSBpbnRlcmZlcmVuY2UgYW1vbmcgY2VsbHMuXG5cdFx0XHRcdENLRURJVE9SLnRvb2xzLnNldFRpbWVvdXQoXG5cdFx0XHRcdFx0KFxuXHRcdFx0XHRcdFx0bGVmdENlbGwsXG5cdFx0XHRcdFx0XHRsZWZ0T2xkV2lkdGgsXG5cdFx0XHRcdFx0XHRyaWdodENlbGwsXG5cdFx0XHRcdFx0XHRyaWdodE9sZFdpZHRoLFxuXHRcdFx0XHRcdFx0dGFibGVXaWR0aCxcblx0XHRcdFx0XHRcdHNpemVTaGlmdFxuXHRcdFx0XHRcdCkgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gMXB4IGlzIHRoZSBtaW5pbXVtIHZhbGlkIHdpZHRoICgjMTE2MjYpLlxuXHRcdFx0XHRcdFx0aWYgKGxlZnRDZWxsKSB7XG5cdFx0XHRcdFx0XHRcdGxlZnRDZWxsLnNldFN0eWxlKFxuXHRcdFx0XHRcdFx0XHRcdCd3aWR0aCcsXG5cdFx0XHRcdFx0XHRcdFx0cHhVbml0KE1hdGgubWF4KGxlZnRPbGRXaWR0aCArIHNpemVTaGlmdCwgMSkpXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAocmlnaHRDZWxsKSB7XG5cdFx0XHRcdFx0XHRcdHJpZ2h0Q2VsbC5zZXRTdHlsZShcblx0XHRcdFx0XHRcdFx0XHQnd2lkdGgnLFxuXHRcdFx0XHRcdFx0XHRcdHB4VW5pdChNYXRoLm1heChyaWdodE9sZFdpZHRoIC0gc2l6ZVNoaWZ0LCAxKSlcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSWYgd2UncmUgaW4gdGhlIGxhc3QgY2VsbCwgd2UgbmVlZCB0byByZXNpemUgdGhlIHRhYmxlIGFzIHdlbGxcblx0XHRcdFx0XHRcdGlmICh0YWJsZVdpZHRoKSB7XG5cdFx0XHRcdFx0XHRcdHRhYmxlLnNldFN0eWxlKFxuXHRcdFx0XHRcdFx0XHRcdCd3aWR0aCcsXG5cdFx0XHRcdFx0XHRcdFx0cHhVbml0KHRhYmxlV2lkdGggKyBzaXplU2hpZnQgKiAocnRsID8gLTEgOiAxKSlcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRsZWZ0Q2VsbCxcblx0XHRcdFx0XHRcdGxlZnRDZWxsICYmIGdldFdpZHRoKGxlZnRDZWxsKSxcblx0XHRcdFx0XHRcdHJpZ2h0Q2VsbCxcblx0XHRcdFx0XHRcdHJpZ2h0Q2VsbCAmJiBnZXRXaWR0aChyaWdodENlbGwpLFxuXHRcdFx0XHRcdFx0KCFsZWZ0Q2VsbCB8fCAhcmlnaHRDZWxsKSAmJlxuXHRcdFx0XHRcdFx0XHRnZXRXaWR0aCh0YWJsZSkgK1xuXHRcdFx0XHRcdFx0XHRcdGdldEJvcmRlcldpZHRoKHRhYmxlLCAnbGVmdCcpICtcblx0XHRcdFx0XHRcdFx0XHRnZXRCb3JkZXJXaWR0aCh0YWJsZSwgJ3JpZ2h0JyksXG5cdFx0XHRcdFx0XHRjdXJyZW50U2hpZnQsXG5cdFx0XHRcdFx0XVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uTW91c2VEb3duKGV2dCkge1xuXHRcdFx0Y2FuY2VsKGV2dCk7XG5cblx0XHRcdHJlc2l6ZVN0YXJ0KCk7XG5cblx0XHRcdGRvY3VtZW50Lm9uKCdtb3VzZXVwJywgb25Nb3VzZVVwLCB0aGlzKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbk1vdXNlVXAoZXZ0KSB7XG5cdFx0XHRldnQucmVtb3ZlTGlzdGVuZXIoKTtcblxuXHRcdFx0cmVzaXplRW5kKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZ0KSB7XG5cdFx0XHRtb3ZlKGV2dC5kYXRhLmdldFBhZ2VPZmZzZXQoKS54KTtcblx0XHR9XG5cblx0XHQvLyBDbGVhbiBET00gd2hlbiBlZGl0b3IgaXMgZGVzdHJveWVkLlxuXHRcdGVkaXRvci5vbignZGVzdHJveScsICgpID0+IHtcblx0XHRcdGRldGFjaCgpO1xuXG5cdFx0XHRyZXNpemVyLnJlbW92ZSgpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gUGxhY2UgdGhlIHJlc2l6ZXIgYWZ0ZXIgYm9keSB0byBwcmV2ZW50IGl0XG5cdFx0Ly8gZnJvbSBiZWluZyBlZGl0YWJsZS5cblx0XHRkb2N1bWVudC5nZXREb2N1bWVudEVsZW1lbnQoKS5hcHBlbmQocmVzaXplcik7XG5cblx0XHRyZXNpemVyLnNldFN0eWxlcyh7XG5cdFx0XHR3aWR0aDogcHhVbml0KHBpbGxhci53aWR0aCksXG5cdFx0XHRoZWlnaHQ6IHB4VW5pdChwaWxsYXIuaGVpZ2h0KSxcblx0XHRcdGxlZnQ6IHB4VW5pdChwaWxsYXIueCksXG5cdFx0XHR0b3A6IHB4VW5pdChwaWxsYXIueSksXG5cdFx0fSk7XG5cblx0XHRyZXNpemVyLm9uKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgdGhpcyk7XG5cblx0XHRkb2N1bWVudC5nZXRCb2R5KCkuc2V0U3R5bGUoJ2N1cnNvcicsICdjb2wtcmVzaXplJyk7XG5cblx0XHQvLyBEaXNwbGF5IHRoZSByZXNpemVyIHRvIHJlY2VpdmUgZXZlbnRzIGJ1dCBkb24ndCBzaG93IGl0LFxuXHRcdC8vIG9ubHkgY2hhbmdlIHRoZSBjdXJzb3IgdG8gcmVzaXphYmxlIHNoYXBlLlxuXHRcdHJlc2l6ZXIuc2hvdygpO1xuXG5cdFx0dGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRkZXRhY2goKTtcblxuXHRcdFx0ZG9jdW1lbnQuZ2V0Qm9keSgpLnNldFN0eWxlKCdjdXJzb3InLCAnYXV0bycpO1xuXG5cdFx0XHRyZXNpemVyLnJlbW92ZSgpO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBjbGVhclBpbGxhcnNDYWNoZShldnQpIHtcblx0XHRjb25zdCB0YXJnZXQgPSBldnQuZGF0YS5nZXRUYXJnZXQoKTtcblxuXHRcdGlmIChldnQubmFtZSA9PT0gJ21vdXNlb3V0Jykge1xuXHRcdFx0Ly8gQnlwYXNzIGludGVyYWwgbW91c2UgbW92ZS5cblx0XHRcdGlmICghdGFyZ2V0LmlzKCd0YWJsZScpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGRlc3QgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoXG5cdFx0XHRcdGV2dC5kYXRhLiQucmVsYXRlZFRhcmdldCB8fCBldnQuZGF0YS4kLnRvRWxlbWVudFxuXHRcdFx0KTtcblx0XHRcdHdoaWxlIChkZXN0ICYmIGRlc3QuJCAmJiAhZGVzdC5lcXVhbHModGFyZ2V0KSAmJiAhZGVzdC5pcygnYm9keScpKSB7XG5cdFx0XHRcdGRlc3QgPSBkZXN0LmdldFBhcmVudCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFkZXN0IHx8IGRlc3QuZXF1YWxzKHRhcmdldCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRhcmdldC5nZXRBc2NlbmRhbnQoJ3RhYmxlJywgMSkucmVtb3ZlQ3VzdG9tRGF0YSgnX2NrZV90YWJsZV9waWxsYXJzJyk7XG5cdFx0ZXZ0LnJlbW92ZUxpc3RlbmVyKCk7XG5cdH1cblxuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfdGFibGVyZXNpemUnLCB7XG5cdFx0cmVxdWlyZXM6ICdhZV90YWJsZXRvb2xzJyxcblxuXHRcdGluaXQoZWRpdG9yKSB7XG5cdFx0XHRlZGl0b3Iub24oJ2NvbnRlbnREb20nLCAoKSA9PiB7XG5cdFx0XHRcdGxldCByZXNpemVyO1xuXG5cdFx0XHRcdGNvbnN0IGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdFx0Ly8gSW4gQ2xhc3NpYyBlZGl0b3IgaXQgaXMgYmV0dGVyIHRvIHVzZSBkb2N1bWVudFxuXHRcdFx0XHQvLyBpbnN0ZWFkIG9mIGVkaXRhYmxlIHNvIGV2ZW50IHdpbGwgd29yayBiZWxvdyBib2R5LlxuXHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0XHRlZGl0YWJsZS5pc0lubGluZSgpID8gZWRpdGFibGUgOiBlZGl0b3IuZG9jdW1lbnQsXG5cdFx0XHRcdFx0J21vdXNlbW92ZScsXG5cdFx0XHRcdFx0ZXZ0ID0+IHtcblx0XHRcdFx0XHRcdGV2dCA9IGV2dC5kYXRhO1xuXG5cdFx0XHRcdFx0XHRjb25zdCB0YXJnZXQgPSBldnQuZ2V0VGFyZ2V0KCk7XG5cblx0XHRcdFx0XHRcdC8vIEZGIG1heSByZXR1cm4gZG9jdW1lbnQgYW5kIElFOCBzb21lIFVGTyAob2JqZWN0IHdpdGggbm8gbm9kZVR5cGUgcHJvcGVydHkuLi4pXG5cdFx0XHRcdFx0XHQvLyBpbnN0ZWFkIG9mIGFuIGVsZW1lbnQgKCMxMTgyMykuXG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0LnR5cGUgIT09IENLRURJVE9SLk5PREVfRUxFTUVOVCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnN0IHBhZ2VYID0gZXZ0LmdldFBhZ2VPZmZzZXQoKS54O1xuXG5cdFx0XHRcdFx0XHQvLyBJZiB3ZSdyZSBhbHJlYWR5IGF0dGFjaGVkIHRvIGEgcGlsbGFyLCBzaW1wbHkgbW92ZSB0aGVcblx0XHRcdFx0XHRcdC8vIHJlc2l6ZXIuXG5cdFx0XHRcdFx0XHRpZiAocmVzaXplcikge1xuXHRcdFx0XHRcdFx0XHRpZiAocmVzaXplci5pc1Jlc2l6aW5nKCkpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNpemVyLm1vdmUocGFnZVgpO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FuY2VsKGV2dCk7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzaXplci5kZXN0cm95KCk7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXNpemVyID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBDb25zaWRlcmluZyB0YWJsZSwgdHIsIHRkLCB0Ym9keSBidXQgbm90aGluZyBlbHNlLlxuXHRcdFx0XHRcdFx0bGV0IHBpbGxhcnM7XG5cblx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0IXRhcmdldC5pcygndGFibGUnKSAmJlxuXHRcdFx0XHRcdFx0XHQhdGFyZ2V0LmdldEFzY2VuZGFudCgndGJvZHknLCAxKVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3QgdGFibGUgPSB0YXJnZXQuZ2V0QXNjZW5kYW50KCd0YWJsZScsIDEpO1xuXG5cdFx0XHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhlIHRhYmxlIHdlIGZvdW5kIGlzIGluc2lkZSB0aGUgY29udGFpbmVyXG5cdFx0XHRcdFx0XHQvLyAoZWcuIHdlIHNob3VsZCBub3QgdXNlIHRhYmxlcyB0aGUgZWRpdG9yIGlzIGVtYmVkZGVkIHdpdGhpbilcblx0XHRcdFx0XHRcdGlmICghZWRpdG9yLmVkaXRhYmxlKCkuY29udGFpbnModGFibGUpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHQhKHBpbGxhcnMgPSB0YWJsZS5nZXRDdXN0b21EYXRhKFxuXHRcdFx0XHRcdFx0XHRcdCdfY2tlX3RhYmxlX3BpbGxhcnMnXG5cdFx0XHRcdFx0XHRcdCkpXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGFibGUgcGlsbGFycyBjYWxjdWxhdGlvbiByZXN1bHQuXG5cdFx0XHRcdFx0XHRcdHRhYmxlLnNldEN1c3RvbURhdGEoXG5cdFx0XHRcdFx0XHRcdFx0J19ja2VfdGFibGVfcGlsbGFycycsXG5cdFx0XHRcdFx0XHRcdFx0KHBpbGxhcnMgPSBidWlsZFRhYmxlQ29sdW1uUGlsbGFycyh0YWJsZSkpXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdHRhYmxlLm9uKCdtb3VzZW91dCcsIGNsZWFyUGlsbGFyc0NhY2hlKTtcblx0XHRcdFx0XHRcdFx0dGFibGUub24oJ21vdXNlZG93bicsIGNsZWFyUGlsbGFyc0NhY2hlKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3QgcGlsbGFyID0gZ2V0UGlsbGFyQXRQb3NpdGlvbihwaWxsYXJzLCBwYWdlWCk7XG5cblx0XHRcdFx0XHRcdGlmIChwaWxsYXIpIHtcblx0XHRcdFx0XHRcdFx0cmVzaXplciA9IG5ldyBDb2x1bW5SZXNpemVyKGVkaXRvciwgcGlsbGFyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHR9KTtcbn1cbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAxNSwgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHA6Ly9ja2VkaXRvci5jb20vbGljZW5zZVxuICovXG5cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3RhYmxldG9vbHMnKSkge1xuXHRjb25zdCBjZWxsTm9kZVJlZ2V4ID0gL14oPzp0ZHx0aCkkLztcblxuXHRmdW5jdGlvbiBnZXRTZWxlY3RlZENlbGxzKHNlbGVjdGlvbikge1xuXHRcdGNvbnN0IHJhbmdlcyA9IHNlbGVjdGlvbi5nZXRSYW5nZXMoKTtcblx0XHRjb25zdCByZXR2YWwgPSBbXTtcblx0XHRjb25zdCBkYXRhYmFzZSA9IHt9O1xuXG5cdFx0ZnVuY3Rpb24gbW92ZU91dE9mQ2VsbEd1YXJkKG5vZGUpIHtcblx0XHRcdC8vIEFwcGx5IHRvIHRoZSBmaXJzdCBjZWxsIG9ubHkuXG5cdFx0XHRpZiAocmV0dmFsLmxlbmd0aCA+IDApIHJldHVybjtcblxuXHRcdFx0Ly8gSWYgd2UgYXJlIGV4aXRpbmcgZnJvbSB0aGUgZmlyc3QgPC90ZD4sIHRoZW4gdGhlIHRkIHNob3VsZCBkZWZpbml0ZWx5IGJlXG5cdFx0XHQvLyBpbmNsdWRlZC5cblx0XHRcdGlmIChcblx0XHRcdFx0bm9kZS50eXBlID09IENLRURJVE9SLk5PREVfRUxFTUVOVCAmJlxuXHRcdFx0XHRjZWxsTm9kZVJlZ2V4LnRlc3Qobm9kZS5nZXROYW1lKCkpICYmXG5cdFx0XHRcdCFub2RlLmdldEN1c3RvbURhdGEoJ3NlbGVjdGVkX2NlbGwnKVxuXHRcdFx0KSB7XG5cdFx0XHRcdENLRURJVE9SLmRvbS5lbGVtZW50LnNldE1hcmtlcihcblx0XHRcdFx0XHRkYXRhYmFzZSxcblx0XHRcdFx0XHRub2RlLFxuXHRcdFx0XHRcdCdzZWxlY3RlZF9jZWxsJyxcblx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdCk7XG5cdFx0XHRcdHJldHZhbC5wdXNoKG5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCByYW5nZSA9IHJhbmdlc1tpXTtcblxuXHRcdFx0aWYgKHJhbmdlLmNvbGxhcHNlZCkge1xuXHRcdFx0XHQvLyBXYWxrZXIgZG9lcyBub3QgaGFuZGxlIGNvbGxhcHNlZCByYW5nZXMgeWV0IC0gZmFsbCBiYWNrIHRvIG9sZCBBUEkuXG5cdFx0XHRcdGNvbnN0IHN0YXJ0Tm9kZSA9IHJhbmdlLmdldENvbW1vbkFuY2VzdG9yKCk7XG5cdFx0XHRcdGNvbnN0IG5lYXJlc3RDZWxsID1cblx0XHRcdFx0XHRzdGFydE5vZGUuZ2V0QXNjZW5kYW50KCd0ZCcsIHRydWUpIHx8XG5cdFx0XHRcdFx0c3RhcnROb2RlLmdldEFzY2VuZGFudCgndGgnLCB0cnVlKTtcblx0XHRcdFx0aWYgKG5lYXJlc3RDZWxsKSByZXR2YWwucHVzaChuZWFyZXN0Q2VsbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCB3YWxrZXIgPSBuZXcgQ0tFRElUT1IuZG9tLndhbGtlcihyYW5nZSk7XG5cdFx0XHRcdGxldCBub2RlO1xuXHRcdFx0XHR3YWxrZXIuZ3VhcmQgPSBtb3ZlT3V0T2ZDZWxsR3VhcmQ7XG5cblx0XHRcdFx0d2hpbGUgKChub2RlID0gd2Fsa2VyLm5leHQoKSkpIHtcblx0XHRcdFx0XHQvLyBJZiBtYXkgYmUgcG9zc2libGUgZm9yIHVzIHRvIGhhdmUgYSByYW5nZSBsaWtlIHRoaXM6XG5cdFx0XHRcdFx0Ly8gPHRkPl4xPC90ZD48dGQ+XjI8L3RkPlxuXHRcdFx0XHRcdC8vIFRoZSAybmQgdGQgc2hvdWxkbid0IGJlIGluY2x1ZGVkLlxuXHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0Ly8gU28gd2UgaGF2ZSB0byB0YWtlIGNhcmUgdG8gaW5jbHVkZSBhIHRkIHdlJ3ZlIGVudGVyZWQgb25seSB3aGVuIHdlJ3ZlXG5cdFx0XHRcdFx0Ly8gd2Fsa2VkIGludG8gaXRzIGNoaWxkcmVuLlxuXG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0bm9kZS50eXBlICE9IENLRURJVE9SLk5PREVfRUxFTUVOVCB8fFxuXHRcdFx0XHRcdFx0IW5vZGUuaXMoQ0tFRElUT1IuZHRkLnRhYmxlKVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgcGFyZW50ID1cblx0XHRcdFx0XHRcdFx0bm9kZS5nZXRBc2NlbmRhbnQoJ3RkJywgdHJ1ZSkgfHxcblx0XHRcdFx0XHRcdFx0bm9kZS5nZXRBc2NlbmRhbnQoJ3RoJywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRpZiAocGFyZW50ICYmICFwYXJlbnQuZ2V0Q3VzdG9tRGF0YSgnc2VsZWN0ZWRfY2VsbCcpKSB7XG5cdFx0XHRcdFx0XHRcdENLRURJVE9SLmRvbS5lbGVtZW50LnNldE1hcmtlcihcblx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZSxcblx0XHRcdFx0XHRcdFx0XHRwYXJlbnQsXG5cdFx0XHRcdFx0XHRcdFx0J3NlbGVjdGVkX2NlbGwnLFxuXHRcdFx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0cmV0dmFsLnB1c2gocGFyZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRDS0VESVRPUi5kb20uZWxlbWVudC5jbGVhckFsbE1hcmtlcnMoZGF0YWJhc2UpO1xuXG5cdFx0cmV0dXJuIHJldHZhbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEZvY3VzRWxlbWVudEFmdGVyRGVsQ2VsbHMoY2VsbHNUb0RlbGV0ZSkge1xuXHRcdGxldCBpID0gMDtcblxuXHRcdGNvbnN0IGxhc3QgPSBjZWxsc1RvRGVsZXRlLmxlbmd0aCAtIDE7XG5cblx0XHRjb25zdCBkYXRhYmFzZSA9IHt9O1xuXG5cdFx0bGV0IGNlbGw7XG5cblx0XHRsZXQgZm9jdXNlZENlbGw7XG5cblx0XHRsZXQgdHI7XG5cblx0XHR3aGlsZSAoKGNlbGwgPSBjZWxsc1RvRGVsZXRlW2krK10pKVxuXHRcdFx0Q0tFRElUT1IuZG9tLmVsZW1lbnQuc2V0TWFya2VyKGRhdGFiYXNlLCBjZWxsLCAnZGVsZXRlX2NlbGwnLCB0cnVlKTtcblxuXHRcdC8vIDEuZmlyc3Qgd2UgY2hlY2sgbGVmdCBvciByaWdodCBzaWRlIGZvY3VzYWJsZSBjZWxsIHJvdyBieSByb3c7XG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKChjZWxsID0gY2VsbHNUb0RlbGV0ZVtpKytdKSkge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQoKGZvY3VzZWRDZWxsID0gY2VsbC5nZXRQcmV2aW91cygpKSAmJlxuXHRcdFx0XHRcdCFmb2N1c2VkQ2VsbC5nZXRDdXN0b21EYXRhKCdkZWxldGVfY2VsbCcpKSB8fFxuXHRcdFx0XHQoKGZvY3VzZWRDZWxsID0gY2VsbC5nZXROZXh0KCkpICYmXG5cdFx0XHRcdFx0IWZvY3VzZWRDZWxsLmdldEN1c3RvbURhdGEoJ2RlbGV0ZV9jZWxsJykpXG5cdFx0XHQpIHtcblx0XHRcdFx0Q0tFRElUT1IuZG9tLmVsZW1lbnQuY2xlYXJBbGxNYXJrZXJzKGRhdGFiYXNlKTtcblx0XHRcdFx0cmV0dXJuIGZvY3VzZWRDZWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdENLRURJVE9SLmRvbS5lbGVtZW50LmNsZWFyQWxsTWFya2VycyhkYXRhYmFzZSk7XG5cblx0XHQvLyAyLiB0aGVuIHdlIGNoZWNrIHRoZSB0b3BwZXN0IHJvdyAob3V0c2lkZSB0aGUgc2VsZWN0aW9uIGFyZWEgc3F1YXJlKSBmb2N1c2FibGUgY2VsbFxuXHRcdHRyID0gY2VsbHNUb0RlbGV0ZVswXS5nZXRQYXJlbnQoKTtcblx0XHRpZiAoKHRyID0gdHIuZ2V0UHJldmlvdXMoKSkpIHJldHVybiB0ci5nZXRMYXN0KCk7XG5cblx0XHQvLyAzLiBsYXN0IHdlIGNoZWNrIHRoZSBsb3dlcmVzdCAgcm93IGZvY3VzYWJsZSBjZWxsXG5cdFx0dHIgPSBjZWxsc1RvRGVsZXRlW2xhc3RdLmdldFBhcmVudCgpO1xuXHRcdGlmICgodHIgPSB0ci5nZXROZXh0KCkpKSByZXR1cm4gdHIuZ2V0Q2hpbGQoMCk7XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGluc2VydFJvdyhlZGl0b3IsIGluc2VydEJlZm9yZSkge1xuXHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdGNvbnN0IGNlbGxzID0gZ2V0U2VsZWN0ZWRDZWxscyhzZWxlY3Rpb24pO1xuXG5cdFx0Y29uc3QgZmlyc3RDZWxsID0gY2VsbHNbMF07XG5cblx0XHRjb25zdCB0YWJsZSA9IGZpcnN0Q2VsbC5nZXRBc2NlbmRhbnQoJ3RhYmxlJyk7XG5cblx0XHRjb25zdCBkb2MgPSBmaXJzdENlbGwuZ2V0RG9jdW1lbnQoKTtcblxuXHRcdGNvbnN0IHN0YXJ0Um93ID0gY2VsbHNbMF0uZ2V0UGFyZW50KCk7XG5cblx0XHRjb25zdCBzdGFydFJvd0luZGV4ID0gc3RhcnRSb3cuJC5yb3dJbmRleDtcblxuXHRcdGNvbnN0IGxhc3RDZWxsID0gY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV07XG5cblx0XHRjb25zdCBlbmRSb3dJbmRleCA9XG5cdFx0XHRsYXN0Q2VsbC5nZXRQYXJlbnQoKS4kLnJvd0luZGV4ICsgbGFzdENlbGwuJC5yb3dTcGFuIC0gMTtcblxuXHRcdGNvbnN0IGVuZFJvdyA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCh0YWJsZS4kLnJvd3NbZW5kUm93SW5kZXhdKTtcblxuXHRcdGNvbnN0IHJvd0luZGV4ID0gaW5zZXJ0QmVmb3JlID8gc3RhcnRSb3dJbmRleCA6IGVuZFJvd0luZGV4O1xuXG5cdFx0Y29uc3Qgcm93ID0gaW5zZXJ0QmVmb3JlID8gc3RhcnRSb3cgOiBlbmRSb3c7XG5cblx0XHRjb25zdCBtYXAgPSBDS0VESVRPUi50b29scy5idWlsZFRhYmxlTWFwKHRhYmxlKTtcblxuXHRcdGNvbnN0IGNsb25lUm93ID0gbWFwW3Jvd0luZGV4XTtcblxuXHRcdGNvbnN0IG5leHRSb3cgPSBpbnNlcnRCZWZvcmUgPyBtYXBbcm93SW5kZXggLSAxXSA6IG1hcFtyb3dJbmRleCArIDFdO1xuXG5cdFx0Y29uc3Qgd2lkdGggPSBtYXBbMF0ubGVuZ3RoO1xuXG5cdFx0Y29uc3QgbmV3Um93ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGNsb25lUm93W2ldICYmIGkgPCB3aWR0aDsgaSsrKSB7XG5cdFx0XHRsZXQgY2VsbDtcblx0XHRcdC8vIENoZWNrIHdoZXRoZXIgdGhlcmUncyBhIHNwYW5uaW5nIHJvdyBoZXJlLCBkbyBub3QgYnJlYWsgaXQuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNsb25lUm93W2ldLnJvd1NwYW4gPiAxICYmXG5cdFx0XHRcdG5leHRSb3cgJiZcblx0XHRcdFx0Y2xvbmVSb3dbaV0gPT0gbmV4dFJvd1tpXVxuXHRcdFx0KSB7XG5cdFx0XHRcdGNlbGwgPSBjbG9uZVJvd1tpXTtcblx0XHRcdFx0Y2VsbC5yb3dTcGFuICs9IDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjZWxsID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGNsb25lUm93W2ldKS5jbG9uZSgpO1xuXHRcdFx0XHRjZWxsLnJlbW92ZUF0dHJpYnV0ZSgncm93U3BhbicpO1xuXHRcdFx0XHRjZWxsLmFwcGVuZEJvZ3VzKCk7XG5cdFx0XHRcdG5ld1Jvdy5hcHBlbmQoY2VsbCk7XG5cdFx0XHRcdGNlbGwgPSBjZWxsLiQ7XG5cdFx0XHR9XG5cblx0XHRcdGkgKz0gY2VsbC5jb2xTcGFuIC0gMTtcblx0XHR9XG5cblx0XHRpZiAoaW5zZXJ0QmVmb3JlKSB7XG5cdFx0XHRuZXdSb3cuaW5zZXJ0QmVmb3JlKHJvdyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld1Jvdy5pbnNlcnRBZnRlcihyb3cpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNlbGwgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQobmV3Um93LiQpLmdldENoaWxkKFxuXHRcdFx0Y2VsbHNbMF0gPyBjZWxsc1swXS4kLmNlbGxJbmRleCA6IDBcblx0XHQpO1xuXHRcdHNlbGVjdEVsZW1lbnQoZWRpdG9yLCBjZWxsKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlbGV0ZVJvd3Moc2VsZWN0aW9uT3JSb3cpIHtcblx0XHRpZiAoc2VsZWN0aW9uT3JSb3cgaW5zdGFuY2VvZiBDS0VESVRPUi5kb20uc2VsZWN0aW9uKSB7XG5cdFx0XHRjb25zdCBjZWxscyA9IGdldFNlbGVjdGVkQ2VsbHMoc2VsZWN0aW9uT3JSb3cpO1xuXG5cdFx0XHRjb25zdCBmaXJzdENlbGwgPSBjZWxsc1swXTtcblxuXHRcdFx0Y29uc3QgdGFibGUgPSBmaXJzdENlbGwuZ2V0QXNjZW5kYW50KCd0YWJsZScpO1xuXG5cdFx0XHRjb25zdCBtYXAgPSBDS0VESVRPUi50b29scy5idWlsZFRhYmxlTWFwKHRhYmxlKTtcblxuXHRcdFx0Y29uc3Qgc3RhcnRSb3cgPSBjZWxsc1swXS5nZXRQYXJlbnQoKTtcblxuXHRcdFx0Y29uc3Qgc3RhcnRSb3dJbmRleCA9IHN0YXJ0Um93LiQucm93SW5kZXg7XG5cblx0XHRcdGNvbnN0IGxhc3RDZWxsID0gY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV07XG5cblx0XHRcdGNvbnN0IGVuZFJvd0luZGV4ID1cblx0XHRcdFx0bGFzdENlbGwuZ2V0UGFyZW50KCkuJC5yb3dJbmRleCArIGxhc3RDZWxsLiQucm93U3BhbiAtIDE7XG5cblx0XHRcdGNvbnN0IHJvd3NUb0RlbGV0ZSA9IFtdO1xuXG5cdFx0XHQvLyBEZWxldGUgY2VsbCBvciByZWR1Y2UgY2VsbCBzcGFucyBieSBjaGVja2luZyB0aHJvdWdoIHRoZSB0YWJsZSBtYXAuXG5cdFx0XHRmb3IgKGxldCBpID0gc3RhcnRSb3dJbmRleDsgaSA8PSBlbmRSb3dJbmRleDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IG1hcFJvdyA9IG1hcFtpXTtcblxuXHRcdFx0XHRjb25zdCByb3cgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQodGFibGUuJC5yb3dzW2ldKTtcblxuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IG1hcFJvdy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGNvbnN0IGNlbGwgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQobWFwUm93W2pdKTtcblxuXHRcdFx0XHRcdGNvbnN0IGNlbGxSb3dJbmRleCA9IGNlbGwuZ2V0UGFyZW50KCkuJC5yb3dJbmRleDtcblxuXHRcdFx0XHRcdGlmIChjZWxsLiQucm93U3BhbiA9PSAxKSBjZWxsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdC8vIFJvdyBzcGFubmVkIGNlbGwuXG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBTcGFuIHJvdyBvZiB0aGUgY2VsbCwgcmVkdWNlIHNwYW5uaW5nLlxuXHRcdFx0XHRcdFx0Y2VsbC4kLnJvd1NwYW4gLT0gMTtcblx0XHRcdFx0XHRcdC8vIFJvb3Qgcm93IG9mIHRoZSBjZWxsLCByb290IGNlbGwgdG8gbmV4dCByb3cuXG5cdFx0XHRcdFx0XHRpZiAoY2VsbFJvd0luZGV4ID09IGkpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbmV4dE1hcFJvdyA9IG1hcFtpICsgMV07XG5cdFx0XHRcdFx0XHRcdGlmIChuZXh0TWFwUm93W2ogLSAxXSkge1xuXHRcdFx0XHRcdFx0XHRcdGNlbGwuaW5zZXJ0QWZ0ZXIoXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQobmV4dE1hcFJvd1tqIC0gMV0pXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoXG5cdFx0XHRcdFx0XHRcdFx0XHR0YWJsZS4kLnJvd3NbaSArIDFdXG5cdFx0XHRcdFx0XHRcdFx0KS5hcHBlbmQoY2VsbCwgMSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqICs9IGNlbGwuJC5jb2xTcGFuIC0gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJvd3NUb0RlbGV0ZS5wdXNoKHJvdyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJvd3MgPSB0YWJsZS4kLnJvd3M7XG5cblx0XHRcdC8vIFdoZXJlIHRvIHB1dCB0aGUgY3Vyc29yIGFmdGVyIHJvd3MgYmVlbiBkZWxldGVkP1xuXHRcdFx0Ly8gMS4gSW50byBuZXh0IHNpYmxpbmcgcm93IGlmIGFueTtcblx0XHRcdC8vIDIuIEludG8gcHJldmlvdXMgc2libGluZyByb3cgaWYgYW55O1xuXHRcdFx0Ly8gMy4gSW50byB0YWJsZSdzIHBhcmVudCBlbGVtZW50IGlmIGl0J3MgdGhlIHZlcnkgbGFzdCByb3cuXG5cdFx0XHRjb25zdCBjdXJzb3JQb3NpdGlvbiA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChcblx0XHRcdFx0cm93c1tlbmRSb3dJbmRleCArIDFdIHx8XG5cdFx0XHRcdFx0KHN0YXJ0Um93SW5kZXggPiAwID8gcm93c1tzdGFydFJvd0luZGV4IC0gMV0gOiBudWxsKSB8fFxuXHRcdFx0XHRcdHRhYmxlLiQucGFyZW50Tm9kZVxuXHRcdFx0KTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IHJvd3NUb0RlbGV0ZS5sZW5ndGg7IGkgPj0gMDsgaS0tKVxuXHRcdFx0XHRkZWxldGVSb3dzKHJvd3NUb0RlbGV0ZVtpXSk7XG5cblx0XHRcdHJldHVybiBjdXJzb3JQb3NpdGlvbjtcblx0XHR9IGVsc2UgaWYgKHNlbGVjdGlvbk9yUm93IGluc3RhbmNlb2YgQ0tFRElUT1IuZG9tLmVsZW1lbnQpIHtcblx0XHRcdGNvbnN0IHRhYmxlID0gc2VsZWN0aW9uT3JSb3cuZ2V0QXNjZW5kYW50KCd0YWJsZScpO1xuXG5cdFx0XHRpZiAodGFibGUuJC5yb3dzLmxlbmd0aCA9PSAxKSB0YWJsZS5yZW1vdmUoKTtcblx0XHRcdGVsc2Ugc2VsZWN0aW9uT3JSb3cucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDZWxsQ29sSW5kZXgoY2VsbCwgaXNTdGFydCkge1xuXHRcdGNvbnN0IHJvdyA9IGNlbGwuZ2V0UGFyZW50KCk7XG5cblx0XHRjb25zdCByb3dDZWxscyA9IHJvdy4kLmNlbGxzO1xuXG5cdFx0bGV0IGNvbEluZGV4ID0gMDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NlbGxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBtYXBDZWxsID0gcm93Q2VsbHNbaV07XG5cdFx0XHRjb2xJbmRleCArPSBpc1N0YXJ0ID8gMSA6IG1hcENlbGwuY29sU3Bhbjtcblx0XHRcdGlmIChtYXBDZWxsID09IGNlbGwuJCkgYnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbEluZGV4IC0gMTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldENvbHVtbnNJbmRpY2VzKGNlbGxzLCBpc1N0YXJ0KSB7XG5cdFx0bGV0IHJldHZhbCA9IGlzU3RhcnQgPyBJbmZpbml0eSA6IDA7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgY29sSW5kZXggPSBnZXRDZWxsQ29sSW5kZXgoY2VsbHNbaV0sIGlzU3RhcnQpO1xuXHRcdFx0aWYgKGlzU3RhcnQgPyBjb2xJbmRleCA8IHJldHZhbCA6IGNvbEluZGV4ID4gcmV0dmFsKVxuXHRcdFx0XHRyZXR2YWwgPSBjb2xJbmRleDtcblx0XHR9XG5cdFx0cmV0dXJuIHJldHZhbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGluc2VydENvbHVtbihlZGl0b3IsIGluc2VydEJlZm9yZSkge1xuXHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdGNvbnN0IGNlbGxzID0gZ2V0U2VsZWN0ZWRDZWxscyhzZWxlY3Rpb24pO1xuXG5cdFx0Y29uc3QgZmlyc3RDZWxsID0gY2VsbHNbMF07XG5cblx0XHRjb25zdCB0YWJsZSA9IGZpcnN0Q2VsbC5nZXRBc2NlbmRhbnQoJ3RhYmxlJyk7XG5cblx0XHRjb25zdCBzdGFydENvbCA9IGdldENvbHVtbnNJbmRpY2VzKGNlbGxzLCAxKTtcblxuXHRcdGNvbnN0IGxhc3RDb2wgPSBnZXRDb2x1bW5zSW5kaWNlcyhjZWxscyk7XG5cblx0XHRjb25zdCBjb2xJbmRleCA9IGluc2VydEJlZm9yZSA/IHN0YXJ0Q29sIDogbGFzdENvbDtcblxuXHRcdGNvbnN0IG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAodGFibGUpO1xuXG5cdFx0Y29uc3QgY2xvbmVDb2wgPSBbXTtcblxuXHRcdGNvbnN0IG5leHRDb2wgPSBbXTtcblxuXHRcdGNvbnN0IGhlaWdodCA9IG1hcC5sZW5ndGg7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG5cdFx0XHRjbG9uZUNvbC5wdXNoKG1hcFtpXVtjb2xJbmRleF0pO1xuXHRcdFx0Y29uc3QgbmV4dENlbGwgPSBpbnNlcnRCZWZvcmVcblx0XHRcdFx0PyBtYXBbaV1bY29sSW5kZXggLSAxXVxuXHRcdFx0XHQ6IG1hcFtpXVtjb2xJbmRleCArIDFdO1xuXHRcdFx0bmV4dENvbC5wdXNoKG5leHRDZWxsKTtcblx0XHR9XG5cblx0XHRjb25zdCBpbnNlcnRlZENlbGxzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuXHRcdFx0bGV0IGNlbGw7XG5cblx0XHRcdGlmICghY2xvbmVDb2xbaV0pIGNvbnRpbnVlO1xuXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIHRoZXJlJ3MgYSBzcGFubmluZyBjb2x1bW4gaGVyZSwgZG8gbm90IGJyZWFrIGl0LlxuXHRcdFx0aWYgKGNsb25lQ29sW2ldLmNvbFNwYW4gPiAxICYmIG5leHRDb2xbaV0gPT0gY2xvbmVDb2xbaV0pIHtcblx0XHRcdFx0Y2VsbCA9IGNsb25lQ29sW2ldO1xuXHRcdFx0XHRjZWxsLmNvbFNwYW4gKz0gMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNlbGwgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoY2xvbmVDb2xbaV0pLmNsb25lKCk7XG5cdFx0XHRcdGNlbGwucmVtb3ZlQXR0cmlidXRlKCdjb2xTcGFuJyk7XG5cdFx0XHRcdGNlbGwuYXBwZW5kQm9ndXMoKTtcblx0XHRcdFx0Y2VsbFtpbnNlcnRCZWZvcmUgPyAnaW5zZXJ0QmVmb3JlJyA6ICdpbnNlcnRBZnRlciddLmNhbGwoXG5cdFx0XHRcdFx0Y2VsbCxcblx0XHRcdFx0XHRuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoY2xvbmVDb2xbaV0pXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNlbGwgPSBjZWxsLiQ7XG5cdFx0XHR9XG5cblx0XHRcdGluc2VydGVkQ2VsbHNbaV0gPSBjZWxsO1xuXG5cdFx0XHRpICs9IGNlbGwucm93U3BhbiAtIDE7XG5cdFx0fVxuXG5cdFx0Y29uc3QgY2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChcblx0XHRcdGluc2VydGVkQ2VsbHNbZmlyc3RDZWxsLmdldFBhcmVudCgpLiQucm93SW5kZXhdXG5cdFx0KTtcblx0XHRzZWxlY3RFbGVtZW50KGVkaXRvciwgY2VsbCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZWxlY3RFbGVtZW50KGVkaXRvciwgZWxlbWVudCkge1xuXHRcdGNvbnN0IHJhbmdlID0gZWRpdG9yLmNyZWF0ZVJhbmdlKCk7XG5cblx0XHRyYW5nZS5tb3ZlVG9Qb3NpdGlvbihlbGVtZW50LCBDS0VESVRPUi5QT1NJVElPTl9BRlRFUl9TVEFSVCk7XG5cdFx0ZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdFJhbmdlcyhbcmFuZ2VdKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlbGV0ZUNvbHVtbnMoc2VsZWN0aW9uT3JDZWxsKSB7XG5cdFx0Y29uc3QgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKHNlbGVjdGlvbk9yQ2VsbCk7XG5cblx0XHRjb25zdCBmaXJzdENlbGwgPSBjZWxsc1swXTtcblxuXHRcdGNvbnN0IGxhc3RDZWxsID0gY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV07XG5cblx0XHRjb25zdCB0YWJsZSA9IGZpcnN0Q2VsbC5nZXRBc2NlbmRhbnQoJ3RhYmxlJyk7XG5cblx0XHRjb25zdCBtYXAgPSBDS0VESVRPUi50b29scy5idWlsZFRhYmxlTWFwKHRhYmxlKTtcblxuXHRcdGxldCBzdGFydENvbEluZGV4O1xuXG5cdFx0bGV0IGVuZENvbEluZGV4O1xuXG5cdFx0Y29uc3Qgcm93c1RvRGVsZXRlID0gW107XG5cblx0XHRsZXQgcm93cztcblxuXHRcdC8vIEZpZ3VyZSBvdXQgc2VsZWN0ZWQgY2VsbHMnIGNvbHVtbiBpbmRpY2VzLlxuXHRcdGZvciAobGV0IGkgPSAwLCByb3dzID0gbWFwLmxlbmd0aDsgaSA8IHJvd3M7IGkrKykge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNvcnQtdmFyc1xuXHRcdFx0Zm9yIChsZXQgaiA9IDAsIGNvbHMgPSBtYXBbaV0ubGVuZ3RoOyBqIDwgY29sczsgaisrKSB7XG5cdFx0XHRcdGlmIChtYXBbaV1bal0gPT0gZmlyc3RDZWxsLiQpIHN0YXJ0Q29sSW5kZXggPSBqO1xuXHRcdFx0XHRpZiAobWFwW2ldW2pdID09IGxhc3RDZWxsLiQpIGVuZENvbEluZGV4ID0gajtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBEZWxldGUgY2VsbCBvciByZWR1Y2UgY2VsbCBzcGFucyBieSBjaGVja2luZyB0aHJvdWdoIHRoZSB0YWJsZSBtYXAuXG5cdFx0Zm9yIChsZXQgaSA9IHN0YXJ0Q29sSW5kZXg7IGkgPD0gZW5kQ29sSW5kZXg7IGkrKykge1xuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBtYXAubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0Y29uc3QgbWFwUm93ID0gbWFwW2pdO1xuXG5cdFx0XHRcdGNvbnN0IHJvdyA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCh0YWJsZS4kLnJvd3Nbal0pO1xuXG5cdFx0XHRcdGNvbnN0IGNlbGwgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQobWFwUm93W2ldKTtcblxuXHRcdFx0XHRpZiAoY2VsbC4kKSB7XG5cdFx0XHRcdFx0aWYgKGNlbGwuJC5jb2xTcGFuID09IDEpIGNlbGwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0Ly8gUmVkdWNlIHRoZSBjb2wgc3BhbnMuXG5cdFx0XHRcdFx0ZWxzZSBjZWxsLiQuY29sU3BhbiAtPSAxO1xuXG5cdFx0XHRcdFx0aiArPSBjZWxsLiQucm93U3BhbiAtIDE7XG5cblx0XHRcdFx0XHRpZiAoIXJvdy4kLmNlbGxzLmxlbmd0aCkgcm93c1RvRGVsZXRlLnB1c2gocm93KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IGZpcnN0Um93Q2VsbHMgPSB0YWJsZS4kLnJvd3NbMF0gJiYgdGFibGUuJC5yb3dzWzBdLmNlbGxzO1xuXG5cdFx0Ly8gV2hlcmUgdG8gcHV0IHRoZSBjdXJzb3IgYWZ0ZXIgY29sdW1ucyBiZWVuIGRlbGV0ZWQ/XG5cdFx0Ly8gMS4gSW50byBuZXh0IGNlbGwgb2YgdGhlIGZpcnN0IHJvdyBpZiBhbnk7XG5cdFx0Ly8gMi4gSW50byBwcmV2aW91cyBjZWxsIG9mIHRoZSBmaXJzdCByb3cgaWYgYW55O1xuXHRcdC8vIDMuIEludG8gdGFibGUncyBwYXJlbnQgZWxlbWVudDtcblx0XHRjb25zdCBjdXJzb3JQb3NpdGlvbiA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChcblx0XHRcdGZpcnN0Um93Q2VsbHNbc3RhcnRDb2xJbmRleF0gfHxcblx0XHRcdFx0KHN0YXJ0Q29sSW5kZXhcblx0XHRcdFx0XHQ/IGZpcnN0Um93Q2VsbHNbc3RhcnRDb2xJbmRleCAtIDFdXG5cdFx0XHRcdFx0OiB0YWJsZS4kLnBhcmVudE5vZGUpXG5cdFx0KTtcblxuXHRcdC8vIERlbGV0ZSB0YWJsZSByb3dzIG9ubHkgaWYgYWxsIGNvbHVtbnMgYXJlIGdvbmUgKGRvIG5vdCByZW1vdmUgZW1wdHkgcm93KS5cblx0XHRpZiAocm93c1RvRGVsZXRlLmxlbmd0aCA9PSByb3dzKSB0YWJsZS5yZW1vdmUoKTtcblxuXHRcdHJldHVybiBjdXJzb3JQb3NpdGlvbjtcblx0fVxuXG5cdGZ1bmN0aW9uIGluc2VydENlbGwoc2VsZWN0aW9uLCBpbnNlcnRCZWZvcmUpIHtcblx0XHRjb25zdCBzdGFydEVsZW1lbnQgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbGVtZW50KCk7XG5cdFx0Y29uc3QgY2VsbCA9XG5cdFx0XHRzdGFydEVsZW1lbnQuZ2V0QXNjZW5kYW50KCd0ZCcsIDEpIHx8XG5cdFx0XHRzdGFydEVsZW1lbnQuZ2V0QXNjZW5kYW50KCd0aCcsIDEpO1xuXG5cdFx0aWYgKCFjZWxsKSByZXR1cm47XG5cblx0XHQvLyBDcmVhdGUgdGhlIG5ldyBjZWxsIGVsZW1lbnQgdG8gYmUgYWRkZWQuXG5cdFx0Y29uc3QgbmV3Q2VsbCA9IGNlbGwuY2xvbmUoKTtcblx0XHRuZXdDZWxsLmFwcGVuZEJvZ3VzKCk7XG5cblx0XHRpZiAoaW5zZXJ0QmVmb3JlKSBuZXdDZWxsLmluc2VydEJlZm9yZShjZWxsKTtcblx0XHRlbHNlIG5ld0NlbGwuaW5zZXJ0QWZ0ZXIoY2VsbCk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWxldGVDZWxscyhzZWxlY3Rpb25PckNlbGwpIHtcblx0XHRpZiAoc2VsZWN0aW9uT3JDZWxsIGluc3RhbmNlb2YgQ0tFRElUT1IuZG9tLnNlbGVjdGlvbikge1xuXHRcdFx0Y29uc3QgY2VsbHNUb0RlbGV0ZSA9IGdldFNlbGVjdGVkQ2VsbHMoc2VsZWN0aW9uT3JDZWxsKTtcblx0XHRcdGNvbnN0IHRhYmxlID1cblx0XHRcdFx0Y2VsbHNUb0RlbGV0ZVswXSAmJiBjZWxsc1RvRGVsZXRlWzBdLmdldEFzY2VuZGFudCgndGFibGUnKTtcblx0XHRcdGNvbnN0IGNlbGxUb0ZvY3VzID0gZ2V0Rm9jdXNFbGVtZW50QWZ0ZXJEZWxDZWxscyhjZWxsc1RvRGVsZXRlKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IGNlbGxzVG9EZWxldGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHRcdGRlbGV0ZUNlbGxzKGNlbGxzVG9EZWxldGVbaV0pO1xuXG5cdFx0XHRpZiAoY2VsbFRvRm9jdXMpIHBsYWNlQ3Vyc29ySW5DZWxsKGNlbGxUb0ZvY3VzLCB0cnVlKTtcblx0XHRcdGVsc2UgaWYgKHRhYmxlKSB0YWJsZS5yZW1vdmUoKTtcblx0XHR9IGVsc2UgaWYgKHNlbGVjdGlvbk9yQ2VsbCBpbnN0YW5jZW9mIENLRURJVE9SLmRvbS5lbGVtZW50KSB7XG5cdFx0XHRjb25zdCB0ciA9IHNlbGVjdGlvbk9yQ2VsbC5nZXRQYXJlbnQoKTtcblx0XHRcdGlmICh0ci5nZXRDaGlsZENvdW50KCkgPT0gMSkgdHIucmVtb3ZlKCk7XG5cdFx0XHRlbHNlIHNlbGVjdGlvbk9yQ2VsbC5yZW1vdmUoKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgZmlsbGVyIGF0IGVuZCBhbmQgZW1wdHkgc3BhY2VzIGFyb3VuZCB0aGUgY2VsbCBjb250ZW50LlxuXHRmdW5jdGlvbiB0cmltQ2VsbChjZWxsKSB7XG5cdFx0Y29uc3QgYm9ndXMgPSBjZWxsLmdldEJvZ3VzKCk7XG5cdFx0aWYgKGJvZ3VzKSB7XG5cdFx0XHRib2d1cy5yZW1vdmUoKTtcblx0XHR9XG5cdFx0Y2VsbC50cmltKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBwbGFjZUN1cnNvckluQ2VsbChjZWxsLCBwbGFjZUF0RW5kKSB7XG5cdFx0Y29uc3QgZG9jSW5uZXIgPSBjZWxsLmdldERvY3VtZW50KCk7XG5cblx0XHRjb25zdCBkb2NPdXRlciA9IENLRURJVE9SLmRvY3VtZW50O1xuXG5cdFx0Ly8gRml4aW5nIFwiVW5zcGVjaWZpZWQgZXJyb3JcIiB0aHJvd24gaW4gSUUxMCBieSByZXNldHRpbmdcblx0XHQvLyBzZWxlY3Rpb24gdGhlIGRpcnR5IGFuZCBzaGFtZWZ1bCB3YXkgKCMxMDMwOCkuXG5cdFx0Ly8gV2UgY2FuIG5vdCBhcHBseSB0aGlzIGhhY2sgdG8gSUU4IGJlY2F1c2Vcblx0XHQvLyBpdCBjYXVzZXMgZXJyb3IgKCMxMTA1OCkuXG5cdFx0aWYgKENLRURJVE9SLmVudi5pZSAmJiBDS0VESVRPUi5lbnYudmVyc2lvbiA9PSAxMCkge1xuXHRcdFx0ZG9jT3V0ZXIuZm9jdXMoKTtcblx0XHRcdGRvY0lubmVyLmZvY3VzKCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmFuZ2UgPSBuZXcgQ0tFRElUT1IuZG9tLnJhbmdlKGRvY0lubmVyKTtcblx0XHRpZiAoXG5cdFx0XHQhcmFuZ2VbJ21vdmVUb0VsZW1lbnRFZGl0JyArIChwbGFjZUF0RW5kID8gJ0VuZCcgOiAnU3RhcnQnKV0oY2VsbClcblx0XHQpIHtcblx0XHRcdHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhjZWxsKTtcblx0XHRcdHJhbmdlLmNvbGxhcHNlKHBsYWNlQXRFbmQgPyBmYWxzZSA6IHRydWUpO1xuXHRcdH1cblx0XHRyYW5nZS5zZWxlY3QodHJ1ZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBjZWxsSW5Sb3codGFibGVNYXAsIHJvd0luZGV4LCBjZWxsKSB7XG5cdFx0Y29uc3Qgb1JvdyA9IHRhYmxlTWFwW3Jvd0luZGV4XTtcblx0XHRpZiAodHlwZW9mIGNlbGwgPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBvUm93O1xuXG5cdFx0Zm9yIChsZXQgYyA9IDA7IG9Sb3cgJiYgYyA8IG9Sb3cubGVuZ3RoOyBjKyspIHtcblx0XHRcdGlmIChjZWxsLmlzICYmIG9Sb3dbY10gPT0gY2VsbC4kKSByZXR1cm4gYztcblx0XHRcdGVsc2UgaWYgKGMgPT0gY2VsbCkgcmV0dXJuIG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChvUm93W2NdKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNlbGwuaXMgPyAtMSA6IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBjZWxsSW5Db2wodGFibGVNYXAsIGNvbEluZGV4KSB7XG5cdFx0Y29uc3Qgb0NvbCA9IFtdO1xuXHRcdGZvciAobGV0IHIgPSAwOyByIDwgdGFibGVNYXAubGVuZ3RoOyByKyspIHtcblx0XHRcdGNvbnN0IHJvdyA9IHRhYmxlTWFwW3JdO1xuXHRcdFx0b0NvbC5wdXNoKHJvd1tjb2xJbmRleF0pO1xuXG5cdFx0XHQvLyBBdm9pZCBhZGRpbmcgZHVwbGljYXRlIGNlbGxzLlxuXHRcdFx0aWYgKHJvd1tjb2xJbmRleF0ucm93U3BhbiA+IDEpIHIgKz0gcm93W2NvbEluZGV4XS5yb3dTcGFuIC0gMTtcblx0XHR9XG5cdFx0cmV0dXJuIG9Db2w7XG5cdH1cblxuXHRmdW5jdGlvbiBtZXJnZUNlbGxzKHNlbGVjdGlvbiwgbWVyZ2VEaXJlY3Rpb24sIGlzRGV0ZWN0KSB7XG5cdFx0Y29uc3QgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKHNlbGVjdGlvbik7XG5cblx0XHQvLyBJbnZhbGlkIG1lcmdlIHJlcXVlc3QgaWY6XG5cdFx0Ly8gMS4gSW4gYmF0Y2ggbW9kZSBkZXNwaXRlIHRoYXQgbGVzcyB0aGFuIHR3byBzZWxlY3RlZC5cblx0XHQvLyAyLiBJbiBzb2xvIG1vZGUgd2hpbGUgbm90IGV4YWN0bHkgb25seSBvbmUgc2VsZWN0ZWQuXG5cdFx0Ly8gMy4gQ2VsbHMgZGlzdHJpYnV0ZWQgaW4gZGlmZmVyZW50IHRhYmxlIGdyb3VwcyAoZS5nLiBmcm9tIGJvdGggdGhlYWQgYW5kIHRib2R5KS5cblx0XHRsZXQgY29tbW9uQW5jZXN0b3I7XG5cdFx0aWYgKFxuXHRcdFx0KG1lcmdlRGlyZWN0aW9uID8gY2VsbHMubGVuZ3RoICE9IDEgOiBjZWxscy5sZW5ndGggPCAyKSB8fFxuXHRcdFx0KChjb21tb25BbmNlc3RvciA9IHNlbGVjdGlvbi5nZXRDb21tb25BbmNlc3RvcigpKSAmJlxuXHRcdFx0XHRjb21tb25BbmNlc3Rvci50eXBlID09IENLRURJVE9SLk5PREVfRUxFTUVOVCAmJlxuXHRcdFx0XHRjb21tb25BbmNlc3Rvci5pcygndGFibGUnKSlcblx0XHQpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRsZXQgY2VsbDtcblxuXHRcdGNvbnN0IGZpcnN0Q2VsbCA9IGNlbGxzWzBdO1xuXG5cdFx0Y29uc3QgdGFibGUgPSBmaXJzdENlbGwuZ2V0QXNjZW5kYW50KCd0YWJsZScpO1xuXG5cdFx0Y29uc3QgbWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCh0YWJsZSk7XG5cblx0XHRjb25zdCBtYXBIZWlnaHQgPSBtYXAubGVuZ3RoO1xuXG5cdFx0Y29uc3QgbWFwV2lkdGggPSBtYXBbMF0ubGVuZ3RoO1xuXG5cdFx0Y29uc3Qgc3RhcnRSb3cgPSBmaXJzdENlbGwuZ2V0UGFyZW50KCkuJC5yb3dJbmRleDtcblxuXHRcdGNvbnN0IHN0YXJ0Q29sdW1uID0gY2VsbEluUm93KG1hcCwgc3RhcnRSb3csIGZpcnN0Q2VsbCk7XG5cblx0XHRpZiAobWVyZ2VEaXJlY3Rpb24pIHtcblx0XHRcdGxldCB0YXJnZXRDZWxsO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3Qgcm93c3BhbiA9XG5cdFx0XHRcdFx0cGFyc2VJbnQoZmlyc3RDZWxsLmdldEF0dHJpYnV0ZSgncm93c3BhbicpLCAxMCkgfHwgMTtcblx0XHRcdFx0Y29uc3QgY29sc3BhbiA9XG5cdFx0XHRcdFx0cGFyc2VJbnQoZmlyc3RDZWxsLmdldEF0dHJpYnV0ZSgnY29sc3BhbicpLCAxMCkgfHwgMTtcblxuXHRcdFx0XHR0YXJnZXRDZWxsID1cblx0XHRcdFx0XHRtYXBbXG5cdFx0XHRcdFx0XHRtZXJnZURpcmVjdGlvbiA9PSAndXAnXG5cdFx0XHRcdFx0XHRcdD8gc3RhcnRSb3cgLSByb3dzcGFuXG5cdFx0XHRcdFx0XHRcdDogbWVyZ2VEaXJlY3Rpb24gPT0gJ2Rvd24nXG5cdFx0XHRcdFx0XHRcdD8gc3RhcnRSb3cgKyByb3dzcGFuXG5cdFx0XHRcdFx0XHRcdDogc3RhcnRSb3dcblx0XHRcdFx0XHRdW1xuXHRcdFx0XHRcdFx0bWVyZ2VEaXJlY3Rpb24gPT0gJ2xlZnQnXG5cdFx0XHRcdFx0XHRcdD8gc3RhcnRDb2x1bW4gLSBjb2xzcGFuXG5cdFx0XHRcdFx0XHRcdDogbWVyZ2VEaXJlY3Rpb24gPT0gJ3JpZ2h0J1xuXHRcdFx0XHRcdFx0XHQ/IHN0YXJ0Q29sdW1uICsgY29sc3BhblxuXHRcdFx0XHRcdFx0XHQ6IHN0YXJ0Q29sdW1uXG5cdFx0XHRcdFx0XTtcblx0XHRcdH0gY2F0Y2ggKGVyKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gMS4gTm8gY2VsbCBjb3VsZCBiZSBtZXJnZWQuXG5cdFx0XHQvLyAyLiBTYW1lIGNlbGwgYWN0dWFsbHkuXG5cdFx0XHRpZiAoIXRhcmdldENlbGwgfHwgZmlyc3RDZWxsLiQgPT0gdGFyZ2V0Q2VsbCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHQvLyBTb3J0IGluIG1hcCBvcmRlciByZWdhcmRsZXNzIG9mIHRoZSBET00gc2VxdWVuY2UuXG5cdFx0XHRjZWxsc1tcblx0XHRcdFx0bWVyZ2VEaXJlY3Rpb24gPT0gJ3VwJyB8fCBtZXJnZURpcmVjdGlvbiA9PSAnbGVmdCdcblx0XHRcdFx0XHQ/ICd1bnNoaWZ0J1xuXHRcdFx0XHRcdDogJ3B1c2gnXG5cdFx0XHRdKG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCh0YXJnZXRDZWxsKSk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RhcnQgZnJvbSBoZXJlIGFyZSBtZXJnaW5nIHdheSBpZ25vcmFuY2UgKG1lcmdlIHVwL3JpZ2h0LCBiYXRjaCBtZXJnZSkuXG5cdFx0Y29uc3QgZG9jID0gZmlyc3RDZWxsLmdldERvY3VtZW50KCk7XG5cblx0XHRsZXQgbGFzdFJvd0luZGV4ID0gc3RhcnRSb3c7XG5cblx0XHRsZXQgdG90YWxSb3dTcGFuID0gMDtcblxuXHRcdGxldCB0b3RhbENvbFNwYW4gPSAwO1xuXG5cdFx0Ly8gVXNlIGEgZG9jdW1lbnRGcmFnbWVudCBhcyBidWZmZXIgd2hlbiBhcHBlbmRpbmcgY2VsbCBjb250ZW50cy5cblxuXHRcdGNvbnN0IGZyYWcgPSAhaXNEZXRlY3QgJiYgbmV3IENLRURJVE9SLmRvbS5kb2N1bWVudEZyYWdtZW50KGRvYyk7XG5cblx0XHRsZXQgZGltZW5zaW9uID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNlbGwgPSBjZWxsc1tpXTtcblxuXHRcdFx0Y29uc3QgdHIgPSBjZWxsLmdldFBhcmVudCgpO1xuXG5cdFx0XHRjb25zdCBjZWxsRmlyc3RDaGlsZCA9IGNlbGwuZ2V0Rmlyc3QoKTtcblxuXHRcdFx0Y29uc3QgY29sU3BhbiA9IGNlbGwuJC5jb2xTcGFuO1xuXG5cdFx0XHRjb25zdCByb3dTcGFuID0gY2VsbC4kLnJvd1NwYW47XG5cblx0XHRcdGNvbnN0IHJvd0luZGV4ID0gdHIuJC5yb3dJbmRleDtcblxuXHRcdFx0Y29uc3QgY29sSW5kZXggPSBjZWxsSW5Sb3cobWFwLCByb3dJbmRleCwgY2VsbCk7XG5cblx0XHRcdC8vIEFjY3VtdWxhdGVkIHRoZSBhY3R1YWwgcGxhY2VzIHRha2VuIGJ5IGFsbCBzZWxlY3RlZCBjZWxscy5cblx0XHRcdGRpbWVuc2lvbiArPSBjb2xTcGFuICogcm93U3Bhbjtcblx0XHRcdC8vIEFjY3VtdWxhdGVkIHRoZSBtYXhpbXVtIHZpcnR1YWwgc3BhbnMgZnJvbSBjb2x1bW4gYW5kIHJvdy5cblx0XHRcdHRvdGFsQ29sU3BhbiA9IE1hdGgubWF4KFxuXHRcdFx0XHR0b3RhbENvbFNwYW4sXG5cdFx0XHRcdGNvbEluZGV4IC0gc3RhcnRDb2x1bW4gKyBjb2xTcGFuXG5cdFx0XHQpO1xuXHRcdFx0dG90YWxSb3dTcGFuID0gTWF0aC5tYXgoXG5cdFx0XHRcdHRvdGFsUm93U3Bhbixcblx0XHRcdFx0cm93SW5kZXggLSBzdGFydFJvdyArIHJvd1NwYW5cblx0XHRcdCk7XG5cblx0XHRcdGlmICghaXNEZXRlY3QpIHtcblx0XHRcdFx0Ly8gVHJpbSBhbGwgY2VsbCBmaWxsZXJzIGFuZCBjaGVjayB0byByZW1vdmUgZW1wdHkgY2VsbHMuXG5cdFx0XHRcdGlmICgodHJpbUNlbGwoY2VsbCksIGNlbGwuZ2V0Q2hpbGRyZW4oKS5jb3VudCgpKSkge1xuXHRcdFx0XHRcdC8vIE1lcmdlIHZlcnRpY2FsbHkgY2VsbHMgYXMgdHdvIHNlcGFyYXRlZCBwYXJhZ3JhcGhzLlxuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdHJvd0luZGV4ICE9IGxhc3RSb3dJbmRleCAmJlxuXHRcdFx0XHRcdFx0Y2VsbEZpcnN0Q2hpbGQgJiZcblx0XHRcdFx0XHRcdCEoXG5cdFx0XHRcdFx0XHRcdGNlbGxGaXJzdENoaWxkLmlzQmxvY2tCb3VuZGFyeSAmJlxuXHRcdFx0XHRcdFx0XHRjZWxsRmlyc3RDaGlsZC5pc0Jsb2NrQm91bmRhcnkoe2JyOiAxfSlcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGxhc3QgPSBmcmFnLmdldExhc3QoXG5cdFx0XHRcdFx0XHRcdENLRURJVE9SLmRvbS53YWxrZXIud2hpdGVzcGFjZXModHJ1ZSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRpZiAobGFzdCAmJiAhKGxhc3QuaXMgJiYgbGFzdC5pcygnYnInKSkpXG5cdFx0XHRcdFx0XHRcdGZyYWcuYXBwZW5kKCdicicpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNlbGwubW92ZUNoaWxkcmVuKGZyYWcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpKSB7XG5cdFx0XHRcdFx0Y2VsbC5yZW1vdmUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjZWxsLnNldEh0bWwoJycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsYXN0Um93SW5kZXggPSByb3dJbmRleDtcblx0XHR9XG5cblx0XHRpZiAoIWlzRGV0ZWN0KSB7XG5cdFx0XHRmcmFnLm1vdmVDaGlsZHJlbihmaXJzdENlbGwpO1xuXG5cdFx0XHRmaXJzdENlbGwuYXBwZW5kQm9ndXMoKTtcblxuXHRcdFx0aWYgKHRvdGFsQ29sU3BhbiA+PSBtYXBXaWR0aCkgZmlyc3RDZWxsLnJlbW92ZUF0dHJpYnV0ZSgncm93U3BhbicpO1xuXHRcdFx0ZWxzZSBmaXJzdENlbGwuJC5yb3dTcGFuID0gdG90YWxSb3dTcGFuO1xuXG5cdFx0XHRpZiAodG90YWxSb3dTcGFuID49IG1hcEhlaWdodCkgZmlyc3RDZWxsLnJlbW92ZUF0dHJpYnV0ZSgnY29sU3BhbicpO1xuXHRcdFx0ZWxzZSBmaXJzdENlbGwuJC5jb2xTcGFuID0gdG90YWxDb2xTcGFuO1xuXG5cdFx0XHQvLyBTd2lwIGVtcHR5IDx0cj4gbGVmdCBhdCB0aGUgZW5kIG9mIHRhYmxlIGR1ZSB0byB0aGUgbWVyZ2luZy5cblx0XHRcdGNvbnN0IHRycyA9IG5ldyBDS0VESVRPUi5kb20ubm9kZUxpc3QodGFibGUuJC5yb3dzKTtcblxuXHRcdFx0bGV0IGNvdW50ID0gdHJzLmNvdW50KCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGNvbnN0IHRhaWxUciA9IHRycy5nZXRJdGVtKGkpO1xuXHRcdFx0XHRpZiAoIXRhaWxUci4kLmNlbGxzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHRhaWxUci5yZW1vdmUoKTtcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmaXJzdENlbGw7XG5cdFx0fVxuXHRcdC8vIEJlIGFibGUgdG8gbWVyZ2UgY2VsbHMgb25seSBpZiBhY3R1YWwgZGltZW5zaW9uIG9mIHNlbGVjdGVkXG5cdFx0Ly8gY2VsbHMgZXF1YWxzIHRvIHRoZSBjYWN1bGF0ZWQgcmVjdGFuZ2xlLlxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRvdGFsUm93U3BhbiAqIHRvdGFsQ29sU3BhbiA9PSBkaW1lbnNpb247XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gdmVydGljYWxTcGxpdENlbGwoc2VsZWN0aW9uLCBpc0RldGVjdCkge1xuXHRcdGNvbnN0IGNlbGxzID0gZ2V0U2VsZWN0ZWRDZWxscyhzZWxlY3Rpb24pO1xuXHRcdGlmIChjZWxscy5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2U7XG5cdFx0ZWxzZSBpZiAoaXNEZXRlY3QpIHJldHVybiB0cnVlO1xuXG5cdFx0Y29uc3QgY2VsbCA9IGNlbGxzWzBdO1xuXG5cdFx0Y29uc3QgdHIgPSBjZWxsLmdldFBhcmVudCgpO1xuXG5cdFx0Y29uc3QgdGFibGUgPSB0ci5nZXRBc2NlbmRhbnQoJ3RhYmxlJyk7XG5cblx0XHRjb25zdCBtYXAgPSBDS0VESVRPUi50b29scy5idWlsZFRhYmxlTWFwKHRhYmxlKTtcblxuXHRcdGNvbnN0IHJvd0luZGV4ID0gdHIuJC5yb3dJbmRleDtcblxuXHRcdGNvbnN0IGNvbEluZGV4ID0gY2VsbEluUm93KG1hcCwgcm93SW5kZXgsIGNlbGwpO1xuXG5cdFx0Y29uc3Qgcm93U3BhbiA9IGNlbGwuJC5yb3dTcGFuO1xuXG5cdFx0bGV0IG5ld0NlbGw7XG5cblx0XHRsZXQgbmV3Um93U3BhbjtcblxuXHRcdGxldCBuZXdDZWxsUm93U3BhbjtcblxuXHRcdGxldCBuZXdSb3dJbmRleDtcblxuXHRcdGlmIChyb3dTcGFuID4gMSkge1xuXHRcdFx0bmV3Um93U3BhbiA9IE1hdGguY2VpbChyb3dTcGFuIC8gMik7XG5cdFx0XHRuZXdDZWxsUm93U3BhbiA9IE1hdGguZmxvb3Iocm93U3BhbiAvIDIpO1xuXHRcdFx0bmV3Um93SW5kZXggPSByb3dJbmRleCArIG5ld1Jvd1NwYW47XG5cdFx0XHRjb25zdCBuZXdDZWxsVHIgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoXG5cdFx0XHRcdHRhYmxlLiQucm93c1tuZXdSb3dJbmRleF1cblx0XHRcdCk7XG5cblx0XHRcdGNvbnN0IG5ld0NlbGxSb3cgPSBjZWxsSW5Sb3cobWFwLCBuZXdSb3dJbmRleCk7XG5cblx0XHRcdGxldCBjYW5kaWRhdGVDZWxsO1xuXG5cdFx0XHRuZXdDZWxsID0gY2VsbC5jbG9uZSgpO1xuXG5cdFx0XHQvLyBGaWd1cmUgb3V0IHdoZXJlIHRvIGluc2VydCB0aGUgbmV3IGNlbGwgYnkgY2hlY2tpbmcgdGhlIHZpdHVhbCByb3cuXG5cdFx0XHRmb3IgKGxldCBjID0gMDsgYyA8IG5ld0NlbGxSb3cubGVuZ3RoOyBjKyspIHtcblx0XHRcdFx0Y2FuZGlkYXRlQ2VsbCA9IG5ld0NlbGxSb3dbY107XG5cdFx0XHRcdC8vIENhdGNoIGZpcnN0IGNlbGwgYWN0dWFsbHkgZm9sbG93aW5nIHRoZSBjb2x1bW4uXG5cdFx0XHRcdGlmIChjYW5kaWRhdGVDZWxsLnBhcmVudE5vZGUgPT0gbmV3Q2VsbFRyLiQgJiYgYyA+IGNvbEluZGV4KSB7XG5cdFx0XHRcdFx0bmV3Q2VsbC5pbnNlcnRCZWZvcmUoXG5cdFx0XHRcdFx0XHRuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoY2FuZGlkYXRlQ2VsbClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNhbmRpZGF0ZUNlbGwgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBkZXN0aW5hdGlvbiByb3cgaXMgZW1wdHksIGFwcGVuZCBhdCB3aWxsLlxuXHRcdFx0aWYgKCFjYW5kaWRhdGVDZWxsKSBuZXdDZWxsVHIuYXBwZW5kKG5ld0NlbGwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdDZWxsUm93U3BhbiA9IG5ld1Jvd1NwYW4gPSAxO1xuXG5cdFx0XHRjb25zdCBuZXdDZWxsVHIgPSB0ci5jbG9uZSgpO1xuXHRcdFx0bmV3Q2VsbFRyLmluc2VydEFmdGVyKHRyKTtcblx0XHRcdG5ld0NlbGxUci5hcHBlbmQoKG5ld0NlbGwgPSBjZWxsLmNsb25lKCkpKTtcblxuXHRcdFx0Y29uc3QgY2VsbHNJblNhbWVSb3cgPSBjZWxsSW5Sb3cobWFwLCByb3dJbmRleCk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxzSW5TYW1lUm93Lmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRjZWxsc0luU2FtZVJvd1tpXS5yb3dTcGFuKys7XG5cdFx0fVxuXG5cdFx0bmV3Q2VsbC5hcHBlbmRCb2d1cygpO1xuXG5cdFx0Y2VsbC4kLnJvd1NwYW4gPSBuZXdSb3dTcGFuO1xuXHRcdG5ld0NlbGwuJC5yb3dTcGFuID0gbmV3Q2VsbFJvd1NwYW47XG5cdFx0aWYgKG5ld1Jvd1NwYW4gPT0gMSkgY2VsbC5yZW1vdmVBdHRyaWJ1dGUoJ3Jvd1NwYW4nKTtcblx0XHRpZiAobmV3Q2VsbFJvd1NwYW4gPT0gMSkgbmV3Q2VsbC5yZW1vdmVBdHRyaWJ1dGUoJ3Jvd1NwYW4nKTtcblxuXHRcdHJldHVybiBuZXdDZWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaG9yaXpvbnRhbFNwbGl0Q2VsbChzZWxlY3Rpb24sIGlzRGV0ZWN0KSB7XG5cdFx0Y29uc3QgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKHNlbGVjdGlvbik7XG5cdFx0aWYgKGNlbGxzLmxlbmd0aCA+IDEpIHJldHVybiBmYWxzZTtcblx0XHRlbHNlIGlmIChpc0RldGVjdCkgcmV0dXJuIHRydWU7XG5cblx0XHRjb25zdCBjZWxsID0gY2VsbHNbMF07XG5cblx0XHRjb25zdCB0ciA9IGNlbGwuZ2V0UGFyZW50KCk7XG5cblx0XHRjb25zdCB0YWJsZSA9IHRyLmdldEFzY2VuZGFudCgndGFibGUnKTtcblxuXHRcdGNvbnN0IG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAodGFibGUpO1xuXG5cdFx0Y29uc3Qgcm93SW5kZXggPSB0ci4kLnJvd0luZGV4O1xuXG5cdFx0Y29uc3QgY29sSW5kZXggPSBjZWxsSW5Sb3cobWFwLCByb3dJbmRleCwgY2VsbCk7XG5cblx0XHRjb25zdCBjb2xTcGFuID0gY2VsbC4kLmNvbFNwYW47XG5cblx0XHRsZXQgbmV3Q29sU3BhbjtcblxuXHRcdGxldCBuZXdDZWxsQ29sU3BhbjtcblxuXHRcdGlmIChjb2xTcGFuID4gMSkge1xuXHRcdFx0bmV3Q29sU3BhbiA9IE1hdGguY2VpbChjb2xTcGFuIC8gMik7XG5cdFx0XHRuZXdDZWxsQ29sU3BhbiA9IE1hdGguZmxvb3IoY29sU3BhbiAvIDIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdDZWxsQ29sU3BhbiA9IG5ld0NvbFNwYW4gPSAxO1xuXHRcdFx0Y29uc3QgY2VsbHNJblNhbWVDb2wgPSBjZWxsSW5Db2wobWFwLCBjb2xJbmRleCk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxzSW5TYW1lQ29sLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRjZWxsc0luU2FtZUNvbFtpXS5jb2xTcGFuKys7XG5cdFx0fVxuXHRcdGNvbnN0IG5ld0NlbGwgPSBjZWxsLmNsb25lKCk7XG5cdFx0bmV3Q2VsbC5pbnNlcnRBZnRlcihjZWxsKTtcblx0XHRuZXdDZWxsLmFwcGVuZEJvZ3VzKCk7XG5cblx0XHRjZWxsLiQuY29sU3BhbiA9IG5ld0NvbFNwYW47XG5cdFx0bmV3Q2VsbC4kLmNvbFNwYW4gPSBuZXdDZWxsQ29sU3Bhbjtcblx0XHRpZiAobmV3Q29sU3BhbiA9PSAxKSBjZWxsLnJlbW92ZUF0dHJpYnV0ZSgnY29sU3BhbicpO1xuXHRcdGlmIChuZXdDZWxsQ29sU3BhbiA9PSAxKSBuZXdDZWxsLnJlbW92ZUF0dHJpYnV0ZSgnY29sU3BhbicpO1xuXG5cdFx0cmV0dXJuIG5ld0NlbGw7XG5cdH1cblxuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfdGFibGV0b29scycsIHtcblx0XHRpbml0KGVkaXRvcikge1xuXHRcdFx0ZnVuY3Rpb24gY3JlYXRlRGVmKGRlZikge1xuXHRcdFx0XHRyZXR1cm4gQ0tFRElUT1IudG9vbHMuZXh0ZW5kKGRlZiB8fCB7fSwge1xuXHRcdFx0XHRcdGNvbnRleHRTZW5zaXRpdmU6IDEsXG5cdFx0XHRcdFx0cmVmcmVzaChlZGl0b3IsIHBhdGgpIHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0U3RhdGUoXG5cdFx0XHRcdFx0XHRcdHBhdGguY29udGFpbnMoe3RkOiAxLCB0aDogMX0sIDEpXG5cdFx0XHRcdFx0XHRcdFx0PyBDS0VESVRPUi5UUklTVEFURV9PRkZcblx0XHRcdFx0XHRcdFx0XHQ6IENLRURJVE9SLlRSSVNUQVRFX0RJU0FCTEVEXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gYWRkQ21kKG5hbWUsIGRlZikge1xuXHRcdFx0XHRsZXQgY21kID0gZWRpdG9yLmdldENvbW1hbmQobmFtZSk7XG5cblx0XHRcdFx0aWYgKGNtZCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNtZCA9IGVkaXRvci5hZGRDb21tYW5kKG5hbWUsIGRlZik7XG5cdFx0XHRcdGVkaXRvci5hZGRGZWF0dXJlKGNtZCk7XG5cdFx0XHR9XG5cblx0XHRcdGFkZENtZChcblx0XHRcdFx0J3Jvd0RlbGV0ZScsXG5cdFx0XHRcdGNyZWF0ZURlZih7XG5cdFx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRcdGV4ZWMoZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0XHRwbGFjZUN1cnNvckluQ2VsbChkZWxldGVSb3dzKHNlbGVjdGlvbikpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0XHRhZGRDbWQoXG5cdFx0XHRcdCdyb3dJbnNlcnRCZWZvcmUnLFxuXHRcdFx0XHRjcmVhdGVEZWYoe1xuXHRcdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0XHRleGVjKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0aW5zZXJ0Um93KGVkaXRvciwgdHJ1ZSk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHRcdGFkZENtZChcblx0XHRcdFx0J3Jvd0luc2VydEFmdGVyJyxcblx0XHRcdFx0Y3JlYXRlRGVmKHtcblx0XHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0YWJsZScsXG5cdFx0XHRcdFx0ZXhlYyhlZGl0b3IpIHtcblx0XHRcdFx0XHRcdGluc2VydFJvdyhlZGl0b3IpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0XHRhZGRDbWQoXG5cdFx0XHRcdCdjb2x1bW5EZWxldGUnLFxuXHRcdFx0XHRjcmVhdGVEZWYoe1xuXHRcdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0XHRleGVjKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdFx0Y29uc3QgZWxlbWVudCA9IGRlbGV0ZUNvbHVtbnMoc2VsZWN0aW9uKTtcblx0XHRcdFx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdHBsYWNlQ3Vyc29ySW5DZWxsKGVsZW1lbnQsIHRydWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0XHRhZGRDbWQoXG5cdFx0XHRcdCdjb2x1bW5JbnNlcnRCZWZvcmUnLFxuXHRcdFx0XHRjcmVhdGVEZWYoe1xuXHRcdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0XHRleGVjKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0aW5zZXJ0Q29sdW1uKGVkaXRvciwgdHJ1ZSk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHRcdGFkZENtZChcblx0XHRcdFx0J2NvbHVtbkluc2VydEFmdGVyJyxcblx0XHRcdFx0Y3JlYXRlRGVmKHtcblx0XHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0YWJsZScsXG5cdFx0XHRcdFx0ZXhlYyhlZGl0b3IpIHtcblx0XHRcdFx0XHRcdGluc2VydENvbHVtbihlZGl0b3IpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0XHRhZGRDbWQoXG5cdFx0XHRcdCdjZWxsRGVsZXRlJyxcblx0XHRcdFx0Y3JlYXRlRGVmKHtcblx0XHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0YWJsZScsXG5cdFx0XHRcdFx0ZXhlYyhlZGl0b3IpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdFx0XHRcdGRlbGV0ZUNlbGxzKHNlbGVjdGlvbik7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHRcdGFkZENtZChcblx0XHRcdFx0J2NlbGxNZXJnZScsXG5cdFx0XHRcdGNyZWF0ZURlZih7XG5cdFx0XHRcdFx0YWxsb3dlZENvbnRlbnQ6ICd0ZFtjb2xzcGFuLHJvd3NwYW5dJyxcblx0XHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0ZFtjb2xzcGFuLHJvd3NwYW5dJyxcblx0XHRcdFx0XHRleGVjKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoXG5cdFx0XHRcdFx0XHRcdG1lcmdlQ2VsbHMoZWRpdG9yLmdldFNlbGVjdGlvbigpKSxcblx0XHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdFx0YWRkQ21kKFxuXHRcdFx0XHQnY2VsbE1lcmdlUmlnaHQnLFxuXHRcdFx0XHRjcmVhdGVEZWYoe1xuXHRcdFx0XHRcdGFsbG93ZWRDb250ZW50OiAndGRbY29sc3Bhbl0nLFxuXHRcdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RkW2NvbHNwYW5dJyxcblx0XHRcdFx0XHRleGVjKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoXG5cdFx0XHRcdFx0XHRcdG1lcmdlQ2VsbHMoZWRpdG9yLmdldFNlbGVjdGlvbigpLCAncmlnaHQnKSxcblx0XHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdFx0YWRkQ21kKFxuXHRcdFx0XHQnY2VsbE1lcmdlRG93bicsXG5cdFx0XHRcdGNyZWF0ZURlZih7XG5cdFx0XHRcdFx0YWxsb3dlZENvbnRlbnQ6ICd0ZFtyb3dzcGFuXScsXG5cdFx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGRbcm93c3Bhbl0nLFxuXHRcdFx0XHRcdGV4ZWMoZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRwbGFjZUN1cnNvckluQ2VsbChcblx0XHRcdFx0XHRcdFx0bWVyZ2VDZWxscyhlZGl0b3IuZ2V0U2VsZWN0aW9uKCksICdkb3duJyksXG5cdFx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHRcdGFkZENtZChcblx0XHRcdFx0J2NlbGxWZXJ0aWNhbFNwbGl0Jyxcblx0XHRcdFx0Y3JlYXRlRGVmKHtcblx0XHRcdFx0XHRhbGxvd2VkQ29udGVudDogJ3RkW3Jvd3NwYW5dJyxcblx0XHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0ZFtyb3dzcGFuXScsXG5cdFx0XHRcdFx0ZXhlYyhlZGl0b3IpIHtcblx0XHRcdFx0XHRcdHBsYWNlQ3Vyc29ySW5DZWxsKFxuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNhbFNwbGl0Q2VsbChlZGl0b3IuZ2V0U2VsZWN0aW9uKCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0XHRhZGRDbWQoXG5cdFx0XHRcdCdjZWxsSG9yaXpvbnRhbFNwbGl0Jyxcblx0XHRcdFx0Y3JlYXRlRGVmKHtcblx0XHRcdFx0XHRhbGxvd2VkQ29udGVudDogJ3RkW2NvbHNwYW5dJyxcblx0XHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0ZFtjb2xzcGFuXScsXG5cdFx0XHRcdFx0ZXhlYyhlZGl0b3IpIHtcblx0XHRcdFx0XHRcdHBsYWNlQ3Vyc29ySW5DZWxsKFxuXHRcdFx0XHRcdFx0XHRob3Jpem9udGFsU3BsaXRDZWxsKGVkaXRvci5nZXRTZWxlY3Rpb24oKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHRcdGFkZENtZChcblx0XHRcdFx0J2NlbGxJbnNlcnRCZWZvcmUnLFxuXHRcdFx0XHRjcmVhdGVEZWYoe1xuXHRcdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0XHRleGVjKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdFx0aW5zZXJ0Q2VsbChzZWxlY3Rpb24sIHRydWUpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0XHRhZGRDbWQoXG5cdFx0XHRcdCdjZWxsSW5zZXJ0QWZ0ZXInLFxuXHRcdFx0XHRjcmVhdGVEZWYoe1xuXHRcdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0XHRleGVjKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdFx0aW5zZXJ0Q2VsbChzZWxlY3Rpb24pO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRnZXRTZWxlY3RlZENlbGxzLFxuXHR9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSB0d28tZGltZW5zaW9uIGFycmF5IHRoYXQgcmVmbGVjdHMgdGhlIGFjdHVhbCBsYXlvdXQgb2YgdGFibGUgY2VsbHMsXG4gKiB3aXRoIGNlbGwgc3BhbnMsIHdpdGggbWFwcGluZ3MgdG8gdGhlIG9yaWdpbmFsIHRkIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IHRhYmxlXG4gKiBAbWVtYmVyIENLRURJVE9SLnRvb2xzXG4gKi9cbkNLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAgPSBmdW5jdGlvbih0YWJsZSkge1xuXHRjb25zdCBhUm93cyA9IHRhYmxlLiQucm93cztcblxuXHQvLyBSb3cgYW5kIENvbHVtbiBjb3VudGVycy5cblx0bGV0IHIgPSAtMTtcblxuXHRjb25zdCBhTWFwID0gW107XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhUm93cy5sZW5ndGg7IGkrKykge1xuXHRcdHIrKztcblx0XHRpZiAoIWFNYXBbcl0pIHtcblx0XHRcdGFNYXBbcl0gPSBbXTtcblx0XHR9XG5cblx0XHRsZXQgYyA9IC0xO1xuXG5cdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBhUm93c1tpXS5jZWxscy5sZW5ndGg7IGorKykge1xuXHRcdFx0Y29uc3Qgb0NlbGwgPSBhUm93c1tpXS5jZWxsc1tqXTtcblxuXHRcdFx0YysrO1xuXHRcdFx0d2hpbGUgKGFNYXBbcl1bY10pIGMrKztcblxuXHRcdFx0Y29uc3QgaUNvbFNwYW4gPSBpc05hTihvQ2VsbC5jb2xTcGFuKSA/IDEgOiBvQ2VsbC5jb2xTcGFuO1xuXHRcdFx0Y29uc3QgaVJvd1NwYW4gPSBpc05hTihvQ2VsbC5yb3dTcGFuKSA/IDEgOiBvQ2VsbC5yb3dTcGFuO1xuXG5cdFx0XHRmb3IgKGxldCBycyA9IDA7IHJzIDwgaVJvd1NwYW47IHJzKyspIHtcblx0XHRcdFx0aWYgKCFhTWFwW3IgKyByc10pIGFNYXBbciArIHJzXSA9IFtdO1xuXG5cdFx0XHRcdGZvciAobGV0IGNzID0gMDsgY3MgPCBpQ29sU3BhbjsgY3MrKykge1xuXHRcdFx0XHRcdGFNYXBbciArIHJzXVtjICsgY3NdID0gYVJvd3NbaV0uY2VsbHNbal07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0YyArPSBpQ29sU3BhbiAtIDE7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhTWFwO1xufTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuY29uc3QgdGFibGVTZWxlY3Rpb25HZXRBcnJvd0JveENsYXNzZXMgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuICdhZS1hcnJvdy1ib3ggYWUtYXJyb3ctYm94LWJvdHRvbSc7XG59O1xuXG5jb25zdCBTZWxlY3Rpb25HZXRBcnJvd0JveENsYXNzZXMgPSB7XG5cdHRhYmxlOiB0YWJsZVNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3Nlcyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcztcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbi8vIERlZmF1bHQgZ3V0dGVyIHZhbHVlIGZvciB0b29sYmFyIHBvc2l0aW9uaW5nXG5jb25zdCBERUZBVUxUX0dVVFRFUiA9IHtcblx0bGVmdDogMCxcblx0dG9wOiAwLFxufTtcblxuLyoqXG4gKiBDZW50ZXJzIGEgVG9vbGJhciBhY2NvcmRpbmcgdG8gZ2l2ZW4gcmVjdGFuZ2xlXG4gKlxuICogQG1ldGhvZCBjZW50ZXJUb29sYmFyXG4gKiBAcGFyYW0ge09iamVjdH0gdG9vbGJhciBUaGUgdG9vbGJhciB0byBiZSBjZW50ZXJlZFxuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgVGhlIHJlY3RhbmdsZSBhY2NvcmRpbmcgdG8gd2hpY2ggdGhlIFRvb2xiYXIgd2lsbCBiZSBjZW50ZXJlZFxuICovXG5jb25zdCBjZW50ZXJUb29sYmFyID0gZnVuY3Rpb24odG9vbGJhciwgcmVjdCkge1xuXHRjb25zdCB0b29sYmFyTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRvb2xiYXIpO1xuXG5cdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHRvb2xiYXIuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0Y29uc3QgdWlOb2RlID0gbmF0aXZlRWRpdG9yLmNvbmZpZy51aU5vZGUgfHwgZG9jdW1lbnQuYm9keTtcblx0Y29uc3QgdWlOb2RlU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHVpTm9kZSk7XG5cdGNvbnN0IHVpTm9kZU1hcmdpbkxlZnQgPSBwYXJzZUludChcblx0XHR1aU5vZGVTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tbGVmdCcpLFxuXHRcdDEwXG5cdCk7XG5cdGNvbnN0IHVpTm9kZU1hcmdpblJpZ2h0ID0gcGFyc2VJbnQoXG5cdFx0dWlOb2RlU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXJpZ2h0JyksXG5cdFx0MTBcblx0KTtcblx0Y29uc3QgdG90YWxXaWR0aCA9XG5cdFx0dWlOb2RlTWFyZ2luTGVmdCArIHVpTm9kZS5jbGllbnRXaWR0aCArIHVpTm9kZU1hcmdpblJpZ2h0O1xuXG5cdGNvbnN0IGhhbGZOb2RlV2lkdGggPSB0b29sYmFyTm9kZS5vZmZzZXRXaWR0aCAvIDI7XG5cdGNvbnN0IHNjcm9sbFBvc2l0aW9uID0gbmV3IENLRURJVE9SLmRvbS53aW5kb3cod2luZG93KS5nZXRTY3JvbGxQb3NpdGlvbigpO1xuXG5cdGNvbnN0IGd1dHRlciA9IHRvb2xiYXIucHJvcHMuZ3V0dGVyIHx8IERFRkFVTFRfR1VUVEVSO1xuXG5cdGNvbnN0IHdpZGdldFhZID0gdG9vbGJhci5nZXRXaWRnZXRYWVBvaW50KFxuXHRcdHJlY3QubGVmdCArIHJlY3Qud2lkdGggLyAyIC0gc2Nyb2xsUG9zaXRpb24ueCxcblx0XHRyZWN0LnRvcCArIHNjcm9sbFBvc2l0aW9uLnksXG5cdFx0Q0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1Bcblx0KTtcblxuXHRjb25zdCBjYXJldFBvc2l0aW9uID0gbmF0aXZlRWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRjb25zdCByYW5nZXMgPSBjYXJldFBvc2l0aW9uLmdldFJhbmdlcygpO1xuXHRsZXQgb2Zmc2V0SGVpZ2h0ID0gMDtcblxuXHRpZiAocmFuZ2VzICYmIHJhbmdlcy5sZW5ndGggPT09IDEpIHtcblx0XHRsZXQgc3RhcnRDb250YWluZXIgPSByYW5nZXNbMF0uc3RhcnRDb250YWluZXI7XG5cdFx0aWYgKHN0YXJ0Q29udGFpbmVyLiQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG5cdFx0XHRzdGFydENvbnRhaW5lciA9IHN0YXJ0Q29udGFpbmVyLmdldFBhcmVudCgpO1xuXHRcdH1cblx0XHRpZiAoc3RhcnRDb250YWluZXIpIHtcblx0XHRcdGNvbnN0IHN0YXJ0Q29udGFpbmVyQ2xpZW50UmVjdCA9IHN0YXJ0Q29udGFpbmVyLmdldENsaWVudFJlY3QoKTtcblx0XHRcdG9mZnNldEhlaWdodCA9IHN0YXJ0Q29udGFpbmVyQ2xpZW50UmVjdC55IC0gcmVjdC50b3A7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3QgZW5kUG9zaXRpb24gPSBbXG5cdFx0cmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAvIDIgLSBoYWxmTm9kZVdpZHRoIC0gc2Nyb2xsUG9zaXRpb24ueCxcblx0XHRyZWN0LnRvcCArXG5cdFx0XHRvZmZzZXRIZWlnaHQgLVxuXHRcdFx0dG9vbGJhck5vZGUub2Zmc2V0SGVpZ2h0ICtcblx0XHRcdHNjcm9sbFBvc2l0aW9uLnkgLVxuXHRcdFx0Z3V0dGVyLnRvcCxcblx0XTtcblxuXHRpZiAoZW5kUG9zaXRpb25bMF0gPCAwKSB7XG5cdFx0ZW5kUG9zaXRpb25bMF0gPSAwO1xuXHR9IGVsc2UgaWYgKGVuZFBvc2l0aW9uWzBdID4gdG90YWxXaWR0aCAtIHRvb2xiYXJOb2RlLm9mZnNldFdpZHRoKSB7XG5cdFx0ZW5kUG9zaXRpb25bMF0gPSB0b3RhbFdpZHRoIC0gdG9vbGJhck5vZGUub2Zmc2V0V2lkdGg7XG5cdH1cblxuXHR0b29sYmFyLm1vdmVUb1BvaW50KHdpZGdldFhZLCBlbmRQb3NpdGlvbik7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgdG9vbGJhciBhY2NvcmRpbmcgdG8gdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWxlY3RlZCBpbWFnZVxuICpcbiAqIEBtZXRob2QgaW1hZ2VTZWxlY3Rpb25TZXRQb3NpdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgUGF5bG9hZCwgc2hvdWxkIGNvbnRhaW4gdGhlIHNlbGVjdGlvbiBkYXRhIGZvciByZXRyaWV2aW5nIHRoZVxuICogY2xpZW50IHJlY3RhbmdsZSBvZiB0aGUgc2VsZWN0ZWQgaW1hZ2VcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUsIGluIGFsbCBjYXNlc1xuICovXG5jb25zdCBpbWFnZVNlbGVjdGlvblNldFBvc2l0aW9uID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuXHRjb25zdCBzZWxlY3Rpb25EYXRhID0gcGF5bG9hZC5zZWxlY3Rpb25EYXRhXG5cdFx0PyBwYXlsb2FkLnNlbGVjdGlvbkRhdGFcblx0XHQ6IHBheWxvYWQuZWRpdG9yRXZlbnRcblx0XHQ/IHBheWxvYWQuZWRpdG9yRXZlbnQuZGF0YS5zZWxlY3Rpb25EYXRhXG5cdFx0OiBudWxsO1xuXG5cdGlmIChzZWxlY3Rpb25EYXRhICYmIHNlbGVjdGlvbkRhdGEuZWxlbWVudCkge1xuXHRcdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHBheWxvYWQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdFx0Y29uc3QgdWlOb2RlID0gbmF0aXZlRWRpdG9yLmNvbmZpZy51aU5vZGU7XG5cblx0XHRjb25zdCBzY3JvbGxUb3AgPSB1aU5vZGUgPyB1aU5vZGUuc2Nyb2xsVG9wIDogMDtcblxuXHRcdGNvbnN0IHJlY3QgPSBzZWxlY3Rpb25EYXRhLmVsZW1lbnQuZ2V0Q2xpZW50UmVjdCgpO1xuXHRcdHJlY3QudG9wICs9IHNjcm9sbFRvcDtcblxuXHRcdGNlbnRlclRvb2xiYXIodGhpcywgcmVjdCk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIHRvb2xiYXIgYWNjb3JkaW5nIHRvIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2VsZWN0ZWQgaW1hZ2VcbiAqXG4gKiBAbWV0aG9kIHRhYmxlU2VsZWN0aW9uU2V0UG9zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIE9iamVjdCwgd2hpY2ggY29udGFpbnMgdGhlIHNlbGVjdGlvbiBkYXRhIGZvciByZXRyaWV2aW5nIHRoZVxuICogY2xpZW50IHJlY3RhbmdsZSBvZiB0aGUgc2VsZWN0ZWQgdGFibGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUsIGluIGFsbCBjYXNlc1xuICovXG5jb25zdCB0YWJsZVNlbGVjdGlvblNldFBvc2l0aW9uID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuXHRjb25zdCBuYXRpdmVFZGl0b3IgPSBwYXlsb2FkLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRjb25zdCB1aU5vZGUgPSBuYXRpdmVFZGl0b3IuY29uZmlnLnVpTm9kZTtcblxuXHRjb25zdCBzY3JvbGxUb3AgPSB1aU5vZGUgPyB1aU5vZGUuc2Nyb2xsVG9wIDogMDtcblxuXHRjb25zdCB0YWJsZSA9IG5ldyBDS0VESVRPUi5UYWJsZShuYXRpdmVFZGl0b3IpLmdldEZyb21TZWxlY3Rpb24oKTtcblx0Y29uc3QgcmVjdCA9IHRhYmxlLmdldENsaWVudFJlY3QoKTtcblx0cmVjdC50b3AgKz0gc2Nyb2xsVG9wO1xuXG5cdGNlbnRlclRvb2xiYXIodGhpcywgcmVjdCk7XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBTZWxlY3Rpb25TZXRQb3NpdGlvbiA9IHtcblx0aW1hZ2U6IGltYWdlU2VsZWN0aW9uU2V0UG9zaXRpb24sXG5cdHRhYmxlOiB0YWJsZVNlbGVjdGlvblNldFBvc2l0aW9uLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0aW9uU2V0UG9zaXRpb247XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmNvbnN0IF9pc1JhbmdlQXRFbGVtZW50RW5kID0gZnVuY3Rpb24ocmFuZ2UsIGVsZW1lbnQpIHtcblx0Ly8gRmluZGluZyBpZiBhIHJhbmdlIGlzIGF0IHRoZSBlbmQgb2YgYW4gZWxlbWVudCBpcyBzb21ld2hhdCB0cmlja3lcblx0Ly8gZHVlIHRvIGhvdyBDS0VkaXRvciBoYW5kbGVzIHJhbmdlcy4gSXQgbWlnaHQgZGVwZW5kIG9uIHdoZXRoZXIgYVxuXHQvLyBzb3VyY2Ugbm9kZSBpbnNpZGUgdGhlIGVsZW1lbnQgaXMgc2VsZWN0ZWQgb3Igbm90LiBGb3Igbm93LCB3ZVxuXHQvLyBuZWVkIHRvIGNvdmVyIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vXG5cdC8vIC0gVGhlIHRleHQgbGVuZ3RoIG9mIHRoZSBlbGVtZW50IGlzIHRoZSBzYW1lIGFzIHRoZSBlbmRPZmZzZXQgb2Zcblx0Ly8gICB0aGUgcmFuZ2UuXG5cdC8vIC0gQm90aCBzdGFydCBhbmQgZW5kIGNvbnRhaW5lcnMgbWF0Y2ggdGhlIGVsZW1lbnQgYW5kIHRoZSBzdGFydFxuXHQvLyAgIGFuZCBlbmQgb2Zmc2V0cyBhcmUgMS5cblxuXHRyZXR1cm4gKFxuXHRcdGVsZW1lbnQuZ2V0VGV4dCgpLmxlbmd0aCA9PT0gcmFuZ2UuZW5kT2Zmc2V0IHx8XG5cdFx0KGVsZW1lbnQuZXF1YWxzKHJhbmdlLnN0YXJ0Q29udGFpbmVyKSAmJlxuXHRcdFx0ZWxlbWVudC5lcXVhbHMocmFuZ2UuZW5kQ29udGFpbmVyKSAmJlxuXHRcdFx0cmFuZ2Uuc3RhcnRPZmZzZXQgPT09IHJhbmdlLmVuZE9mZnNldCAmJlxuXHRcdFx0cmFuZ2UuZW5kT2Zmc2V0ID09PSAxKVxuXHQpO1xufTtcblxuY29uc3QgZW1iZWRTZWxlY3Rpb25UZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuXHRjb25zdCBzZWxlY3Rpb25EYXRhID0gcGF5bG9hZC5kYXRhLnNlbGVjdGlvbkRhdGE7XG5cblx0cmV0dXJuICEhKFxuXHRcdHNlbGVjdGlvbkRhdGEuZWxlbWVudCAmJlxuXHRcdHNlbGVjdGlvbkRhdGEuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtd2lkZ2V0JykgPT09ICdhZV9lbWJlZCdcblx0KTtcbn07XG5cbmNvbnN0IGVtYmVkVXJsU2VsZWN0aW9uVGVzdCA9IGZ1bmN0aW9uKHBheWxvYWQpIHtcblx0Y29uc3Qgc2VsZWN0aW9uRGF0YSA9IHBheWxvYWQuZGF0YS5zZWxlY3Rpb25EYXRhO1xuXG5cdHJldHVybiAhIShcblx0XHRzZWxlY3Rpb25EYXRhLmVsZW1lbnQgJiZcblx0XHRzZWxlY3Rpb25EYXRhLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXdpZGdldCcpID09PSAnZW1iZWR1cmwnXG5cdCk7XG59O1xuXG5jb25zdCBoZWFkaW5nVGV4dFNlbGVjdGlvblRlc3QgPSBmdW5jdGlvbihwYXlsb2FkKSB7XG5cdGNvbnN0IGhlYWRpbmdzID0gWydoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNiddO1xuXHRjb25zdCBuYXRpdmVFZGl0b3IgPSBwYXlsb2FkLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRjb25zdCBzZWxlY3Rpb25EYXRhID0gcGF5bG9hZC5kYXRhLnNlbGVjdGlvbkRhdGE7XG5cdGNvbnN0IHNlbGVjdGlvbkVtcHR5ID0gbmF0aXZlRWRpdG9yLmlzU2VsZWN0aW9uRW1wdHkoKTtcblxuXHRyZXR1cm4gISEoXG5cdFx0IXNlbGVjdGlvbkRhdGEuZWxlbWVudCAmJlxuXHRcdHNlbGVjdGlvbkRhdGEucmVnaW9uICYmXG5cdFx0IXNlbGVjdGlvbkVtcHR5ICYmXG5cdFx0IW5hdGl2ZUVkaXRvclxuXHRcdFx0LmdldFNlbGVjdGlvbigpXG5cdFx0XHQuZ2V0Q29tbW9uQW5jZXN0b3IoKVxuXHRcdFx0LmlzUmVhZE9ubHkoKSAmJlxuXHRcdG5hdGl2ZUVkaXRvci5lbGVtZW50UGF0aCgpLmNvbnRhaW5zKGhlYWRpbmdzKVxuXHQpO1xufTtcblxuY29uc3QgbGlua1NlbGVjdGlvblRlc3QgPSBmdW5jdGlvbihwYXlsb2FkKSB7XG5cdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHBheWxvYWQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdGNvbnN0IHJhbmdlID0gbmF0aXZlRWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFJhbmdlcygpWzBdO1xuXHRjb25zdCBzZWxlY3Rpb25EYXRhID0gcGF5bG9hZC5kYXRhLnNlbGVjdGlvbkRhdGE7XG5cblx0Y29uc3QgZWxlbWVudCA9IG5ldyBDS0VESVRPUi5MaW5rKG5hdGl2ZUVkaXRvcikuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXHRjb25zdCBpc1NlbGVjdGlvbkVtcHR5ID0gbmF0aXZlRWRpdG9yLmlzU2VsZWN0aW9uRW1wdHkoKTtcblx0Y29uc3QgZWxlbWVudElzTm90SW1hZ2UgPSBzZWxlY3Rpb25EYXRhLmVsZW1lbnRcblx0XHQ/IHNlbGVjdGlvbkRhdGEuZWxlbWVudC5nZXROYW1lKCkgIT09ICdpbWcnXG5cdFx0OiB0cnVlO1xuXG5cdHJldHVybiAhIShcblx0XHRpc1NlbGVjdGlvbkVtcHR5ICYmXG5cdFx0ZWxlbWVudElzTm90SW1hZ2UgJiZcblx0XHRlbGVtZW50ICYmXG5cdFx0ZWxlbWVudC5nZXRUZXh0KCkubGVuZ3RoICE9PSByYW5nZS5lbmRPZmZzZXQgJiZcblx0XHRlbGVtZW50ICYmXG5cdFx0IWVsZW1lbnQuaXNSZWFkT25seSgpICYmXG5cdFx0IV9pc1JhbmdlQXRFbGVtZW50RW5kKHJhbmdlLCBlbGVtZW50KVxuXHQpO1xufTtcblxuY29uc3QgaW1hZ2VTZWxlY3Rpb25UZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuXHRjb25zdCBzZWxlY3Rpb25EYXRhID0gcGF5bG9hZC5kYXRhLnNlbGVjdGlvbkRhdGE7XG5cdGNvbnN0IGVsZW1lbnQgPSBzZWxlY3Rpb25EYXRhLmVsZW1lbnQ7XG5cdGNvbnN0IGhhc0ltYWdlID0gISFlbGVtZW50ICYmICEhZWxlbWVudC5maW5kT25lKCdpbWcnKTtcblx0Y29uc3QgaXNJbWFnZSA9ICEhZWxlbWVudCAmJiBlbGVtZW50LmdldE5hbWUoKSA9PT0gJ2ltZyc7XG5cblx0cmV0dXJuICEhKGVsZW1lbnQgJiYgKGhhc0ltYWdlIHx8IGlzSW1hZ2UpKTtcbn07XG5cbmNvbnN0IHRleHRTZWxlY3Rpb25UZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuXHRjb25zdCBuYXRpdmVFZGl0b3IgPSBwYXlsb2FkLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdGNvbnN0IHNlbGVjdGlvbkVtcHR5ID0gbmF0aXZlRWRpdG9yLmlzU2VsZWN0aW9uRW1wdHkoKTtcblxuXHRjb25zdCBzZWxlY3Rpb25EYXRhID0gcGF5bG9hZC5kYXRhLnNlbGVjdGlvbkRhdGE7XG5cblx0cmV0dXJuICEhKFxuXHRcdCFzZWxlY3Rpb25EYXRhLmVsZW1lbnQgJiZcblx0XHRzZWxlY3Rpb25EYXRhLnJlZ2lvbiAmJlxuXHRcdCFzZWxlY3Rpb25FbXB0eSAmJlxuXHRcdCFuYXRpdmVFZGl0b3Jcblx0XHRcdC5nZXRTZWxlY3Rpb24oKVxuXHRcdFx0LmdldENvbW1vbkFuY2VzdG9yKClcblx0XHRcdC5pc1JlYWRPbmx5KClcblx0KTtcbn07XG5cbmNvbnN0IHRhYmxlU2VsZWN0aW9uVGVzdCA9IGZ1bmN0aW9uKHBheWxvYWQpIHtcblx0Y29uc3QgbmF0aXZlRWRpdG9yID0gcGF5bG9hZC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRjb25zdCB0YWJsZSA9IG5ldyBDS0VESVRPUi5UYWJsZShuYXRpdmVFZGl0b3IpO1xuXHRjb25zdCBlbGVtZW50ID0gdGFibGUuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXG5cdHJldHVybiAhIShlbGVtZW50ICYmIHRhYmxlLmlzRWRpdGFibGUoZWxlbWVudCkpO1xufTtcblxuY29uc3QgU2VsZWN0aW9uVGVzdCA9IHtcblx0ZW1iZWQ6IGVtYmVkU2VsZWN0aW9uVGVzdCxcblx0ZW1iZWRVcmw6IGVtYmVkVXJsU2VsZWN0aW9uVGVzdCxcblx0aGVhZGVyOiBoZWFkaW5nVGV4dFNlbGVjdGlvblRlc3QsXG5cdGltYWdlOiBpbWFnZVNlbGVjdGlvblRlc3QsXG5cdGxpbms6IGxpbmtTZWxlY3Rpb25UZXN0LFxuXHR0YWJsZTogdGFibGVTZWxlY3Rpb25UZXN0LFxuXHR0ZXh0OiB0ZXh0U2VsZWN0aW9uVGVzdCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdGlvblRlc3Q7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBTZWxlY3Rpb25HZXRBcnJvd0JveENsYXNzZXMgZnJvbSAnLi9zZWxlY3Rpb24tYXJyb3dib3gnO1xuaW1wb3J0IFNlbGVjdGlvblNldFBvc2l0aW9uIGZyb20gJy4vc2VsZWN0aW9uLXBvc2l0aW9uJztcbmltcG9ydCBTZWxlY3Rpb25UZXN0IGZyb20gJy4vc2VsZWN0aW9uLXRlc3QnO1xuXG5jb25zdCBTZWxlY3Rpb25zID0gW1xuXHR7XG5cdFx0bmFtZTogJ2VtYmVkJyxcblx0XHRidXR0b25zOiBbJ2VtYmVkUmVtb3ZlJywgJ2VtYmVkRWRpdCddLFxuXHRcdHRlc3Q6IFNlbGVjdGlvblRlc3QuZW1iZWQsXG5cdH0sXG5cdHtcblx0XHRuYW1lOiAnZW1iZWRVcmwnLFxuXHRcdGJ1dHRvbnM6IFsnZW1iZWRWaWRlbycsICdlbWJlZFZpZGVvRWRpdCddLFxuXHRcdHRlc3Q6IFNlbGVjdGlvblRlc3QuZW1iZWRVcmwsXG5cdH0sXG5cdHtcblx0XHRuYW1lOiAnbGluaycsXG5cdFx0YnV0dG9uczogWydsaW5rRWRpdCddLFxuXHRcdHRlc3Q6IFNlbGVjdGlvblRlc3QubGluayxcblx0fSxcblx0e1xuXHRcdG5hbWU6ICdpbWFnZScsXG5cdFx0YnV0dG9uczogWydpbWFnZUxlZnQnLCAnaW1hZ2VDZW50ZXInLCAnaW1hZ2VSaWdodCcsICdyZW1vdmVJbWFnZSddLFxuXHRcdHNldFBvc2l0aW9uOiBTZWxlY3Rpb25TZXRQb3NpdGlvbi5pbWFnZSxcblx0XHR0ZXN0OiBTZWxlY3Rpb25UZXN0LmltYWdlLFxuXHR9LFxuXHR7XG5cdFx0bmFtZTogJ3RleHQnLFxuXHRcdGJ1dHRvbnM6IHtcblx0XHRcdGZ1bGw6IFtcblx0XHRcdFx0W1xuXHRcdFx0XHRcdCdGb250Jyxcblx0XHRcdFx0XHQnRm9udFNpemUnLFxuXHRcdFx0XHRcdCdzZXBhcmF0b3InLFxuXHRcdFx0XHRcdCdib2xkJyxcblx0XHRcdFx0XHQnaXRhbGljJyxcblx0XHRcdFx0XHQndW5kZXJsaW5lJyxcblx0XHRcdFx0XHQnc3RyaWtlJyxcblx0XHRcdFx0XHQnc2VwYXJhdG9yJyxcblx0XHRcdFx0XHQnbGluaycsXG5cdFx0XHRcdF0sXG5cdFx0XHRcdFtcblx0XHRcdFx0XHQncGFyYWdyYXBoQWxpZ24nLFxuXHRcdFx0XHRcdCdzZXBhcmF0b3InLFxuXHRcdFx0XHRcdCd1bCcsXG5cdFx0XHRcdFx0J29sJyxcblx0XHRcdFx0XHQnc2VwYXJhdG9yJyxcblx0XHRcdFx0XHQnaDEnLFxuXHRcdFx0XHRcdCdoMicsXG5cdFx0XHRcdFx0J3NlcGFyYXRvcicsXG5cdFx0XHRcdFx0J2luZGVudEJsb2NrJyxcblx0XHRcdFx0XHQnb3V0ZGVudEJsb2NrJyxcblx0XHRcdFx0XHQnc2VwYXJhdG9yJyxcblx0XHRcdFx0XHQnVGV4dENvbG9yJyxcblx0XHRcdFx0XHQnQkdDb2xvcicsXG5cdFx0XHRcdFx0J3NlcGFyYXRvcicsXG5cdFx0XHRcdFx0J2NvZGUnLFxuXHRcdFx0XHRcdCdxdW90ZScsXG5cdFx0XHRcdFx0J3NlcGFyYXRvcicsXG5cdFx0XHRcdFx0J3JlbW92ZUZvcm1hdCcsXG5cdFx0XHRcdF0sXG5cdFx0XHRdLFxuXG5cdFx0XHRzaW1wbGU6IFsnc3R5bGVzJywgJ2JvbGQnLCAnaXRhbGljJywgJ3VuZGVybGluZScsICdsaW5rJ10sXG5cdFx0fSxcblx0XHR0ZXN0OiBTZWxlY3Rpb25UZXN0LnRleHQsXG5cdH0sXG5cdHtcblx0XHRuYW1lOiAndGFibGUnLFxuXHRcdGJ1dHRvbnM6IFtcblx0XHRcdCd0YWJsZUhlYWRpbmcnLFxuXHRcdFx0J3RhYmxlUm93Jyxcblx0XHRcdCd0YWJsZUNvbHVtbicsXG5cdFx0XHQndGFibGVDZWxsJyxcblx0XHRcdCd0YWJsZVJlbW92ZScsXG5cdFx0XSxcblx0XHRnZXRBcnJvd0JveENsYXNzZXM6IFNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3Nlcy50YWJsZSxcblx0XHRzZXRQb3NpdGlvbjogU2VsZWN0aW9uU2V0UG9zaXRpb24udGFibGUsXG5cdFx0dGVzdDogU2VsZWN0aW9uVGVzdC50YWJsZSxcblx0fSxcbl07XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdGlvbnM7XG4iLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gd2luZG93W3VuZGVmaW5lZF07IH0oKSk7IiwiKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1t1bmRlZmluZWRdOyB9KCkpOyJdLCJzb3VyY2VSb290IjoiIn0=