function F(){return!1}function T(){return!0}function add(t,n){return 1===arguments.length?n=>add(t,n):Number(t)+Number(n)}function curry(t,n=[]){return(...e)=>(n=>n.length>=t.length?t(...n):curry(t,n))([...n,...e])}function adjustFn(t,n,e){const r=t<0?e.length+t:t;if(t>=e.length||r<0)return e;const i=e.slice();return i[r]=n(i[r]),i}const adjust=curry(adjustFn);function all(t,n){if(1===arguments.length)return n=>all(t,n);for(let e=0;e<n.length;e++)if(!t(n[e]))return!1;return!0}function allPass(t){return n=>{let e=0;for(;e<t.length;){if(!t[e](n))return!1;e++}return!0}}function always(t){return()=>t}function and(t,n){return 1===arguments.length?n=>and(t,n):t&&n}function any(t,n){if(1===arguments.length)return n=>any(t,n);let e=0;for(;e<n.length;){if(t(n[e],e))return!0;e++}return!1}function anyPass(t){return n=>{let e=0;for(;e<t.length;){if(t[e](n))return!0;e++}return!1}}function append(t,n){if(1===arguments.length)return n=>append(t,n);if("string"==typeof n)return n.split("").concat(t);const e=n.slice();return e.push(t),e}const _isArray=Array.isArray;function __findHighestArity(t,n=0){for(const e in t)!1!==t.hasOwnProperty(e)&&"constructor"!==e&&("object"==typeof t[e]&&(n=Math.max(n,__findHighestArity(t[e]))),"function"==typeof t[e]&&(n=Math.max(n,t[e].length)));return n}function __filterUndefined(){const t=[];let n=0;const e=arguments.length;for(;n<e&&void 0!==arguments[n];)t[n]=arguments[n],n++;return t}function __applySpecWithArity(t,n,e){const r=n-e.length;if(1===r)return r=>__applySpecWithArity(t,n,__filterUndefined(...e,r));if(2===r)return(r,i)=>__applySpecWithArity(t,n,__filterUndefined(...e,r,i));if(3===r)return(r,i,o)=>__applySpecWithArity(t,n,__filterUndefined(...e,r,i,o));if(4===r)return(r,i,o,u)=>__applySpecWithArity(t,n,__filterUndefined(...e,r,i,o,u));if(r>4)return(...r)=>__applySpecWithArity(t,n,__filterUndefined(...e,...r));if(_isArray(t)){const r=[];let i=0;const o=t.length;for(;i<o;i++)("object"==typeof t[i]||_isArray(t[i]))&&(r[i]=__applySpecWithArity(t[i],n,e)),"function"==typeof t[i]&&(r[i]=t[i](...e));return r}const i={};for(const r in t)!1!==t.hasOwnProperty(r)&&"constructor"!==r&&("object"!=typeof t[r]?"function"==typeof t[r]&&(i[r]=t[r](...e)):i[r]=__applySpecWithArity(t[r],n,e));return i}function applySpec(t,...n){const e=__findHighestArity(t);return 0===e?()=>({}):__applySpecWithArity(t,e,n)}function assocFn(t,n,e){return Object.assign({},e,{[t]:n})}const assoc=curry(assocFn);function _isInteger(t){return t<<0===t}var _isInteger$1=Number.isInteger||_isInteger;function assocPathFn(t,n,e){const r="string"==typeof t?t.split(".").map(t=>_isInteger(Number(t))?Number(t):t):t;if(0===r.length)return n;const i=r[0];if(r.length>1){const t="object"!=typeof e||null===e||!e.hasOwnProperty(i)?_isInteger(r[1])?[]:{}:e[i];n=assocPathFn(Array.prototype.slice.call(r,1),n,t)}if(_isInteger(i)&&_isArray(e)){const t=e.slice();return t[i]=n,t}return assoc(i,n,e)}const assocPath=curry(assocPathFn);function both(t,n){return 1===arguments.length?n=>both(t,n):(...e)=>t(...e)&&n(...e)}function chain(t,n){return 1===arguments.length?n=>chain(t,n):[].concat(...n.map(t))}function clampFn(t,n,e){if(t>n)throw new Error("min must not be greater than max in clamp(min, max, value)");return e>=t&&e<=n?e:e>n?n:e<t?t:void 0}const clamp=curry(clampFn);function clone(t){const n=_isArray(t)?Array(t.length):{};if(t&&t.getTime)return new Date(t.getTime());for(const e in t){const r=t[e];n[e]="object"==typeof r&&null!==r?r.getTime?new Date(r.getTime()):clone(r):r}return n}function complement(t){return(...n)=>!t(...n)}function compose(...t){if(0===t.length)throw new Error("compose requires at least one argument");return(...n)=>{const e=t.slice();if(e.length>0){let t=e.pop()(...n);for(;e.length>0;)t=e.pop()(t);return t}}}function concat(t,n){return 1===arguments.length?n=>concat(t,n):"string"==typeof t?`${t}${n}`:[...t,...n]}function cond(t){return n=>{let e,r=!1;return t.forEach(([t,i])=>{!r&&t(n)&&(r=!0,e=i(n))}),e}}function _curryN(t,n,e){return function(){let r=0,i=0;const o=n.length,u=arguments.length,c=new Array(o+u);for(;r<o;)c[r]=n[r],r++;for(;i<u;)c[o+i]=arguments[i],i++;const s=t-c.length;return c.length>=t?e.apply(this,c):_arity(s,_curryN(t,c,e))}}function _arity(t,n){switch(t){case 0:return function(){return n.apply(this,arguments)};case 1:return function(t){return n.apply(this,arguments)};case 2:return function(t,e){return n.apply(this,arguments)};case 3:return function(t,e,r){return n.apply(this,arguments)};case 4:return function(t,e,r,i){return n.apply(this,arguments)};case 5:return function(t,e,r,i,o){return n.apply(this,arguments)};case 6:return function(t,e,r,i,o,u){return n.apply(this,arguments)};case 7:return function(t,e,r,i,o,u,c){return n.apply(this,arguments)};case 8:return function(t,e,r,i,o,u,c,s){return n.apply(this,arguments)};case 9:return function(t,e,r,i,o,u,c,s,l){return n.apply(this,arguments)};default:return function(t,e,r,i,o,u,c,s,l,f){return n.apply(this,arguments)}}}function curryN(t,n){if(1===arguments.length)return n=>curryN(t,n);if(t>10)throw new Error("First argument to _arity must be a non-negative integer no greater than ten");return _arity(t,_curryN(t,[],n))}const _keys=Object.keys;function mapArray(t,n,e=!1){let r=0;const i=Array(n.length);for(;r<n.length;)i[r]=e?t(n[r],r):t(n[r]),r++;return i}function mapObject(t,n){let e=0;const r=_keys(n),i=r.length,o={};for(;e<i;){const i=r[e];o[i]=t(n[i],i,n),e++}return o}function map(t,n){return 1===arguments.length?n=>map(t,n):void 0===n?[]:_isArray(n)?mapArray(t,n):mapObject(t,n)}function max(t,n){return 1===arguments.length?n=>max(t,n):n>t?n:t}function reduceFn(t,n,e){if(!_isArray(e))throw new TypeError("reduce: list must be array or iterable");let r=0;const i=e.length;for(;r<i;)n=t(n,e[r],r,e),r++;return n}const reduce=curry(reduceFn);function converge(t,n){if(1===arguments.length)return n=>converge(t,n);return curryN(reduce((t,n)=>max(t,n.length),0,n),function(){return t.apply(this,map(t=>t.apply(this,arguments),n))})}const dec=t=>t-1;function isFalsy(t){return null==t||!0===Number.isNaN(t)}function defaultTo(t,n){return 1===arguments.length?n=>defaultTo(t,n):isFalsy(n)?t:n}function type(t){const n=typeof t;if(null===t)return"Null";if(void 0===t)return"Undefined";if("boolean"===n)return"Boolean";if("number"===n)return Number.isNaN(t)?"NaN":"Number";if("string"===n)return"String";if(_isArray(t))return"Array";if("symbol"===n)return"Symbol";if(t instanceof RegExp)return"RegExp";const e=t&&t.toString?t.toString():"";return["true","false"].includes(e)?"Boolean":Number.isNaN(Number(e))?e.startsWith("async")?"Async":"[object Promise]"===e?"Promise":"function"===n?"Function":t instanceof String?"String":"Object":"Number"}function parseError(t){const n=t.__proto__.toString();return["Error","TypeError"].includes(n)?[n,t.message]:[]}function parseDate(t){return t.toDateString?[!0,t.getTime()]:[!1]}function parseRegex(t){return t.constructor!==RegExp?[!1]:[!0,t.toString()]}function equals(t,n){if(1===arguments.length)return n=>equals(t,n);const e=type(t);if(e!==type(n))return!1;if("Function"===e)return void 0!==t.name&&t.name===n.name;if(["NaN","Undefined","Null"].includes(e))return!0;if("Number"===e)return Object.is(-0,t)===Object.is(-0,n)&&t.toString()===n.toString();if(["String","Boolean"].includes(e))return t.toString()===n.toString();if("Array"===e){const e=Array.from(t),r=Array.from(n);if(e.toString()!==r.toString())return!1;let i=!0;return e.forEach((t,n)=>{i&&(t===r[n]||equals(t,r[n])||(i=!1))}),i}const r=parseRegex(t),i=parseRegex(n);if(r[0])return!!i[0]&&r[1]===i[1];if(i[0])return!1;const o=parseDate(t),u=parseDate(n);if(o[0])return!!u[0]&&o[1]===u[1];if(u[0])return!1;const c=parseError(t),s=parseError(n);if(c[0])return!!s[0]&&(c[0]===s[0]&&c[1]===s[1]);if("Object"===e){const e=Object.keys(t);if(e.length!==Object.keys(n).length)return!1;let r=!0;return e.forEach(e=>{if(r){const i=t[e],o=n[e];i===o||equals(i,o)||(r=!1)}}),r}return!1}function includes(t,n){if(1===arguments.length)return n=>includes(t,n);if("string"==typeof n)return n.includes(t);if(!n)throw new TypeError(`Cannot read property 'indexOf' of ${n}`);if(!_isArray(n))return!1;let e=-1;for(;++e<n.length;)if(equals(n[e],t))return!0;return!1}function uniq(t){let n=-1;const e=[];for(;++n<t.length;){const r=t[n];includes(r,e)||e.push(r)}return e}function difference(t,n){return 1===arguments.length?n=>difference(t,n):uniq(t).filter(t=>!includes(t,n))}function dissoc(t,n){if(1===arguments.length)return n=>dissoc(t,n);if(null==n)return{};const e={};for(const t in n)e[t]=n[t];return delete e[t],e}function divide(t,n){return 1===arguments.length?n=>divide(t,n):t/n}function drop(t,n){return 1===arguments.length?n=>drop(t,n):n.slice(t>0?t:0)}function dropLast(t,n){return 1===arguments.length?n=>dropLast(t,n):t>0?n.slice(0,-t):n.slice()}function dropLastWhile(t,n){if(1===arguments.length)return n=>dropLastWhile(t,n);if(0===n.length)return n;const e=_isArray(n);if("function"!=typeof t)throw new Error(`'predicate' is from wrong type ${typeof t}`);if(!e&&"string"!=typeof n)throw new Error(`'iterable' is from wrong type ${typeof n}`);let r=!1;const i=[];let o=n.length;for(;o>0;)o--,r||!1!==t(n[o])?r&&i.push(n[o]):(r=!0,i.push(n[o]));return e?i.reverse():i.reverse().join("")}function dropRepeats(t){if(!_isArray(t))throw new Error(`${t} is not a list`);const n=[];return t.reduce((t,e)=>(equals(t,e)||n.push(e),e),void 0),n}function dropRepeatsWith(t,n){if(1===arguments.length)return n=>dropRepeatsWith(t,n);if(!_isArray(n))throw new Error(`${n} is not a list`);const e=[];return n.reduce((n,r)=>void 0===n?(e.push(r),r):(t(n,r)||e.push(r),r),void 0),e}function dropWhile(t,n){if(1===arguments.length)return n=>dropWhile(t,n);const e=_isArray(n);if(!e&&"string"!=typeof n)throw new Error("`iterable` is neither list nor a string");let r=!1;const i=[];let o=-1;for(;o++<n.length-1;)r?i.push(n[o]):t(n[o])||(r||(r=!0),i.push(n[o]));return e?i:i.join("")}function either(t,n){return 1===arguments.length?n=>either(t,n):(...e)=>Boolean(t(...e)||n(...e))}function endsWith(t,n){return 1===arguments.length?n=>endsWith(t,n):n.endsWith(t)}function eqPropsFn(t,n,e){if(!n||!e)throw new Error("wrong object inputs are passed to R.eqProps");return equals(n[t],e[t])}const eqProps=curry(eqPropsFn);function evolveArray(t,n){return mapArray((n,e)=>"Function"===type(t[e])?t[e](n):n,n,!0)}function evolveObject(t,n){return mapObject((n,e)=>{if("Object"===type(n)){const r=type(t[e]);return"Function"===r?t[e](n):"Object"===r?evolve(t[e],n):n}return"Function"===type(t[e])?t[e](n):n},n)}function evolve(t,n){if(1===arguments.length)return n=>evolve(t,n);const e=type(t),r=type(n);if(r!==e)throw new Error("iterableType !== rulesType");if(!["Object","Array"].includes(e))throw new Error(`'iterable' and 'rules' are from wrong type ${e}`);return"Object"===r?evolveObject(t,n):evolveArray(t,n)}function filterObject(t,n){const e={};for(const r in n)t(n[r],r,n)&&(e[r]=n[r]);return e}function filterArray(t,n,e=!1){let r=0;const i=n.length,o=[];for(;r<i;){(e?t(n[r],r):t(n[r]))&&o.push(n[r]),r++}return o}function filter(t,n){return 1===arguments.length?n=>filter(t,n):n?_isArray(n)?filterArray(t,n):filterObject(t,n):[]}function find(t,n){if(1===arguments.length)return n=>find(t,n);let e=0;const r=n.length;for(;e<r;){const r=n[e];if(t(r))return r;e++}}function findIndex(t,n){if(1===arguments.length)return n=>findIndex(t,n);const e=n.length;let r=-1;for(;++r<e;)if(t(n[r]))return r;return-1}function findLast(t,n){if(1===arguments.length)return n=>findLast(t,n);let e=n.length;for(;--e>=0;)if(t(n[e]))return n[e]}function findLastIndex(t,n){if(1===arguments.length)return n=>findLastIndex(t,n);let e=n.length;for(;--e>=0;)if(t(n[e]))return e;return-1}function flatten(t,n){const e=void 0===n?[]:n;for(let n=0;n<t.length;n++)_isArray(t[n])?flatten(t[n],e):e.push(t[n]);return e}function flipFn(t){return(...n)=>{if(1===n.length)return e=>t(e,n[0]);if(2===n.length)return t(n[1],n[0]);if(3===n.length)return t(n[1],n[0],n[2]);if(4===n.length)return t(n[1],n[0],n[2],n[3]);throw new Error("R.flip doesn't work with arity > 4")}}function flip(t){return flipFn(t)}function forEach(t,n){if(1===arguments.length)return n=>forEach(t,n);if(void 0!==n){if(_isArray(n)){let e=0;const r=n.length;for(;e<r;)t(n[e]),e++}else{let e=0;const r=_keys(n),i=r.length;for(;e<i;){const i=r[e];t(n[i],i,n),e++}}return n}}function fromPairs(t){const n={};return t.forEach(([t,e])=>n[t]=e),n}function groupBy(t,n){if(1===arguments.length)return n=>groupBy(t,n);const e={};for(let r=0;r<n.length;r++){const i=n[r],o=t(i);e[o]||(e[o]=[]),e[o].push(i)}return e}function groupWith(t,n){if(!_isArray(n))throw new TypeError("list.reduce is not a function");const e=n.slice();if(1===n.length)return[e];const r=[];let i=[];return e.reduce((e,o,u)=>{if(0===u)return o;const c=t(e,o),s=0===i.length,l=u===n.length-1;return c?(s&&i.push(e),i.push(o),l&&r.push(i),o):s?(r.push([e]),l&&r.push([o]),o):(r.push(i),l&&r.push([o]),i=[],o)},void 0),r}function has(t,n){return 1===arguments.length?n=>has(t,n):!!n&&void 0!==n[t]}function path(t,n){if(1===arguments.length)return n=>path(t,n);if(null==n)return;let e=n,r=0;const i="string"==typeof t?t.split("."):t;for(;r<i.length;){if(null==e)return;e=e[i[r]],r++}return e}function hasPath(t,n){return 1===arguments.length?n=>hasPath(t,n):void 0!==path(t,n)}function head(t){return"string"==typeof t?t[0]||"":t[0]}function _objectIs(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}var _objectIs$1=Object.is||_objectIs;function identical(t,n){return 1===arguments.length?n=>identical(t,n):_objectIs$1(t,n)}function identity(t){return t}function ifElseFn(t,n,e){return(...r)=>{return!0===("boolean"==typeof t?t:t(...r))?n(...r):e(...r)}}const ifElse=curry(ifElseFn),inc=t=>t+1;function indexByPath(t,n){const e={};for(let r=0;r<n.length;r++){const i=n[r];e[path(t,i)]=i}return e}function indexBy(t,n){if(1===arguments.length)return n=>indexBy(t,n);if("string"==typeof t)return indexByPath(t,n);const e={};for(let r=0;r<n.length;r++){const i=n[r];e[t(i)]=i}return e}function indexOf(t,n){if(1===arguments.length)return n=>indexOf(t,n);let e=-1;const{length:r}=n;for(;++e<r;)if(n[e]===t)return e;return-1}function baseSlice(t,n,e){let r=-1,{length:i}=t;(e=e>i?i:e)<0&&(e+=i),i=n>e?0:e-n>>>0,n>>>=0;const o=Array(i);for(;++r<i;)o[r]=t[r+n];return o}function init(t){return"string"==typeof t?t.slice(0,-1):t.length?baseSlice(t,0,-1):[]}function intersection(t,n){return 1===arguments.length?n=>intersection(t,n):filter(t=>includes(t,n),t)}function intersperse(t,n){if(1===arguments.length)return n=>intersperse(t,n);let e=-1;const r=n.length,i=[];for(;++e<r;)e===r-1?i.push(n[e]):i.push(n[e],t);return i}function is(t,n){return 1===arguments.length?n=>is(t,n):null!=n&&n.constructor===t||n instanceof t}function isEmpty(t){const n=type(t);return!["Undefined","NaN","Number","Null"].includes(n)&&(!t||("Object"===n?0===Object.keys(t).length:"Array"===n&&0===t.length))}function isNil(t){return null==t}function join(t,n){return 1===arguments.length?n=>join(t,n):n.join(t)}function keys(t){return Object.keys(t)}function last(t){return"string"==typeof t?t[t.length-1]||"":t[t.length-1]}function lastIndexOf(t,n){if(1===arguments.length)return n=>lastIndexOf(t,n);let e=n.length;for(;--e>0;)if(equals(n[e],t))return e;return-1}function length(t){return!t&&""!==t||void 0===t.length?NaN:t.length}function lens(t,n){return function(e){return function(r){return e(t(r)).map(t=>n(t,r))}}}function nth(t,n){if(1===arguments.length)return n=>nth(t,n);const e=t<0?n.length+t:t;return"[object String]"===Object.prototype.toString.call(n)?n.charAt(e):n[e]}function updateFn(t,n,e){return e.slice().fill(n,t,t+1)}const update=curry(updateFn);function lensIndex(t){return lens(nth(t),update(t))}function lensPath(t){return lens(path(t),assocPath(t))}function prop(t,n){return 1===arguments.length?n=>prop(t,n):n?n[t]:void 0}function lensProp(t){return lens(prop(t),assoc(t))}function match(t,n){if(1===arguments.length)return n=>match(t,n);const e=n.match(t);return null===e?[]:e}function mathMod(t,n){return 1===arguments.length?n=>mathMod(t,n):!_isInteger$1(t)||!_isInteger$1(n)||n<1?NaN:(t%n+n)%n}function maxByFn(t,n,e){return t(e)>t(n)?e:n}const maxBy=curry(maxByFn);function sum(t){return t.reduce((t,n)=>t+n,0)}function mean(t){return sum(t)/t.length}function median(t){const n=t.length;if(0===n)return NaN;const e=2-n%2,r=(n-e)/2;return mean(Array.prototype.slice.call(t,0).sort((t,n)=>t===n?0:t<n?-1:1).slice(r,r+e))}function merge(t,n){return 1===arguments.length?n=>merge(t,n):Object.assign({},t||{},n||{})}function mergeAll(t){let n={};return map(t=>{n=merge(n,t)},t),n}function mergeDeepRight(t,n){if(1===arguments.length)return n=>mergeDeepRight(t,n);const e=JSON.parse(JSON.stringify(t));return Object.keys(n).forEach(r=>{"Object"===type(n[r])&&"Object"===type(t[r])?e[r]=mergeDeepRight(t[r],n[r]):e[r]=n[r]}),e}function mergeLeft(t,n){return 1===arguments.length?n=>mergeLeft(t,n):merge(n,t)}function min(t,n){return 1===arguments.length?n=>min(t,n):n<t?n:t}function minByFn(t,n,e){return t(e)<t(n)?e:n}const minBy=curry(minByFn);function modulo(t,n){return 1===arguments.length?n=>modulo(t,n):t%n}function moveFn(t,n,e){if(t<0||n<0)throw new Error("Rambda.move does not support negative indexes");if(t>e.length-1||n>e.length-1)return e;const r=e.slice();return r[t]=e[n],r[n]=e[t],r}const move=curry(moveFn);function multiply(t,n){return 1===arguments.length?n=>multiply(t,n):t*n}function negate(t){return-t}function none(t,n){if(1===arguments.length)return n=>none(t,n);for(let e=0;e<n.length;e++)if(!t(n[e]))return!0;return!1}function not(t){return!t}function of(t){return[t]}function omit(t,n){if(1===arguments.length)return n=>omit(t,n);if(null==n)return;const e="string"==typeof t?t.split(","):t,r={};for(const t in n)e.includes(t)||(r[t]=n[t]);return r}function onceFn(t,n){let e;return function(){return t&&(e=t.apply(n||this,arguments),t=null),e}}function once(t,n){if(1===arguments.length){return curry(onceFn(t,n))}return onceFn(t,n)}function or(t,n){return 1===arguments.length?n=>or(t,n):t||n}const Identity=t=>({x:t,map:n=>Identity(n(t))});function overFn(t,n,e){return t(t=>Identity(n(t)))(e).x}const over=curry(overFn);function partial(t,...n){const e=t.length;return(...r)=>n.length+r.length>=e?t(...n,...r):partial(t,...[...n,...r])}function partitionObject(t,n){const e={},r={};return Object.entries(n).forEach(([n,i])=>{t(i,n)?e[n]=i:r[n]=i}),[e,r]}function partitionArray(t,n){const e=[],r=[];let i=-1;for(;i++<n.length-1;)t(n[i])?e.push(n[i]):r.push(n[i]);return[e,r]}function partition(t,n){return 1===arguments.length?n=>partition(t,n):_isArray(n)?partitionArray(t,n):partitionObject(t,n)}function pathEqFn(t,n,e){return equals(path(t,e),n)}const pathEq=curry(pathEqFn);function pathOrFn(t,n,e){return defaultTo(t,path(n,e))}const pathOr=curry(pathOrFn);function paths(t,n){return 1===arguments.length?n=>paths(t,n):t.map(t=>path(t,n))}function pick(t,n){if(1===arguments.length)return n=>pick(t,n);if(null==n)return;const e="string"==typeof t?t.split(","):t,r={};let i=0;for(;i<e.length;)e[i]in n&&(r[e[i]]=n[e[i]]),i++;return r}function pickAll(t,n){if(1===arguments.length)return n=>pickAll(t,n);if(null==n)return;const e="string"==typeof t?t.split(","):t,r={};let i=0;for(;i<e.length;)e[i]in n?r[e[i]]=n[e[i]]:r[e[i]]=void 0,i++;return r}function pipe(...t){if(0===t.length)throw new Error("pipe requires at least one argument");return(...n)=>{const e=t.slice();if(e.length>0){let t=e.shift()(...n);for(;e.length>0;)t=e.shift()(t);return t}}}function pluck(t,n){if(1===arguments.length)return n=>pluck(t,n);const e=[];return map(n=>{void 0!==n[t]&&e.push(n[t])},n),e}function prepend(t,n){return 1===arguments.length?n=>prepend(t,n):[t].concat("string"==typeof n?n.split(""):n)}const product=reduce(multiply,1);function propEqFn(t,n,e){return!!e&&e[t]===n}const propEq=curry(propEqFn);function propIsFn(t,n,e){return is(t,e[n])}const propIs=curry(propIsFn);function propOrFn(t,n,e){return e?defaultTo(t,e[n]):t}const propOr=curry(propOrFn);function props(t,n){if(1===arguments.length)return n=>props(t,n);if(!_isArray(t))throw new Error("propsToPick is not a list");return mapArray(t=>n[t],t)}function range(t,n){if(1===arguments.length)return n=>range(t,n);if(Number.isNaN(Number(t))||Number.isNaN(Number(n)))throw new TypeError("Both arguments to range must be numbers");if(n<t)return[];const e=n-t,r=Array(e);for(let n=0;n<e;n++)r[n]=t+n;return r}function reject(t,n){return 1===arguments.length?n=>reject(t,n):filter(n=>!t(n),n)}function repeat(t,n){return 1===arguments.length?n=>repeat(t,n):Array(n).fill(t)}function replaceFn(t,n,e){return e.replace(t,n)}const replace=curry(replaceFn);function reverse(t){if("string"==typeof t)return t.split("").reverse().join("");return t.slice().reverse()}function setFn(t,n,e){return over(t,always(n),e)}const set=curry(setFn);function sliceFn(t,n,e){return e.slice(t,n)}const slice=curry(sliceFn);function sort(t,n){if(1===arguments.length)return n=>sort(t,n);return n.slice().sort(t)}function sortBy(t,n){if(1===arguments.length)return n=>sortBy(t,n);return n.slice().sort((n,e)=>{const r=t(n),i=t(e);return r===i?0:r<i?-1:1})}function split(t,n){return 1===arguments.length?n=>split(t,n):n.split(t)}function maybe(t,n,e){const r=t&&"Function"===type(n)?n():n,i=t||"Function"!==type(e)?e:e();return t?r:i}function take(t,n){return 1===arguments.length?n=>take(t,n):t<0?n.slice():"string"==typeof n?n.slice(0,t):baseSlice(n,0,t)}function splitAt(t,n){if(1===arguments.length)return n=>splitAt(t,n);if(!n)throw new TypeError(`Cannot read property 'slice' of ${n}`);if(!_isArray(n)&&"string"!=typeof n)return[[],[]];const e=maybe(t<0,n.length+t<0?0:n.length+t,t);return[take(e,n),drop(e,n)]}function splitEvery(t,n){if(1===arguments.length)return n=>splitEvery(t,n);if(t<1)throw new Error("First argument to splitEvery must be a positive integer");const e=[];let r=0;for(;r<n.length;)e.push(n.slice(r,r+=t));return e}function splitWhen(t,n){if(1===arguments.length)return n=>splitWhen(t,n);if(!n)throw new TypeError(`Cannot read property 'length' of ${n}`);const e=[],r=[];let i=!1,o=-1;for(;o++<n.length-1;)i?r.push(n[o]):t(n[o])?(r.push(n[o]),i=!0):e.push(n[o]);return[e,r]}function startsWith(t,n){return 1===arguments.length?n=>startsWith(t,n):n.startsWith(t)}function subtract(t,n){return 1===arguments.length?n=>subtract(t,n):t-n}function symmetricDifference(t,n){return 1===arguments.length?n=>symmetricDifference(t,n):concat(filter(t=>!includes(t,n),t),filter(n=>!includes(n,t),n))}function tail(t){return drop(1,t)}function takeLast(t,n){if(1===arguments.length)return n=>takeLast(t,n);const e=n.length;if(t<0)return n.slice();let r=t>e?e:t;return"string"==typeof n?n.slice(e-r):baseSlice(n,r=e-r,e)}function takeLastWhile(t,n){if(1===arguments.length)return n=>takeLastWhile(t,n);if(0===n.length)return n;let e=!1;const r=[];let i=n.length;for(;!e||0===i;)!1===t(n[--i])?e=!0:e||r.push(n[i]);return _isArray(n)?r.reverse():r.reverse().join("")}function takeWhile(t,n){if(1===arguments.length)return n=>takeWhile(t,n);const e=_isArray(n);if(!e&&"string"!=typeof n)throw new Error("`iterable` is neither list nor a string");let r=!0;const i=[];let o=-1;for(;o++<n.length-1;)t(n[o])?r&&i.push(n[o]):r&&(r=!1);return e?i:i.join("")}function tap(t,n){return 1===arguments.length?n=>tap(t,n):(t(n),n)}function test(t,n){if(1===arguments.length)return n=>test(t,n);if("string"==typeof t)throw new TypeError(`‘test’ requires a value of type RegExp as its first argument; received "${t}"`);return-1!==n.search(t)}function times(t,n){if(1===arguments.length)return n=>times(t,n);if(!Number.isInteger(n)||n<0)throw new RangeError("n must be an integer");return map(t,range(0,n))}function toLower(t){return t.toLowerCase()}function toPairs(t){return Object.entries(t)}function toString(t){return t.toString()}function toUpper(t){return t.toUpperCase()}function transpose(t){return t.reduce((t,n)=>(n.forEach((n,e)=>_isArray(t[e])?t[e].push(n):t.push([n])),t),[])}function trim(t){return t.trim()}function isFunction(t){return["Async","Function"].includes(type(t))}function tryCatch(t,n){if(!isFunction(t))throw new Error(`R.tryCatch | fn '${t}'`);const e=isFunction(n);return(...r)=>{try{return t(...r)}catch(t){return e?n(t,...r):n}}}function union(t,n){if(1===arguments.length)return n=>union(t,n);const e=t.slice();return n.forEach(n=>{includes(n,t)||e.push(n)}),e}function uniqWith(t,n){if(1===arguments.length)return n=>uniqWith(t,n);let e=-1;const r=n.length,i=[];for(;++e<r;){const r=n[e];any(n=>t(r,n),i)||i.push(r)}return i}function unless(t,n){return 1===arguments.length?n=>unless(t,n):e=>t(e)?e:n(e)}function values(t){return"Object"!==type(t)?[]:Object.values(t)}const Const=t=>({x:t,map:n=>Const(t)});function view(t,n){return 1===arguments.length?n=>view(t,n):t(Const)(n).x}function whenFn(t,n,e){return t(e)?n(e):e}const when=curry(whenFn);function where(t,n){if(void 0===n)return n=>where(t,n);let e=!0;for(const r in t){const i=t[r](n[r]);e&&!1===i&&(e=!1)}return e}function whereEq(t,n){if(1===arguments.length)return n=>whereEq(t,n);const e=filter((t,e)=>equals(t,n[e]),t);return Object.keys(e).length===Object.keys(t).length}function without(t,n){return void 0===n?n=>without(t,n):reduce((n,e)=>includes(e,t)?n:n.concat(e),[],n)}function xor(t,n){return 1===arguments.length?n=>xor(t,n):Boolean(t)&&!n||Boolean(n)&&!t}function zip(t,n){if(1===arguments.length)return n=>zip(t,n);const e=[],r=Math.min(t.length,n.length);for(let i=0;i<r;i++)e[i]=[t[i],n[i]];return e}function zipObj(t,n){return 1===arguments.length?n=>zipObj(t,n):take(n.length,t).reduce((t,e,r)=>(t[e]=n[r],t),{})}function zipWithFn(t,n,e){return take(n.length>e.length?e.length:n.length,n).map((n,r)=>t(n,e[r]))}const zipWith=curry(zipWithFn);export{F,T,add,adjust,all,allPass,always,and,any,anyPass,append,applySpec,assoc,assocPath,both,chain,clamp,clone,complement,compose,concat,cond,converge,curry,curryN,dec,defaultTo,difference,dissoc,divide,drop,dropLast,dropLastWhile,dropRepeats,dropRepeatsWith,dropWhile,either,endsWith,eqProps,equals,evolve,evolveArray,evolveObject,filter,filterArray,filterObject,find,findIndex,findLast,findLastIndex,flatten,flip,forEach,fromPairs,groupBy,groupWith,has,hasPath,head,identical,identity,ifElse,inc,includes,indexBy,indexOf,init,intersection,intersperse,is,isEmpty,isNil,join,keys,last,lastIndexOf,length,lens,lensIndex,lensPath,lensProp,map,mapArray,mapObject,match,mathMod,max,maxBy,maxByFn,mean,median,merge,mergeAll,mergeDeepRight,mergeLeft,min,minBy,minByFn,modulo,move,multiply,negate,none,not,nth,of,omit,once,or,over,partial,partition,partitionArray,partitionObject,path,pathEq,pathOr,paths,pick,pickAll,pipe,pluck,prepend,product,prop,propEq,propIs,propOr,props,range,reduce,reject,repeat,replace,reverse,set,slice,sort,sortBy,split,splitAt,splitEvery,splitWhen,startsWith,subtract,sum,symmetricDifference,tail,take,takeLast,takeLastWhile,takeWhile,tap,test,times,toLower,toPairs,toString,toUpper,transpose,trim,tryCatch,type,union,uniq,uniqWith,unless,update,values,view,when,where,whereEq,without,xor,zip,zipObj,zipWith};