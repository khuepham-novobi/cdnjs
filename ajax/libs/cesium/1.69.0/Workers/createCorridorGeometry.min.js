define(["./when-b43ff45e","./Check-d404a0fe","./Math-336da716","./Cartesian2-3c21ddb9","./Transforms-ffcbad88","./RuntimeError-bf10f3d5","./WebGLConstants-56de22c0","./ComponentDatatype-8956ad9a","./GeometryAttribute-c9800e88","./GeometryAttributes-fbf888b4","./IndexDatatype-c5295474","./IntersectionTests-e522b831","./Plane-56dc8a69","./GeometryOffsetAttribute-9f7392ac","./VertexFormat-89c0971b","./arrayRemoveDuplicates-a7dee4b8","./EllipsoidTangentPlane-0c88eccf","./EllipsoidRhumbLine-6daaa4d2","./PolygonPipeline-b2950861","./PolylineVolumeGeometryLibrary-ff75c3ae","./EllipsoidGeodesic-acfd9e4b","./PolylinePipeline-1c467caa","./CorridorGeometryLibrary-b3b4d039"],function(rt,t,at,it,m,e,r,ot,nt,st,lt,a,i,E,V,y,o,n,F,f,s,l,dt){"use strict";var ut=new it.Cartesian3,mt=new it.Cartesian3,yt=new it.Cartesian3,ft=new it.Cartesian3,L=new it.Cartesian3,ct=new it.Cartesian3,pt=new it.Cartesian3,ht=new it.Cartesian3;function c(t,e){for(var r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function gt(t,e,r,a,i,o){var n=t.normals,s=t.tangents,l=t.bitangents,t=it.Cartesian3.normalize(it.Cartesian3.cross(r,e,pt),pt);o.normal&&dt.CorridorGeometryLibrary.addAttribute(n,e,a,i),o.tangent&&dt.CorridorGeometryLibrary.addAttribute(s,t,a,i),o.bitangent&&dt.CorridorGeometryLibrary.addAttribute(l,r,a,i)}function P(t,e,r){var a,i,o=t.positions,n=t.corners,s=t.endPositions,l=t.lefts,d=t.normals,u=new st.GeometryAttributes,m=0,y=0,f=0;for(D=0;D<o.length;D+=2)m+=i=o[D].length-3,f+=2*i,y+=o[D+1].length-3;for(m+=3,y+=3,D=0;D<n.length;D++){a=n[D];var c=n[D].leftPositions;rt.defined(c)?m+=i=c.length:y+=i=n[D].rightPositions.length,f+=i}var p,h=rt.defined(s);h&&(m+=p=s[0].length-3,y+=p,f+=6*(p/=3));var g,C,b,v,A,_,t=m+y,w=new Float64Array(t),T={normals:e.normal?new Float32Array(t):void 0,tangents:e.tangent?new Float32Array(t):void 0,bitangents:e.bitangent?new Float32Array(t):void 0},G=0,E=t-1,V=ut,F=mt,L=p/2,P=lt.IndexDatatype.createTypedArray(t/3,f),x=0;if(h){_=yt,A=ft;for(var N=s[0],V=it.Cartesian3.fromArray(d,0,V),F=it.Cartesian3.fromArray(l,0,F),D=0;D<L;D++)_=it.Cartesian3.fromArray(N,3*(L-1-D),_),A=it.Cartesian3.fromArray(N,3*(L+D),A),dt.CorridorGeometryLibrary.addAttribute(w,A,G),dt.CorridorGeometryLibrary.addAttribute(w,_,void 0,E),gt(T,V,F,G,E,e),v=1+(C=G/3),b=(g=(E-2)/3)-1,P[x++]=g,P[x++]=C,P[x++]=b,P[x++]=b,P[x++]=C,P[x++]=v,G+=3,E-=3}var M,O,I=0,S=0,R=o[I++],k=o[I++];for(w.set(R,G),w.set(k,E-k.length+1),F=it.Cartesian3.fromArray(l,S,F),i=k.length-3,D=0;D<i;D+=3)M=r.geodeticSurfaceNormal(it.Cartesian3.fromArray(R,D,pt),pt),O=r.geodeticSurfaceNormal(it.Cartesian3.fromArray(k,i-D,ht),ht),gt(T,V=it.Cartesian3.normalize(it.Cartesian3.add(M,O,V),V),F,G,E,e),v=1+(C=G/3),b=(g=(E-2)/3)-1,P[x++]=g,P[x++]=C,P[x++]=b,P[x++]=b,P[x++]=C,P[x++]=v,G+=3,E-=3;for(M=r.geodeticSurfaceNormal(it.Cartesian3.fromArray(R,i,pt),pt),O=r.geodeticSurfaceNormal(it.Cartesian3.fromArray(k,i,ht),ht),V=it.Cartesian3.normalize(it.Cartesian3.add(M,O,V),V),S+=3,D=0;D<n.length;D++){var H,z,U,B=(a=n[D]).leftPositions,Y=a.rightPositions,W=ct,q=yt,J=ft;if(V=it.Cartesian3.fromArray(d,S,V),rt.defined(B)){for(gt(T,V,F,void 0,E,e),E-=3,z=v,U=b,H=0;H<B.length/3;H++)W=it.Cartesian3.fromArray(B,3*H,W),P[x++]=z,P[x++]=U-H-1,P[x++]=U-H,dt.CorridorGeometryLibrary.addAttribute(w,W,void 0,E),q=it.Cartesian3.fromArray(w,3*(U-H-1),q),J=it.Cartesian3.fromArray(w,3*z,J),gt(T,V,F=it.Cartesian3.normalize(it.Cartesian3.subtract(q,J,F),F),void 0,E,e),E-=3;W=it.Cartesian3.fromArray(w,3*z,W),q=it.Cartesian3.subtract(it.Cartesian3.fromArray(w,3*U,q),W,q),J=it.Cartesian3.subtract(it.Cartesian3.fromArray(w,3*(U-H),J),W,J),gt(T,V,F=it.Cartesian3.normalize(it.Cartesian3.add(q,J,F),F),G,void 0,e),G+=3}else{for(gt(T,V,F,G,void 0,e),G+=3,z=b,U=v,H=0;H<Y.length/3;H++)W=it.Cartesian3.fromArray(Y,3*H,W),P[x++]=z,P[x++]=U+H,P[x++]=U+H+1,dt.CorridorGeometryLibrary.addAttribute(w,W,G),q=it.Cartesian3.fromArray(w,3*z,q),J=it.Cartesian3.fromArray(w,3*(U+H),J),gt(T,V,F=it.Cartesian3.normalize(it.Cartesian3.subtract(q,J,F),F),G,void 0,e),G+=3;W=it.Cartesian3.fromArray(w,3*z,W),q=it.Cartesian3.subtract(it.Cartesian3.fromArray(w,3*(U+H),q),W,q),J=it.Cartesian3.subtract(it.Cartesian3.fromArray(w,3*U,J),W,J),gt(T,V,F=it.Cartesian3.normalize(it.Cartesian3.negate(it.Cartesian3.add(J,q,F),F),F),void 0,E,e),E-=3}for(R=o[I++],k=o[I++],R.splice(0,3),k.splice(k.length-3,3),w.set(R,G),w.set(k,E-k.length+1),i=k.length-3,S+=3,F=it.Cartesian3.fromArray(l,S,F),H=0;H<k.length;H+=3)M=r.geodeticSurfaceNormal(it.Cartesian3.fromArray(R,H,pt),pt),O=r.geodeticSurfaceNormal(it.Cartesian3.fromArray(k,i-H,ht),ht),gt(T,V=it.Cartesian3.normalize(it.Cartesian3.add(M,O,V),V),F,G,E,e),C=(v=G/3)-1,g=1+(b=(E-2)/3),P[x++]=g,P[x++]=C,P[x++]=b,P[x++]=b,P[x++]=C,P[x++]=v,G+=3,E-=3;G-=3,E+=3}if(gt(T,V=it.Cartesian3.fromArray(d,d.length-3,V),F,G,E,e),h){G+=3,E-=3,_=yt,A=ft;var j=s[1];for(D=0;D<L;D++)_=it.Cartesian3.fromArray(j,3*(p-D-1),_),A=it.Cartesian3.fromArray(j,3*D,A),dt.CorridorGeometryLibrary.addAttribute(w,_,void 0,E),dt.CorridorGeometryLibrary.addAttribute(w,A,G),gt(T,V,F,G,E,e),C=(v=G/3)-1,g=1+(b=(E-2)/3),P[x++]=g,P[x++]=C,P[x++]=b,P[x++]=b,P[x++]=C,P[x++]=v,G+=3,E-=3}if(u.position=new nt.GeometryAttribute({componentDatatype:ot.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:w}),e.st){var K=new Float32Array(t/3*2),Q=0;if(h){m/=3,y/=3;var X,Z=Math.PI/(p+1),$=1/(m-p+1),tt=1/(y-p+1),et=p/2;for(D=1+et;D<p+1;D++)X=at.CesiumMath.PI_OVER_TWO+Z*D,K[Q++]=tt*(1+Math.cos(X)),K[Q++]=.5*(1+Math.sin(X));for(D=1;D<y-p+1;D++)K[Q++]=D*tt,K[Q++]=0;for(D=p;et<D;D--)X=at.CesiumMath.PI_OVER_TWO-D*Z,K[Q++]=1-tt*(1+Math.cos(X)),K[Q++]=.5*(1+Math.sin(X));for(D=et;0<D;D--)X=at.CesiumMath.PI_OVER_TWO-Z*D,K[Q++]=1-$*(1+Math.cos(X)),K[Q++]=.5*(1+Math.sin(X));for(D=m-p;0<D;D--)K[Q++]=D*$,K[Q++]=1;for(D=1;D<1+et;D++)X=at.CesiumMath.PI_OVER_TWO+Z*D,K[Q++]=$*(1+Math.cos(X)),K[Q++]=.5*(1+Math.sin(X))}else{for($=1/((m/=3)-1),tt=1/((y/=3)-1),D=0;D<y;D++)K[Q++]=D*tt,K[Q++]=0;for(D=m;0<D;D--)K[Q++]=(D-1)*$,K[Q++]=1}u.st=new nt.GeometryAttribute({componentDatatype:ot.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:K})}return e.normal&&(u.normal=new nt.GeometryAttribute({componentDatatype:ot.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T.normals})),e.tangent&&(u.tangent=new nt.GeometryAttribute({componentDatatype:ot.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T.tangents})),e.bitangent&&(u.bitangent=new nt.GeometryAttribute({componentDatatype:ot.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T.bitangents})),{attributes:u,indices:P}}function x(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(var a=3;a<t.length;a+=3){var i=t[a],o=t[a+1],n=t[a+2];r[e++]=i,r[e++]=o,r[e++]=n,r[e++]=i,r[e++]=o,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}var p=new it.Cartesian3,h=new it.Cartesian3,g=new it.Cartographic;function C(t,e,r,a,i,o){var n=it.Cartesian3.subtract(e,t,p);it.Cartesian3.normalize(n,n);var s=r.geodeticSurfaceNormal(t,h),l=it.Cartesian3.cross(n,s,p);it.Cartesian3.multiplyByScalar(l,a,l);var d=i.latitude,u=i.longitude,e=o.latitude,n=o.longitude;it.Cartesian3.add(t,l,h),r.cartesianToCartographic(h,g);s=g.latitude,a=g.longitude,d=Math.min(d,s),u=Math.min(u,a),e=Math.max(e,s),n=Math.max(n,a);it.Cartesian3.subtract(t,l,h),r.cartesianToCartographic(h,g),s=g.latitude,a=g.longitude,d=Math.min(d,s),u=Math.min(u,a),e=Math.max(e,s),n=Math.max(n,a),i.latitude=d,i.longitude=u,o.latitude=e,o.longitude=n}var b=new it.Cartesian3,v=new it.Cartesian3,A=new it.Cartographic,_=new it.Cartographic;function d(t,e,r,a,i){t=c(t,e);var o=y.arrayRemoveDuplicates(t,it.Cartesian3.equalsEpsilon),n=o.length;if(n<2||r<=0)return new it.Rectangle;var s,l,d=.5*r;A.latitude=Number.POSITIVE_INFINITY,A.longitude=Number.POSITIVE_INFINITY,_.latitude=Number.NEGATIVE_INFINITY,_.longitude=Number.NEGATIVE_INFINITY,a===f.CornerType.ROUNDED&&(m=o[0],it.Cartesian3.subtract(m,o[1],b),it.Cartesian3.normalize(b,b),it.Cartesian3.multiplyByScalar(b,d,b),it.Cartesian3.add(m,b,v),e.cartesianToCartographic(v,g),s=g.latitude,l=g.longitude,A.latitude=Math.min(A.latitude,s),A.longitude=Math.min(A.longitude,l),_.latitude=Math.max(_.latitude,s),_.longitude=Math.max(_.longitude,l));for(var u=0;u<n-1;++u)C(o[u],o[u+1],e,d,A,_);var m=o[n-1];it.Cartesian3.subtract(m,o[n-2],b),it.Cartesian3.normalize(b,b),it.Cartesian3.multiplyByScalar(b,d,b),it.Cartesian3.add(m,b,v),C(m,v,e,d,A,_),a===f.CornerType.ROUNDED&&(e.cartesianToCartographic(v,g),s=g.latitude,l=g.longitude,A.latitude=Math.min(A.latitude,s),A.longitude=Math.min(A.longitude,l),_.latitude=Math.max(_.latitude,s),_.longitude=Math.max(_.longitude,l));i=rt.defined(i)?i:new it.Rectangle;return i.north=_.latitude,i.south=A.latitude,i.east=_.longitude,i.west=A.longitude,i}function w(t){var e=(t=rt.defaultValue(t,rt.defaultValue.EMPTY_OBJECT)).positions,r=t.width,a=rt.defaultValue(t.height,0),i=rt.defaultValue(t.extrudedHeight,a);this._positions=e,this._ellipsoid=it.Ellipsoid.clone(rt.defaultValue(t.ellipsoid,it.Ellipsoid.WGS84)),this._vertexFormat=V.VertexFormat.clone(rt.defaultValue(t.vertexFormat,V.VertexFormat.DEFAULT)),this._width=r,this._height=Math.max(a,i),this._extrudedHeight=Math.min(a,i),this._cornerType=rt.defaultValue(t.cornerType,f.CornerType.ROUNDED),this._granularity=rt.defaultValue(t.granularity,at.CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=rt.defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*it.Cartesian3.packedLength+it.Ellipsoid.packedLength+V.VertexFormat.packedLength+7}w.pack=function(t,e,r){r=rt.defaultValue(r,0);var a=t._positions,i=a.length;e[r++]=i;for(var o=0;o<i;++o,r+=it.Cartesian3.packedLength)it.Cartesian3.pack(a[o],e,r);return it.Ellipsoid.pack(t._ellipsoid,e,r),r+=it.Ellipsoid.packedLength,V.VertexFormat.pack(t._vertexFormat,e,r),r+=V.VertexFormat.packedLength,e[r++]=t._width,e[r++]=t._height,e[r++]=t._extrudedHeight,e[r++]=t._cornerType,e[r++]=t._granularity,e[r++]=t._shadowVolume?1:0,e[r]=rt.defaultValue(t._offsetAttribute,-1),e};var T=it.Ellipsoid.clone(it.Ellipsoid.UNIT_SPHERE),G=new V.VertexFormat,N={positions:void 0,ellipsoid:T,vertexFormat:G,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};return w.unpack=function(t,e,r){e=rt.defaultValue(e,0);for(var a=t[e++],i=new Array(a),o=0;o<a;++o,e+=it.Cartesian3.packedLength)i[o]=it.Cartesian3.unpack(t,e);var n=it.Ellipsoid.unpack(t,e,T);e+=it.Ellipsoid.packedLength;var s=V.VertexFormat.unpack(t,e,G);e+=V.VertexFormat.packedLength;var l=t[e++],d=t[e++],u=t[e++],m=t[e++],y=t[e++],f=1===t[e++],c=t[e];return rt.defined(r)?(r._positions=i,r._ellipsoid=it.Ellipsoid.clone(n,r._ellipsoid),r._vertexFormat=V.VertexFormat.clone(s,r._vertexFormat),r._width=l,r._height=d,r._extrudedHeight=u,r._cornerType=m,r._granularity=y,r._shadowVolume=f,r._offsetAttribute=-1===c?void 0:c,r):(N.positions=i,N.width=l,N.height=d,N.extrudedHeight=u,N.cornerType=m,N.granularity=y,N.shadowVolume=f,N.offsetAttribute=-1===c?void 0:c,new w(N))},w.computeRectangle=function(t,e){var r=(t=rt.defaultValue(t,rt.defaultValue.EMPTY_OBJECT)).positions,a=t.width;return d(r,rt.defaultValue(t.ellipsoid,it.Ellipsoid.WGS84),a,rt.defaultValue(t.cornerType,f.CornerType.ROUNDED),e)},w.createGeometry=function(t){var e=t._positions,r=t._width,a=t._ellipsoid,e=c(e,a),i=y.arrayRemoveDuplicates(e,it.Cartesian3.equalsEpsilon);if(!(i.length<2||r<=0)){var o,n=t._height,s=t._extrudedHeight,l=!at.CesiumMath.equalsEpsilon(n,s,0,at.CesiumMath.EPSILON2),e=t._vertexFormat,r={ellipsoid:a,positions:i,width:r,cornerType:t._cornerType,granularity:t._granularity,saveAttributes:!0};l?(r.height=n,r.extrudedHeight=s,r.shadowVolume=t._shadowVolume,r.offsetAttribute=t._offsetAttribute,o=function(t,e){var r=new V.VertexFormat({position:e.position,normal:e.normal||e.bitangent||t.shadowVolume,tangent:e.tangent,bitangent:e.normal||e.bitangent,st:e.st}),a=t.ellipsoid,i=P(dt.CorridorGeometryLibrary.computePositions(t),r,a),o=t.height,n=t.extrudedHeight,s=i.attributes,l=i.indices,d=s.position.values,u=d.length,m=new Float64Array(6*u);(r=new Float64Array(u)).set(d),i=new Float64Array(4*u),i=x(d=F.PolygonPipeline.scaleToGeodeticHeight(d,o,a),0,i),i=x(r=F.PolygonPipeline.scaleToGeodeticHeight(r,n,a),2*u,i),m.set(d),m.set(r,u),m.set(i,2*u),s.position.values=m,s=function(t,e){if(!(e.normal||e.tangent||e.bitangent||e.st))return t;var r,a=t.position.values;(e.normal||e.bitangent)&&(r=t.normal.values,l=t.bitangent.values);var i=t.position.values.length/18,o=3*i,n=2*i,s=2*o;if(e.normal||e.bitangent||e.tangent){for(var l,d=e.normal?new Float32Array(6*o):void 0,u=e.tangent?new Float32Array(6*o):void 0,m=e.bitangent?new Float32Array(6*o):void 0,y=ut,f=mt,c=yt,p=ft,h=L,g=ct,C=s,b=0;b<o;b+=3){var v=C+s,y=it.Cartesian3.fromArray(a,b,y),f=it.Cartesian3.fromArray(a,b+o,f),c=it.Cartesian3.fromArray(a,(b+3)%o,c);f=it.Cartesian3.subtract(f,y,f),c=it.Cartesian3.subtract(c,y,c),p=it.Cartesian3.normalize(it.Cartesian3.cross(f,c,p),p),e.normal&&(dt.CorridorGeometryLibrary.addAttribute(d,p,v),dt.CorridorGeometryLibrary.addAttribute(d,p,v+3),dt.CorridorGeometryLibrary.addAttribute(d,p,C),dt.CorridorGeometryLibrary.addAttribute(d,p,C+3)),(e.tangent||e.bitangent)&&(g=it.Cartesian3.fromArray(r,b,g),e.bitangent&&(dt.CorridorGeometryLibrary.addAttribute(m,g,v),dt.CorridorGeometryLibrary.addAttribute(m,g,v+3),dt.CorridorGeometryLibrary.addAttribute(m,g,C),dt.CorridorGeometryLibrary.addAttribute(m,g,C+3)),e.tangent&&(h=it.Cartesian3.normalize(it.Cartesian3.cross(g,p,h),h),dt.CorridorGeometryLibrary.addAttribute(u,h,v),dt.CorridorGeometryLibrary.addAttribute(u,h,v+3),dt.CorridorGeometryLibrary.addAttribute(u,h,C),dt.CorridorGeometryLibrary.addAttribute(u,h,C+3))),C+=6}if(e.normal){for(d.set(r),b=0;b<o;b+=3)d[b+o]=-r[b],d[b+o+1]=-r[b+1],d[b+o+2]=-r[b+2];t.normal.values=d}else t.normal=void 0;e.bitangent?(m.set(l),m.set(l,o),t.bitangent.values=m):t.bitangent=void 0,e.tangent&&(l=t.tangent.values,u.set(l),u.set(l,o),t.tangent.values=u)}if(e.st){var A=t.st.values,_=new Float32Array(6*n);_.set(A),_.set(A,n);for(var w=2*n,T=0;T<2;T++){for(_[w++]=A[0],_[w++]=A[1],b=2;b<n;b+=2){var G=A[b],E=A[b+1];_[w++]=G,_[w++]=E,_[w++]=G,_[w++]=E}_[w++]=A[0],_[w++]=A[1]}t.st.values=_}return t}(s,e);var y=u/3;if(t.shadowVolume){for(var f=s.normal.values,u=f.length,i=new Float32Array(6*u),c=0;c<u;c++)f[c]=-f[c];i.set(f,u),i=x(f,4*u,i),s.extrudeDirection=new nt.GeometryAttribute({componentDatatype:ot.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:i}),e.normal||(s.normal=void 0)}rt.defined(t.offsetAttribute)&&(e=new Uint8Array(6*y),e=t.offsetAttribute===E.GeometryOffsetAttribute.TOP?(e=E.arrayFill(e,1,0,y),E.arrayFill(e,1,2*y,4*y)):(t=t.offsetAttribute===E.GeometryOffsetAttribute.NONE?0:1,E.arrayFill(e,t)),s.applyOffset=new nt.GeometryAttribute({componentDatatype:ot.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e}));var p=l.length,h=y+y,g=lt.IndexDatatype.createTypedArray(m.length/3,2*p+3*h);g.set(l);var C,b,v,A,_=p;for(c=0;c<p;c+=3){var w=l[c],T=l[c+1],G=l[c+2];g[_++]=G+y,g[_++]=T+y,g[_++]=w+y}for(c=0;c<h;c+=2)v=(C=c+h)+1,A=(b=C+h)+1,g[_++]=C,g[_++]=b,g[_++]=v,g[_++]=v,g[_++]=b,g[_++]=A;return{attributes:s,indices:g}}(r,e)):((o=P(dt.CorridorGeometryLibrary.computePositions(r),e,a)).attributes.position.values=F.PolygonPipeline.scaleToGeodeticHeight(o.attributes.position.values,n,a),rt.defined(t._offsetAttribute)&&(d=t._offsetAttribute===E.GeometryOffsetAttribute.NONE?0:1,u=o.attributes.position.values.length,u=new Uint8Array(u/3),E.arrayFill(u,d),o.attributes.applyOffset=new nt.GeometryAttribute({componentDatatype:ot.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:u})));var d=o.attributes,u=m.BoundingSphere.fromVertices(d.position.values,void 0,3);return e.position||(o.attributes.position.values=void 0),new nt.Geometry({attributes:d,indices:o.indices,primitiveType:nt.PrimitiveType.TRIANGLES,boundingSphere:u,offsetAttribute:t._offsetAttribute})}},w.createShadowVolume=function(t,e,r){var a=t._granularity,i=t._ellipsoid,e=e(a,i),r=r(a,i);return new w({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:i,granularity:a,extrudedHeight:e,height:r,vertexFormat:V.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(w.prototype,{rectangle:{get:function(){return rt.defined(this._rectangle)||(this._rectangle=d(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}}),function(t,e){return rt.defined(e)&&(t=w.unpack(t,e)),t._ellipsoid=it.Ellipsoid.clone(t._ellipsoid),w.createGeometry(t)}});