import{markRaw,h,getCurrentInstance,inject,defineComponent,reactive,onUnmounted,Teleport}from"vue";const resolveOption=e=>(t,r)=>{let n=-1;if(r.reduce((t,r,o)=>{const s=e(t,r);return s!==t?(n=o,s):t},void 0),n>-1)return t[n]};function setup(e){let t=0;if(e.vm){let{vm:r}=e;do{r.parent&&(t++,r=r.parent)}while(r&&r.parent&&r!==r.root)}e.depth=t}const resolve=resolveOption((e,t)=>{const{depth:r}=t;if(!e||r>e)return e});var deepest=Object.freeze({__proto__:null,setup:setup,resolve:resolve});const defaultConfig={body:{tag:"script",to:"body"},base:{valueAttribute:"href"},charset:{tag:"meta",nameless:!0,valueAttribute:"charset"},description:{tag:"meta"},og:{group:!0,namespacedAttribute:!0,tag:"meta",keyAttribute:"property"},twitter:{group:!0,namespacedAttribute:!0,tag:"meta"},htmlAttrs:{attributesFor:"html"},headAttrs:{attributesFor:"head"},bodyAttrs:{attributesFor:"body"}};"production"===process.env.NODE_ENV||Object.freeze({}),"production"===process.env.NODE_ENV||Object.freeze([]);const isArray=Array.isArray,isFunction=e=>"function"==typeof e,isString=e=>"string"==typeof e,isObject=e=>null!==e&&"object"==typeof e,objectToString=Object.prototype.toString,toTypeString=e=>objectToString.call(e),isPlainObject=e=>"[object Object]"===toTypeString(e),tags={title:{attributes:!1},base:{contentAsAttribute:!0,attributes:["href","target"]},meta:{contentAsAttribute:!0,keyAttribute:"name",attributes:["content","name","http-equiv","charset"]},link:{contentAsAttribute:!0,attributes:["href","crossorigin","rel","media","integrity","hreflang","type","referrerpolicy","sizes","imagesrcset","imagesizes","as","color"]},style:{attributes:["media"]},script:{attributes:["src","type","nomodule","async","defer","crossorigin","integrity","referrerpolicy"]},noscript:{attributes:!1}};function getConfigByKey(e,t,r){if(r&&t in r)return r[t];if(isArray(e)){for(const r of e)if(r&&r in tags)return tags[r][t]}else if(e in tags){return tags[e][t]}}const IS_PROXY=Symbol("kIsProxy"),PROXY_SOURCES=Symbol("kProxySources"),PROXY_TARGET=Symbol("kProxyTarget"),RESOLVE_CONTEXT=Symbol("kResolveContext");function clone(e){if(isArray(e))return e.map(clone);if(isObject(e)){const t={};for(const r in e)t[r]="context"===r?e[r]:clone(e[r]);return t}return e}const pluck=(e,t,r)=>{const n=[];for(const o of e)t in o&&(n.push(o[t]),r&&r(o));return n},allKeys=(e,...t)=>{const r=e?Object.keys(e):[];if(t)for(const e of t)if(e&&isObject(e))for(const t in e)r.includes(t)||r.push(t);return r},recompute=(e,t,r,n=[])=>{if(n.length||(r||(r=e.active),t||(t=e.sources)),!r||!t)return;const o=allKeys(...t),s=Object.keys(r);for(const e of s)o.includes(e)||delete r[e];for(const s of o){if(isPlainObject(t[0][s])){r[s]||(r[s]={});const o=[];for(const e of t)s in e&&o.push(e[s]);recompute(e,o,r[s],[...n,s]);continue}!r[s]&&isArray(t[0][s])&&(r[s]=[]);const o=[],i=pluck(t,s,e=>o.push(e[RESOLVE_CONTEXT]));let a=e.resolve(i,o,r[s],s,n);isPlainObject(a)&&(a=clone(a)),r[s]=a}},createProxy=(e,t,r,n=[])=>{const o=createHandler(e,r,n),s=markRaw(new Proxy(t,o));return!n.length&&e.sources&&e.sources.push(s),s},createHandler=(e,t,r=[])=>({get:(n,o,s)=>{if(o===IS_PROXY)return!0;if(o===PROXY_SOURCES)return e.sources;if(o===PROXY_TARGET)return n;if(o===RESOLVE_CONTEXT)return t;let i=Reflect.get(n,o,s);if(!isObject(i))return i;if(!i[IS_PROXY]){const s=[...r,o];i=createProxy(e,i,t,s),n[o]=i}return i},set:(t,n,o)=>{const s=Reflect.set(t,n,o);if(s){const o=isArray(t);let i,a=!1,{sources:c,active:u}=e,l=0;for(const e of r){if(c=pluck(c,e),o&&l===r.length-1){i=e;break}isArray(u)&&(a=!0),u=u[e],l++}if(a)return recompute(e),s;let f,p=[];o?(f=c,p=c.map(e=>e[RESOLVE_CONTEXT])):f=pluck(c,n,e=>p.push(e[RESOLVE_CONTEXT]));let d=e.resolve(f,p,u,n,r);isPlainObject(d)&&(d=clone(d)),o&&i?u[i]=d:u[n]=d}return s},deleteProperty:(t,n)=>{const o=Reflect.deleteProperty(t,n);if(o){const o=isArray(t);let s,i=e.sources,a=e.active,c=0;for(const e of r){if(i=i.map(t=>t[e]),o&&c===r.length-1){s=e;break}a=a[e],c++}if(i.some(e=>n in e)){let t,c=[];o?(t=i,c=i.map(e=>e[RESOLVE_CONTEXT])):t=pluck(i,n,e=>c.push(e[RESOLVE_CONTEXT]));let u=e.resolve(t,c,a,n,r);isPlainObject(u)&&(u=clone(u)),o&&s?a[s]=u:a[n]=u}else delete a[n]}return o}}),createMergedObject=(e,t={})=>{const r=[];t||(t={});const n={active:t,resolve:e,sources:r},o=()=>recompute(n);return{context:n,active:t,resolve:e,sources:r,addSource:(e,t,r=!1)=>{const s=createProxy(n,e,t||{});return r&&o(),s},delSource:(e,t=!0)=>{const n=r.findIndex(t=>t===e||t[PROXY_TARGET]===e);return n>-1&&(r.splice(n,1),t&&o(),!0)},compute:o}};function renderMeta(e,t,r,n){return n.attributesFor?renderAttributes(e,t,r,n):n.group?renderGroup(e,t,r,n):renderTag(e,t,r,n)}function renderGroup(e,t,r,n){return isArray(r)?("production"!==process.env.NODE_ENV&&console.warn("Specifying an array for group properties isnt supported mostly as we didnt found a use-case for this yet. If you have one, please create an issue on the vue-meta repo"),[]):Object.keys(r).map(o=>{const s={group:t,data:r};if(n.namespaced)s.tagNamespace=!0===n.namespaced?t:n.namespaced;else if(n.namespacedAttribute){const e=!0===n.namespacedAttribute?t:n.namespacedAttribute;s.fullName=`${e}:${o}`,s.slotName=`${e}(${o})`}return renderTag(e,t,r[o],n,s)}).flat()}function renderTag(e,t,r,n={},o){const s=["content","json","rawContent"],i=e=>getConfigByKey([a,n.tag],e,n);if(isArray(r))return r.map(r=>renderTag(e,t,r,n,o)).flat();const{tag:a=n.tag||t}=r;let c,u=!1,l=!1;if(isString(r))c=r;else if(r.children&&isArray(r.children))u=!0,c=r.children.map(r=>{const s=renderTag(e,t,r,n,o);return isArray(s)?s.map(({vnode:e})=>e):s.vnode});else{let e=0;for(const t of s){if(!c&&r[t]){c=1===e?JSON.stringify(r[t]):r[t],l=e>1;break}e++}}const f=o&&o.fullName||t,p=o&&o.slotName||t;let{attrs:d}=r;if(d||"object"!=typeof r)d||(d={});else{delete(d={...r}).tag,delete d.children,delete d.to;for(const e of s)delete d[e]}if(u)c=getSlotContent(e,p,c,r);else{const t=i("contentAsAttribute");let s=n.valueAttribute;if(!s&&t){const e=i("attributes");s=isString(t)?t:e[0]}if(s){if(!n.nameless){const e=i("keyAttribute");e&&(d[e]=f)}d[s]=getSlotContent(e,p,d[s]||c,o),c=void 0}else c=getSlotContent(e,p,c,r)}const g=o&&o.tagNamespace?`${o.tagNamespace}:${a}`:a;let m;return l?(d.innerHTML=c,m=h(g,d)):m=h(g,d,c),{to:r.to,vnode:m}}function renderAttributes(e,t,r,n={}){const{attributesFor:o}=n;return{to:"",vnode:h(`ssr-${o}`,r)}}function getSlotContent({metainfo:e,slots:t},r,n,o){if(!t||!t[r])return n;const s={content:n,metainfo:e};o&&o.group&&(s[o.group]=o.data);const i=t[r](s);return i&&i.length?i[0].children:n}const hasSymbol="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag,PolySymbol=e=>hasSymbol?Symbol("production"!==process.env.NODE_ENV?"[vue-meta]: "+e:e):("production"!==process.env.NODE_ENV?"[vue-meta]: ":"_vm_")+e,metaInfoKey=PolySymbol("production"!==process.env.NODE_ENV?"metainfo":"mi");function getCurrentManager(e){return e||(e=getCurrentInstance()),e.appContext.config.globalProperties.$metaManager}function useMeta(e,t){const r=getCurrentInstance();if(!t&&r&&(t=getCurrentManager(r)),!t)throw new Error("No manager or current instance");return t.addMeta(e,r||void 0)}function useMetainfo(){return inject(metaInfoKey)}const MetainfoImpl=defineComponent({name:"Metainfo",inheritAttrs:!1,setup:(e,{slots:t})=>()=>{const e=getCurrentManager();if(e)return e.render({slots:t})}}),Metainfo=MetainfoImpl,ssrAttribute="data-vm-ssr",active=reactive({});function addVnode(e,t,r){const n=isArray(r)?r:[r];t.endsWith("Attrs")||n.forEach(e=>{e.props||(e.props={}),e.props[ssrAttribute]=!0}),e[t]||(e[t]=[]),e[t].push(...n)}function createMetaManager(e,t){const{addSource:r,delSource:n}=createMergedObject((e,r,n,o,s)=>isFunction(t)?t(e,r,n,o,s):t.resolve(e,r,n,o,s),active),o={config:e,install(e){e.component("Metainfo",Metainfo),e.config.globalProperties.$metaManager=o,e.provide(metaInfoKey,active)},addMeta(e,o){const s={vm:o};t&&"setup"in t&&isFunction(t.setup)&&t.setup(s);const i=r(e,s,!0),a=()=>n(i);return o&&onUnmounted(a),{meta:i,unmount:a}},render({slots:e}={}){const t={};for(const r in active){const n=this.config[r]||{},o=renderMeta({metainfo:active,slots:e},r,active[r],n);if(!o)continue;const s=isArray(o)?o:[o],i="base"!==r&&active[r].to||n.to||(n.attributesFor?r:"head");for(const{to:e,vnode:r}of s)addVnode(t,e||i,r)}if(e)for(const r in e){const n=e[r];isFunction(n)&&addVnode(t,"default"===r?"head":r,n({metainfo:active}))}return Object.keys(t).map(e=>h(Teleport,{to:e},t[e]))}};return o}const{renderToString:renderToString}=require("@vue/server-renderer");async function renderToStringWithMeta(e){const t={},r=await renderToString(e,t);if(!t.teleports||!t.teleports.head){const r=e.config.globalProperties.$metaManager.render();await Promise.all(r.map(e=>renderToString(e,t)))}const{teleports:n}=t;for(const e in n)if(e.endsWith("Attrs")){const t=n[e];n[e]=t.slice(t.indexOf(" ")+1,t.indexOf(">"))}return[r,t]}export{createMetaManager,deepest as deepestResolver,defaultConfig,getCurrentManager,renderToStringWithMeta,resolveOption,useMeta,useMetainfo};